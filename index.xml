<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>zhangzw</title>
    <link>https://k1s.club/</link>
    <description>Recent content on zhangzw</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Wed, 13 Jan 2021 14:24:43 +0800</lastBuildDate><atom:link href="https://k1s.club/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Gin学习 简单记录form数据获取源码解读</title>
      <link>https://k1s.club/golang/gin%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95form%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</link>
      <pubDate>Wed, 13 Jan 2021 14:24:43 +0800</pubDate>
      
      <guid>https://k1s.club/golang/gin%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95form%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</guid>
      <description>http.request form 数据测试 func main() { e := gin.Default() e.Any(&amp;#34;/test&amp;#34;,func(c *gin.Context) { // 获取所有参数 	_ = c.Request.ParseForm() // log.Println(c.Request.Header[&amp;#34;Content-Type&amp;#34;])  // get form 参数, c.Request.URL.Query, err = url.ParseQuery 	log.Println(c.Request.URL.Query()) //log.Println(url.ParseQuery(c.Request.URL.RawQuery)) 	// post form 参数 	log.Println(c.Request.PostForm) // form 参数 	log.Println(c.Request.Form) }) e.Run(&amp;#34;localhost:8123&amp;#34;) }  请求日志
 # curl -XPOST &amp;quot;http://localhost:8123/test&amp;quot; -d &amp;quot;abc=123&amp;amp;q=123&amp;amp;ccc=123123&amp;quot; 2021/01/13 14:31:30 map[] 2021/01/13 14:31:30 map[abc:[123] ccc:[123123] q:[123]] 2021/01/13 14:31:30 map[abc:[123] ccc:[123123] q:[123]] [GIN] 2021/01/13 - 14:31:30 | 200 | 339.</description>
    </item>
    
    <item>
      <title>Gin学习 Validator</title>
      <link>https://k1s.club/golang/gin%E5%AD%A6%E4%B9%A0-validator/</link>
      <pubDate>Tue, 12 Jan 2021 10:17:46 +0800</pubDate>
      
      <guid>https://k1s.club/golang/gin%E5%AD%A6%E4%B9%A0-validator/</guid>
      <description>&lt;p&gt;记录一下Gin学习验证器和翻译器模块&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Google资深工程师深度讲解Go语言 Elastic简单使用</title>
      <link>https://k1s.club/golang/google%E8%B5%84%E6%B7%B1%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%B7%B1%E5%BA%A6%E8%AE%B2%E8%A7%A3go%E8%AF%AD%E8%A8%80-elastic%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Wed, 06 Jan 2021 14:27:27 +0800</pubDate>
      
      <guid>https://k1s.club/golang/google%E8%B5%84%E6%B7%B1%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%B7%B1%E5%BA%A6%E8%AE%B2%E8%A7%A3go%E8%AF%AD%E8%A8%80-elastic%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Google资深工程师深度讲解Go语言 单任务爬虫</title>
      <link>https://k1s.club/golang/google%E8%B5%84%E6%B7%B1%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%B7%B1%E5%BA%A6%E8%AE%B2%E8%A7%A3go%E8%AF%AD%E8%A8%80-%E5%8D%95%E4%BB%BB%E5%8A%A1%E7%88%AC%E8%99%AB/</link>
      <pubDate>Mon, 21 Dec 2020 18:03:36 +0800</pubDate>
      
      <guid>https://k1s.club/golang/google%E8%B5%84%E6%B7%B1%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%B7%B1%E5%BA%A6%E8%AE%B2%E8%A7%A3go%E8%AF%AD%E8%A8%80-%E5%8D%95%E4%BB%BB%E5%8A%A1%E7%88%AC%E8%99%AB/</guid>
      <description>&lt;p&gt;由于教程的代码在zhenai.com更新之后无法访问,所以记录下代码改动&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>广度优先算法学习-迷宫</title>
      <link>https://k1s.club/golang/%E5%B9%BF%E5%BA%A6%E6%B7%B1%E5%BA%A6%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E8%BF%B7%E5%AE%AB/</link>
      <pubDate>Fri, 18 Dec 2020 18:00:44 +0800</pubDate>
      
      <guid>https://k1s.club/golang/%E5%B9%BF%E5%BA%A6%E6%B7%B1%E5%BA%A6%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E8%BF%B7%E5%AE%AB/</guid>
      <description>这里学习了Google吱声工程师深度讲解go语言-迷宫广度优先算法以记录
算法说明 图源: 图解迷宫算法（广度优先遍历)
首先看一张迷宫图, 左右黄色0 表示起始点, 0 表示可以行走, 1表示墙体 迷宫的广度优先算法的意思是, 可以通过0 发现四个方向的1, 然后在通过四个1 发现所有的2, 所有的2探索完 , 在探索3&amp;hellip; 以此类推&amp;hellip; 这里每个点都有三种状态:  未发现 已发现未探索 已探索  最终我们能探索到这样的结果图: 下面是详细代码 代码结构 ── maze ├── maze.go └── maze.in maze.in文件 6 5 0 1 0 0 0 0 0 0 1 0 0 1 0 1 0 1 1 1 0 0 0 1 0 0 1 0 1 0 0 0 maze.go package main import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;os&amp;#34; ) /* maze.</description>
    </item>
    
    <item>
      <title>Gitlab-Ce的https开启问题</title>
      <link>https://k1s.club/posts/63-gitlab-ce%E7%9A%84https%E5%BC%80%E5%90%AF%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 15 Dec 2020 11:15:52 +0800</pubDate>
      
      <guid>https://k1s.club/posts/63-gitlab-ce%E7%9A%84https%E5%BC%80%E5%90%AF%E9%97%AE%E9%A2%98/</guid>
      <description>前言
 首先需要开启https并不会因为之前没有开启, 之前已经是https访问, 通过nginx反向代理到gitlab-ce:10080端口
但是由于新版Chrome浏览器对于https的域名内部post调用http时 会提示不安全
这种情况下才准备将gitlab直接通过https启动, 然后nginx反代到https的gitlab-ce上
首先修改下gitlab.rb  external_url &#39;https://gitlab.xxx.com&#39; nginx[&#39;redirect_http_to_https&#39;] = true nginx[&#39;redirect_http_to_https_port&#39;] = 80 nginx[&#39;listen_port&#39;] = 80 nginx[&#39;ssl_certificate&#39;] = &amp;quot;/etc/gitlab/ssl/server.pem&amp;quot; nginx[&#39;ssl_certificate_key&#39;] = &amp;quot;/etc/gitlab/ssl/server.key&amp;quot;  这里有个插曲, 因为我之前配置的时候docker 端口映射是10080:10080, 所以容器的gitlab.rb配置是这样:
  nginx[&#39;redirect_http_to_https_port&#39;] = 10080 nginx[&#39;listen_port&#39;] = 10080 这样就导致开启https的redirect 可能有点问题(可能漏改, 或者某些默认配置的问题), 其实没必要, 目前改成容器内默认的80
然后reconfigure即可 gitlab-ctl reconfigure 由于我是docker swarm启动 version:&amp;#34;3&amp;#34;services:gitlab:image:hub.xxx.com/bq/gitlab-ce:11.5.4hostname:&amp;#39;gitlab.xxx.com&amp;#39;environment:TZ:&amp;#39;Asia/Shanghai&amp;#39;GITLAB_OMNIBUS_CONFIG:|gitlab_rails[&amp;#39;time_zone&amp;#39;] = &amp;#39;Asia/Shanghai&amp;#39;volumes:- /data/container/gitlab-ce/logs:/var/log/gitlab- /data/container/gitlab-ce/data/:/var/opt/gitlab:rw- /data/container/gitlab-ce/config/:/etc/gitlab:rwdeploy:replicas:1restart_policy:condition:on-failureports:- 10443:443- 10080:80- 10022:22networks:- gitlabnetenvironment:HOSTNAME:gitlab.xxx.comnetworks:gitlabnet:nginx代理修改 server { listen 80; listen 443 ssl http2; charset utf-8; server_name gitlab.</description>
    </item>
    
    <item>
      <title>linux遇到一些问题统计</title>
      <link>https://k1s.club/posts/9-linux%E9%81%87%E5%88%B0%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E7%BB%9F%E8%AE%A1%E6%80%BB%E7%BB%93/</link>
      <pubDate>Tue, 08 Dec 2020 17:42:54 +0000</pubDate>
      
      <guid>https://k1s.club/posts/9-linux%E9%81%87%E5%88%B0%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E7%BB%9F%E8%AE%A1%E6%80%BB%E7%BB%93/</guid>
      <description>记录一些Linux,nginx或其他服务一些问题
  分布式问题: 分布式算法 Basic paxos 算法 1. 获取一个Proposal ID n，为了保证Proposal ID唯一，可采用时间戳+Server ID生成； 2. Proposer向所有Acceptors广播Prepare(n)请求； 3. Acceptor比较n和minProposal，如果n&amp;gt;minProposal，minProposal=n，并且将 acceptedProposal 和 acceptedValue 返回； 4. Proposer接收到过半数回复后，如果发现有acceptedValue返回，将所有回复中acceptedProposal最大的acceptedValue作为本次提案的value，否则可以任意决定本次提案的value； 5. 到这里可以进入第二阶段，广播Accept (n,value) 到所有节点； 6. Acceptor比较n和minProposal，如果n&amp;gt;=minProposal，则acceptedProposal=minProposal=n，acceptedValue=value，本地持久化后，返回；否则，返回minProposal。 7. 提议者接收到过半数请求后，如果发现有返回值result &amp;gt;n，表示有更新的提议，跳转到1；否则value达成一致。 Multi-Paxos 算法  为了解决实际应用中连续多值传输的高效性,改进了Basix Paxos为Multi-Paxos:
 1. 针对每一个要确定的值，运行一次Paxos算法实例（Instance），形成决议。每一个Paxos实例使用唯一的Instance ID标识。 2. 在所有Proposers中选举一个Leader，由Leader唯一地提交Proposal给Acceptors进行表决。这样没有Proposer竞争，解决了活锁问题。在系统中仅有一个Leader进行Value提交的情况下，Prepare阶段就可以跳过，从而将两阶段变为一阶段，提高效率。 raft  为了更简便理解和实现,改进了Multi-Paxos 为raft
 1. 发送的log的是连续的, 也就是说raft 的append 操作必须是连续的. 而paxos 可以并发的. (其实这里并发只是append log 的并发提高, 应用的state machine 还是必须是有序的) 2. 选主是有限制的, 必须有最新, 最全的日志节点才可以当选. 而multi-paxos 是随意的 所以raft 可以看成是简化版本的multi paxos(这里multi-paxos 因为允许并发的写log, 因此不存在一个最新, 最全的日志节点, 因此只能这么做.</description>
    </item>
    
    <item>
      <title>Tcpdump抓包分析tcp三次握手和四次挥手</title>
      <link>https://k1s.club/posts/62-tcpdump%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</link>
      <pubDate>Fri, 13 Nov 2020 17:28:38 +0800</pubDate>
      
      <guid>https://k1s.club/posts/62-tcpdump%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</guid>
      <description>命令参数说明  -n 主机名域名显示成ip -S 用绝对而非相对数值列出TCP关联数。 -i 接口名,指定网卡名 host 请求地址: www.baidu.com tcp 请求端口: tcp:80  标志说明  Flags [S]: 请求连接(SYN) Flags [S.]: sync+ack(SYN+ACK) Flags [.]: ack(ACK) Flags [P.]: 发送数据包(PUSH) Flags [F]: 发送方没有更多包发送了(FIN) Flags [R]: 表明packet的发送方马上就要断开当前连接了(RST)   参考官方手册
 本次抓取的结果  通过curl http://www.baiu.com得到
 # 抓取 enp0s3 网卡请求 http://www.baidu.com 的包并显示ip和实际发送seq和ack tcpdump -n -S -i enp0s3 host www.baidu.com and tcp port 80 tcpdump: verbose output suppressed, use -v or -vv for full protocol decode listening on enp0s3, link-type EN10MB (Ethernet), capture size 262144 bytes # 三次握手包 15:35:23.</description>
    </item>
    
    <item>
      <title>k8s遇到的一些问题统计总结</title>
      <link>https://k1s.club/posts/3-k8s%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E7%BB%9F%E8%AE%A1%E6%80%BB%E7%BB%93/</link>
      <pubDate>Tue, 10 Nov 2020 14:06:41 +0000</pubDate>
      
      <guid>https://k1s.club/posts/3-k8s%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E7%BB%9F%E8%AE%A1%E6%80%BB%E7%BB%93/</guid>
      <description>不定时更新,文章可能比较散乱,&amp;gt;_&amp;lt;
  1. 单机版k8s pod一直是pending的问题  describe一下pod会发现错误: 1 node(s) had taints that the pod didnt tolerate. 这是因为master上存在污点,pod不会再改节点上创建 两种办法:
  deploy 的时候加上 容忍该污点 直接取消master上的污点  # 取消master上污点 kubectl taint nodes --all node-role.kubernetes.io/master- # 查看taint kubectl describe node node1   2. 修改service-node-port-range  由于traefik部署需要对外开放80端口, 但默认仅允许30000以上端口
 # kubeadm 1.14 配置 apiServer: extraArgs: authorization-mode: Node,RBAC service-node-port-range: 79-33000 # kubeadm 1.10配置 apiServerExtraArgs: service-node-port-range: 79-33000   3. traefik断电后重新启动报错 command traefik error: field not found, node: redirect 看到这个错误猜测可能是用的latest镜像问题, 从`hub.</description>
    </item>
    
    <item>
      <title>1356 根据数字二进制下1的数目排序</title>
      <link>https://k1s.club/leetcode/1356-%E6%A0%B9%E6%8D%AE%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8B1%E7%9A%84%E6%95%B0%E7%9B%AE%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Fri, 06 Nov 2020 18:30:36 +0800</pubDate>
      
      <guid>https://k1s.club/leetcode/1356-%E6%A0%B9%E6%8D%AE%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8B1%E7%9A%84%E6%95%B0%E7%9B%AE%E6%8E%92%E5%BA%8F/</guid>
      <description>题目链接: sort-integers-by-the-number-of-1-bits
 题目简介 给你一个整数数组 arr 。请你将数组中的元素按照其二进制表示中数字 1 的数目升序排序。
如果存在多个数字二进制中 1 的数目相同，则必须将它们按照数值大小升序排列。
请你返回排序后的数组。
  示例 1：  输入：arr = [0,1,2,3,4,5,6,7,8] 输出：[0,1,2,4,8,3,5,6,7] 解释：[0] 是唯一一个有 0 个 1 的数。 [1,2,4,8] 都有 1 个 1 。 [3,5,6] 有 2 个 1 。 [7] 有 3 个 1 。 按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7] 示例 2： 解题思路 1 首先对数组中每个元素进行bitcount计算, 如果bit大一定靠前, 所以bitcount的结果 * 100000 首先按bit为1数量排序 2 其次将 乘法之后的结果 加上本身, 表示如果bit为1的count相同, 那就需要看本身数字谁大 代码示例 func sortByBits(arr []int) []int { for i :=0 ; i &amp;lt; len(arr) ; i++ { arr[i] = getCount(arr[i]) * 1000000 + arr[i] } sort.</description>
    </item>
    
  </channel>
</rss>
