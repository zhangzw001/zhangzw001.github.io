<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>K8s on zhangzw</title>
		<link>https://www.ngirl.xyz/k8s/</link>
		<description>Recent content in K8s on zhangzw</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>zh-hans</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Wed, 08 Jun 2022 16:35:12 +0800</lastBuildDate>
		<atom:link href="https://www.ngirl.xyz/k8s/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>K8s源码学习 简单记录</title>
			<link>https://www.ngirl.xyz/k8s/k8s%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/</link>
			<pubDate>Wed, 08 Jun 2022 16:35:12 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/k8s/k8s%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/</guid>
			<description>源码查看rc和rs的区别 通过追寻 NewControllerInitializers 函数中到RS和RC的源码发现, startReplicationController 和 startReplicaSetController 都是 NewBaseController 函数初始化的 ReplicaSetController 结构体, 不过两个传参不通 RS是: ctx.InformerFactory.Apps().V1().ReplicaSets() RC是: ctx.InformerFactory.Core().V1().ReplicationControllers(), 所以我们就需要找到RC和RS的InformerFactory的不同 沿着 NewControllerInitializers 往回找, 我们看到了 StartControllers 中会真正的执行 NewControllerInitializers 初始化的 controllers 代码: for controllerName, initFn := range controllers { debugHandler, started, err := initFn(ctx) } 这里的循环就会执行 startReplicationController(ctx) 和 startReplicaSetController(ctx), 这里的ctx就是StartControllers的第一个参数 回到 (cmd/kube-controller-manager/app/controllermanager.go) Run方法中, StartControllers(controllerContext, saTokenControllerInitFunc, NewControllerInitializers(controllerContext.LoopMode), unsecuredMux) 的controllerContext 正是 我们要找的ctx 往上我们看到 -&amp;gt; CreateControllerContext() -&amp;gt; NewSharedInformerFactory() -&amp;gt; NewSharedInformerFactoryWithOptions 找到了 sharedInformerFactory 结构体 sharedInformerFactory 就是真正的执行了 .Apps().V1().ReplicaSets() 和 .</description>
			<content type="html"><![CDATA[<h3 id="源码查看rc和rs的区别">源码查看rc和rs的区别</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="nx">通过追寻</span> <span class="nx">NewControllerInitializers</span> <span class="nx">函数中到RS和RC的源码发现</span><span class="p">,</span> <span class="nx">startReplicationController</span> <span class="nx">和</span> <span class="nx">startReplicaSetController</span> <span class="nx">都是</span> <span class="nx">NewBaseController</span> <span class="nx">函数初始化的</span> <span class="nx">ReplicaSetController</span> <span class="nx">结构体</span><span class="p">,</span> <span class="nx">不过两个传参不通</span>
<span class="nx">RS是</span><span class="p">:</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">InformerFactory</span><span class="p">.</span><span class="nf">Apps</span><span class="p">().</span><span class="nf">V1</span><span class="p">().</span><span class="nf">ReplicaSets</span><span class="p">()</span>
<span class="nx">RC是</span><span class="p">:</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">InformerFactory</span><span class="p">.</span><span class="nf">Core</span><span class="p">().</span><span class="nf">V1</span><span class="p">().</span><span class="nf">ReplicationControllers</span><span class="p">(),</span>
<span class="nx">所以我们就需要找到RC和RS的InformerFactory的不同</span>

<span class="nx">沿着</span> <span class="nx">NewControllerInitializers</span> <span class="nx">往回找</span><span class="p">,</span> <span class="nx">我们看到了</span> <span class="nx">StartControllers</span> <span class="nx">中会真正的执行</span> <span class="nx">NewControllerInitializers</span> <span class="nx">初始化的</span> <span class="nx">controllers</span>
<span class="nx">代码</span><span class="p">:</span>
<span class="k">for</span> <span class="nx">controllerName</span><span class="p">,</span> <span class="nx">initFn</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">controllers</span> <span class="p">{</span>
        <span class="nx">debugHandler</span><span class="p">,</span> <span class="nx">started</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">initFn</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">这里的循环就会执行</span> <span class="nf">startReplicationController</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span> <span class="nx">和</span> <span class="nf">startReplicaSetController</span><span class="p">(</span><span class="nx">ctx</span><span class="p">),</span> <span class="nx">这里的ctx就是StartControllers的第一个参数</span>

<span class="nx">回到</span> <span class="p">(</span><span class="nx">cmd</span><span class="o">/</span><span class="nx">kube</span><span class="o">-</span><span class="nx">controller</span><span class="o">-</span><span class="nx">manager</span><span class="o">/</span><span class="nx">app</span><span class="o">/</span><span class="nx">controllermanager</span><span class="p">.</span><span class="k">go</span><span class="p">)</span> <span class="nx">Run方法中</span><span class="p">,</span> 		
<span class="nf">StartControllers</span><span class="p">(</span><span class="nx">controllerContext</span><span class="p">,</span> <span class="nx">saTokenControllerInitFunc</span><span class="p">,</span> <span class="nf">NewControllerInitializers</span><span class="p">(</span><span class="nx">controllerContext</span><span class="p">.</span><span class="nx">LoopMode</span><span class="p">),</span> <span class="nx">unsecuredMux</span><span class="p">)</span>
<span class="nx">的controllerContext</span> <span class="nx">正是</span> <span class="nx">我们要找的ctx</span>

<span class="nx">往上我们看到</span> <span class="o">-</span><span class="p">&gt;</span> <span class="nf">CreateControllerContext</span><span class="p">()</span> <span class="o">-</span><span class="p">&gt;</span> <span class="nf">NewSharedInformerFactory</span><span class="p">()</span> <span class="o">-</span><span class="p">&gt;</span> <span class="nx">NewSharedInformerFactoryWithOptions</span> <span class="nx">找到了</span> <span class="nx">sharedInformerFactory</span> <span class="nx">结构体</span>
<span class="nx">sharedInformerFactory</span> <span class="nx">就是真正的执行了</span>  <span class="p">.</span><span class="nf">Apps</span><span class="p">().</span><span class="nf">V1</span><span class="p">().</span><span class="nf">ReplicaSets</span><span class="p">()</span> <span class="nx">和</span> <span class="p">.</span><span class="nf">Core</span><span class="p">().</span><span class="nf">V1</span><span class="p">().</span><span class="nf">ReplicationControllers</span><span class="p">()</span><span class="nx">的结构体</span>

<span class="nx">依次我们找到如下结构体</span><span class="p">:</span>

<span class="c1">// vendor/k8s.io/api/apps/v1/types.go
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ReplicaSet</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">metav1</span><span class="p">.</span><span class="nx">TypeMeta</span> <span class="s">`json:&#34;,inline&#34;`</span>
	<span class="nx">metav1</span><span class="p">.</span><span class="nx">ObjectMeta</span> <span class="s">`json:&#34;metadata,omitempty&#34; protobuf:&#34;bytes,1,opt,name=metadata&#34;`</span>
	<span class="nx">Spec</span> <span class="nx">ReplicaSetSpec</span> <span class="s">`json:&#34;spec,omitempty&#34; protobuf:&#34;bytes,2,opt,name=spec&#34;`</span>
	<span class="nx">Status</span> <span class="nx">ReplicaSetStatus</span> <span class="s">`json:&#34;status,omitempty&#34; protobuf:&#34;bytes,3,opt,name=status&#34;`</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">ReplicaSetSpec</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Replicas</span> <span class="o">*</span><span class="kt">int32</span> <span class="s">`json:&#34;replicas,omitempty&#34; protobuf:&#34;varint,1,opt,name=replicas&#34;`</span>
	<span class="nx">MinReadySeconds</span> <span class="kt">int32</span> <span class="s">`json:&#34;minReadySeconds,omitempty&#34; protobuf:&#34;varint,4,opt,name=minReadySeconds&#34;`</span>
	<span class="nx">Selector</span> <span class="o">*</span><span class="nx">metav1</span><span class="p">.</span><span class="nx">LabelSelector</span> <span class="s">`json:&#34;selector&#34; protobuf:&#34;bytes,2,opt,name=selector&#34;`</span>
	<span class="nx">Template</span> <span class="nx">v1</span><span class="p">.</span><span class="nx">PodTemplateSpec</span> <span class="s">`json:&#34;template,omitempty&#34; protobuf:&#34;bytes,3,opt,name=template&#34;`</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">LabelSelector</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">MatchLabels</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span> <span class="s">`json:&#34;matchLabels,omitempty&#34; protobuf:&#34;bytes,1,rep,name=matchLabels&#34;`</span>
	<span class="nx">MatchExpressions</span> <span class="p">[]</span><span class="nx">LabelSelectorRequirement</span> <span class="s">`json:&#34;matchExpressions,omitempty&#34; protobuf:&#34;bytes,2,rep,name=matchExpressions&#34;`</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">LabelSelectorRequirement</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Key</span> <span class="kt">string</span> <span class="s">`json:&#34;key&#34; patchStrategy:&#34;merge&#34; patchMergeKey:&#34;key&#34; protobuf:&#34;bytes,1,opt,name=key&#34;`</span>
	<span class="nx">Operator</span> <span class="nx">LabelSelectorOperator</span> <span class="s">`json:&#34;operator&#34; protobuf:&#34;bytes,2,opt,name=operator,casttype=LabelSelectorOperator&#34;`</span>
	<span class="nx">Values</span> <span class="p">[]</span><span class="kt">string</span> <span class="s">`json:&#34;values,omitempty&#34; protobuf:&#34;bytes,3,rep,name=values&#34;`</span>
<span class="p">}</span>

<span class="c1">// vendor/k8s.io/api/core/v1/types.go
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ReplicationController</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">metav1</span><span class="p">.</span><span class="nx">TypeMeta</span> <span class="s">`json:&#34;,inline&#34;`</span>
	<span class="nx">metav1</span><span class="p">.</span><span class="nx">ObjectMeta</span> <span class="s">`json:&#34;metadata,omitempty&#34; protobuf:&#34;bytes,1,opt,name=metadata&#34;`</span>
	<span class="nx">Spec</span> <span class="nx">ReplicationControllerSpec</span> <span class="s">`json:&#34;spec,omitempty&#34; protobuf:&#34;bytes,2,opt,name=spec&#34;`</span>
	<span class="nx">Status</span> <span class="nx">ReplicationControllerStatus</span> <span class="s">`json:&#34;status,omitempty&#34; protobuf:&#34;bytes,3,opt,name=status&#34;`</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">ReplicationControllerSpec</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Replicas</span> <span class="o">*</span><span class="kt">int32</span> <span class="s">`json:&#34;replicas,omitempty&#34; protobuf:&#34;varint,1,opt,name=replicas&#34;`</span>
	<span class="nx">MinReadySeconds</span> <span class="kt">int32</span> <span class="s">`json:&#34;minReadySeconds,omitempty&#34; protobuf:&#34;varint,4,opt,name=minReadySeconds&#34;`</span>
	<span class="nx">Selector</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span> <span class="s">`json:&#34;selector,omitempty&#34; protobuf:&#34;bytes,2,rep,name=selector&#34;`</span>
	<span class="nx">Template</span> <span class="o">*</span><span class="nx">PodTemplateSpec</span> <span class="s">`json:&#34;template,omitempty&#34; protobuf:&#34;bytes,3,opt,name=template&#34;`</span>
<span class="p">}</span>


<span class="nx">显然这里的区别很小</span><span class="p">,</span>  <span class="nx">RS</span> <span class="nx">的MatchLabels</span> <span class="nx">等同RC的Selector</span><span class="p">,</span> <span class="nx">同时RS还扩展了MatchExpressions</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>K8s源码学习 Job源码分析</title>
			<link>https://www.ngirl.xyz/k8s/k8s%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-job%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
			<pubDate>Thu, 09 Dec 2021 10:22:02 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/k8s/k8s%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-job%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
			<description>首先我们知道cronjob和job是受控于controller manager组件的, 下面我们先看看job controller是怎么初始化的
 初始化的流程 1. cmd/kube-controller-manager/controller-manager.go main() -&amp;gt; app.NewControllerManagerCommand() 2. cmd/kube-controller-manager/app/controllermanager.go NewControllerManagerCommand() *cobra.Command -&amp;gt; Run(...) -&amp;gt; NewControllerInitializers(...) map[string]InitFunc // 这里返回控制器的map,后续会对他遍历执行InitFunc  { controllers[&amp;#34;job&amp;#34;] = startJobController // job的初始化  controllers[&amp;#34;cronjob&amp;#34;] = startCronJobController } 3. cmd/kube-controller-manager/app/batch.go startJobController(...) (...) -&amp;gt; NewJobController(...) *JobController // 返回一个JobController  { jm.syncHandler = jm.syncJob // 核心的handler初始化  } -&amp;gt; (jm *JobController) Run(...) -&amp;gt; (jm *JobController) worker() -&amp;gt; for jm.processNextWorkItem() {} // 这里是循环  -&amp;gt; jm.syncHandler(...) // 最终在processNextWorkItem的函数内部调用了syncHandler, 也就是上面初始化的syncJob JobController 结构体 type JobController struct { kubeClient clientset.</description>
			<content type="html"><![CDATA[<blockquote>
<p>首先我们知道cronjob和job是受控于controller manager组件的, 下面我们先看看job controller是怎么初始化的</p>
</blockquote>
<h2 id="初始化的流程">初始化的流程</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="mf">1.</span> <span class="nx">cmd</span><span class="o">/</span><span class="nx">kube</span><span class="o">-</span><span class="nx">controller</span><span class="o">-</span><span class="nx">manager</span><span class="o">/</span><span class="nx">controller</span><span class="o">-</span><span class="nx">manager</span><span class="p">.</span><span class="k">go</span>
        <span class="nf">main</span><span class="p">()</span>  
        <span class="o">-</span><span class="p">&gt;</span> <span class="nx">app</span><span class="p">.</span><span class="nf">NewControllerManagerCommand</span><span class="p">()</span>
<span class="mf">2.</span> <span class="nx">cmd</span><span class="o">/</span><span class="nx">kube</span><span class="o">-</span><span class="nx">controller</span><span class="o">-</span><span class="nx">manager</span><span class="o">/</span><span class="nx">app</span><span class="o">/</span><span class="nx">controllermanager</span><span class="p">.</span><span class="k">go</span>
        <span class="nf">NewControllerManagerCommand</span><span class="p">()</span> <span class="o">*</span><span class="nx">cobra</span><span class="p">.</span><span class="nx">Command</span>
        <span class="o">-</span><span class="p">&gt;</span> <span class="nf">Run</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
        <span class="o">-</span><span class="p">&gt;</span> <span class="nf">NewControllerInitializers</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">InitFunc</span>   <span class="c1">// 这里返回控制器的map,后续会对他遍历执行InitFunc
</span><span class="c1"></span>                <span class="p">{</span>
                        <span class="nx">controllers</span><span class="p">[</span><span class="s">&#34;job&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">startJobController</span> <span class="c1">// job的初始化
</span><span class="c1"></span>                        <span class="nx">controllers</span><span class="p">[</span><span class="s">&#34;cronjob&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">startCronJobController</span>
                <span class="p">}</span>
<span class="mf">3.</span> <span class="nx">cmd</span><span class="o">/</span><span class="nx">kube</span><span class="o">-</span><span class="nx">controller</span><span class="o">-</span><span class="nx">manager</span><span class="o">/</span><span class="nx">app</span><span class="o">/</span><span class="nx">batch</span><span class="p">.</span><span class="k">go</span>
        <span class="nf">startJobController</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="p">(</span><span class="o">...</span><span class="p">)</span>
        <span class="o">-</span><span class="p">&gt;</span> <span class="nf">NewJobController</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="o">*</span><span class="nx">JobController</span> <span class="c1">// 返回一个JobController
</span><span class="c1"></span>                <span class="p">{</span>
                        <span class="nx">jm</span><span class="p">.</span><span class="nx">syncHandler</span> <span class="p">=</span> <span class="nx">jm</span><span class="p">.</span><span class="nx">syncJob</span>     <span class="c1">// 核心的handler初始化
</span><span class="c1"></span>                <span class="p">}</span>
        <span class="o">-</span><span class="p">&gt;</span>  <span class="p">(</span><span class="nx">jm</span> <span class="o">*</span><span class="nx">JobController</span><span class="p">)</span> <span class="nf">Run</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
        <span class="o">-</span><span class="p">&gt;</span>  <span class="p">(</span><span class="nx">jm</span> <span class="o">*</span><span class="nx">JobController</span><span class="p">)</span> <span class="nf">worker</span><span class="p">()</span>
        <span class="o">-</span><span class="p">&gt;</span>  <span class="k">for</span> <span class="nx">jm</span><span class="p">.</span><span class="nf">processNextWorkItem</span><span class="p">()</span> <span class="p">{}</span>     <span class="c1">// 这里是循环
</span><span class="c1"></span>        <span class="o">-</span><span class="p">&gt;</span>  <span class="nx">jm</span><span class="p">.</span><span class="nf">syncHandler</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="c1">// 最终在processNextWorkItem的函数内部调用了syncHandler, 也就是上面初始化的syncJob
</span></code></pre></div><h2 id="jobcontroller-结构体">JobController 结构体</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">JobController</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">kubeClient</span> <span class="nx">clientset</span><span class="p">.</span><span class="nx">Interface</span>
	<span class="nx">podControl</span> <span class="nx">controller</span><span class="p">.</span><span class="nx">PodControlInterface</span>

	<span class="nx">updateHandler</span> <span class="kd">func</span><span class="p">(</span><span class="nx">job</span> <span class="o">*</span><span class="nx">batch</span><span class="p">.</span><span class="nx">Job</span><span class="p">)</span> <span class="kt">error</span>
        <span class="c1">// sync同步发光法
</span><span class="c1"></span>	<span class="nx">syncHandler</span>   <span class="kd">func</span><span class="p">(</span><span class="nx">jobKey</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
	<span class="nx">podStoreSynced</span> <span class="nx">cache</span><span class="p">.</span><span class="nx">InformerSynced</span>
	<span class="nx">jobStoreSynced</span> <span class="nx">cache</span><span class="p">.</span><span class="nx">InformerSynced</span>
	<span class="nx">expectations</span> <span class="nx">controller</span><span class="p">.</span><span class="nx">ControllerExpectationsInterface</span>
	<span class="nx">jobLister</span> <span class="nx">batchv1listers</span><span class="p">.</span><span class="nx">JobLister</span>
	<span class="nx">podStore</span> <span class="nx">corelisters</span><span class="p">.</span><span class="nx">PodLister</span>
	<span class="c1">// 延迟队列
</span><span class="c1"></span>	<span class="nx">queue</span> <span class="nx">workqueue</span><span class="p">.</span><span class="nx">RateLimitingInterface</span>
	<span class="nx">recorder</span> <span class="nx">record</span><span class="p">.</span><span class="nx">EventRecorder</span>
<span class="p">}</span>

</code></pre></div><h2 id="startjobcontroller">startJobController</h2>
<blockquote>
<p>首先看下初始化的过程</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">startJobController</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">ControllerContext</span><span class="p">)</span> <span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">Handler</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 查看是否支持GVR
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">AvailableResources</span><span class="p">[</span><span class="nx">schema</span><span class="p">.</span><span class="nx">GroupVersionResource</span><span class="p">{</span><span class="nx">Group</span><span class="p">:</span> <span class="s">&#34;batch&#34;</span><span class="p">,</span> <span class="nx">Version</span><span class="p">:</span> <span class="s">&#34;v1&#34;</span><span class="p">,</span> <span class="nx">Resource</span><span class="p">:</span> <span class="s">&#34;jobs&#34;</span><span class="p">}]</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">nil</span>
	<span class="p">}</span>
        <span class="c1">// 创建结构体
</span><span class="c1"></span>	<span class="k">go</span> <span class="nx">job</span><span class="p">.</span><span class="nf">NewJobController</span><span class="p">(</span>
                <span class="c1">// pods Informer
</span><span class="c1"></span>		<span class="nx">ctx</span><span class="p">.</span><span class="nx">InformerFactory</span><span class="p">.</span><span class="nf">Core</span><span class="p">().</span><span class="nf">V1</span><span class="p">().</span><span class="nf">Pods</span><span class="p">(),</span>
                <span class="c1">// jobs Informer, InformerFactory被初始化为 sharedInformerFactory 结构体
</span><span class="c1"></span>		<span class="nx">ctx</span><span class="p">.</span><span class="nx">InformerFactory</span><span class="p">.</span><span class="nf">Batch</span><span class="p">().</span><span class="nf">V1</span><span class="p">().</span><span class="nf">Jobs</span><span class="p">(),</span>
                <span class="c1">// kubeclient
</span><span class="c1"></span>		<span class="nx">ctx</span><span class="p">.</span><span class="nx">ClientBuilder</span><span class="p">.</span><span class="nf">ClientOrDie</span><span class="p">(</span><span class="s">&#34;job-controller&#34;</span><span class="p">),</span>
        <span class="c1">// 执行Run
</span><span class="c1"></span>	<span class="p">).</span><span class="nf">Run</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">ComponentConfig</span><span class="p">.</span><span class="nx">JobController</span><span class="p">.</span><span class="nx">ConcurrentJobSyncs</span><span class="p">),</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">Stop</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><h3 id="newjobcontroller">NewJobController</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewJobController</span><span class="p">(</span><span class="nx">podInformer</span> <span class="nx">coreinformers</span><span class="p">.</span><span class="nx">PodInformer</span><span class="p">,</span> <span class="nx">jobInformer</span> <span class="nx">batchinformers</span><span class="p">.</span><span class="nx">JobInformer</span><span class="p">,</span> <span class="nx">kubeClient</span> <span class="nx">clientset</span><span class="p">.</span><span class="nx">Interface</span><span class="p">)</span> <span class="o">*</span><span class="nx">JobController</span> <span class="p">{</span>
	<span class="o">...</span>
        <span class="c1">// 初始化的JobController
</span><span class="c1"></span>	<span class="nx">jm</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">JobController</span><span class="p">{</span>
		<span class="nx">kubeClient</span><span class="p">:</span> <span class="nx">kubeClient</span><span class="p">,</span>
		<span class="nx">podControl</span><span class="p">:</span> <span class="nx">controller</span><span class="p">.</span><span class="nx">RealPodControl</span><span class="p">{</span>
			<span class="nx">KubeClient</span><span class="p">:</span> <span class="nx">kubeClient</span><span class="p">,</span>
			<span class="nx">Recorder</span><span class="p">:</span>   <span class="nx">eventBroadcaster</span><span class="p">.</span><span class="nf">NewRecorder</span><span class="p">(</span><span class="nx">scheme</span><span class="p">.</span><span class="nx">Scheme</span><span class="p">,</span> <span class="nx">v1</span><span class="p">.</span><span class="nx">EventSource</span><span class="p">{</span><span class="nx">Component</span><span class="p">:</span> <span class="s">&#34;job-controller&#34;</span><span class="p">}),</span>
		<span class="p">},</span>
		<span class="nx">expectations</span><span class="p">:</span> <span class="nx">controller</span><span class="p">.</span><span class="nf">NewControllerExpectations</span><span class="p">(),</span>
                <span class="c1">// 这里初始化的queue队列
</span><span class="c1"></span>                <span class="nx">queue</span><span class="p">:</span>        <span class="nx">workqueue</span><span class="p">.</span><span class="nf">NewNamedRateLimitingQueue</span><span class="p">(</span><span class="nx">workqueue</span><span class="p">.</span><span class="nf">NewItemExponentialFailureRateLimiter</span><span class="p">(</span><span class="nx">DefaultJobBackOff</span><span class="p">,</span> <span class="nx">MaxJobBackOff</span><span class="p">),</span> <span class="s">&#34;job&#34;</span><span class="p">),</span>
		<span class="nx">recorder</span><span class="p">:</span>     <span class="nx">eventBroadcaster</span><span class="p">.</span><span class="nf">NewRecorder</span><span class="p">(</span><span class="nx">scheme</span><span class="p">.</span><span class="nx">Scheme</span><span class="p">,</span> <span class="nx">v1</span><span class="p">.</span><span class="nx">EventSource</span><span class="p">{</span><span class="nx">Component</span><span class="p">:</span> <span class="s">&#34;job-controller&#34;</span><span class="p">}),</span>
	<span class="p">}</span>

	<span class="nx">jobInformer</span><span class="p">.</span><span class="nf">Informer</span><span class="p">().</span><span class="nf">AddEventHandler</span><span class="p">(</span><span class="nx">cache</span><span class="p">.</span><span class="nx">ResourceEventHandlerFuncs</span><span class="p">{</span>
		<span class="nx">AddFunc</span><span class="p">:</span> <span class="kd">func</span><span class="p">(</span><span class="nx">obj</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
			<span class="nx">jm</span><span class="p">.</span><span class="nf">enqueueController</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
		<span class="p">},</span>
		<span class="nx">UpdateFunc</span><span class="p">:</span> <span class="nx">jm</span><span class="p">.</span><span class="nx">updateJob</span><span class="p">,</span>
		<span class="nx">DeleteFunc</span><span class="p">:</span> <span class="kd">func</span><span class="p">(</span><span class="nx">obj</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
			<span class="nx">jm</span><span class="p">.</span><span class="nf">enqueueController</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
		<span class="p">},</span>
	<span class="p">})</span>
        <span class="c1">// joblister
</span><span class="c1"></span>	<span class="nx">jm</span><span class="p">.</span><span class="nx">jobLister</span> <span class="p">=</span> <span class="nx">jobInformer</span><span class="p">.</span><span class="nf">Lister</span><span class="p">()</span>
	<span class="nx">jm</span><span class="p">.</span><span class="nx">jobStoreSynced</span> <span class="p">=</span> <span class="nx">jobInformer</span><span class="p">.</span><span class="nf">Informer</span><span class="p">().</span><span class="nx">HasSynced</span>

	<span class="nx">podInformer</span><span class="p">.</span><span class="nf">Informer</span><span class="p">().</span><span class="nf">AddEventHandler</span><span class="p">(</span><span class="nx">cache</span><span class="p">.</span><span class="nx">ResourceEventHandlerFuncs</span><span class="p">{</span>
		<span class="nx">AddFunc</span><span class="p">:</span>    <span class="nx">jm</span><span class="p">.</span><span class="nx">addPod</span><span class="p">,</span>
		<span class="nx">UpdateFunc</span><span class="p">:</span> <span class="nx">jm</span><span class="p">.</span><span class="nx">updatePod</span><span class="p">,</span>
		<span class="nx">DeleteFunc</span><span class="p">:</span> <span class="nx">jm</span><span class="p">.</span><span class="nx">deletePod</span><span class="p">,</span>
	<span class="p">})</span>
        <span class="c1">// podLister
</span><span class="c1"></span>	<span class="nx">jm</span><span class="p">.</span><span class="nx">podStore</span> <span class="p">=</span> <span class="nx">podInformer</span><span class="p">.</span><span class="nf">Lister</span><span class="p">()</span>
	<span class="nx">jm</span><span class="p">.</span><span class="nx">podStoreSynced</span> <span class="p">=</span> <span class="nx">podInformer</span><span class="p">.</span><span class="nf">Informer</span><span class="p">().</span><span class="nx">HasSynced</span>
        <span class="c1">// 更新状态
</span><span class="c1"></span>	<span class="nx">jm</span><span class="p">.</span><span class="nx">updateHandler</span> <span class="p">=</span> <span class="nx">jm</span><span class="p">.</span><span class="nx">updateJobStatus</span>
        <span class="c1">// job核心
</span><span class="c1"></span>	<span class="nx">jm</span><span class="p">.</span><span class="nx">syncHandler</span> <span class="p">=</span> <span class="nx">jm</span><span class="p">.</span><span class="nx">syncJob</span>

	<span class="k">return</span> <span class="nx">jm</span>
<span class="p">}</span>

</code></pre></div><h3 id="run">Run</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">jm</span> <span class="o">*</span><span class="nx">JobController</span><span class="p">)</span> <span class="nf">Run</span><span class="p">(</span><span class="nx">workers</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">stopCh</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nx">utilruntime</span><span class="p">.</span><span class="nf">HandleCrash</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">jm</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nf">ShutDown</span><span class="p">()</span>

	<span class="nx">klog</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;Starting job controller&#34;</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nx">klog</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;Shutting down job controller&#34;</span><span class="p">)</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">cache</span><span class="p">.</span><span class="nf">WaitForNamedCacheSync</span><span class="p">(</span><span class="s">&#34;job&#34;</span><span class="p">,</span> <span class="nx">stopCh</span><span class="p">,</span> <span class="nx">jm</span><span class="p">.</span><span class="nx">podStoreSynced</span><span class="p">,</span> <span class="nx">jm</span><span class="p">.</span><span class="nx">jobStoreSynced</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">workers</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">go</span> <span class="nx">wait</span><span class="p">.</span><span class="nf">Until</span><span class="p">(</span><span class="nx">jm</span><span class="p">.</span><span class="nx">worker</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span> <span class="nx">stopCh</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="o">&lt;-</span><span class="nx">stopCh</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">jm</span> <span class="o">*</span><span class="nx">JobController</span><span class="p">)</span> <span class="nf">worker</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">jm</span><span class="p">.</span><span class="nf">processNextWorkItem</span><span class="p">()</span> <span class="p">{</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="p">(</span><span class="nx">jm</span> <span class="o">*</span><span class="nx">JobController</span><span class="p">)</span> <span class="nf">processNextWorkItem</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">key</span><span class="p">,</span> <span class="nx">quit</span> <span class="o">:=</span> <span class="nx">jm</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Get</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">quit</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">jm</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Done</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
        <span class="c1">// 核心代码, 实际就是syncJob
</span><span class="c1"></span>	<span class="nx">forget</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">jm</span><span class="p">.</span><span class="nf">syncHandler</span><span class="p">(</span><span class="nx">key</span><span class="p">.(</span><span class="kt">string</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">forget</span> <span class="p">{</span>
			<span class="nx">jm</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Forget</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="nx">utilruntime</span><span class="p">.</span><span class="nf">HandleError</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;Error syncing job: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">))</span>
        <span class="c1">// 详细说明11
</span><span class="c1"></span>	<span class="nx">jm</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nf">AddRateLimited</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>

	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></div><h2 id="syncjob">syncJob</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">jm</span> <span class="o">*</span><span class="nx">JobController</span><span class="p">)</span> <span class="nf">syncJob</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">startTime</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">klog</span><span class="p">.</span><span class="nf">V</span><span class="p">(</span><span class="mi">4</span><span class="p">).</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;Finished syncing job %q (%v)&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Since</span><span class="p">(</span><span class="nx">startTime</span><span class="p">))</span>
	<span class="p">}()</span>
        <span class="c1">// 将key通过&#34;/&#34;拆分为namespace 和 jobname
</span><span class="c1"></span>	<span class="nx">ns</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cache</span><span class="p">.</span><span class="nf">SplitMetaNamespaceKey</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nb">len</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;invalid job key %q: either namespace or name is missing&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
	<span class="p">}</span>
        <span class="c1">// 见下面&#34;详细说明1&#34;
</span><span class="c1"></span>	<span class="nx">sharedJob</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">jm</span><span class="p">.</span><span class="nx">jobLister</span><span class="p">.</span><span class="nf">Jobs</span><span class="p">(</span><span class="nx">ns</span><span class="p">).</span><span class="nf">Get</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">IsNotFound</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">klog</span><span class="p">.</span><span class="nf">V</span><span class="p">(</span><span class="mi">4</span><span class="p">).</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;Job has been deleted: %v&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
			<span class="nx">jm</span><span class="p">.</span><span class="nx">expectations</span><span class="p">.</span><span class="nf">DeleteExpectations</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
			<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="nx">job</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">sharedJob</span>

	<span class="c1">// status.Conditions.type如果是 &#34;Complete&#34; 或者 &#34;Failed&#34; 并且 status.Conditions.Status 是 &#34;True&#34; 那就返回,job结束
</span><span class="c1"></span>        <span class="c1">// 见下面&#34;详细说明2&#34;
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">IsJobFinished</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">job</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="c1">// 重试次数
</span><span class="c1"></span>	<span class="nx">previousRetry</span> <span class="o">:=</span> <span class="nx">jm</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nf">NumRequeues</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
        <span class="c1">// 判断是否需要 同步pod
</span><span class="c1"></span>	<span class="nx">jobNeedsSync</span> <span class="o">:=</span> <span class="nx">jm</span><span class="p">.</span><span class="nx">expectations</span><span class="p">.</span><span class="nf">SatisfiedExpectations</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
        <span class="c1">// 详细说明3
</span><span class="c1"></span>	<span class="nx">pods</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">jm</span><span class="p">.</span><span class="nf">getPodsForJob</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">job</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
        <span class="c1">// 得到运行中pod的列表
</span><span class="c1"></span>        <span class="c1">// v1.PodSucceeded != p.Status.Phase &amp;&amp; v1.PodFailed != p.Status.Phase &amp;&amp;p.DeletionTimestamp == nil
</span><span class="c1"></span>	<span class="nx">activePods</span> <span class="o">:=</span> <span class="nx">controller</span><span class="p">.</span><span class="nf">FilterActivePods</span><span class="p">(</span><span class="nx">pods</span><span class="p">)</span>
        <span class="c1">// 当前运行的pod数量
</span><span class="c1"></span>	<span class="nx">active</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">activePods</span><span class="p">))</span>
        <span class="c1">// 分别计算成功和失败的数量
</span><span class="c1"></span>	<span class="nx">succeeded</span><span class="p">,</span> <span class="nx">failed</span> <span class="o">:=</span> <span class="nf">getStatus</span><span class="p">(</span><span class="nx">pods</span><span class="p">)</span>
        <span class="c1">// conditions 的长度
</span><span class="c1"></span>	<span class="nx">conditions</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">job</span><span class="p">.</span><span class="nx">Status</span><span class="p">.</span><span class="nx">Conditions</span><span class="p">)</span>
	<span class="c1">// 首次运行
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">job</span><span class="p">.</span><span class="nx">Status</span><span class="p">.</span><span class="nx">StartTime</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">now</span> <span class="o">:=</span> <span class="nx">metav1</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
                <span class="c1">// 设置status
</span><span class="c1"></span>		<span class="nx">job</span><span class="p">.</span><span class="nx">Status</span><span class="p">.</span><span class="nx">StartTime</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">now</span>
		<span class="c1">// 如果设置 ActiveDeadlineSeconds 了, 那么就需要加入到 延迟队列,
</span><span class="c1"></span>                <span class="c1">// 详细 延迟队列讲解, 见文末链接 &#34;k8s源码学习-client-go延迟队列&#34;,(标注1)
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">job</span><span class="p">.</span><span class="nx">Spec</span><span class="p">.</span><span class="nx">ActiveDeadlineSeconds</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">jm</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nf">AddAfter</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="o">*</span><span class="nx">job</span><span class="p">.</span><span class="nx">Spec</span><span class="p">.</span><span class="nx">ActiveDeadlineSeconds</span><span class="p">)</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">manageJobErr</span> <span class="kt">error</span>
	<span class="nx">jobFailed</span> <span class="o">:=</span> <span class="kc">false</span>
        <span class="c1">// 失败原因, 会记录到job.Status.Conditions 和Event
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">failureReason</span> <span class="kt">string</span>
	<span class="kd">var</span> <span class="nx">failureMessage</span> <span class="kt">string</span>

	<span class="nx">jobHaveNewFailure</span> <span class="o">:=</span> <span class="nx">failed</span> <span class="p">&gt;</span> <span class="nx">job</span><span class="p">.</span><span class="nx">Status</span><span class="p">.</span><span class="nx">Failed</span>
        <span class="c1">// BackoffLimit 默认被初始化为6, 在SetDefaults_Job() 函数初始化
</span><span class="c1"></span>        <span class="c1">// 如果失败了, 并且活跃数不等于并行数, 并且当前重试次数已经达到6次了
</span><span class="c1"></span>	<span class="nx">exceedsBackoffLimit</span> <span class="o">:=</span> <span class="nx">jobHaveNewFailure</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">active</span> <span class="o">!=</span> <span class="o">*</span><span class="nx">job</span><span class="p">.</span><span class="nx">Spec</span><span class="p">.</span><span class="nx">Parallelism</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="nb">int32</span><span class="p">(</span><span class="nx">previousRetry</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span> <span class="p">&gt;</span> <span class="o">*</span><span class="nx">job</span><span class="p">.</span><span class="nx">Spec</span><span class="p">.</span><span class="nx">BackoffLimit</span><span class="p">)</span>
        <span class="c1">// 标记为 BackoffLimitExceeded
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">exceedsBackoffLimit</span> <span class="o">||</span> <span class="nf">pastBackoffLimitOnFailure</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">job</span><span class="p">,</span> <span class="nx">pods</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">jobFailed</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nx">failureReason</span> <span class="p">=</span> <span class="s">&#34;BackoffLimitExceeded&#34;</span>
		<span class="nx">failureMessage</span> <span class="p">=</span> <span class="s">&#34;Job has reached the specified backoff limit&#34;</span>
        <span class="c1">// Deadline 的状态
</span><span class="c1"></span>	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nf">pastActiveDeadline</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">job</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">jobFailed</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nx">failureReason</span> <span class="p">=</span> <span class="s">&#34;DeadlineExceeded&#34;</span>
		<span class="nx">failureMessage</span> <span class="p">=</span> <span class="s">&#34;Job was active longer than specified deadline&#34;</span>
	<span class="p">}</span>
        <span class="c1">// 如果是失败了的, 说明要么就是 BackoffLimitExceeded 要么就是 DeadlineExceeded
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">jobFailed</span> <span class="p">{</span>
		<span class="nx">errCh</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">error</span><span class="p">,</span> <span class="nx">active</span><span class="p">)</span>
                <span class="c1">// 删除activepod
</span><span class="c1"></span>		<span class="nx">jm</span><span class="p">.</span><span class="nf">deleteJobPods</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">job</span><span class="p">,</span> <span class="nx">activePods</span><span class="p">,</span> <span class="nx">errCh</span><span class="p">)</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">manageJobErr</span> <span class="p">=</span> <span class="o">&lt;-</span><span class="nx">errCh</span><span class="p">:</span>
			<span class="k">if</span> <span class="nx">manageJobErr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
		<span class="k">default</span><span class="p">:</span>
		<span class="p">}</span>

		<span class="c1">// 增加失败的个数
</span><span class="c1"></span>		<span class="nx">failed</span> <span class="o">+=</span> <span class="nx">active</span>
		<span class="nx">active</span> <span class="p">=</span> <span class="mi">0</span>
                <span class="c1">// job.Status.Conditions 中添加新的状态
</span><span class="c1"></span>		<span class="nx">job</span><span class="p">.</span><span class="nx">Status</span><span class="p">.</span><span class="nx">Conditions</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">job</span><span class="p">.</span><span class="nx">Status</span><span class="p">.</span><span class="nx">Conditions</span><span class="p">,</span> <span class="nf">newCondition</span><span class="p">(</span><span class="nx">batch</span><span class="p">.</span><span class="nx">JobFailed</span><span class="p">,</span> <span class="nx">failureReason</span><span class="p">,</span> <span class="nx">failureMessage</span><span class="p">))</span>
                <span class="c1">// Event 更新
</span><span class="c1"></span>		<span class="nx">jm</span><span class="p">.</span><span class="nx">recorder</span><span class="p">.</span><span class="nf">Event</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">job</span><span class="p">,</span> <span class="nx">v1</span><span class="p">.</span><span class="nx">EventTypeWarning</span><span class="p">,</span> <span class="nx">failureReason</span><span class="p">,</span> <span class="nx">failureMessage</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// 如果需要继续同步
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">jobNeedsSync</span> <span class="o">&amp;&amp;</span> <span class="nx">job</span><span class="p">.</span><span class="nx">DeletionTimestamp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">active</span><span class="p">,</span> <span class="nx">manageJobErr</span> <span class="p">=</span> <span class="nx">jm</span><span class="p">.</span><span class="nf">manageJob</span><span class="p">(</span><span class="nx">activePods</span><span class="p">,</span> <span class="nx">succeeded</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">job</span><span class="p">)</span>
		<span class="p">}</span>
                <span class="c1">// 标记完成
</span><span class="c1"></span>		<span class="nx">completions</span> <span class="o">:=</span> <span class="nx">succeeded</span>
		<span class="nx">complete</span> <span class="o">:=</span> <span class="kc">false</span>
		<span class="k">if</span> <span class="nx">job</span><span class="p">.</span><span class="nx">Spec</span><span class="p">.</span><span class="nx">Completions</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// 没有正常执行的了, 并且1个以上成功的就算完成,
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">succeeded</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">active</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">complete</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// 完成的pod数 已经达到job.Spec.Completions预期, 默认是1, 也在SetDefaults_Job() 函数初始化
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">completions</span> <span class="o">&gt;=</span> <span class="o">*</span><span class="nx">job</span><span class="p">.</span><span class="nx">Spec</span><span class="p">.</span><span class="nx">Completions</span> <span class="p">{</span>
				<span class="nx">complete</span> <span class="p">=</span> <span class="kc">true</span>
				<span class="k">if</span> <span class="nx">active</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
					<span class="nx">jm</span><span class="p">.</span><span class="nx">recorder</span><span class="p">.</span><span class="nf">Event</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">job</span><span class="p">,</span> <span class="nx">v1</span><span class="p">.</span><span class="nx">EventTypeWarning</span><span class="p">,</span> <span class="s">&#34;TooManyActivePods&#34;</span><span class="p">,</span> <span class="s">&#34;Too many active pods running after completion count reached&#34;</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">completions</span> <span class="p">&gt;</span> <span class="o">*</span><span class="nx">job</span><span class="p">.</span><span class="nx">Spec</span><span class="p">.</span><span class="nx">Completions</span> <span class="p">{</span>
					<span class="nx">jm</span><span class="p">.</span><span class="nx">recorder</span><span class="p">.</span><span class="nf">Event</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">job</span><span class="p">,</span> <span class="nx">v1</span><span class="p">.</span><span class="nx">EventTypeWarning</span><span class="p">,</span> <span class="s">&#34;TooManySucceededPods&#34;</span><span class="p">,</span> <span class="s">&#34;Too many succeeded pods running after completion count reached&#34;</span><span class="p">)</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
                <span class="c1">// 修改完成的状态状况
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">complete</span> <span class="p">{</span>
			<span class="nx">job</span><span class="p">.</span><span class="nx">Status</span><span class="p">.</span><span class="nx">Conditions</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">job</span><span class="p">.</span><span class="nx">Status</span><span class="p">.</span><span class="nx">Conditions</span><span class="p">,</span> <span class="nf">newCondition</span><span class="p">(</span><span class="nx">batch</span><span class="p">.</span><span class="nx">JobComplete</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">))</span>
			<span class="nx">now</span> <span class="o">:=</span> <span class="nx">metav1</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
			<span class="nx">job</span><span class="p">.</span><span class="nx">Status</span><span class="p">.</span><span class="nx">CompletionTime</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">now</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">forget</span> <span class="o">:=</span> <span class="kc">false</span>
	<span class="k">if</span> <span class="nx">job</span><span class="p">.</span><span class="nx">Status</span><span class="p">.</span><span class="nx">Succeeded</span> <span class="p">&lt;</span> <span class="nx">succeeded</span> <span class="p">{</span>
		<span class="nx">forget</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="c1">// 是否有任何状态 更新
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">job</span><span class="p">.</span><span class="nx">Status</span><span class="p">.</span><span class="nx">Active</span> <span class="o">!=</span> <span class="nx">active</span> <span class="o">||</span> <span class="nx">job</span><span class="p">.</span><span class="nx">Status</span><span class="p">.</span><span class="nx">Succeeded</span> <span class="o">!=</span> <span class="nx">succeeded</span> <span class="o">||</span> <span class="nx">job</span><span class="p">.</span><span class="nx">Status</span><span class="p">.</span><span class="nx">Failed</span> <span class="o">!=</span> <span class="nx">failed</span> <span class="o">||</span> <span class="nb">len</span><span class="p">(</span><span class="nx">job</span><span class="p">.</span><span class="nx">Status</span><span class="p">.</span><span class="nx">Conditions</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">conditions</span> <span class="p">{</span>
		<span class="nx">job</span><span class="p">.</span><span class="nx">Status</span><span class="p">.</span><span class="nx">Active</span> <span class="p">=</span> <span class="nx">active</span>
		<span class="nx">job</span><span class="p">.</span><span class="nx">Status</span><span class="p">.</span><span class="nx">Succeeded</span> <span class="p">=</span> <span class="nx">succeeded</span>
		<span class="nx">job</span><span class="p">.</span><span class="nx">Status</span><span class="p">.</span><span class="nx">Failed</span> <span class="p">=</span> <span class="nx">failed</span>
                <span class="c1">// 详细说明4
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">jm</span><span class="p">.</span><span class="nf">updateHandler</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">job</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">forget</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">jobHaveNewFailure</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nf">IsJobFinished</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">job</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">forget</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;failed pod(s) detected for job key %q&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="nx">forget</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">forget</span><span class="p">,</span> <span class="nx">manageJobErr</span>
<span class="p">}</span>

</code></pre></div><hr>
<h2 id="其他">其他</h2>
<h3 id="详细说明1-jmjoblisterjobsnsgetname">详细说明1 jm.jobLister.Jobs(ns).Get(name)</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">如何看这个方法是哪个结构体实现</span><span class="o">...</span>
<span class="nx">首先找到</span> <span class="nx">jobLister</span> <span class="nx">的初始化</span> <span class="nx">在</span> <span class="nx">NewJobController</span> <span class="nx">中被设置</span> <span class="nx">jm</span><span class="p">.</span><span class="nx">jobLister</span> <span class="p">=</span> <span class="nx">jobInformer</span><span class="p">.</span><span class="nf">Lister</span><span class="p">()</span>
<span class="nx">jobInformer</span> <span class="nx">是</span> <span class="nx">NewJobController的入参</span><span class="p">,</span> <span class="nx">在</span> <span class="nx">startJobController</span> <span class="nx">函数内可以看到是</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">InformerFactory</span><span class="p">.</span><span class="nf">Batch</span><span class="p">().</span><span class="nf">V1</span><span class="p">().</span><span class="nf">Jobs</span><span class="p">()</span>
<span class="nx">然后找到</span> <span class="nx">InformerFactory</span> <span class="nx">的初始化</span>
<span class="nx">继续从</span> <span class="nx">startJobController的入参</span> <span class="nx">ControllerContext</span> <span class="nx">往上找</span><span class="p">,</span> <span class="nx">我们知道</span> <span class="nx">startJobController</span> <span class="nx">是在</span> <span class="nx">NewControllerInitializers</span> <span class="nx">中初始化</span><span class="p">,</span> <span class="nx">并且返回一个map</span>
<span class="nx">在</span> <span class="nx">StartControllers</span> <span class="nx">函数内部</span> <span class="nx">执行</span> <span class="nf">initFn</span><span class="p">(</span><span class="nx">ctx</span><span class="p">),</span> <span class="nx">所以</span> <span class="nx">startJobController</span> <span class="nx">的ctx参数就是</span> <span class="nx">StartControllers中的</span>
<span class="nx">然后找到</span> <span class="nf">CreateControllerContext</span><span class="p">()</span> <span class="nx">初始化的ctx</span><span class="p">,</span> <span class="nx">ControllerContext</span><span class="p">.</span><span class="nx">InformerFactory</span> <span class="nx">是被</span> <span class="nx">informers</span><span class="p">.</span><span class="nf">NewSharedInformerFactory</span><span class="p">()</span> <span class="nx">设置</span>
<span class="nx">最终返回的是一个</span> <span class="nx">sharedInformerFactory</span> <span class="nx">结构体</span> <span class="nx">来实现SharedInformerFactory</span> <span class="nx">接口</span>

<span class="nx">SharedInformerFactory</span> <span class="nx">的方法</span>
<span class="c1">// ctx.InformerFactory.Batch()
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">sharedInformerFactory</span><span class="p">)</span> <span class="nf">Batch</span><span class="p">()</span> <span class="nx">batch</span><span class="p">.</span><span class="nx">Interface</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">batch</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">f</span><span class="p">.</span><span class="nx">namespace</span><span class="p">,</span> <span class="nx">f</span><span class="p">.</span><span class="nx">tweakListOptions</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// batch.New 是返回group 来实现 batch.Interface 接口
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">f</span> <span class="nx">internalinterfaces</span><span class="p">.</span><span class="nx">SharedInformerFactory</span><span class="p">,</span> <span class="nx">namespace</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">tweakListOptions</span> <span class="nx">internalinterfaces</span><span class="p">.</span><span class="nx">TweakListOptionsFunc</span><span class="p">)</span> <span class="nx">Interface</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">group</span><span class="p">{</span><span class="nx">factory</span><span class="p">:</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">namespace</span><span class="p">:</span> <span class="nx">namespace</span><span class="p">,</span> <span class="nx">tweakListOptions</span><span class="p">:</span> <span class="nx">tweakListOptions</span><span class="p">}</span>
<span class="p">}</span>
<span class="c1">// ctx.InformerFactory.Batch().V1()
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">g</span> <span class="o">*</span><span class="nx">group</span><span class="p">)</span> <span class="nf">V1</span><span class="p">()</span> <span class="nx">v1</span><span class="p">.</span><span class="nx">Interface</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">v1</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">g</span><span class="p">.</span><span class="nx">factory</span><span class="p">,</span> <span class="nx">g</span><span class="p">.</span><span class="nx">namespace</span><span class="p">,</span> <span class="nx">g</span><span class="p">.</span><span class="nx">tweakListOptions</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// v1.version 实现的 v1.Interface
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">f</span> <span class="nx">internalinterfaces</span><span class="p">.</span><span class="nx">SharedInformerFactory</span><span class="p">,</span> <span class="nx">namespace</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">tweakListOptions</span> <span class="nx">internalinterfaces</span><span class="p">.</span><span class="nx">TweakListOptionsFunc</span><span class="p">)</span> <span class="nx">Interface</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">version</span><span class="p">{</span><span class="nx">factory</span><span class="p">:</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">namespace</span><span class="p">:</span> <span class="nx">namespace</span><span class="p">,</span> <span class="nx">tweakListOptions</span><span class="p">:</span> <span class="nx">tweakListOptions</span><span class="p">}</span>
<span class="p">}</span>
<span class="c1">//ctx.InformerFactory.Batch().V1().Jobs()
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">version</span><span class="p">)</span> <span class="nf">Jobs</span><span class="p">()</span> <span class="nx">JobInformer</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">jobInformer</span><span class="p">{</span><span class="nx">factory</span><span class="p">:</span> <span class="nx">v</span><span class="p">.</span><span class="nx">factory</span><span class="p">,</span> <span class="nx">namespace</span><span class="p">:</span> <span class="nx">v</span><span class="p">.</span><span class="nx">namespace</span><span class="p">,</span> <span class="nx">tweakListOptions</span><span class="p">:</span> <span class="nx">v</span><span class="p">.</span><span class="nx">tweakListOptions</span><span class="p">}</span>
<span class="p">}</span>

<span class="nx">继续来看</span> <span class="nx">jm</span><span class="p">.</span><span class="nx">jobLister</span><span class="p">.</span><span class="nf">Jobs</span><span class="p">(</span><span class="nx">ns</span><span class="p">).</span><span class="nf">Get</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
<span class="c1">// vendor/k8s.io/client-go/informers/batch/v1/job.go
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">jobInformer</span><span class="p">)</span> <span class="nf">Lister</span><span class="p">()</span> <span class="nx">v1</span><span class="p">.</span><span class="nx">JobLister</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">v1</span><span class="p">.</span><span class="nf">NewJobLister</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nf">Informer</span><span class="p">().</span><span class="nf">GetIndexer</span><span class="p">())</span>
<span class="p">}</span>
<span class="c1">// v1.NewJobLister
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewJobLister</span><span class="p">(</span><span class="nx">indexer</span> <span class="nx">cache</span><span class="p">.</span><span class="nx">Indexer</span><span class="p">)</span> <span class="nx">JobLister</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">jobLister</span><span class="p">{</span><span class="nx">indexer</span><span class="p">:</span> <span class="nx">indexer</span><span class="p">}</span>
<span class="p">}</span>
<span class="c1">// jm.jobLister.Jobs(ns)
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">jobLister</span><span class="p">)</span> <span class="nf">Jobs</span><span class="p">(</span><span class="nx">namespace</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">JobNamespaceLister</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">jobNamespaceLister</span><span class="p">{</span><span class="nx">indexer</span><span class="p">:</span> <span class="nx">s</span><span class="p">.</span><span class="nx">indexer</span><span class="p">,</span> <span class="nx">namespace</span><span class="p">:</span> <span class="nx">namespace</span><span class="p">}</span>
<span class="p">}</span>
<span class="c1">// jm.jobLister.Jobs(ns).Get(name)
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">jobNamespaceLister</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">v1</span><span class="p">.</span><span class="nx">Job</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">obj</span><span class="p">,</span> <span class="nx">exists</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">indexer</span><span class="p">.</span><span class="nf">GetByKey</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">namespace</span> <span class="o">+</span> <span class="s">&#34;/&#34;</span> <span class="o">+</span> <span class="nx">name</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">exists</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">NewNotFound</span><span class="p">(</span><span class="nx">v1</span><span class="p">.</span><span class="nf">Resource</span><span class="p">(</span><span class="s">&#34;job&#34;</span><span class="p">),</span> <span class="nx">name</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">obj</span><span class="p">.(</span><span class="o">*</span><span class="nx">v1</span><span class="p">.</span><span class="nx">Job</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>

</code></pre></div><h3 id="详细说明2-isjobfinished">详细说明2 IsJobFinished</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">IsJobFinished</span><span class="p">(</span><span class="nx">j</span> <span class="o">*</span><span class="nx">batch</span><span class="p">.</span><span class="nx">Job</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
        <span class="c1">// 对status.Conditions字段遍历
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">j</span><span class="p">.</span><span class="nx">Status</span><span class="p">.</span><span class="nx">Conditions</span> <span class="p">{</span>
                <span class="c1">// status.Conditions.type如果是 &#34;Complete&#34; 或者 &#34;Failed&#34; 并且 status.Conditions.Status 是 &#34;True&#34; 那就返回,job结束
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">batch</span><span class="p">.</span><span class="nx">JobComplete</span> <span class="o">||</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">batch</span><span class="p">.</span><span class="nx">JobFailed</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Status</span> <span class="o">==</span> <span class="nx">v1</span><span class="p">.</span><span class="nx">ConditionTrue</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">true</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></div><h3 id="详细说明3-getpodsforjob">详细说明3 getPodsForJob</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">jm</span> <span class="o">*</span><span class="nx">JobController</span><span class="p">)</span> <span class="nf">getPodsForJob</span><span class="p">(</span><span class="nx">j</span> <span class="o">*</span><span class="nx">batch</span><span class="p">.</span><span class="nx">Job</span><span class="p">)</span> <span class="p">([]</span><span class="o">*</span><span class="nx">v1</span><span class="p">.</span><span class="nx">Pod</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">selector</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">metav1</span><span class="p">.</span><span class="nf">LabelSelectorAsSelector</span><span class="p">(</span><span class="nx">j</span><span class="p">.</span><span class="nx">Spec</span><span class="p">.</span><span class="nx">Selector</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;couldn&#39;t convert Job selector: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// List all pods to include those that don&#39;t match the selector anymore
</span><span class="c1"></span>	<span class="c1">// but have a ControllerRef pointing to this controller.
</span><span class="c1"></span>	<span class="nx">pods</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">jm</span><span class="p">.</span><span class="nx">podStore</span><span class="p">.</span><span class="nf">Pods</span><span class="p">(</span><span class="nx">j</span><span class="p">.</span><span class="nx">Namespace</span><span class="p">).</span><span class="nf">List</span><span class="p">(</span><span class="nx">labels</span><span class="p">.</span><span class="nf">Everything</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="c1">// If any adoptions are attempted, we should first recheck for deletion
</span><span class="c1"></span>	<span class="c1">// with an uncached quorum read sometime after listing Pods (see #42639).
</span><span class="c1"></span>	<span class="nx">canAdoptFunc</span> <span class="o">:=</span> <span class="nx">controller</span><span class="p">.</span><span class="nf">RecheckDeletionTimestamp</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="nx">metav1</span><span class="p">.</span><span class="nx">Object</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">fresh</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">jm</span><span class="p">.</span><span class="nx">kubeClient</span><span class="p">.</span><span class="nf">BatchV1</span><span class="p">().</span><span class="nf">Jobs</span><span class="p">(</span><span class="nx">j</span><span class="p">.</span><span class="nx">Namespace</span><span class="p">).</span><span class="nf">Get</span><span class="p">(</span><span class="nx">j</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="nx">metav1</span><span class="p">.</span><span class="nx">GetOptions</span><span class="p">{})</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">fresh</span><span class="p">.</span><span class="nx">UID</span> <span class="o">!=</span> <span class="nx">j</span><span class="p">.</span><span class="nx">UID</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;original Job %v/%v is gone: got uid %v, wanted %v&#34;</span><span class="p">,</span> <span class="nx">j</span><span class="p">.</span><span class="nx">Namespace</span><span class="p">,</span> <span class="nx">j</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="nx">fresh</span><span class="p">.</span><span class="nx">UID</span><span class="p">,</span> <span class="nx">j</span><span class="p">.</span><span class="nx">UID</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">fresh</span><span class="p">,</span> <span class="kc">nil</span>
	<span class="p">})</span>
	<span class="nx">cm</span> <span class="o">:=</span> <span class="nx">controller</span><span class="p">.</span><span class="nf">NewPodControllerRefManager</span><span class="p">(</span><span class="nx">jm</span><span class="p">.</span><span class="nx">podControl</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">selector</span><span class="p">,</span> <span class="nx">controllerKind</span><span class="p">,</span> <span class="nx">canAdoptFunc</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">cm</span><span class="p">.</span><span class="nf">ClaimPods</span><span class="p">(</span><span class="nx">pods</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3 id="详细说明4-updatehandler">详细说明4 updateHandler</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">jm</span> <span class="o">*</span><span class="nx">JobController</span><span class="p">)</span> <span class="nf">updateJobStatus</span><span class="p">(</span><span class="nx">job</span> <span class="o">*</span><span class="nx">batch</span><span class="p">.</span><span class="nx">Job</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">jobClient</span> <span class="o">:=</span> <span class="nx">jm</span><span class="p">.</span><span class="nx">kubeClient</span><span class="p">.</span><span class="nf">BatchV1</span><span class="p">().</span><span class="nf">Jobs</span><span class="p">(</span><span class="nx">job</span><span class="p">.</span><span class="nx">Namespace</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">statusUpdateRetries</span><span class="p">;</span> <span class="nx">i</span> <span class="p">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">newJob</span> <span class="o">*</span><span class="nx">batch</span><span class="p">.</span><span class="nx">Job</span>
		<span class="nx">newJob</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">jobClient</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">job</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="nx">metav1</span><span class="p">.</span><span class="nx">GetOptions</span><span class="p">{})</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">newJob</span><span class="p">.</span><span class="nx">Status</span> <span class="p">=</span> <span class="nx">job</span><span class="p">.</span><span class="nx">Status</span>
		<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">jobClient</span><span class="p">.</span><span class="nf">UpdateStatus</span><span class="p">(</span><span class="nx">newJob</span><span class="p">);</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></div><h3 id="详细说明5-addafter">详细说明5 AddAfter</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">q</span> <span class="o">*</span><span class="nx">delayingType</span><span class="p">)</span> <span class="nf">AddAfter</span><span class="p">(</span><span class="nx">item</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">duration</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// don&#39;t add if we&#39;re already shutting down
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">q</span><span class="p">.</span><span class="nf">ShuttingDown</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">q</span><span class="p">.</span><span class="nx">metrics</span><span class="p">.</span><span class="nf">retry</span><span class="p">()</span>

	<span class="c1">// immediately add things with no delay
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">duration</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">q</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">q</span><span class="p">.</span><span class="nx">stopCh</span><span class="p">:</span>
		<span class="c1">// unblock if ShutDown() is called
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">q</span><span class="p">.</span><span class="nx">waitingForAddCh</span> <span class="o">&lt;-</span> <span class="o">&amp;</span><span class="nx">waitFor</span><span class="p">{</span><span class="nx">data</span><span class="p">:</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">readyAt</span><span class="p">:</span> <span class="nx">q</span><span class="p">.</span><span class="nx">clock</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="nx">duration</span><span class="p">)}:</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="详细说明11-addratelimited">详细说明11 AddRateLimited</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// 给item 元素添加一个延迟时间
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">q</span> <span class="o">*</span><span class="nx">rateLimitingType</span><span class="p">)</span> <span class="nf">AddRateLimited</span><span class="p">(</span><span class="nx">item</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nx">q</span><span class="p">.</span><span class="nx">DelayingInterface</span><span class="p">.</span><span class="nf">AddAfter</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">rateLimiter</span><span class="p">.</span><span class="nf">When</span><span class="p">(</span><span class="nx">item</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ItemExponentialFailureRateLimiter</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">failuresLock</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
        <span class="c1">// 某个item对应的失败次数
</span><span class="c1"></span>	<span class="nx">failures</span>     <span class="kd">map</span><span class="p">[</span><span class="kd">interface</span><span class="p">{}]</span><span class="kt">int</span>
        <span class="c1">// 基础的延迟时间
</span><span class="c1"></span>	<span class="nx">baseDelay</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
        <span class="c1">// 最大的延迟时间
</span><span class="c1"></span>	<span class="nx">maxDelay</span>  <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">ItemExponentialFailureRateLimiter</span><span class="p">)</span> <span class="nf">When</span><span class="p">(</span><span class="nx">item</span> <span class="kd">interface</span><span class="p">{})</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="p">{</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">failuresLock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">r</span><span class="p">.</span><span class="nx">failuresLock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
        <span class="c1">// 得到 item的 失败次数
</span><span class="c1"></span>	<span class="nx">exp</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">failures</span><span class="p">[</span><span class="nx">item</span><span class="p">]</span>
        <span class="c1">// 递增
</span><span class="c1"></span>	<span class="nx">r</span><span class="p">.</span><span class="nx">failures</span><span class="p">[</span><span class="nx">item</span><span class="p">]</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">failures</span><span class="p">[</span><span class="nx">item</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

	<span class="c1">// 在baseDelay的基础上 根据次数(exp) 指数递增
</span><span class="c1"></span>	<span class="nx">backoff</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">baseDelay</span><span class="p">.</span><span class="nf">Nanoseconds</span><span class="p">())</span> <span class="o">*</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">exp</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">backoff</span> <span class="p">&gt;</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MaxInt64</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">maxDelay</span>
	<span class="p">}</span>
        <span class="c1">// 转换一下
</span><span class="c1"></span>	<span class="nx">calculated</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">backoff</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">calculated</span> <span class="p">&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">maxDelay</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">maxDelay</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">calculated</span>
<span class="p">}</span>
</code></pre></div><hr>
<h2 id="资料">资料</h2>
<ul>
<li>(标注1)<strong><a href="/k8s/k8s%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-client-go%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/">K8s源码学习 client-go延迟队列</a></strong></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>K8s源码学习 client-go延迟队列</title>
			<link>https://www.ngirl.xyz/k8s/k8s%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-client-go%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/</link>
			<pubDate>Wed, 08 Dec 2021 16:04:39 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/k8s/k8s%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-client-go%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/</guid>
			<description>我们知道在部署 pod的时候, 如果失败了, pod会不断的重试, 重试的时间间隔也是不一样的, 重试到一定次数就不在重试
那我们这里的重试间隔时间是如何控制的呢?
下面我们去了解一下
从 controller 找到 deployment 初始化方法看一下
 1 deployment 初始化  k8s的大多组件代码格式结构是类似的
 1. cmd/kube-controller-manager/controller-manager.go main() -&amp;gt; app.NewControllerManagerCommand() 2. cmd/kube-controller-manager/app/controllermanager.go NewControllerManagerCommand() *cobra.Command -&amp;gt; Run(...) -&amp;gt; NewControllerInitializers(...) map[string]InitFunc // 这里返回控制器的map,后续会对他遍历执行InitFunc  { controllers[&amp;#34;deployment&amp;#34;] = startDeploymentController } 3. cmd/kube-controller-manager/app/apps.go startDeploymentController(...) (...) { dc, err := deployment.NewDeploymentController(...) go dc.Run(int(ctx.ComponentConfig.DeploymentController.ConcurrentDeploymentSyncs), ctx.Stop) } 3.1 pkg/controller/deployment/deployment_controller.go -&amp;gt; NewDeploymentController(...) (...) { dc := &amp;amp;DeploymentController{ queue: workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), &amp;#34;deployment&amp;#34;), } } -&amp;gt; NewNamedRateLimitingQueue(.</description>
			<content type="html"><![CDATA[<blockquote>
<p>我们知道在部署 pod的时候, 如果失败了, pod会不断的重试, 重试的时间间隔也是不一样的, 重试到一定次数就不在重试</p>
<p>那我们这里的重试间隔时间是如何控制的呢?</p>
<p>下面我们去了解一下</p>
<p>从 controller 找到 deployment 初始化方法看一下</p>
</blockquote>
<h2 id="1-deployment-初始化">1 deployment 初始化</h2>
<blockquote>
<p>k8s的大多组件代码格式结构是类似的</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="mf">1.</span> <span class="nx">cmd</span><span class="o">/</span><span class="nx">kube</span><span class="o">-</span><span class="nx">controller</span><span class="o">-</span><span class="nx">manager</span><span class="o">/</span><span class="nx">controller</span><span class="o">-</span><span class="nx">manager</span><span class="p">.</span><span class="k">go</span>
        <span class="nf">main</span><span class="p">()</span>  
        <span class="o">-</span><span class="p">&gt;</span> <span class="nx">app</span><span class="p">.</span><span class="nf">NewControllerManagerCommand</span><span class="p">()</span>
<span class="mf">2.</span> <span class="nx">cmd</span><span class="o">/</span><span class="nx">kube</span><span class="o">-</span><span class="nx">controller</span><span class="o">-</span><span class="nx">manager</span><span class="o">/</span><span class="nx">app</span><span class="o">/</span><span class="nx">controllermanager</span><span class="p">.</span><span class="k">go</span>
        <span class="nf">NewControllerManagerCommand</span><span class="p">()</span> <span class="o">*</span><span class="nx">cobra</span><span class="p">.</span><span class="nx">Command</span>
        <span class="o">-</span><span class="p">&gt;</span> <span class="nf">Run</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
        <span class="o">-</span><span class="p">&gt;</span> <span class="nf">NewControllerInitializers</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">InitFunc</span>   <span class="c1">// 这里返回控制器的map,后续会对他遍历执行InitFunc
</span><span class="c1"></span>                <span class="p">{</span>
                        <span class="nx">controllers</span><span class="p">[</span><span class="s">&#34;deployment&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">startDeploymentController</span>
                <span class="p">}</span>
<span class="mf">3.</span> <span class="nx">cmd</span><span class="o">/</span><span class="nx">kube</span><span class="o">-</span><span class="nx">controller</span><span class="o">-</span><span class="nx">manager</span><span class="o">/</span><span class="nx">app</span><span class="o">/</span><span class="nx">apps</span><span class="p">.</span><span class="k">go</span>
        <span class="nf">startDeploymentController</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">dc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">deployment</span><span class="p">.</span><span class="nf">NewDeploymentController</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
                <span class="k">go</span> <span class="nx">dc</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">ComponentConfig</span><span class="p">.</span><span class="nx">DeploymentController</span><span class="p">.</span><span class="nx">ConcurrentDeploymentSyncs</span><span class="p">),</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">Stop</span><span class="p">)</span>

        <span class="p">}</span>
<span class="mf">3.1</span> <span class="nx">pkg</span><span class="o">/</span><span class="nx">controller</span><span class="o">/</span><span class="nx">deployment</span><span class="o">/</span><span class="nx">deployment_controller</span><span class="p">.</span><span class="k">go</span>
        <span class="o">-</span><span class="p">&gt;</span> <span class="nf">NewDeploymentController</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">dc</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">DeploymentController</span><span class="p">{</span>
                        <span class="nx">queue</span><span class="p">:</span>         <span class="nx">workqueue</span><span class="p">.</span><span class="nf">NewNamedRateLimitingQueue</span><span class="p">(</span><span class="nx">workqueue</span><span class="p">.</span><span class="nf">DefaultControllerRateLimiter</span><span class="p">(),</span> <span class="s">&#34;deployment&#34;</span><span class="p">),</span>
                <span class="p">}</span>
        <span class="p">}</span>
        <span class="o">-</span><span class="p">&gt;</span> <span class="nf">NewNamedRateLimitingQueue</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="nx">RateLimitingInterface</span> <span class="p">{</span>
                <span class="k">return</span> <span class="o">&amp;</span><span class="nx">rateLimitingType</span><span class="p">{</span>
                        <span class="nx">DelayingInterface</span><span class="p">:</span> <span class="nf">NewNamedDelayingQueue</span><span class="p">(</span><span class="nx">name</span><span class="p">),</span>
                        <span class="nx">rateLimiter</span><span class="p">:</span>       <span class="nx">rateLimiter</span><span class="p">,</span> <span class="c1">// 限流器
</span><span class="c1"></span>                <span class="p">}</span>
        <span class="p">}</span>
        <span class="o">-</span><span class="p">&gt;</span> <span class="nf">NewNamedDelayingQueue</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="nx">DelayingInterface</span>
        <span class="o">-</span><span class="p">&gt;</span> <span class="nf">newDelayingQueue</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="nx">DelayingInterface</span> <span class="p">{</span>
                <span class="nx">ret</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">delayingType</span><span class="p">{</span>
        		<span class="nx">Interface</span><span class="p">:</span>       <span class="nf">NewNamed</span><span class="p">(</span><span class="nx">name</span><span class="p">),</span>
        	       <span class="p">}</span>
                <span class="p">}</span>
        <span class="o">-</span><span class="p">&gt;</span> <span class="nf">NewNamed</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="o">*</span><span class="nx">Type</span>

<span class="mf">3.2</span> <span class="nx">pkg</span><span class="o">/</span><span class="nx">controller</span><span class="o">/</span><span class="nx">deployment</span><span class="o">/</span><span class="nx">deployment_controller</span><span class="p">.</span><span class="k">go</span>
        <span class="nf">Run</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
        <span class="o">-</span><span class="p">&gt;</span> <span class="nx">dc</span><span class="p">.</span><span class="nf">worker</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">for</span> <span class="nx">dc</span><span class="p">.</span><span class="nf">processNextWorkItem</span><span class="p">()</span> <span class="p">{</span>
	        <span class="p">}</span>
           <span class="p">}</span>
        <span class="o">-</span><span class="p">&gt;</span> <span class="nf">processNextWorkItem</span><span class="p">()</span> <span class="p">{</span>
                <span class="nx">err</span> <span class="o">:=</span> <span class="nx">dc</span><span class="p">.</span><span class="nf">syncHandler</span><span class="p">(</span><span class="nx">key</span><span class="p">.(</span><span class="kt">string</span><span class="p">))</span>
                <span class="nx">dc</span><span class="p">.</span><span class="nf">handleErr</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
           <span class="p">}</span>
</code></pre></div><blockquote>
<p>看到以上流程, 我们知道</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">rateLimitingType</span> <span class="nx">结构体实现了</span> <span class="nx">RateLimitingInterface</span> <span class="nx">限流队列接口</span>
<span class="nx">delayingType</span> <span class="nx">结构体实现了</span> <span class="nx">DelayingInterface</span> <span class="nx">延迟队列接口</span>
<span class="o">*</span><span class="nx">Type</span> <span class="nx">指针类型结构体实现了</span> <span class="nx">Interface</span> <span class="nx">同样队列接口</span>
</code></pre></div><h3 id="11-队列接口">1.1 队列接口</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// vendor/k8s.io/client-go/util/workqueue/rate_limiting_queue.go
</span><span class="c1">// 限流接口
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">RateLimitingInterface</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">DelayingInterface</span>
	<span class="nf">AddRateLimited</span><span class="p">(</span><span class="nx">item</span> <span class="kd">interface</span><span class="p">{})</span>
	<span class="nf">Forget</span><span class="p">(</span><span class="nx">item</span> <span class="kd">interface</span><span class="p">{})</span>
	<span class="nf">NumRequeues</span><span class="p">(</span><span class="nx">item</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="c1">// vendor/k8s.io/client-go/util/workqueue/delaying_queue.go
</span><span class="c1">// 延迟接口
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">DelayingInterface</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Interface</span>      <span class="c1">// 通用接口
</span><span class="c1"></span>	<span class="nf">AddAfter</span><span class="p">(</span><span class="nx">item</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">duration</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span>     
<span class="p">}</span>

<span class="c1">// vendor/k8s.io/client-go/util/workqueue/queue.go
</span><span class="c1">// 通用接口
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Interface</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Add</span><span class="p">(</span><span class="nx">item</span> <span class="kd">interface</span><span class="p">{})</span>
	<span class="nf">Len</span><span class="p">()</span> <span class="kt">int</span>
	<span class="nf">Get</span><span class="p">()</span> <span class="p">(</span><span class="nx">item</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">shutdown</span> <span class="kt">bool</span><span class="p">)</span>
	<span class="nf">Done</span><span class="p">(</span><span class="nx">item</span> <span class="kd">interface</span><span class="p">{})</span>
	<span class="nf">ShutDown</span><span class="p">()</span>
	<span class="nf">ShuttingDown</span><span class="p">()</span> <span class="kt">bool</span>
<span class="p">}</span>
<span class="c1">// 限流接口
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">RateLimiter</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">When</span><span class="p">(</span><span class="nx">item</span> <span class="kd">interface</span><span class="p">{})</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
	<span class="nf">Forget</span><span class="p">(</span><span class="nx">item</span> <span class="kd">interface</span><span class="p">{})</span>
	<span class="nf">NumRequeues</span><span class="p">(</span><span class="nx">item</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">int</span>
<span class="p">}</span>

</code></pre></div><h3 id="12-实现接口的结构体">1.2 实现接口的结构体</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 限流结构体直接嵌套 延迟队列 接口的
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">rateLimitingType</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">DelayingInterface</span>
	<span class="nx">rateLimiter</span> <span class="nx">RateLimiter</span>
<span class="p">}</span>
<span class="c1">// 延迟结构体 同样嵌套 同样队列接口
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">delayingType</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Interface</span>
	<span class="c1">// 时钟
</span><span class="c1"></span>	<span class="nx">clock</span> <span class="nx">clock</span><span class="p">.</span><span class="nx">Clock</span>
	<span class="c1">// 退出信号
</span><span class="c1"></span>	<span class="nx">stopCh</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
	<span class="nx">stopOnce</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
	<span class="nx">heartbeat</span> <span class="nx">clock</span><span class="p">.</span><span class="nx">Ticker</span>
	<span class="nx">waitingForAddCh</span> <span class="kd">chan</span> <span class="o">*</span><span class="nx">waitFor</span>  <span class="c1">// 用于保存到小顶堆中的 channel 通道
</span><span class="c1"></span>	<span class="c1">// 重试的次数, retryMetrics 接口 只有一个retry() 方法
</span><span class="c1"></span>	<span class="nx">metrics</span> <span class="nx">retryMetrics</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">waitFor</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">data</span>    <span class="nx">t</span>              <span class="c1">// 元素
</span><span class="c1"></span>	<span class="nx">readyAt</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>      <span class="c1">// 延迟多久添加到队列
</span><span class="c1"></span>	<span class="nx">index</span> <span class="kt">int</span>              <span class="c1">// 小顶堆的索引
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">// 工作队列
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Type</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">queue</span> <span class="p">[]</span><span class="nx">t</span>      <span class="c1">// type t interface{}
</span><span class="c1"></span>	<span class="nx">dirty</span> <span class="nx">set</span>      <span class="c1">// type set map[t]empty
</span><span class="c1"></span>	<span class="nx">processing</span> <span class="nx">set</span>
	<span class="nx">cond</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">Cond</span>
	<span class="nx">shuttingDown</span> <span class="kt">bool</span>
	<span class="nx">metrics</span> <span class="nx">queueMetrics</span>   
	<span class="nx">unfinishedWorkUpdatePeriod</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
	<span class="nx">clock</span>                      <span class="nx">clock</span><span class="p">.</span><span class="nx">Clock</span>
<span class="p">}</span>

</code></pre></div><hr>
<blockquote>
<p>在 <code>startDeploymentController</code> 中核心就是两个方法, 一个是 <code>NewDeploymentController</code>, 一个是 <code>Run</code></p>
</blockquote>
<h2 id="2-newdeploymentcontroller">2 NewDeploymentController</h2>
<h3 id="21-队列初始化">2.1 队列初始化</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 从例子中deployment控制器的初始化我们看到queue的初始化
</span><span class="c1"></span><span class="nx">queue</span><span class="p">:</span>         <span class="nx">workqueue</span><span class="p">.</span><span class="nf">NewNamedRateLimitingQueue</span><span class="p">(</span><span class="nx">workqueue</span><span class="p">.</span><span class="nf">DefaultControllerRateLimiter</span><span class="p">(),</span> <span class="s">&#34;deployment&#34;</span><span class="p">),</span>
</code></pre></div><ul>
<li>先看下第一个参数</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// workqueue.DefaultControllerRateLimiter() 函数
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">DefaultControllerRateLimiter</span><span class="p">()</span> <span class="nx">RateLimiter</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">NewMaxOfRateLimiter</span><span class="p">(</span>
                <span class="c1">// 第一个限流器,指数级, 设置失败的item的限流队列, 并设置 baseDelay 和maxDelay
</span><span class="c1"></span>		<span class="nf">NewItemExponentialFailureRateLimiter</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">,</span> <span class="mi">1000</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">),</span>
                <span class="c1">// 第二个限流器,令牌桶常数级, 10qps,100的桶, 这是一个令牌桶
</span><span class="c1"></span>		<span class="o">&amp;</span><span class="nx">BucketRateLimiter</span><span class="p">{</span><span class="nx">Limiter</span><span class="p">:</span> <span class="nx">rate</span><span class="p">.</span><span class="nf">NewLimiter</span><span class="p">(</span><span class="nx">rate</span><span class="p">.</span><span class="nf">Limit</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="mi">100</span><span class="p">)},</span>
	<span class="p">)</span>
<span class="p">}</span>
<span class="c1">// 一个[]RateLimiter 列表
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewMaxOfRateLimiter</span><span class="p">(</span><span class="nx">limiters</span> <span class="o">...</span><span class="nx">RateLimiter</span><span class="p">)</span> <span class="nx">RateLimiter</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">MaxOfRateLimiter</span><span class="p">{</span><span class="nx">limiters</span><span class="p">:</span> <span class="nx">limiters</span><span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 第一个限流器 NewItemExponentialFailureRateLimiter
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewItemExponentialFailureRateLimiter</span><span class="p">(</span><span class="nx">baseDelay</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">,</span> <span class="nx">maxDelay</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="nx">RateLimiter</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">ItemExponentialFailureRateLimiter</span><span class="p">{</span>
		<span class="nx">failures</span><span class="p">:</span>  <span class="kd">map</span><span class="p">[</span><span class="kd">interface</span><span class="p">{}]</span><span class="kt">int</span><span class="p">{},</span>
		<span class="nx">baseDelay</span><span class="p">:</span> <span class="nx">baseDelay</span><span class="p">,</span>
		<span class="nx">maxDelay</span><span class="p">:</span>  <span class="nx">maxDelay</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 第二个令牌桶 BucketRateLimiter
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewLimiter</span><span class="p">(</span><span class="nx">r</span> <span class="nx">Limit</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Limiter</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Limiter</span><span class="p">{</span>
		<span class="nx">limit</span><span class="p">:</span> <span class="nx">r</span><span class="p">,</span>
		<span class="nx">burst</span><span class="p">:</span> <span class="nx">b</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>接着看下初始化函数</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// NewNamedRateLimitingQueue 两个参数, 第一个 RateLimiter 接口, 第二个是名字字符串
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewNamedRateLimitingQueue</span><span class="p">(</span><span class="nx">rateLimiter</span> <span class="nx">RateLimiter</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">RateLimitingInterface</span> <span class="p">{</span>
        <span class="c1">// 返回 rateLimitingType 这个结构体, 实现限流队列接口
</span><span class="c1"></span>	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">rateLimitingType</span><span class="p">{</span>
                <span class="c1">// 延迟队列的初始化
</span><span class="c1"></span>		<span class="nx">DelayingInterface</span><span class="p">:</span> <span class="nf">NewNamedDelayingQueue</span><span class="p">(</span><span class="nx">name</span><span class="p">),</span>
		<span class="nx">rateLimiter</span><span class="p">:</span>       <span class="nx">rateLimiter</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="c1">// NewNamedDelayingQueue
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewNamedDelayingQueue</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">DelayingInterface</span> <span class="p">{</span>
        <span class="c1">// RealClock结构体没有元素, RealClock really calls time.Now()
</span><span class="c1"></span>	<span class="k">return</span> <span class="nf">newDelayingQueue</span><span class="p">(</span><span class="nx">clock</span><span class="p">.</span><span class="nx">RealClock</span><span class="p">{},</span> <span class="nx">name</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">newDelayingQueue</span><span class="p">(</span><span class="nx">clock</span> <span class="nx">clock</span><span class="p">.</span><span class="nx">Clock</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">DelayingInterface</span> <span class="p">{</span>
        <span class="c1">// delayingType 结构体初始化
</span><span class="c1"></span>	<span class="nx">ret</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">delayingType</span><span class="p">{</span>
                <span class="c1">// 同样接口初始化
</span><span class="c1"></span>		<span class="nx">Interface</span><span class="p">:</span>       <span class="nf">NewNamed</span><span class="p">(</span><span class="nx">name</span><span class="p">),</span>
		<span class="nx">clock</span><span class="p">:</span>           <span class="nx">clock</span><span class="p">,</span>
		<span class="nx">heartbeat</span><span class="p">:</span>       <span class="nx">clock</span><span class="p">.</span><span class="nf">NewTicker</span><span class="p">(</span><span class="nx">maxWait</span><span class="p">),</span>
		<span class="nx">stopCh</span><span class="p">:</span>          <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}),</span>
		<span class="nx">waitingForAddCh</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="o">*</span><span class="nx">waitFor</span><span class="p">,</span> <span class="mi">1000</span><span class="p">),</span>
		<span class="nx">metrics</span><span class="p">:</span>         <span class="nf">newRetryMetrics</span><span class="p">(</span><span class="nx">name</span><span class="p">),</span>
	<span class="p">}</span>
        <span class="c1">// 协程循环
</span><span class="c1"></span>	<span class="k">go</span> <span class="nx">ret</span><span class="p">.</span><span class="nf">waitingLoop</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>核心的延迟循环</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">q</span> <span class="o">*</span><span class="nx">delayingType</span><span class="p">)</span> <span class="nf">waitingLoop</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nx">utilruntime</span><span class="p">.</span><span class="nf">HandleCrash</span><span class="p">()</span>

	<span class="c1">// 赋值nextReadyAt,首次pass
</span><span class="c1"></span>	<span class="nx">never</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span>
        <span class="c1">// waitForPriorityQueue 结构体是一个堆的实现
</span><span class="c1"></span>	<span class="nx">waitingForQueue</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">waitForPriorityQueue</span><span class="p">{}</span>
        <span class="c1">// 初始化 小顶堆
</span><span class="c1"></span>	<span class="nx">heap</span><span class="p">.</span><span class="nf">Init</span><span class="p">(</span><span class="nx">waitingForQueue</span><span class="p">)</span>
        <span class="c1">// 定义一个map存储 waitfor
</span><span class="c1"></span>	<span class="nx">waitingEntryByData</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="nx">t</span><span class="p">]</span><span class="o">*</span><span class="nx">waitFor</span><span class="p">{}</span>
	<span class="k">for</span> <span class="p">{</span>
                <span class="c1">// 如果 工作队列正在结束, 就是看shuttingDown的标志位
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Interface</span><span class="p">.</span><span class="nf">ShuttingDown</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
                <span class="c1">// 当前时间戳 time.Now()
</span><span class="c1"></span>		<span class="nx">now</span> <span class="o">:=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">clock</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>

		<span class="c1">// 如果 堆 不空
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">waitingForQueue</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                        <span class="c1">// 堆顶, 也就是时间戳最小的元素, 拿出来看一眼先
</span><span class="c1"></span>			<span class="nx">entry</span> <span class="o">:=</span> <span class="nx">waitingForQueue</span><span class="p">.</span><span class="nf">Peek</span><span class="p">().(</span><span class="o">*</span><span class="nx">waitFor</span><span class="p">)</span>
                        <span class="c1">// entry.readyAt 时间如果晚于 now, 说明第一个还没到时间, 那么就退出循环
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">readyAt</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
                        <span class="c1">// 否则的话, 看过了没问题, 现在就真的要出堆了
</span><span class="c1"></span>                        <span class="c1">// 因为是小顶堆, 所以先把最后一个和第一个(堆顶)交换, 然后对最后一个进行下沉操作, 最后返回从堆顶交换下来的(旧堆顶)出堆
</span><span class="c1"></span>			<span class="nx">entry</span> <span class="p">=</span> <span class="nx">heap</span><span class="p">.</span><span class="nf">Pop</span><span class="p">(</span><span class="nx">waitingForQueue</span><span class="p">).(</span><span class="o">*</span><span class="nx">waitFor</span><span class="p">)</span>
                        <span class="c1">// Add是Interface通用接口的方法
</span><span class="c1"></span>                        <span class="c1">// 往工作队列中添加 data 去消费了
</span><span class="c1"></span>			<span class="nx">q</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">entry</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span>
                        <span class="c1">// 然后把waitingEntryByData 表清理一下
</span><span class="c1"></span>			<span class="nb">delete</span><span class="p">(</span><span class="nx">waitingEntryByData</span><span class="p">,</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// 走到这里的话 说明waitingForQueue.Len() == 0
</span><span class="c1"></span>                <span class="c1">// 首次初始化的情况
</span><span class="c1"></span>		<span class="nx">nextReadyAt</span> <span class="o">:=</span> <span class="nx">never</span>
                <span class="c1">// 如果还有元素
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">waitingForQueue</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                        <span class="c1">// 再看一眼
</span><span class="c1"></span>			<span class="nx">entry</span> <span class="o">:=</span> <span class="nx">waitingForQueue</span><span class="p">.</span><span class="nf">Peek</span><span class="p">().(</span><span class="o">*</span><span class="nx">waitFor</span><span class="p">)</span>
                        <span class="c1">// entry.readyAt.Sub 是把这个元素的时间 entry.readyAt 减去 当前时间now
</span><span class="c1"></span>                        <span class="c1">// q.clock.After 实际就是 time.After, 所以就是延迟了
</span><span class="c1"></span>			<span class="nx">nextReadyAt</span> <span class="p">=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">clock</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="nx">entry</span><span class="p">.</span><span class="nx">readyAt</span><span class="p">.</span><span class="nf">Sub</span><span class="p">(</span><span class="nx">now</span><span class="p">))</span>
		<span class="p">}</span>

		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">q</span><span class="p">.</span><span class="nx">stopCh</span><span class="p">:</span>
			<span class="k">return</span>
                <span class="c1">// ticker
</span><span class="c1"></span>		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">q</span><span class="p">.</span><span class="nx">heartbeat</span><span class="p">.</span><span class="nf">C</span><span class="p">():</span>
                <span class="c1">// 如果上面拿到元素了就可以直接循环去处理那个看过的entry
</span><span class="c1"></span>                <span class="c1">// 当然如果没有元素, 这里就是never, 会被pass
</span><span class="c1"></span>		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">nextReadyAt</span><span class="p">:</span>
			<span class="c1">// continue the loop, which will add ready items
</span><span class="c1"></span>                <span class="c1">// waitingForAddCh channel 有写入, 一般在After函数中
</span><span class="c1"></span>		<span class="k">case</span> <span class="nx">waitEntry</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">q</span><span class="p">.</span><span class="nx">waitingForAddCh</span><span class="p">:</span>
                        <span class="c1">// 同样比较一个 waitEntry.readyAt 是否 大于 当前时间戳
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">waitEntry</span><span class="p">.</span><span class="nx">readyAt</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">clock</span><span class="p">.</span><span class="nf">Now</span><span class="p">())</span> <span class="p">{</span>
                                <span class="c1">// 大于的话就加入到等待队列
</span><span class="c1"></span>				<span class="nf">insert</span><span class="p">(</span><span class="nx">waitingForQueue</span><span class="p">,</span> <span class="nx">waitingEntryByData</span><span class="p">,</span> <span class="nx">waitEntry</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                                <span class="c1">// 否则就处理工作
</span><span class="c1"></span>				<span class="nx">q</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">waitEntry</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span>
			<span class="p">}</span>
                        <span class="c1">// 批量处理, 把waitingForAddCh 取完
</span><span class="c1"></span>			<span class="nx">drained</span> <span class="o">:=</span> <span class="kc">false</span>
			<span class="k">for</span> <span class="p">!</span><span class="nx">drained</span> <span class="p">{</span>
				<span class="k">select</span> <span class="p">{</span>
				<span class="k">case</span> <span class="nx">waitEntry</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">q</span><span class="p">.</span><span class="nx">waitingForAddCh</span><span class="p">:</span>
					<span class="k">if</span> <span class="nx">waitEntry</span><span class="p">.</span><span class="nx">readyAt</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">clock</span><span class="p">.</span><span class="nf">Now</span><span class="p">())</span> <span class="p">{</span>
						<span class="nf">insert</span><span class="p">(</span><span class="nx">waitingForQueue</span><span class="p">,</span> <span class="nx">waitingEntryByData</span><span class="p">,</span> <span class="nx">waitEntry</span><span class="p">)</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="nx">q</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">waitEntry</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span>
					<span class="p">}</span>
                                <span class="c1">// 取完了
</span><span class="c1"></span>				<span class="k">default</span><span class="p">:</span>
					<span class="nx">drained</span> <span class="p">=</span> <span class="kc">true</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>waitingLoop 总结</li>
</ul>
<blockquote>
<p>看完 <code>waitingLoop</code> 我们发现, 延迟队列是通过一个 <code>waitForPriorityQueue</code> 队列实现, <code>waitForPriorityQueue</code> 其实 sort接口 和 heap接口</p>
<p>从实现的 <code>Less</code> 方法我们知道, <code>readyAt</code> 最小的在堆顶</p>
<p>通过循环 读取 <code>waitingForAddCh</code> 通道的数据, 然后添加到 <code>waitingForQueue</code>, 进行堆排, 然后执行 <code>time.After</code> 延迟后加入到 工作队列执行</p>
</blockquote>
<blockquote>
<p>那么 <code>waitingForAddCh</code>通道的内容是在什么时候加进来的呢? 我们接着 <code>NewDeploymentController</code> 继续往下看</p>
</blockquote>
<h3 id="22-sync方法">2.2 sync方法</h3>
<blockquote>
<p>syncHandler 是在什么时候执行的呢? 我们后面会见到</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewDeploymentController</span><span class="p">(</span><span class="nx">dInformer</span> <span class="nx">appsinformers</span><span class="p">.</span><span class="nx">DeploymentInformer</span><span class="p">,</span> <span class="nx">rsInformer</span> <span class="nx">appsinformers</span><span class="p">.</span><span class="nx">ReplicaSetInformer</span><span class="p">,</span> <span class="nx">podInformer</span> <span class="nx">coreinformers</span><span class="p">.</span><span class="nx">PodInformer</span><span class="p">,</span> <span class="nx">client</span> <span class="nx">clientset</span><span class="p">.</span><span class="nx">Interface</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">DeploymentController</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">...</span>
	<span class="nx">dc</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">DeploymentController</span><span class="p">{</span>
		<span class="nx">queue</span><span class="p">:</span>         <span class="nx">workqueue</span><span class="p">.</span><span class="nf">NewNamedRateLimitingQueue</span><span class="p">(</span><span class="nx">workqueue</span><span class="p">.</span><span class="nf">DefaultControllerRateLimiter</span><span class="p">(),</span> <span class="s">&#34;deployment&#34;</span><span class="p">),</span>
	<span class="p">}</span>
	<span class="o">...</span>
	<span class="nx">dc</span><span class="p">.</span><span class="nx">syncHandler</span> <span class="p">=</span> <span class="nx">dc</span><span class="p">.</span><span class="nx">syncDeployment</span>
        <span class="o">...</span>
	<span class="k">return</span> <span class="nx">dc</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>syncDeployment</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// pkg/controller/deployment/deployment_controller.go
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">dc</span> <span class="o">*</span><span class="nx">DeploymentController</span><span class="p">)</span> <span class="nf">syncDeployment</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
        <span class="o">...</span>
	<span class="nx">namespace</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cache</span><span class="p">.</span><span class="nf">SplitMetaNamespaceKey</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
        <span class="o">...</span>
	<span class="nx">deployment</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">dc</span><span class="p">.</span><span class="nx">dLister</span><span class="p">.</span><span class="nf">Deployments</span><span class="p">(</span><span class="nx">namespace</span><span class="p">).</span><span class="nf">Get</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
        <span class="o">...</span>
        <span class="c1">// 深copy一份
</span><span class="c1"></span>	<span class="nx">d</span> <span class="o">:=</span> <span class="nx">deployment</span><span class="p">.</span><span class="nf">DeepCopy</span><span class="p">()</span>

	<span class="o">...</span>
        <span class="c1">// 查看 deployment的状态
</span><span class="c1"></span>	<span class="k">switch</span> <span class="nx">d</span><span class="p">.</span><span class="nx">Spec</span><span class="p">.</span><span class="nx">Strategy</span><span class="p">.</span><span class="nx">Type</span> <span class="p">{</span>
        <span class="c1">// &#34;Recreate&#34;
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">apps</span><span class="p">.</span><span class="nx">RecreateDeploymentStrategyType</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">dc</span><span class="p">.</span><span class="nf">rolloutRecreate</span><span class="p">(</span><span class="nx">d</span><span class="p">,</span> <span class="nx">rsList</span><span class="p">,</span> <span class="nx">podMap</span><span class="p">)</span>
        <span class="c1">// &#34;RollingUpdate&#34;
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">apps</span><span class="p">.</span><span class="nx">RollingUpdateDeploymentStrategyType</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">dc</span><span class="p">.</span><span class="nf">rolloutRolling</span><span class="p">(</span><span class="nx">d</span><span class="p">,</span> <span class="nx">rsList</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;unexpected deployment strategy type: %s&#34;</span><span class="p">,</span> <span class="nx">d</span><span class="p">.</span><span class="nx">Spec</span><span class="p">.</span><span class="nx">Strategy</span><span class="p">.</span><span class="nx">Type</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 不管是 Recreate 还是 RollingUpdate 最终都会调用 syncRolloutStatus
</span><span class="c1">// pkg/controller/deployment/progress.go
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">dc</span> <span class="o">*</span><span class="nx">DeploymentController</span><span class="p">)</span> <span class="nf">syncRolloutStatus</span><span class="p">(</span><span class="nx">allRSs</span> <span class="p">[]</span><span class="o">*</span><span class="nx">apps</span><span class="p">.</span><span class="nx">ReplicaSet</span><span class="p">,</span> <span class="nx">newRS</span> <span class="o">*</span><span class="nx">apps</span><span class="p">.</span><span class="nx">ReplicaSet</span><span class="p">,</span> <span class="nx">d</span> <span class="o">*</span><span class="nx">apps</span><span class="p">.</span><span class="nx">Deployment</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
        <span class="nx">newStatus</span> <span class="o">:=</span> <span class="nf">calculateStatus</span><span class="p">(</span><span class="nx">allRSs</span><span class="p">,</span> <span class="nx">newRS</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span>
        <span class="o">...</span>
        <span class="c1">// 如果没有新的更新
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">DeepEqual</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">Status</span><span class="p">,</span> <span class="nx">newStatus</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 这个时候就去调用延迟队列了
</span><span class="c1"></span>                <span class="nx">dc</span><span class="p">.</span><span class="nf">requeueStuckDeployment</span><span class="p">(</span><span class="nx">d</span><span class="p">,</span> <span class="nx">newStatus</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// requeueStuckDeployment
</span><span class="c1">// pkg/controller/deployment/progress.go
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">dc</span> <span class="o">*</span><span class="nx">DeploymentController</span><span class="p">)</span> <span class="nf">requeueStuckDeployment</span><span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">apps</span><span class="p">.</span><span class="nx">Deployment</span><span class="p">,</span> <span class="nx">newStatus</span> <span class="nx">apps</span><span class="p">.</span><span class="nx">DeploymentStatus</span><span class="p">)</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="p">{</span>
	<span class="nx">currentCond</span> <span class="o">:=</span> <span class="nx">util</span><span class="p">.</span><span class="nf">GetDeploymentCondition</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">Status</span><span class="p">,</span> <span class="nx">apps</span><span class="p">.</span><span class="nx">DeploymentProgressing</span><span class="p">)</span>
	<span class="c1">// 如果没有设置 spec.ProgressDeadlineSeconds的话 就直接退出了, 不会延迟
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">util</span><span class="p">.</span><span class="nf">HasProgressDeadline</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span> <span class="o">||</span> <span class="nx">currentCond</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
        <span class="c1">// 已经完成了 或者超时的原因 也直接退出
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">util</span><span class="p">.</span><span class="nf">DeploymentComplete</span><span class="p">(</span><span class="nx">d</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">newStatus</span><span class="p">)</span> <span class="o">||</span> <span class="nx">currentCond</span><span class="p">.</span><span class="nx">Reason</span> <span class="o">==</span> <span class="nx">util</span><span class="p">.</span><span class="nx">TimedOutReason</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 计算要延迟的时间
</span><span class="c1"></span>        <span class="c1">// = LastUpdateTime + ProgressDeadlineSeconds - time.now()
</span><span class="c1"></span>	<span class="nx">after</span> <span class="o">:=</span> <span class="nx">currentCond</span><span class="p">.</span><span class="nx">LastUpdateTime</span><span class="p">.</span><span class="nx">Time</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="o">*</span><span class="nx">d</span><span class="p">.</span><span class="nx">Spec</span><span class="p">.</span><span class="nx">ProgressDeadlineSeconds</span><span class="p">)</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">).</span><span class="nf">Sub</span><span class="p">(</span><span class="nf">nowFn</span><span class="p">())</span>
	<span class="o">...</span>
        <span class="c1">// 要延迟 after + 1 秒
</span><span class="c1"></span>	<span class="nx">dc</span><span class="p">.</span><span class="nf">enqueueAfter</span><span class="p">(</span><span class="nx">d</span><span class="p">,</span> <span class="nx">after</span><span class="o">+</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">after</span>
<span class="p">}</span>
<span class="c1">// enqueueAfter
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">dc</span> <span class="o">*</span><span class="nx">DeploymentController</span><span class="p">)</span> <span class="nf">enqueueAfter</span><span class="p">(</span><span class="nx">deployment</span> <span class="o">*</span><span class="nx">apps</span><span class="p">.</span><span class="nx">Deployment</span><span class="p">,</span> <span class="nx">after</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">...</span>
        <span class="c1">// queue 我们知道在 初始化是 被rateLimitingType 结构体实现的 , 但它并没有AddAfter 方法, 因为它嵌套了 DelayingInterface
</span><span class="c1"></span>        <span class="c1">// 而 DelayingInterface 又被 NewNamedDelayingQueue() 方法初始化 由 delayingType 结构体来实现
</span><span class="c1"></span>	<span class="nx">dc</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nf">AddAfter</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">after</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// 因此我们找到了 delayingType 的 AddAfter 方法
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">q</span> <span class="o">*</span><span class="nx">delayingType</span><span class="p">)</span> <span class="nf">AddAfter</span><span class="p">(</span><span class="nx">item</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">duration</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// don&#39;t add if we&#39;re already shutting down
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">q</span><span class="p">.</span><span class="nf">ShuttingDown</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
        <span class="c1">// 重试次数增加
</span><span class="c1"></span>	<span class="nx">q</span><span class="p">.</span><span class="nx">metrics</span><span class="p">.</span><span class="nf">retry</span><span class="p">()</span>

	<span class="c1">// immediately add things with no delay
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">duration</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">q</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
        <span class="c1">// 终于我们看到了什么时候 写入 waitingForAddCh channel中
</span><span class="c1"></span>	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">q</span><span class="p">.</span><span class="nx">stopCh</span><span class="p">:</span>
	<span class="k">case</span> <span class="nx">q</span><span class="p">.</span><span class="nx">waitingForAddCh</span> <span class="o">&lt;-</span> <span class="o">&amp;</span><span class="nx">waitFor</span><span class="p">{</span><span class="nx">data</span><span class="p">:</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">readyAt</span><span class="p">:</span> <span class="nx">q</span><span class="p">.</span><span class="nx">clock</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="nx">duration</span><span class="p">)}:</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="3-run">3 Run</h2>
<h3 id="31-dcrun">3.1 dc.Run</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// pkg/controller/deployment/deployment_controller.go
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">dc</span> <span class="o">*</span><span class="nx">DeploymentController</span><span class="p">)</span> <span class="nf">Run</span><span class="p">(</span><span class="nx">workers</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">stopCh</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nx">utilruntime</span><span class="p">.</span><span class="nf">HandleCrash</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">dc</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nf">ShutDown</span><span class="p">()</span>

	<span class="nx">klog</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;Starting deployment controller&#34;</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nx">klog</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;Shutting down deployment controller&#34;</span><span class="p">)</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">cache</span><span class="p">.</span><span class="nf">WaitForNamedCacheSync</span><span class="p">(</span><span class="s">&#34;deployment&#34;</span><span class="p">,</span> <span class="nx">stopCh</span><span class="p">,</span> <span class="nx">dc</span><span class="p">.</span><span class="nx">dListerSynced</span><span class="p">,</span> <span class="nx">dc</span><span class="p">.</span><span class="nx">rsListerSynced</span><span class="p">,</span> <span class="nx">dc</span><span class="p">.</span><span class="nx">podListerSynced</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">workers</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">go</span> <span class="nx">wait</span><span class="p">.</span><span class="nf">Until</span><span class="p">(</span><span class="nx">dc</span><span class="p">.</span><span class="nx">worker</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span> <span class="nx">stopCh</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="o">&lt;-</span><span class="nx">stopCh</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">dc</span> <span class="o">*</span><span class="nx">DeploymentController</span><span class="p">)</span> <span class="nf">worker</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">dc</span><span class="p">.</span><span class="nf">processNextWorkItem</span><span class="p">()</span> <span class="p">{</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">dc</span> <span class="o">*</span><span class="nx">DeploymentController</span><span class="p">)</span> <span class="nf">processNextWorkItem</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">key</span><span class="p">,</span> <span class="nx">quit</span> <span class="o">:=</span> <span class="nx">dc</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Get</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">quit</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">dc</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Done</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
        <span class="c1">// 这里就是syncDeployment, 上面已经详细介绍过了
</span><span class="c1"></span>	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">dc</span><span class="p">.</span><span class="nf">syncHandler</span><span class="p">(</span><span class="nx">key</span><span class="p">.(</span><span class="kt">string</span><span class="p">))</span>
        <span class="c1">// 这里会写入延迟队列的 channel
</span><span class="c1"></span>	<span class="nx">dc</span><span class="p">.</span><span class="nf">handleErr</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>

	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>dc.handleErr</li>
</ul>
<blockquote>
<p>这里就看到了 限流器的代码</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">dc</span> <span class="o">*</span><span class="nx">DeploymentController</span><span class="p">)</span> <span class="nf">handleErr</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">,</span> <span class="nx">key</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">dc</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Forget</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
        <span class="c1">// 没有超过最大重试次数
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">dc</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nf">NumRequeues</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">maxRetries</span> <span class="p">{</span>
                <span class="c1">// 把key加入到限流队列中, 实际调用 rateLimitingType.AddRateLimited
</span><span class="c1"></span>		<span class="nx">dc</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nf">AddRateLimited</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">utilruntime</span><span class="p">.</span><span class="nf">HandleError</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="nx">klog</span><span class="p">.</span><span class="nf">V</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;Dropping deployment %q out of the queue: %v&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="nx">dc</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Forget</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// AddRateLimited 方法
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">q</span> <span class="o">*</span><span class="nx">rateLimitingType</span><span class="p">)</span> <span class="nf">AddRateLimited</span><span class="p">(</span><span class="nx">item</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
        <span class="c1">// 1. 调用个延迟队列的 AddAfter
</span><span class="c1"></span>        <span class="c1">// 上面介绍到了 NewNamedDelayingQueue() 函数初始化的 延迟队列接口 DelayingInterface
</span><span class="c1"></span>        <span class="c1">// 所以实际执行的是 delayingType.AddAfter, 也就是上面介绍的delayingType.AddAfter , 对延迟队列channel 写入 waitfor
</span><span class="c1"></span>        <span class="c1">// 2. When 方法是调用了 令牌桶
</span><span class="c1"></span>        <span class="c1">// 上面介绍到 DefaultControllerRateLimiter() 函数初始化的 令牌桶接口 RateLimiter
</span><span class="c1"></span>        <span class="c1">// 所以实际执行的是 MaxOfRateLimiter.When, 最终得到两个限流器中最大的延迟时间
</span><span class="c1"></span>	<span class="nx">q</span><span class="p">.</span><span class="nx">DelayingInterface</span><span class="p">.</span><span class="nf">AddAfter</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">rateLimiter</span><span class="p">.</span><span class="nf">When</span><span class="p">(</span><span class="nx">item</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><h3 id="32-maxofratelimiter">3.2 MaxOfRateLimiter</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// RateLimiter的包装, 实现了RateLimiter 接口
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">MaxOfRateLimiter</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">limiters</span> <span class="p">[]</span><span class="nx">RateLimiter</span>
<span class="p">}</span>
<span class="c1">// 这其实是包装了多个限流器, 迭代执行When
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">MaxOfRateLimiter</span><span class="p">)</span> <span class="nf">When</span><span class="p">(</span><span class="nx">item</span> <span class="kd">interface</span><span class="p">{})</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="p">{</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">limiter</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">r</span><span class="p">.</span><span class="nx">limiters</span> <span class="p">{</span>
		<span class="nx">curr</span> <span class="o">:=</span> <span class="nx">limiter</span><span class="p">.</span><span class="nf">When</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span>
                <span class="c1">// 大于就保存
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">curr</span> <span class="p">&gt;</span> <span class="nx">ret</span> <span class="p">{</span>
			<span class="nx">ret</span> <span class="p">=</span> <span class="nx">curr</span>
		<span class="p">}</span>
	<span class="p">}</span>
        <span class="c1">// 返回所有 限流器里面的最大值
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>
</code></pre></div><blockquote>
<p>上面一共初始化了两个限流器 一个是 <code>ItemExponentialFailureRateLimiter</code> , 一个是 <code>BucketRateLimiter</code></p>
<p>分别来看下</p>
</blockquote>
<ul>
<li>ItemExponentialFailureRateLimiter</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 指数级, 实现了RateLimiter 接口
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ItemExponentialFailureRateLimiter</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">failuresLock</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
	<span class="nx">failures</span>     <span class="kd">map</span><span class="p">[</span><span class="kd">interface</span><span class="p">{}]</span><span class="kt">int</span>

	<span class="nx">baseDelay</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
	<span class="nx">maxDelay</span>  <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">ItemExponentialFailureRateLimiter</span><span class="p">)</span> <span class="nf">When</span><span class="p">(</span><span class="nx">item</span> <span class="kd">interface</span><span class="p">{})</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="p">{</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">failuresLock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">r</span><span class="p">.</span><span class="nx">failuresLock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="nx">exp</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">failures</span><span class="p">[</span><span class="nx">item</span><span class="p">]</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">failures</span><span class="p">[</span><span class="nx">item</span><span class="p">]</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">failures</span><span class="p">[</span><span class="nx">item</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1">// 根据失败的次数 指数级增加
</span><span class="c1"></span>	<span class="nx">backoff</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">baseDelay</span><span class="p">.</span><span class="nf">Nanoseconds</span><span class="p">())</span> <span class="o">*</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">exp</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">backoff</span> <span class="p">&gt;</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MaxInt64</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">maxDelay</span>
	<span class="p">}</span>

	<span class="nx">calculated</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">backoff</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">calculated</span> <span class="p">&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">maxDelay</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">maxDelay</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">calculated</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>BucketRateLimiter</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// BucketRateLimiter, 实现了RateLimiter 接口
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">BucketRateLimiter</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="o">*</span><span class="nx">rate</span><span class="p">.</span><span class="nx">Limiter</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">BucketRateLimiter</span><span class="p">)</span> <span class="nf">When</span><span class="p">(</span><span class="nx">item</span> <span class="kd">interface</span><span class="p">{})</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Limiter</span><span class="p">.</span><span class="nf">Reserve</span><span class="p">().</span><span class="nf">Delay</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">lim</span> <span class="o">*</span><span class="nx">Limiter</span><span class="p">)</span> <span class="nf">Reserve</span><span class="p">()</span> <span class="o">*</span><span class="nx">Reservation</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">lim</span><span class="p">.</span><span class="nf">ReserveN</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">lim</span> <span class="o">*</span><span class="nx">Limiter</span><span class="p">)</span> <span class="nf">ReserveN</span><span class="p">(</span><span class="nx">now</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Reservation</span> <span class="p">{</span>
        <span class="c1">// InfDuration = time.Duration(1&lt;&lt;63-1) 最大的64位数
</span><span class="c1"></span>	<span class="nx">r</span> <span class="o">:=</span> <span class="nx">lim</span><span class="p">.</span><span class="nf">reserveN</span><span class="p">(</span><span class="nx">now</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">InfDuration</span><span class="p">)</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">r</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">lim</span> <span class="o">*</span><span class="nx">Limiter</span><span class="p">)</span> <span class="nf">reserveN</span><span class="p">(</span><span class="nx">now</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">maxFutureReserve</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="nx">Reservation</span> <span class="p">{</span>
	<span class="nx">lim</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
        <span class="o">...</span>
        <span class="c1">// 调整当前的令牌桶的资源
</span><span class="c1"></span>	<span class="nx">now</span><span class="p">,</span> <span class="nx">last</span><span class="p">,</span> <span class="nx">tokens</span> <span class="o">:=</span> <span class="nx">lim</span><span class="p">.</span><span class="nf">advance</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span>

	<span class="c1">// 除去需要拿走 n 个token, 这里是1, 得到剩余的tokens
</span><span class="c1"></span>	<span class="nx">tokens</span> <span class="o">-=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>

	<span class="c1">// Calculate the wait duration
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">waitDuration</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
        <span class="c1">// 如果tokens少于0了
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">tokens</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="c1">// 算出需要等待多久 我们的 令牌桶中 才有n个tokens
</span><span class="c1"></span>		<span class="nx">waitDuration</span> <span class="p">=</span> <span class="nx">lim</span><span class="p">.</span><span class="nx">limit</span><span class="p">.</span><span class="nf">durationFromTokens</span><span class="p">(</span><span class="o">-</span><span class="nx">tokens</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// n 前面传的是1 , 就是需要拿一个token
</span><span class="c1"></span>	<span class="nx">ok</span> <span class="o">:=</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="nx">lim</span><span class="p">.</span><span class="nx">burst</span> <span class="o">&amp;&amp;</span> <span class="nx">waitDuration</span> <span class="o">&lt;=</span> <span class="nx">maxFutureReserve</span>

	<span class="c1">// 构建Reservation
</span><span class="c1"></span>	<span class="nx">r</span> <span class="o">:=</span> <span class="nx">Reservation</span><span class="p">{</span>
		<span class="nx">ok</span><span class="p">:</span>    <span class="nx">ok</span><span class="p">,</span>
		<span class="nx">lim</span><span class="p">:</span>   <span class="nx">lim</span><span class="p">,</span>
		<span class="nx">limit</span><span class="p">:</span> <span class="nx">lim</span><span class="p">.</span><span class="nx">limit</span><span class="p">,</span>
	<span class="p">}</span>
        <span class="c1">// 可以拿到token
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">r</span><span class="p">.</span><span class="nx">tokens</span> <span class="p">=</span> <span class="nx">n</span>
		<span class="nx">r</span><span class="p">.</span><span class="nx">timeToAct</span> <span class="p">=</span> <span class="nx">now</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">waitDuration</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 更新状态
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">lim</span><span class="p">.</span><span class="nx">last</span> <span class="p">=</span> <span class="nx">now</span>
		<span class="nx">lim</span><span class="p">.</span><span class="nx">tokens</span> <span class="p">=</span> <span class="nx">tokens</span>
		<span class="nx">lim</span><span class="p">.</span><span class="nx">lastEvent</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">timeToAct</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">lim</span><span class="p">.</span><span class="nx">last</span> <span class="p">=</span> <span class="nx">last</span>
	<span class="p">}</span>

	<span class="nx">lim</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Reservation</span><span class="p">)</span> <span class="nf">Delay</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nf">DelayFrom</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">())</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Reservation</span><span class="p">)</span> <span class="nf">DelayFrom</span><span class="p">(</span><span class="nx">now</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">r</span><span class="p">.</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">InfDuration</span>
	<span class="p">}</span>
        <span class="c1">// 这里 timeToAct 在拿到token的时候会被更新
</span><span class="c1"></span>	<span class="nx">delay</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">timeToAct</span><span class="p">.</span><span class="nf">Sub</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">delay</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">delay</span>
<span class="p">}</span>
</code></pre></div><hr>
<h2 id="-参考资料">~ 参考资料</h2>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;mid=2651441921&amp;idx=3&amp;sn=3d2b7a0013e1ee5c377782bdc30575f1&amp;chksm=80bb15f3b7cc9ce5360c6df591a6cef8bbfaebe431b6ce57f391dd7a0b49e8d4f70e44ceadaf&amp;scene=21#wechat_redirect">K8s 延迟队列</a></li>
<li><a href="https://jishuin.proginn.com/p/763bfbd2dcfe">k8s 限速队列</a></li>
</ul>
]]></content>
		</item>
		
	</channel>
</rss>
