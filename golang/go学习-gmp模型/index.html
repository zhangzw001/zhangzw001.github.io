<!DOCTYPE html>
<html lang="zh-hans">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#494f5c">
	<meta name="msapplication-TileColor" content="#494f5c">
<meta itemprop="name" content="Go学习 Gmp模型">
<meta itemprop="description" content="GMP模型 为什么需要P  如果没有P, 所有的G都必须在一个全局的队列中, 然后M一个个从全局队列中获取, 这种共享内存的方式并发必须需要加锁 如果没有P, 当前g1中包含了创建新协程g2(go func)时, 当前的M1还得继续执行g1, 因此M1必须主动转移g2给另外一个线程M2去执行,这就造成了不必要的转移,浪费cpu资源, 因为g1 g2是相关的, 如果都在本地M1上执行更好, 而不是调度出去执行  简介  全局队列（Global Queue）：存放等待运行的G。 P的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G&rsquo;时，G&rsquo;优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。 P列表：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS(可配置)个。 M：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列拿一批G放到P的本地队列，或从其他P的本地队列偷一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。 g0: 一个比一比g大的多栈(64k), 可以用于 创建goroutine, deferproc函数里新建_defer,垃圾回收相关工资  何时会创建 P : 由启动时环境变量$GOMAXPROCS或者是由runtime的方法GOMAXPROCS()决定, 运行时系统就会创建 M : 如果P找不到空闲的M去绑定,就会创建M 调度器策略 work stealing : 当本地G队列为空时, 尝试从全局队列或者其他的线程绑定的P偷取G,而不是销毁线程 hand off : 当g阻塞时,实际是当前M线程会阻塞, 如果是同步模式,M和G会一起阻塞 如果是非同步模式,G会被&quot;net poller&quot;代理进入阻塞,M不会阻塞,继续执行其他的G,效率更高 gmp结构体  m  // src/runtime/runtime2.go type m struct { g0 *g // 用于执行调度指令的 Goroutine 	gsignal *g // 处理 signal 的 g 	tls [6]uintptr // 线程本地存储 	curg *g // 当前运行的用户 Goroutine 	p puintptr // 执行 go 代码时持有的 p (如果没有执行则为 nil) 	preemptoff string // if !">
<meta itemprop="datePublished" content="2021-11-17T09:31:09+08:00" />
<meta itemprop="dateModified" content="2021-11-17T09:31:09+08:00" />
<meta itemprop="wordCount" content="6289">



<meta itemprop="keywords" content="golang," />
<meta property="og:title" content="Go学习 Gmp模型" />
<meta property="og:description" content="GMP模型 为什么需要P  如果没有P, 所有的G都必须在一个全局的队列中, 然后M一个个从全局队列中获取, 这种共享内存的方式并发必须需要加锁 如果没有P, 当前g1中包含了创建新协程g2(go func)时, 当前的M1还得继续执行g1, 因此M1必须主动转移g2给另外一个线程M2去执行,这就造成了不必要的转移,浪费cpu资源, 因为g1 g2是相关的, 如果都在本地M1上执行更好, 而不是调度出去执行  简介  全局队列（Global Queue）：存放等待运行的G。 P的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G&rsquo;时，G&rsquo;优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。 P列表：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS(可配置)个。 M：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列拿一批G放到P的本地队列，或从其他P的本地队列偷一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。 g0: 一个比一比g大的多栈(64k), 可以用于 创建goroutine, deferproc函数里新建_defer,垃圾回收相关工资  何时会创建 P : 由启动时环境变量$GOMAXPROCS或者是由runtime的方法GOMAXPROCS()决定, 运行时系统就会创建 M : 如果P找不到空闲的M去绑定,就会创建M 调度器策略 work stealing : 当本地G队列为空时, 尝试从全局队列或者其他的线程绑定的P偷取G,而不是销毁线程 hand off : 当g阻塞时,实际是当前M线程会阻塞, 如果是同步模式,M和G会一起阻塞 如果是非同步模式,G会被&quot;net poller&quot;代理进入阻塞,M不会阻塞,继续执行其他的G,效率更高 gmp结构体  m  // src/runtime/runtime2.go type m struct { g0 *g // 用于执行调度指令的 Goroutine 	gsignal *g // 处理 signal 的 g 	tls [6]uintptr // 线程本地存储 	curg *g // 当前运行的用户 Goroutine 	p puintptr // 执行 go 代码时持有的 p (如果没有执行则为 nil) 	preemptoff string // if !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-gmp%E6%A8%A1%E5%9E%8B/" />
<meta property="article:published_time" content="2021-11-17T09:31:09+08:00" />
<meta property="article:modified_time" content="2021-11-17T09:31:09+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go学习 Gmp模型"/>
<meta name="twitter:description" content="GMP模型 为什么需要P  如果没有P, 所有的G都必须在一个全局的队列中, 然后M一个个从全局队列中获取, 这种共享内存的方式并发必须需要加锁 如果没有P, 当前g1中包含了创建新协程g2(go func)时, 当前的M1还得继续执行g1, 因此M1必须主动转移g2给另外一个线程M2去执行,这就造成了不必要的转移,浪费cpu资源, 因为g1 g2是相关的, 如果都在本地M1上执行更好, 而不是调度出去执行  简介  全局队列（Global Queue）：存放等待运行的G。 P的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G&rsquo;时，G&rsquo;优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。 P列表：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS(可配置)个。 M：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列拿一批G放到P的本地队列，或从其他P的本地队列偷一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。 g0: 一个比一比g大的多栈(64k), 可以用于 创建goroutine, deferproc函数里新建_defer,垃圾回收相关工资  何时会创建 P : 由启动时环境变量$GOMAXPROCS或者是由runtime的方法GOMAXPROCS()决定, 运行时系统就会创建 M : 如果P找不到空闲的M去绑定,就会创建M 调度器策略 work stealing : 当本地G队列为空时, 尝试从全局队列或者其他的线程绑定的P偷取G,而不是销毁线程 hand off : 当g阻塞时,实际是当前M线程会阻塞, 如果是同步模式,M和G会一起阻塞 如果是非同步模式,G会被&quot;net poller&quot;代理进入阻塞,M不会阻塞,继续执行其他的G,效率更高 gmp结构体  m  // src/runtime/runtime2.go type m struct { g0 *g // 用于执行调度指令的 Goroutine 	gsignal *g // 处理 signal 的 g 	tls [6]uintptr // 线程本地存储 	curg *g // 当前运行的用户 Goroutine 	p puintptr // 执行 go 代码时持有的 p (如果没有执行则为 nil) 	preemptoff string // if !"/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>Go学习 Gmp模型</title>
	<link rel="stylesheet" href="https://www.ngirl.xyz/css/style.min.d3141168199607bf3a517216ce3c263814eecdbc8fca72a9a88700799a838219.css">
	
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp faster">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://www.ngirl.xyz">zhangzw</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					<a href="https://www.ngirl.xyz/golang/">golang</a>
					<a href="https://www.ngirl.xyz/k8s/">k8s</a>
					<a href="https://www.ngirl.xyz/posts/">文章</a>
				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<button id="toc-btn" class="hdr-btn desktop-only-ib" title="Table of Contents"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-list"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3" y2="6"></line><line x1="3" y1="12" x2="3" y2="12"></line><line x1="3" y1="18" x2="3" y2="18"></line></svg></button><span class="hdr-social hide-in-mobile"><a href="https://github.com/zhangzw001" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a></span><button id="menu-btn" class="hdr-btn" title="Menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://www.ngirl.xyz/posts/">文章</a></li>
			<li><a href="https://www.ngirl.xyz/tags/">标签</a></li>
			<li><a href="https://www.ngirl.xyz/about/">关于</a></li>
		</ul>
	</div>



	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>Nov 17, 2021</span></div>
				<h1>Go学习 Gmp模型</h1>
			</header>
			<div class="content">
				<h3 id="gmp模型">GMP模型<a href="#gmp模型" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p><img src="images/golang/gmp-jiagou.png" alt=""></p>
<h4 id="为什么需要p">为什么需要P<a href="#为什么需要p" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<ul>
<li>如果没有P, 所有的G都必须在一个全局的队列中, 然后M一个个从全局队列中获取, 这种共享内存的方式并发必须需要加锁</li>
<li>如果没有P, 当前g1中包含了创建新协程g2(go func)时, 当前的M1还得继续执行g1, 因此M1必须主动转移g2给另外一个线程M2去执行,这就造成了不必要的转移,浪费cpu资源, 因为g1 g2是相关的, 如果都在本地M1上执行更好, 而不是调度出去执行</li>
</ul>
<h4 id="简介">简介<a href="#简介" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<ul>
<li>全局队列（Global Queue）：存放等待运行的G。</li>
<li>P的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G&rsquo;时，G&rsquo;优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。</li>
<li>P列表：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS(可配置)个。</li>
<li>M：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列拿一批G放到P的本地队列，或从其他P的本地队列偷一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。</li>
<li>g0: 一个比一比g大的多栈(64k), 可以用于 创建goroutine, deferproc函数里新建_defer,垃圾回收相关工资</li>
</ul>
<h4 id="何时会创建">何时会创建<a href="#何时会创建" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<pre><code>P : 由启动时环境变量$GOMAXPROCS或者是由runtime的方法GOMAXPROCS()决定, 运行时系统就会创建
M : 如果P找不到空闲的M去绑定,就会创建M
</code></pre><h4 id="调度器策略">调度器策略<a href="#调度器策略" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<pre><code>work stealing : 当本地G队列为空时, 尝试从全局队列或者其他的线程绑定的P偷取G,而不是销毁线程
hand off : 当g阻塞时,实际是当前M线程会阻塞,
        如果是同步模式,M和G会一起阻塞
        如果是非同步模式,G会被&quot;net poller&quot;代理进入阻塞,M不会阻塞,继续执行其他的G,效率更高
</code></pre><p><img src="images/golang/gmp.jpeg" alt=""></p>
<h4 id="gmp结构体">gmp结构体<a href="#gmp结构体" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<ul>
<li>m</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/runtime2.go
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">m</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">g0</span>         <span class="o">*</span><span class="nx">g</span>          <span class="c1">// 用于执行调度指令的 Goroutine
</span><span class="c1"></span>	<span class="nx">gsignal</span>    <span class="o">*</span><span class="nx">g</span>          <span class="c1">// 处理 signal 的 g
</span><span class="c1"></span>	<span class="nx">tls</span>        <span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="kt">uintptr</span>  <span class="c1">// 线程本地存储
</span><span class="c1"></span>	<span class="nx">curg</span>       <span class="o">*</span><span class="nx">g</span>          <span class="c1">// 当前运行的用户 Goroutine
</span><span class="c1"></span>	<span class="nx">p</span>          <span class="nx">puintptr</span>    <span class="c1">// 执行 go 代码时持有的 p (如果没有执行则为 nil)
</span><span class="c1"></span>	<span class="nx">preemptoff</span> <span class="kt">string</span>      <span class="c1">// if != &#34;&#34;, keep curg running on this m
</span><span class="c1"></span>	<span class="nx">spinning</span>   <span class="kt">bool</span>        <span class="c1">// m 当前没有运行 work 且正处于寻找 work 的活跃状态,自旋和非自旋状态
</span><span class="c1"></span>	<span class="nx">blocked</span>    <span class="kt">bool</span>        <span class="c1">// m is blocked on a note
</span><span class="c1"></span>	<span class="nx">freeWait</span>   <span class="kt">uint32</span>      <span class="c1">// if == 0, safe to free g0 and delete m (atomic)
</span><span class="c1"></span>	<span class="nx">cgoCallers</span> <span class="o">*</span><span class="nx">cgoCallers</span> <span class="c1">// cgo 调用崩溃的 cgo 回溯
</span><span class="c1"></span>	<span class="nx">alllink</span>    <span class="o">*</span><span class="nx">m</span>          <span class="c1">// 在 allm 上
</span><span class="c1"></span>	<span class="nx">mcache</span>     <span class="o">*</span><span class="nx">mcache</span>     <span class="c1">// 当前线程上进行内存分配的本地缓存 mcache
</span><span class="c1"></span>	<span class="nx">freelink</span>   <span class="o">*</span><span class="nx">m</span>          <span class="c1">// on sched.freem
</span><span class="c1"></span>	<span class="o">...</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>p</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/runtime2.go
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">p</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">id</span>           <span class="kt">int32</span>
	<span class="nx">status</span>       <span class="kt">uint32</span>         <span class="c1">// p 的状态 pidle/prunning/...
</span><span class="c1"></span>	<span class="nx">link</span>         <span class="nx">puintptr</span>       <span class="c1">// 链表
</span><span class="c1"></span>	<span class="nx">m</span>            <span class="nx">muintptr</span>       <span class="c1">// 反向链接到关联的 m （nil 则表示 idle）
</span><span class="c1"></span>	<span class="nx">mcache</span>       <span class="o">*</span><span class="nx">mcache</span>        <span class="c1">// mcache
</span><span class="c1"></span>	<span class="nx">pcache</span>       <span class="nx">pageCache</span>      <span class="c1">// pageCache
</span><span class="c1"></span>	<span class="nx">deferpool</span>    <span class="p">[</span><span class="mi">5</span><span class="p">][]</span><span class="o">*</span><span class="nx">_defer</span>   <span class="c1">// 不同大小的可用的 defer 结构池
</span><span class="c1"></span>	<span class="nx">deferpoolbuf</span> <span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">32</span><span class="p">]</span><span class="o">*</span><span class="nx">_defer</span> <span class="c1">// buf
</span><span class="c1"></span>	<span class="nx">runqhead</span>     <span class="kt">uint32</span>         <span class="c1">// 可运行的 Goroutine 队列，可无锁访问
</span><span class="c1"></span>	<span class="nx">runqtail</span>     <span class="kt">uint32</span>         <span class="c1">// 尾
</span><span class="c1"></span>	<span class="nx">runq</span>         <span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="nx">guintptr</span>  <span class="c1">// 本地队列
</span><span class="c1"></span>	<span class="nx">runnext</span>      <span class="nx">guintptr</span>       <span class="c1">// 下一个要执行的g
</span><span class="c1"></span>	<span class="nx">timersLock</span>   <span class="nx">mutex</span>
	<span class="nx">timers</span>       <span class="p">[]</span><span class="o">*</span><span class="nx">timer</span>
	<span class="nx">preempt</span>      <span class="kt">bool</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>g</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/runtime2.go
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">g</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">stack</span> <span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">lo</span> <span class="kt">uintptr</span>
		<span class="nx">hi</span> <span class="kt">uintptr</span>
	<span class="p">}</span> <span class="c1">// 栈内存 界限：[stack.lo, stack.hi)
</span><span class="c1"></span>	<span class="nx">stackguard0</span> <span class="kt">uintptr</span>
	<span class="nx">stackguard1</span> <span class="kt">uintptr</span>

	<span class="nx">_panic</span>   <span class="o">*</span><span class="nx">_panic</span>
	<span class="nx">_defer</span>   <span class="o">*</span><span class="nx">_defer</span>
	<span class="nx">m</span>        <span class="o">*</span><span class="nx">m</span>             <span class="c1">// 当前的 m
</span><span class="c1"></span>	<span class="nx">sched</span>    <span class="nx">gobuf</span>          <span class="c1">// 保存g和调度信息
</span><span class="c1"></span>	<span class="nx">stktopsp</span> <span class="kt">uintptr</span>        <span class="c1">// 期望 sp 位于栈顶，用于回溯检查
</span><span class="c1"></span>	<span class="nx">param</span>    <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// wakeup 唤醒时候传递的参数
</span><span class="c1"></span>	<span class="nx">goid</span>     <span class="kt">int64</span>          <span class="c1">// goid
</span><span class="c1"></span>	<span class="nx">preempt</span>  <span class="kt">bool</span>           <span class="c1">// 抢占信号，stackguard0 = stackpreempt 的副本
</span><span class="c1"></span>	<span class="nx">timer</span>    <span class="o">*</span><span class="nx">timer</span>         <span class="c1">// 为 time.Sleep 缓存的计时器
</span><span class="c1"></span>	<span class="o">...</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">gobuf</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">sp</span>   <span class="kt">uintptr</span>        <span class="c1">// 存储 sp 寄存器的值
</span><span class="c1"></span>	<span class="nx">pc</span>   <span class="kt">uintptr</span>        <span class="c1">// 存储 ip 寄存器的值
</span><span class="c1"></span>	<span class="nx">g</span>    <span class="nx">guintptr</span>       <span class="c1">// 指向 goroutine
</span><span class="c1"></span>	<span class="nx">ctxt</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 这必须是一个指针，以便GC对其进行扫描
</span><span class="c1"></span>	<span class="nx">ret</span>  <span class="nx">sys</span><span class="p">.</span><span class="nx">Uintreg</span>    <span class="c1">// 保存系统调用的返回值
</span><span class="c1"></span>	<span class="nx">lr</span>   <span class="kt">uintptr</span>
	<span class="nx">bp</span>   <span class="kt">uintptr</span> <span class="c1">// for GOEXPERIMENT=framepointer
</span><span class="c1"></span><span class="p">}</span>

</code></pre></div><ul>
<li>调度器 schedt
<ul>
<li>管理了能够将 G 和 M 进行绑定的 M 队列</li>
<li>管理了空闲的 P 链表（队列）</li>
<li>管理了 G 的全局队列</li>
<li>管理了可被复用的 G 的全局缓存</li>
<li>管理了 defer 池</li>
</ul>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/runtime2.go
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">schedt</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">lock</span>       <span class="nx">mutex</span>
	<span class="nx">ngsys</span>      <span class="kt">uint32</span>   <span class="c1">// 系统 goroutine的数量; 自增
</span><span class="c1"></span>	<span class="nx">pidle</span>      <span class="nx">puintptr</span> <span class="c1">// 空闲 p 链表
</span><span class="c1"></span>	<span class="nx">npidle</span>     <span class="kt">uint32</span>   <span class="c1">// 空闲 p 数量
</span><span class="c1"></span>	<span class="nx">nmspinning</span> <span class="kt">uint32</span>   <span class="c1">// 自旋状态的 M 的数量
</span><span class="c1"></span>	<span class="nx">runq</span>       <span class="nx">gQueue</span>   <span class="c1">// 全局 G 队列
</span><span class="c1"></span>	<span class="nx">runqsize</span>   <span class="kt">int32</span>    <span class="c1">// 全局队列大小
</span><span class="c1"></span>	<span class="nx">gFree</span>      <span class="kd">struct</span> <span class="p">{</span> <span class="c1">// 有效 dead G 的全局缓存.
</span><span class="c1"></span>		<span class="nx">lock</span>    <span class="nx">mutex</span> <span class="c1">// 锁
</span><span class="c1"></span>		<span class="nx">stack</span>   <span class="nx">gList</span> <span class="c1">// 包含栈的 Gs
</span><span class="c1"></span>		<span class="nx">noStack</span> <span class="nx">gList</span> <span class="c1">// 没有栈的 Gs
</span><span class="c1"></span>		<span class="nx">n</span>       <span class="kt">int32</span>
	<span class="p">}</span>
	<span class="nx">sudoglock</span>  <span class="nx">mutex</span>  <span class="c1">// sudog 锁
</span><span class="c1"></span>	<span class="nx">sudogcache</span> <span class="o">*</span><span class="nx">sudog</span> <span class="c1">// sudog 结构的集中缓存
</span><span class="c1"></span>	<span class="nx">deferlock</span>  <span class="nx">mutex</span>  <span class="c1">// 不同大小的有效的 defer 结构的池
</span><span class="c1"></span>	<span class="nx">deferpool</span>  <span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">*</span><span class="nx">_defer</span>

	<span class="o">...</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">gQueue</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">head</span> <span class="nx">guintptr</span>
	<span class="nx">tail</span> <span class="nx">guintptr</span>
<span class="p">}</span>
</code></pre></div><h3 id="go函数真正的入口">go函数真正的入口<a href="#go函数真正的入口" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<h4 id="通过gdb调试-找到入口文件">通过gdb调试, 找到入口文件<a href="#通过gdb调试-找到入口文件" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<pre><code class="language-assembly" data-lang="assembly"># GOFLAGS=&quot;-ldflags=-compressdwarf=false&quot; go build gdb-main.go

# gdb gdb-main
(gdb) info files
Symbols from &quot;/Users/zhangzw/work/go/github.com/zhangzw001/learngo/basic/gdb/gdb-main&quot;.
Local exec file:
	`/Users/zhangzw/work/go/github.com/zhangzw001/learngo/basic/gdb/gdb-main', file type mach-o-x86-64.
	Entry point: 0x1065600
	0x0000000001001000 - 0x00000000010a2e8a is .text
	0x00000000010a2ea0 - 0x00000000010a2fa2 is __TEXT.__symbol_stub1
	...
(gdb) b *0x1065600  // 上面的Entry point后面的地址
Breakpoint 1 at 0x1065600: file /usr/local/go/src/runtime/rt0_darwin_amd64.s, line 8.   // 这里是mac
</code></pre><h4 id="继续查看">继续查看<a href="#继续查看" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<pre><code class="language-assembly" data-lang="assembly">// src/runtime/rt0_amd64.s
TEXT _rt0_amd64_linux(SB),NOSPLIT,$-8
	JMP	_rt0_amd64(SB) //跳转到 _rt0_amd64

TEXT _rt0_amd64(SB),NOSPLIT,$-8
	MOVQ	0(SP), DI	// argc
	LEAQ	8(SP), SI	// argv
	JMP	runtime·rt0_go(SB)// 又跳转到runtime·rt0_go


</code></pre><h4 id="来到核心入口代码">来到核心入口代码<a href="#来到核心入口代码" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<pre><code class="language-assembly" data-lang="assembly">// src/runtime/asm_amd64.s
TEXT runtime·rt0_go&lt;ABIInternal&gt;(SB),NOSPLIT,$0
        ...
        // DI 现在是g0的地址
        MOVQ	$runtime·g0(SB), DI
        // BX = SP-64*1024+104 准备64k的内存空间
        LEAQ	(-64*1024+104)(SP), BX
        // 设置 g.stackguard0
        MOVQ	BX, g_stackguard0(DI)   
        // 设置 g.stackguard1   
        MOVQ	BX, g_stackguard1(DI)
        // g0 栈的low低地址
        MOVQ	BX, (g_stack+stack_lo)(DI)
        // g0 栈的high高地址
        MOVQ	SP, (g_stack+stack_hi)(DI)
	...
        // m0的tls成员
        LEAQ	runtime·m0+m_tls(SB), DI
        // 通过fs段寄存器找到m.tls
        CALL	runtime·settls(SB)
        // 获得fs段地址放入BX = m0.tls[1]
        get_tls(BX)
        MOVQ	$0x123, g(BX)
        MOVQ	runtime·m0+m_tls(SB), AX
        // AX肯定还是$0x123
        CMPQ	AX, $0x123
        // EQ的话就跳2行执行
        JEQ 2(PC)
        CALL	runtime·abort(SB)
ok:
	get_tls(BX)
        // DX 现在是g0的地址
	LEAL	runtime·g0(SB), DX
        // m0.tls[0] = DX
	MOVL	DX, g(BX)
        // AX 现在是m0的地址
	LEAL	runtime·m0(SB), AX
        // m0 和g0绑定
	// m0.g0 = &amp;g0
	MOVL	DX, m_g0(AX)
	// g0.m0 = &amp;m0
	MOVL	AX, g_m(DX)

        CLD				// convention is D is always left cleared
	CALL	runtime·check(SB)  // 运行时类型检查，主要是校验编译器的翻译工作是否正确
	MOVL	16(SP), AX	   // copy argc
	MOVL	AX, 0(SP)
	MOVQ	24(SP), AX	   // copy argv
	MOVQ	AX, 8(SP)
	CALL	runtime·args(SB)	  //系统参数传递，主要是将系统参数转换传递给程序使用
	CALL	runtime·osinit(SB)	  //系统基本参数设置，主要是获取 CPU 核心数和内存物理页大小
	CALL	runtime·schedinit(SB)     //进行各种运行时组件的初始化，包含调度器、内存分配器、堆、栈、GC 等一大堆初始化工作。会进行 p 的初始化，并将 m0 和某一个 p 进行绑定。

	// 创建一个新的goroutine来运行程序
        // 主要工作是运行 main goroutine，虽然在runtime·rt0_go 中指向的是$runtime·mainPC，但实质指向的是 runtime.main。
	MOVQ	$runtime·mainPC(SB), AX
        // 入栈新的goroutine的地址
        PUSHQ	AX	  
        // main函数参数个数是0
        PUSHL	$0	                  // arg size
        // 创建一个新的 goroutine，且绑定 runtime.main 方法（也就是应用程序中的入口 main 方法）。并将其放入 m0 绑定的p的本地队列中去，以便后续调度。
	CALL	runtime·newproc(SB)       
        // 出站
	POPL	AX
	POPL	AX

	// start this M
	CALL	runtime·mstart(SB)
        // 以下不会执行, 万一mstart返回了,这里直接abort crash掉
	CALL	runtime·abort(SB)
	RET
</code></pre><h3 id="schedinit-运行时初始化">schedinit 运行时初始化<a href="#schedinit-运行时初始化" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/proc.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">schedinit</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">lockRankSched</span><span class="p">)</span>
        <span class="o">...</span>
	<span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heapStats</span><span class="p">.</span><span class="nx">noPLock</span><span class="p">,</span> <span class="nx">lockRankLeafRank</span><span class="p">)</span>
        <span class="c1">// g0
</span><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">racectx</span><span class="p">,</span> <span class="nx">raceprocctx0</span> <span class="p">=</span> <span class="nf">raceinit</span><span class="p">()</span>
	<span class="p">}</span>
        <span class="c1">// 设置全局变量 最大的m线程数量
</span><span class="c1"></span>	<span class="nx">sched</span><span class="p">.</span><span class="nx">maxmcount</span> <span class="p">=</span> <span class="mi">10000</span>

	<span class="c1">// The world starts stopped.
</span><span class="c1"></span>	<span class="nf">worldStopped</span><span class="p">()</span>

	<span class="nf">moduledataverify</span><span class="p">()</span>
	<span class="nf">stackinit</span><span class="p">()</span>
	<span class="nf">mallocinit</span><span class="p">()</span>
	<span class="nf">fastrandinit</span><span class="p">()</span>  <span class="c1">// must run before mcommoninit
</span><span class="c1"></span>        <span class="c1">// 初始化 m0, 详细见后面
</span><span class="c1"></span>	<span class="nf">mcommoninit</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="nf">cpuinit</span><span class="p">()</span>       <span class="c1">// must run before alginit
</span><span class="c1"></span>	<span class="nf">alginit</span><span class="p">()</span>       <span class="c1">// maps must not be used before this call
</span><span class="c1"></span>	<span class="nf">modulesinit</span><span class="p">()</span>   <span class="c1">// provides activeModules
</span><span class="c1"></span>	<span class="nf">typelinksinit</span><span class="p">()</span> <span class="c1">// uses maps, activeModules
</span><span class="c1"></span>	<span class="nf">itabsinit</span><span class="p">()</span>     <span class="c1">// uses activeModules
</span><span class="c1"></span>
	<span class="nf">sigsave</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">sigmask</span><span class="p">)</span>
	<span class="nx">initSigmask</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">sigmask</span>

	<span class="nf">goargs</span><span class="p">()</span>
	<span class="nf">goenvs</span><span class="p">()</span>
	<span class="nf">parsedebugvars</span><span class="p">()</span>
	<span class="nf">gcinit</span><span class="p">()</span>
        <span class="c1">// 锁
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span> <span class="p">=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nf">nanotime</span><span class="p">())</span>
	<span class="nx">procs</span> <span class="o">:=</span> <span class="nx">ncpu</span>
        <span class="c1">// 读一下是否设置了env
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nf">atoi32</span><span class="p">(</span><span class="nf">gogetenv</span><span class="p">(</span><span class="s">&#34;GOMAXPROCS&#34;</span><span class="p">));</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">procs</span> <span class="p">=</span> <span class="nx">n</span>
	<span class="p">}</span>
        <span class="c1">// 初始化p,详细见后面
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">procresize</span><span class="p">(</span><span class="nx">procs</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;unknown runnable goroutine during bootstrap&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// World is effectively started now, as P&#39;s can run.
</span><span class="c1"></span>	<span class="nf">worldStarted</span><span class="p">()</span>
        <span class="o">...</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>mcommoninit m初始化</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mcommoninit</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">,</span> <span class="nx">id</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// g0
</span><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="c1">// g0 stack won&#39;t make sense for user (and is not necessary unwindable).
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span> <span class="o">!=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span> <span class="p">{</span>
		<span class="nf">callers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">createstack</span><span class="p">[:])</span>
	<span class="p">}</span>

	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="c1">// 设置mp id, 初始化传入的id=-1
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">id</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">mp</span><span class="p">.</span><span class="nx">id</span> <span class="p">=</span> <span class="nx">id</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// 取一个id,m0=0,之后的递增 , 详细见后面
</span><span class="c1"></span>		<span class="nx">mp</span><span class="p">.</span><span class="nx">id</span> <span class="p">=</span> <span class="nf">mReserveID</span><span class="p">()</span>
	<span class="p">}</span>
        <span class="c1">// rand初始化
</span><span class="c1"></span>	<span class="nx">mp</span><span class="p">.</span><span class="nx">fastrand</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nf">int64Hash</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">mp</span><span class="p">.</span><span class="nx">id</span><span class="p">),</span> <span class="nx">fastrandseed</span><span class="p">))</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">fastrand</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nf">int64Hash</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nf">cputicks</span><span class="p">()),</span> <span class="p">^</span><span class="nx">fastrandseed</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">fastrand</span><span class="p">[</span><span class="mi">0</span><span class="p">]|</span><span class="nx">mp</span><span class="p">.</span><span class="nx">fastrand</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">mp</span><span class="p">.</span><span class="nx">fastrand</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="p">}</span>
        <span class="c1">// 设置信号
</span><span class="c1"></span>	<span class="nf">mpreinit</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">gsignal</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">mp</span><span class="p">.</span><span class="nx">gsignal</span><span class="p">.</span><span class="nx">stackguard1</span> <span class="p">=</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">gsignal</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
	<span class="p">}</span>

	<span class="c1">// Add to allm so garbage collector doesn&#39;t free g-&gt;m
</span><span class="c1"></span>	<span class="c1">// when it is just in a register or thread-local storage.
</span><span class="c1"></span>	<span class="nx">mp</span><span class="p">.</span><span class="nx">alllink</span> <span class="p">=</span> <span class="nx">allm</span>

	<span class="c1">// NumCgoCall() iterates over allm w/o schedlock,
</span><span class="c1"></span>	<span class="c1">// so we need to publish it safely.
</span><span class="c1"></span>	<span class="nf">atomicstorep</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allm</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">mp</span><span class="p">))</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// Allocate memory to hold a cgo traceback if the cgo call crashes.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">iscgo</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;solaris&#34;</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;illumos&#34;</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;windows&#34;</span> <span class="p">{</span>
		<span class="nx">mp</span><span class="p">.</span><span class="nx">cgoCallers</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">cgoCallers</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>mReserveID m自增id</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mReserveID</span><span class="p">()</span> <span class="kt">int64</span> <span class="p">{</span>
        <span class="c1">// 加锁, 操作全局变量sched
</span><span class="c1"></span>	<span class="nf">assertLockHeld</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="c1">// 满了
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">mnext</span><span class="o">+</span><span class="mi">1</span> <span class="p">&lt;</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">mnext</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: thread ID overflow&#34;</span><span class="p">)</span>
	<span class="p">}</span>
        <span class="c1">// 得到id
</span><span class="c1"></span>	<span class="nx">id</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">mnext</span>
	<span class="nx">sched</span><span class="p">.</span><span class="nx">mnext</span><span class="o">++</span>
        <span class="c1">// 检查是否超过 maxcount
</span><span class="c1"></span>	<span class="nf">checkmcount</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">id</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>mpreinit</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mpreinit</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// new 一个 g 结构体对象，然后从堆上为其分配栈，并设置 g 的 stack 成员和两个 stackgard 成员
</span><span class="c1"></span>	<span class="nx">mp</span><span class="p">.</span><span class="nx">gsignal</span> <span class="p">=</span> <span class="nf">malg</span><span class="p">(</span><span class="mi">32</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="c1">// OS X wants &gt;= 8K
</span><span class="c1"></span>	<span class="nx">mp</span><span class="p">.</span><span class="nx">gsignal</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="nx">mp</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>malg</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">malg</span><span class="p">(</span><span class="nx">stacksize</span> <span class="kt">int32</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
        <span class="c1">// new 结构体
</span><span class="c1"></span>	<span class="nx">newg</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">g</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">stacksize</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">stacksize</span> <span class="p">=</span> <span class="nf">round2</span><span class="p">(</span><span class="nx">_StackSystem</span> <span class="o">+</span> <span class="nx">stacksize</span><span class="p">)</span>
                <span class="c1">// g0来分配堆栈
</span><span class="c1"></span>		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span> <span class="p">=</span> <span class="nf">stackalloc</span><span class="p">(</span><span class="nb">uint32</span><span class="p">(</span><span class="nx">stacksize</span><span class="p">))</span>
		<span class="p">})</span>
		<span class="nx">newg</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
		<span class="nx">newg</span><span class="p">.</span><span class="nx">stackguard1</span> <span class="p">=</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
		<span class="c1">// Clear the bottom word of the stack. We record g
</span><span class="c1"></span>		<span class="c1">// there on gsignal stack during VDSO on ARM and ARM64.
</span><span class="c1"></span>		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">))</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">newg</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>systemstack</li>
</ul>
<pre><code class="language-assembly" data-lang="assembly">// 切换到g0 执行
// func systemstack(fn func())
TEXT runtime·systemstack(SB), NOSPLIT, $0-8
	MOVQ	fn+0(FP), DI	// DI = fn
        // CX = m0.tls[1]
	get_tls(CX)
        // AX = m0.tls[0], 为啥这是g? 去看runtime·gogo代码, 我们设置过m0.tls[0] =g
	MOVQ	g(CX), AX	// AX = g
	MOVQ	g_m(AX), BX	// BX = m

	CMPQ	AX, m_gsignal(BX)
	JEQ	noswitch

	MOVQ	m_g0(BX), DX	// DX = g0
	CMPQ	AX, DX
	JEQ	noswitch

	CMPQ	AX, m_curg(BX)
	JNE	bad

	// switch stacks
	// save our state in g-&gt;sched. Pretend to
	// be systemstack_switch if the G stack is scanned.
	MOVQ	$runtime·systemstack_switch(SB), SI
	MOVQ	SI, (g_sched+gobuf_pc)(AX)
	MOVQ	SP, (g_sched+gobuf_sp)(AX)
	MOVQ	AX, (g_sched+gobuf_g)(AX)
	MOVQ	BP, (g_sched+gobuf_bp)(AX)

	// DX是g0
	MOVQ	DX, g(CX)
        // 保存sp
	MOVQ	(g_sched+gobuf_sp)(DX), BX
	// make it look like mstart called systemstack on g0, to stop traceback
	SUBQ	$8, BX
	MOVQ	$runtime·mstart(SB), DX
	MOVQ	DX, 0(BX)
	MOVQ	BX, SP

	// 这里调用了fn函数
	MOVQ	DI, DX
	MOVQ	0(DI), DI
	CALL	DI

	// switch back to g
	get_tls(CX)
	MOVQ	g(CX), AX
	MOVQ	g_m(AX), BX
	MOVQ	m_curg(BX), AX
	MOVQ	AX, g(CX)
	MOVQ	(g_sched+gobuf_sp)(AX), SP
	MOVQ	$0, (g_sched+gobuf_sp)(AX)
	RET

        ...

</code></pre><ul>
<li>procresize 如何分配p</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">procresize</span><span class="p">(</span><span class="nx">nprocs</span> <span class="kt">int32</span><span class="p">)</span> <span class="o">*</span><span class="nx">p</span> <span class="p">{</span>
	<span class="nf">assertLockHeld</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nf">assertWorldStopped</span><span class="p">()</span>

	<span class="nx">old</span> <span class="o">:=</span> <span class="nx">gomaxprocs</span>
	<span class="k">if</span> <span class="nx">old</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">nprocs</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;procresize: invalid arg&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGomaxprocs</span><span class="p">(</span><span class="nx">nprocs</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// update statistics
</span><span class="c1"></span>	<span class="nx">now</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">procresizetime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">sched</span><span class="p">.</span><span class="nx">totaltime</span> <span class="o">+=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">old</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nx">now</span> <span class="o">-</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">procresizetime</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">sched</span><span class="p">.</span><span class="nx">procresizetime</span> <span class="p">=</span> <span class="nx">now</span>

	<span class="nx">maskWords</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">nprocs</span> <span class="o">+</span> <span class="mi">31</span><span class="p">)</span> <span class="o">/</span> <span class="mi">32</span>

	<span class="c1">// 第一次allp肯定是0
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">nprocs</span> <span class="p">&gt;</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">allp</span><span class="p">))</span> <span class="p">{</span>
		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
                <span class="c1">// cap(allp) 第一次肯定是0
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">nprocs</span> <span class="o">&lt;=</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">allp</span><span class="p">))</span> <span class="p">{</span>
			<span class="nx">allp</span> <span class="p">=</span> <span class="nx">allp</span><span class="p">[:</span><span class="nx">nprocs</span><span class="p">]</span>
                <span class="c1">// 第一次是走else
</span><span class="c1"></span>                <span class="c1">// 如果运行过程中存在手工调整p的情况, 减小了也可能走这里
</span><span class="c1"></span>		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="c1">// 生成p的数组
</span><span class="c1"></span>			<span class="nx">nallp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">nprocs</span><span class="p">)</span>
                        <span class="c1">// 会需要需要减小的情况, 需要把原来的p copy过来
</span><span class="c1"></span>                        <span class="c1">// 初始化的话,allp肯定是空的
</span><span class="c1"></span>			<span class="nb">copy</span><span class="p">(</span><span class="nx">nallp</span><span class="p">,</span> <span class="nx">allp</span><span class="p">[:</span><span class="nb">cap</span><span class="p">(</span><span class="nx">allp</span><span class="p">)])</span>
                        <span class="c1">// 设置一下全局变量
</span><span class="c1"></span>			<span class="nx">allp</span> <span class="p">=</span> <span class="nx">nallp</span>
		<span class="p">}</span>
                <span class="o">...</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// initialize new P&#39;s
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">old</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">nprocs</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">pp</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="k">if</span> <span class="nx">pp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">pp</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
		<span class="p">}</span>
                <span class="c1">// 详细内容见后面
</span><span class="c1"></span>		<span class="nx">pp</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
                <span class="c1">// p存入到allp中
</span><span class="c1"></span>		<span class="nf">atomicstorep</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allp</span><span class="p">[</span><span class="nx">i</span><span class="p">]),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">pp</span><span class="p">))</span>
	<span class="p">}</span>
        <span class="c1">// 初始化是g0
</span><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">id</span> <span class="p">&lt;</span> <span class="nx">nprocs</span> <span class="p">{</span>
		<span class="c1">// continue to use the current P
</span><span class="c1"></span>		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Prunning</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">mcache</span><span class="p">.</span><span class="nf">prepareForSweep</span><span class="p">()</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">...</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="p">=</span> <span class="mi">0</span>
                <span class="c1">// 取队列的第0个p
</span><span class="c1"></span>		<span class="nx">p</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1">//
</span><span class="c1"></span>		<span class="nx">p</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="mi">0</span>
                <span class="c1">// 把p设置为idle
</span><span class="c1"></span>		<span class="nx">p</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pidle</span>
                <span class="c1">// p0 和 m0 关联起来, 详细内容见后面
</span><span class="c1"></span>		<span class="nf">acquirep</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
			<span class="nf">traceGoStart</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// g.m.p is now set, so we no longer need mcache0 for bootstrapping.
</span><span class="c1"></span>	<span class="nx">mcache0</span> <span class="p">=</span> <span class="kc">nil</span>

	<span class="c1">// 如果是手工缩小p就 释放
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">nprocs</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">old</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
                <span class="c1">// 这里释放主要是把一些本地的g都加到全局队列中去
</span><span class="c1"></span>                <span class="c1">// 然后p都设置为dead, 这里并没有去删除,方便下次需要直接调用
</span><span class="c1"></span>		<span class="nx">p</span><span class="p">.</span><span class="nf">destroy</span><span class="p">()</span>
		<span class="c1">// can&#39;t free P itself because it can be referenced by an M in syscall
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="c1">// 对p队列做一次伸缩
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">allp</span><span class="p">))</span> <span class="o">!=</span> <span class="nx">nprocs</span> <span class="p">{</span>
		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
		<span class="nx">allp</span> <span class="p">=</span> <span class="nx">allp</span><span class="p">[:</span><span class="nx">nprocs</span><span class="p">]</span>
		<span class="nx">idlepMask</span> <span class="p">=</span> <span class="nx">idlepMask</span><span class="p">[:</span><span class="nx">maskWords</span><span class="p">]</span>
		<span class="nx">timerpMask</span> <span class="p">=</span> <span class="nx">timerpMask</span><span class="p">[:</span><span class="nx">maskWords</span><span class="p">]</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">runnablePs</span> <span class="o">*</span><span class="nx">p</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">nprocs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
                <span class="c1">// g0.m.p是p0, 不用加入到空闲队列
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">==</span> <span class="nx">p</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
                <span class="c1">// 设置idle
</span><span class="c1"></span>		<span class="nx">p</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pidle</span>
                <span class="c1">// 可运行的空闲队列,详细见后面
</span><span class="c1"></span>		<span class="k">if</span> <span class="nf">runqempty</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
                        <span class="c1">// 放入全局空闲链表, 详细见后面
</span><span class="c1"></span>			<span class="nf">pidleput</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="c1">// mget() 获取一个m 绑定到这个p上去执行
</span><span class="c1"></span>			<span class="nx">p</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nf">mget</span><span class="p">())</span>
                        <span class="c1">// 设置链表
</span><span class="c1"></span>			<span class="nx">p</span><span class="p">.</span><span class="nx">link</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">runnablePs</span><span class="p">)</span>
			<span class="nx">runnablePs</span> <span class="p">=</span> <span class="nx">p</span>
		<span class="p">}</span>
	<span class="p">}</span>
        <span class="c1">// 对randomOrder的队列做一个随机处理, 为了后续有偷取的时候更随机,调度更公平
</span><span class="c1"></span>	<span class="nx">stealOrder</span><span class="p">.</span><span class="nf">reset</span><span class="p">(</span><span class="nb">uint32</span><span class="p">(</span><span class="nx">nprocs</span><span class="p">))</span>
	<span class="kd">var</span> <span class="nx">int32p</span> <span class="o">*</span><span class="kt">int32</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">gomaxprocs</span> <span class="c1">// make compiler check that gomaxprocs is an int32
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">((</span><span class="o">*</span><span class="kt">uint32</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">int32p</span><span class="p">)),</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">nprocs</span><span class="p">))</span>
        <span class="c1">// 返回本地任务链表p头, allp队列里的第一个可执行的p
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">runnablePs</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>init p初始化函数</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">pp</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="nf">init</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// id就是索引了
</span><span class="c1"></span>	<span class="nx">pp</span><span class="p">.</span><span class="nx">id</span> <span class="p">=</span> <span class="nx">id</span>
        <span class="c1">// 新建的p开始是stop状态
</span><span class="c1"></span>	<span class="nx">pp</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pgcstop</span>
	<span class="o">...</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>acquirep</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">acquirep</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 继续追
</span><span class="c1"></span>	<span class="nf">wirep</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
	<span class="nx">_p_</span><span class="p">.</span><span class="nx">mcache</span><span class="p">.</span><span class="nf">prepareForSweep</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceProcStart</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>wirep</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">wirep</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// g0
</span><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
        <span class="c1">// 第一次是g0.m.p == 0  
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;wirep: already in go&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span> <span class="o">!=</span> <span class="nx">_Pidle</span> <span class="p">{</span>
		<span class="nx">id</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">id</span> <span class="p">=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">id</span>
		<span class="p">}</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;wirep: p-&gt;m=&#34;</span><span class="p">,</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">,</span> <span class="s">&#34;(&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="s">&#34;) p-&gt;status=&#34;</span><span class="p">,</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;wirep: invalid p state&#34;</span><span class="p">)</span>
	<span class="p">}</span>
        <span class="c1">// g0.m.p = p0
</span><span class="c1"></span>	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
        <span class="c1">// p0.m0 = m0
</span><span class="c1"></span>	<span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">)</span>
        <span class="c1">// 现在就可以设置为running了
</span><span class="c1"></span>	<span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Prunning</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>runqempty</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">runqempty</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
        <span class="c1">// 这里是无锁的方式判断
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">head</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">)</span>
		<span class="nx">tail</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span><span class="p">)</span>
		<span class="nx">runnext</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Loaduintptr</span><span class="p">((</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span><span class="p">)))</span>
		<span class="k">if</span> <span class="nx">tail</span> <span class="o">==</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">head</span> <span class="o">==</span> <span class="nx">tail</span> <span class="o">&amp;&amp;</span> <span class="nx">runnext</span> <span class="o">==</span> <span class="mi">0</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>pidleput</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">pidleput</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">assertLockHeld</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="k">if</span> <span class="p">!</span><span class="nf">runqempty</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;pidleput: P has non-empty run queue&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">updateTimerPMask</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="c1">// clear if there are no timers.
</span><span class="c1"></span>	<span class="nx">idlepMask</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span>
        <span class="c1">// sched.pidle 是全局空闲p链表的最后一个
</span><span class="c1"></span>        <span class="c1">// 当前p的link记录
</span><span class="c1"></span>	<span class="nx">_p_</span><span class="p">.</span><span class="nx">link</span> <span class="p">=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">pidle</span>
        <span class="c1">// 然后把sched.pidle 设置为当前p, 这样就连起来了
</span><span class="c1"></span>	<span class="nx">sched</span><span class="p">.</span><span class="nx">pidle</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// TODO: fast atomic
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>到 runtime·schedinit时的状态图, 来自<img src="https://qcrao.com/ishare/go-scheduler" alt="https://qcrao.com">的图:</p>
<p><img src="/images/golang/gmp-1.png" alt=""></p>
<hr>
<pre><code class="language-assembly" data-lang="assembly">        MOVQ	$runtime·mainPC(SB), AX
        // 入栈新的goroutine的地址
        PUSHQ	AX	  
        // main函数参数个数是0
        PUSHL	$0
        // 创建goroutine
        CALL	runtime·newproc(SB)       
        POPL	AX
        POPL	AX
</code></pre><blockquote>
<p>gmp已经初始化的差不多了, 现在可以创建main goroutine了</p>
</blockquote>
<h3 id="创建g-newproc">创建g newproc<a href="#创建g-newproc" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/proc.go
</span><span class="c1">// 两个参数, 一个是函数siz,一个是函数地址
</span><span class="c1">// type funcval struct {
</span><span class="c1">// 	fn uintptr
</span><span class="c1">// 	// variable-size, fn-specific data here
</span><span class="c1">// }
</span><span class="c1">// 函数栈从高到底依次是:
</span><span class="c1">// fn的参数        这里是高地址, &amp;fn+sys.PtrSize
</span><span class="c1">// fn的地址        这里是&amp;fn
</span><span class="c1">// fn的size
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newproc</span><span class="p">(</span><span class="nx">siz</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">fn</span> <span class="o">*</span><span class="nx">funcval</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// fn的第一个参数
</span><span class="c1"></span>	<span class="nx">argp</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">fn</span><span class="p">),</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span>
        <span class="c1">// g0
</span><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
        <span class="c1">// 调用者的pc,call pc就是调用者的下一个指令, 我们看到runtime·rt0_go中, call runtime-newproc后 POPL AX了
</span><span class="c1"></span>        <span class="c1">// 所以这里的调用者pc 就是 AX地址, AX 是 main的地址
</span><span class="c1"></span>	<span class="nx">pc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
        <span class="c1">// systemstack 的作用是切换到 g0 栈执行作为参数的函数
</span><span class="c1"></span>        <span class="c1">// 用 g0 系统栈创建 goroutine 对象
</span><span class="c1"></span>        <span class="c1">// 传递的参数包括 fn 函数入口地址，argp 参数起始地址，siz 参数长度，调用方 pc（goroutine）
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
                <span class="c1">// 真正的创建go
</span><span class="c1"></span>		<span class="nx">newg</span> <span class="o">:=</span> <span class="nf">newproc1</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">argp</span><span class="p">,</span> <span class="nx">siz</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
                <span class="c1">// 获取到本地绑定的p
</span><span class="c1"></span>		<span class="nx">_p_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
                <span class="c1">// 将这里新创建的 g 放入 p 的本地队列或直接放入全局队列
</span><span class="c1"></span>                <span class="c1">// true 表示放入执行队列的下一个，false 表示放入队尾
</span><span class="c1"></span>		<span class="nf">runqput</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">newg</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>

		<span class="k">if</span> <span class="nx">mainStarted</span> <span class="p">{</span>
			<span class="nf">wakep</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">})</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>newproc1 核心创建goroutine</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/proc.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newproc1</span><span class="p">(</span><span class="nx">fn</span> <span class="o">*</span><span class="nx">funcval</span><span class="p">,</span> <span class="nx">argp</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">narg</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">callergp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">callerpc</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
        <span class="c1">// g0, systemstack 切换的
</span><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
        <span class="c1">// go 命令后面的函数肯定不能是nil
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">fn</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">throwing</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1">// do not dump full stacks
</span><span class="c1"></span>		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;go of nil func value&#34;</span><span class="p">)</span>
	<span class="p">}</span>
        <span class="c1">// 绑定m
</span><span class="c1"></span>	<span class="nf">acquirem</span><span class="p">()</span> <span class="c1">// disable preemption because it can be holding p in a local var
</span><span class="c1"></span>	<span class="nx">siz</span> <span class="o">:=</span> <span class="nx">narg</span>
        <span class="c1">// 内存对齐, &amp;^ 7 会把低三位全部置为0
</span><span class="c1"></span>	<span class="nx">siz</span> <span class="p">=</span> <span class="p">(</span><span class="nx">siz</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;^</span> <span class="mi">7</span>

        <span class="o">...</span>
        <span class="c1">// 当前g0所绑定的p
</span><span class="c1"></span>	<span class="nx">_p_</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
        <span class="c1">// 从p的本地队列获取一个g,空的话会从全局拿一个,初始化肯定是nil 详细见后面
</span><span class="c1"></span>	<span class="nx">newg</span> <span class="o">:=</span> <span class="nf">gfget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">newg</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="c1">// 分配一个2k空间的g
</span><span class="c1"></span>		<span class="nx">newg</span> <span class="p">=</span> <span class="nf">malg</span><span class="p">(</span><span class="nx">_StackMin</span><span class="p">)</span>
                <span class="c1">// 设置为dead状态
</span><span class="c1"></span>		<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">newg</span><span class="p">,</span> <span class="nx">_Gidle</span><span class="p">,</span> <span class="nx">_Gdead</span><span class="p">)</span>
                <span class="c1">// 加入到 allgs 全局队列中
</span><span class="c1"></span>		<span class="nf">allgadd</span><span class="p">(</span><span class="nx">newg</span><span class="p">)</span> <span class="c1">// publishes with a g-&gt;status of Gdead so GC scanner doesn&#39;t look at uninitialized stack.
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;newproc1: newg missing stack&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">newg</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">_Gdead</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;newproc1: new g is not Gdead&#34;</span><span class="p">)</span>
	<span class="p">}</span>
        <span class="c1">// 计算内存空间
</span><span class="c1"></span>	<span class="nx">totalSize</span> <span class="o">:=</span> <span class="mi">4</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">RegSize</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">siz</span><span class="p">)</span> <span class="o">+</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">MinFrameSize</span> <span class="c1">// extra space in case of reads slightly beyond frame
</span><span class="c1"></span>        <span class="c1">// 对于arm环境的sys.SpAlign=16,其他的是1
</span><span class="c1"></span>	<span class="nx">totalSize</span> <span class="o">+=</span> <span class="o">-</span><span class="nx">totalSize</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nx">SpAlign</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>                  <span class="c1">// align to spAlign
</span><span class="c1"></span>        <span class="c1">// 预留空间, 确定sp栈顶的位置
</span><span class="c1"></span>	<span class="nx">sp</span> <span class="o">:=</span> <span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="o">-</span> <span class="nx">totalSize</span>
        <span class="c1">// 确定参数入栈位置
</span><span class="c1"></span>	<span class="nx">spArg</span> <span class="o">:=</span> <span class="nx">sp</span>
        <span class="o">...</span>
	<span class="k">if</span> <span class="nx">narg</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="c1">// argp 是fn的第一个参数地址
</span><span class="c1"></span>                <span class="c1">// 这是copy 参数到新的g栈的spArg参数位置
</span><span class="c1"></span>		<span class="nf">memmove</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">spArg</span><span class="p">),</span> <span class="nx">argp</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">narg</span><span class="p">))</span>
                <span class="o">...</span>
	<span class="p">}</span>
        <span class="c1">// 把 newg.sched 结构体成员的所有成员设置为 0
</span><span class="c1"></span>	<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">))</span>
        <span class="c1">// 设置 newg 的 sched 成员，调度器需要依靠这些字段才能把 goroutine 调度到 CPU 上运行
</span><span class="c1"></span>	<span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span> <span class="p">=</span> <span class="nx">sp</span>
	<span class="nx">newg</span><span class="p">.</span><span class="nx">stktopsp</span> <span class="p">=</span> <span class="nx">sp</span>
        <span class="c1">// 设置newg被调度时的第一个指令, Goexit函数地址,
</span><span class="c1"></span>        <span class="c1">// sys.PCQuantum =1, +1表示goexit函数的第一条指令?
</span><span class="c1"></span>	<span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="nf">funcPC</span><span class="p">(</span><span class="nx">goexit</span><span class="p">)</span> <span class="o">+</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PCQuantum</span> <span class="c1">// +PCQuantum 这样前一条指令就在同一个函数中了
</span><span class="c1"></span>	<span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nf">guintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">newg</span><span class="p">))</span>
        <span class="c1">// 设置newg.sched的 sp和pc等信息,pc设为fn的地址了 详细见后面
</span><span class="c1"></span>	<span class="nf">gostartcallfn</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">,</span> <span class="nx">fn</span><span class="p">)</span>
        <span class="c1">// 设置为调用者pc
</span><span class="c1"></span>	<span class="nx">newg</span><span class="p">.</span><span class="nx">gopc</span> <span class="p">=</span> <span class="nx">callerpc</span>
	<span class="nx">newg</span><span class="p">.</span><span class="nx">ancestors</span> <span class="p">=</span> <span class="nf">saveAncestors</span><span class="p">(</span><span class="nx">callergp</span><span class="p">)</span>
	<span class="nx">newg</span><span class="p">.</span><span class="nx">startpc</span> <span class="p">=</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">fn</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">newg</span><span class="p">.</span><span class="nx">labels</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span><span class="p">.</span><span class="nx">labels</span>
	<span class="p">}</span>
        <span class="c1">// runtime. 前缀的属于系统goroutine
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">isSystemGoroutine</span><span class="p">(</span><span class="nx">newg</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ngsys</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
        <span class="c1">// g的状态设置为可运行
</span><span class="c1"></span>	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">newg</span><span class="p">,</span> <span class="nx">_Gdead</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span> <span class="o">==</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcacheend</span> <span class="p">{</span>
                <span class="c1">// Sched.goidgen 为最后一个分配的 id，相当于一个全局计数器
</span><span class="c1"></span>		<span class="c1">// 这一批必须为 [sched.goidgen+1, sched.goidgen+GoidCacheBatch].
</span><span class="c1"></span>		<span class="c1">// 启动时 sched.goidgen=0, 因此主 Goroutine 的 goid 为 1
</span><span class="c1"></span>		<span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span> <span class="p">=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">goidgen</span><span class="p">,</span> <span class="nx">_GoidCacheBatch</span><span class="p">)</span>
		<span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span> <span class="o">-=</span> <span class="nx">_GoidCacheBatch</span> <span class="o">-</span> <span class="mi">1</span>
		<span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcacheend</span> <span class="p">=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span> <span class="o">+</span> <span class="nx">_GoidCacheBatch</span>
	<span class="p">}</span>
        <span class="c1">// 生成goid
</span><span class="c1"></span>	<span class="nx">newg</span><span class="p">.</span><span class="nx">goid</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span><span class="p">)</span>
	<span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span><span class="o">++</span>
	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nx">newg</span><span class="p">.</span><span class="nx">racectx</span> <span class="p">=</span> <span class="nf">racegostart</span><span class="p">(</span><span class="nx">callerpc</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGoCreate</span><span class="p">(</span><span class="nx">newg</span><span class="p">,</span> <span class="nx">newg</span><span class="p">.</span><span class="nx">startpc</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">releasem</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">newg</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>gfget</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/proc.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">gfget</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
<span class="nx">retry</span><span class="p">:</span>
        <span class="c1">// 如果p本地空闲队列为空 并且全局空闲队列不空
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(!</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="o">||</span> <span class="p">!</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">noStack</span><span class="p">.</span><span class="nf">empty</span><span class="p">())</span> <span class="p">{</span>
                <span class="c1">// 操作全局,上锁
</span><span class="c1"></span>		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="c1">// Move a batch of free Gs to the P.
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span> <span class="p">&lt;</span> <span class="mi">32</span> <span class="p">{</span>
			<span class="c1">// 从全局拿一个g
</span><span class="c1"></span>			<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">gp</span> <span class="p">=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">noStack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
				<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="k">break</span>
				<span class="p">}</span>
			<span class="p">}</span>
                        <span class="c1">// 全局的n--
</span><span class="c1"></span>			<span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span><span class="o">--</span>
                        <span class="c1">// 全局的放入到p本地队列中
</span><span class="c1"></span>			<span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
			<span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
                <span class="c1">// 本地队列加一个了, 然后再去retry一下
</span><span class="c1"></span>		<span class="k">goto</span> <span class="nx">retry</span>
	<span class="p">}</span>
        <span class="c1">// 如果本地不为空直接取
</span><span class="c1"></span>        <span class="c1">// 如果本地为空 并且全局也是空, 初始化的情况,也得取一个nil
</span><span class="c1"></span>        <span class="c1">// 直接从本地的p空闲队列取出
</span><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="c1">// 初始化的情况
</span><span class="c1"></span>		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span><span class="o">--</span>
	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Stack was deallocated in gfput. Allocate a new one.
</span><span class="c1"></span>		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span> <span class="p">=</span> <span class="nf">stackalloc</span><span class="p">(</span><span class="nx">_FixedStack</span><span class="p">)</span>
		<span class="p">})</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
			<span class="nf">racemalloc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">),</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span><span class="o">-</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">msanenabled</span> <span class="p">{</span>
			<span class="nf">msanmalloc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">),</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span><span class="o">-</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">gp</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>gostartcallfn</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gostartcallfn</span><span class="p">(</span><span class="nx">gobuf</span> <span class="o">*</span><span class="nx">gobuf</span><span class="p">,</span> <span class="nx">fv</span> <span class="o">*</span><span class="nx">funcval</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">fn</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
	<span class="k">if</span> <span class="nx">fv</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="c1">// goroutine入口, 初始化时是 runtime.main()
</span><span class="c1"></span>		<span class="nx">fn</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">fv</span><span class="p">.</span><span class="nx">fn</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">fn</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nf">funcPC</span><span class="p">(</span><span class="nx">nilfunc</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="nf">gostartcall</span><span class="p">(</span><span class="nx">gobuf</span><span class="p">,</span> <span class="nx">fn</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">fv</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">gostartcall</span><span class="p">(</span><span class="nx">buf</span> <span class="o">*</span><span class="nx">gobuf</span><span class="p">,</span> <span class="nx">fn</span><span class="p">,</span> <span class="nx">ctxt</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// newg.sched.sp
</span><span class="c1"></span>	<span class="nx">sp</span> <span class="o">:=</span> <span class="nx">buf</span><span class="p">.</span><span class="nx">sp</span>
	<span class="k">if</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">RegSize</span> <span class="p">&gt;</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="p">{</span>
		<span class="nx">sp</span> <span class="o">-=</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sp</span><span class="p">))</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
        <span class="c1">// newg.sched.sp下移8
</span><span class="c1"></span>	<span class="nx">sp</span> <span class="o">-=</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
        <span class="c1">// newg.sched.pc之前是记录我们newg函数的第一条指令 goexit函数,给他保存到sp位置
</span><span class="c1"></span>        <span class="c1">// 伪装fn是被goexit调用, 这样fn执行完sp上移8 就执行了goexit函数了
</span><span class="c1"></span>	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sp</span><span class="p">))</span> <span class="p">=</span> <span class="nx">buf</span><span class="p">.</span><span class="nx">pc</span>
        <span class="c1">// 更新为最新的sp
</span><span class="c1"></span>	<span class="nx">buf</span><span class="p">.</span><span class="nx">sp</span> <span class="p">=</span> <span class="nx">sp</span>
        <span class="c1">// 把newg.sched.pc 设置为fn的地址
</span><span class="c1"></span>        <span class="c1">// 当goroutine执行的时候, 就先执行了buf.pc地址的函数fn
</span><span class="c1"></span>	<span class="nx">buf</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span>
	<span class="nx">buf</span><span class="p">.</span><span class="nx">ctxt</span> <span class="p">=</span> <span class="nx">ctxt</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>runqput</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// runqput 尝试将 g 放到本地可执行队列里。
</span><span class="c1">// 如果 next 为假，runqput 将 g 添加到可运行队列的尾部
</span><span class="c1">// 如果 next 为真，runqput 将 g 添加到 p.runnext 字段
</span><span class="c1">// 如果 run queue 满了，runnext 将 g 放到全局队列里
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">runqput</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">next</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 如果是设置了随机模式?
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">randomizeScheduler</span> <span class="o">&amp;&amp;</span> <span class="nx">next</span> <span class="o">&amp;&amp;</span> <span class="nf">fastrand</span><span class="p">()</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">next</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="p">}</span>
        <span class="c1">// 如果需要放入队尾
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">next</span> <span class="p">{</span>
	<span class="nx">retryNext</span><span class="p">:</span>
                <span class="c1">// 原本的p队列的next保存
</span><span class="c1"></span>		<span class="nx">oldnext</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span>
                <span class="c1">// 将新的gp放到runnext位置执行
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span><span class="p">.</span><span class="nf">cas</span><span class="p">(</span><span class="nx">oldnext</span><span class="p">,</span> <span class="nf">guintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gp</span><span class="p">)))</span> <span class="p">{</span>
                        <span class="c1">// 有其它线程在操作 oldnext 成员，需要重试
</span><span class="c1"></span>			<span class="k">goto</span> <span class="nx">retryNext</span>
		<span class="p">}</span>
                <span class="c1">// 不用管
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">oldnext</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
                <span class="c1">// 把oldnext设置为了gp, 后续会对他入队尾的
</span><span class="c1"></span>		<span class="nx">gp</span> <span class="p">=</span> <span class="nx">oldnext</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="p">}</span>

<span class="nx">retry</span><span class="p">:</span>
	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadAcq</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">)</span> <span class="c1">// load-acquire, synchronize with consumers
</span><span class="c1"></span>	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span>
        <span class="c1">// 没满
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">t</span><span class="o">-</span><span class="nx">h</span> <span class="p">&lt;</span> <span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))</span> <span class="p">{</span>
                <span class="c1">// gp 入到队尾的, 可能是newg,也可能是oldnext
</span><span class="c1"></span>		<span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">[</span><span class="nx">t</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))].</span><span class="nf">set</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
                <span class="c1">// 原子操作
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreRel</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span><span class="p">,</span> <span class="nx">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// store-release, makes the item available for consumption
</span><span class="c1"></span>		<span class="k">return</span>
	<span class="p">}</span>
        <span class="c1">// 如果本地满了, 把本地的一半 和gp 放到全局队列中去,详细见后面
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">runqputslow</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// 现在本地队列没满, 再试一次
</span><span class="c1"></span>	<span class="k">goto</span> <span class="nx">retry</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>runqputslow</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">runqputslow</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">t</span> <span class="kt">uint32</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
        <span class="c1">// 新建一个本地队列一半(128)+1大小的队列
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">batch</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="nx">g</span>

	<span class="c1">// First, grab a batch from local queue.
</span><span class="c1"></span>        <span class="c1">// 如果满了, t-h=256
</span><span class="c1"></span>	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">t</span> <span class="o">-</span> <span class="nx">h</span>
        <span class="c1">// n = 128
</span><span class="c1"></span>	<span class="nx">n</span> <span class="p">=</span> <span class="nx">n</span> <span class="o">/</span> <span class="mi">2</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="o">!=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runqputslow: queue is not full&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">batch</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">[(</span><span class="nx">h</span><span class="o">+</span><span class="nx">i</span><span class="p">)</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))].</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="p">}</span>
        <span class="c1">// CasRel 如果未false, 那就说明本地队列没满, 直接返回
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">CasRel</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">h</span><span class="o">+</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// cas-release, commits consume
</span><span class="c1"></span>		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
        <span class="c1">// 索引为128的是队尾, gp放到队尾
</span><span class="c1"></span>	<span class="nx">batch</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="p">=</span> <span class="nx">gp</span>
        <span class="c1">// 如果是随机调度
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">randomizeScheduler</span> <span class="p">{</span>
                <span class="c1">// 把这个batch队列打乱
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">j</span> <span class="o">:=</span> <span class="nf">fastrandn</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
			<span class="nx">batch</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">batch</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">batch</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">batch</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 设置为链表
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">batch</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">schedlink</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">batch</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
	<span class="p">}</span>
        <span class="c1">// 定义个g队列元素
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">q</span> <span class="nx">gQueue</span>
	<span class="nx">q</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">batch</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="nx">q</span><span class="p">.</span><span class="nx">tail</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">batch</span><span class="p">[</span><span class="nx">n</span><span class="p">])</span>

	<span class="c1">// 上锁,
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="c1">// 放到全局队列中
</span><span class="c1"></span>	<span class="nf">globrunqputbatch</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">q</span><span class="p">,</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>globrunqputbatch</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">globrunqputbatch</span><span class="p">(</span><span class="nx">batch</span> <span class="o">*</span><span class="nx">gQueue</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">assertLockHeld</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="c1">// 操作链表的函数
</span><span class="c1"></span>	<span class="nx">sched</span><span class="p">.</span><span class="nx">runq</span><span class="p">.</span><span class="nf">pushBackAll</span><span class="p">(</span><span class="o">*</span><span class="nx">batch</span><span class="p">)</span>
	<span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="o">+=</span> <span class="nx">n</span>
	<span class="o">*</span><span class="nx">batch</span> <span class="p">=</span> <span class="nx">gQueue</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">q</span> <span class="o">*</span><span class="nx">gQueue</span><span class="p">)</span> <span class="nf">pushBackAll</span><span class="p">(</span><span class="nx">q2</span> <span class="nx">gQueue</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">q2</span><span class="p">.</span><span class="nx">tail</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">q2</span><span class="p">.</span><span class="nx">tail</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">schedlink</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="k">if</span> <span class="nx">q</span><span class="p">.</span><span class="nx">tail</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="c1">// 如果当前的q(sched.runq)的tail不是0,那么先把指向 batch.head
</span><span class="c1"></span>		<span class="nx">q</span><span class="p">.</span><span class="nx">tail</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">schedlink</span> <span class="p">=</span> <span class="nx">q2</span><span class="p">.</span><span class="nx">head</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// 如果sched.runq.tail 是空的, 那么就batch.head就是全局队列的head
</span><span class="c1"></span>		<span class="nx">q</span><span class="p">.</span><span class="nx">head</span> <span class="p">=</span> <span class="nx">q2</span><span class="p">.</span><span class="nx">head</span>
	<span class="p">}</span>
        <span class="c1">// 设置新的队尾
</span><span class="c1"></span>	<span class="nx">q</span><span class="p">.</span><span class="nx">tail</span> <span class="p">=</span> <span class="nx">q2</span><span class="p">.</span><span class="nx">tail</span>
<span class="p">}</span>

</code></pre></div><p>现在在goroutine的堆上结构体如下, 来自<img src="https://qcrao.com/ishare/go-scheduler" alt="https://qcrao.com">的图:</p>
<p><img src="/images/golang/gmp-2.png" alt=""></p>
<h3 id="开始调度-mstart">开始调度 mstart()<a href="#开始调度-mstart" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<ul>
<li>mstart()</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/proc.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">mstart</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// g0
</span><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="p">..</span>
	<span class="nf">mstart1</span><span class="p">()</span>

	<span class="c1">// 退出线程
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">mStackIsSystemAllocated</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">osStack</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="nf">mexit</span><span class="p">(</span><span class="nx">osStack</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h4 id="实质逻辑-mstart1">实质逻辑 mstart1()<a href="#实质逻辑-mstart1" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/proc.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">mstart1</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 必须是g0
</span><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">_g_</span> <span class="o">!=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad runtime·mstart&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 记录pc,sp到当前的g0.sched
</span><span class="c1"></span>	<span class="nf">save</span><span class="p">(</span><span class="nf">getcallerpc</span><span class="p">(),</span> <span class="nf">getcallersp</span><span class="p">())</span>
	<span class="nf">asminit</span><span class="p">()</span>  
	<span class="nf">minit</span><span class="p">()</span>
	<span class="c1">// 若当前 g 所绑定的 m 是 m0，
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nx">m0</span> <span class="p">{</span>
		<span class="nf">mstartm0</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">// 运行启动函数,初始化过程中，fn == nil
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">fn</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mstartfn</span><span class="p">;</span> <span class="nx">fn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">fn</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">//若当前 g 所绑定的 m 不是 m0，
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="nx">m0</span> <span class="p">{</span>
		<span class="c1">//则需要调用 acquirep 方法获取并绑定 p，也就是 m 与 p 绑定。
</span><span class="c1"></span>		<span class="nf">acquirep</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">nextp</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">nextp</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
        <span class="c1">// 调度, 永不退出
</span><span class="c1"></span>	<span class="nf">schedule</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><h4 id="真正的调度-schedule">真正的调度 schedule()<a href="#真正的调度-schedule" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">schedule</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// g0
</span><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;schedule: holding locks&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedg</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">stoplockedm</span><span class="p">()</span>
		<span class="nf">execute</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedg</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="kc">false</span><span class="p">)</span> <span class="c1">// Never returns.
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="c1">// We should not schedule away from a g that is executing a cgo call,
</span><span class="c1"></span>	<span class="c1">// since the cgo call is using the m&#39;s g0 stack.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">incgo</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;schedule: in cgo&#34;</span><span class="p">)</span>
	<span class="p">}</span>

<span class="nx">top</span><span class="p">:</span>
        <span class="c1">// 获取一个p
</span><span class="c1"></span>	<span class="nx">pp</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
        <span class="c1">// 抢占信号
</span><span class="c1"></span>	<span class="nx">pp</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">=</span> <span class="kc">false</span>

	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="c1">// 会调用 stopm()
</span><span class="c1"></span>		<span class="nf">gcstopm</span><span class="p">()</span>
		<span class="k">goto</span> <span class="nx">top</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">runSafePointFn</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">runSafePointFn</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">runnext</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">runqhead</span> <span class="o">!=</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">runqtail</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;schedule: spinning with local work&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nf">checkTimers</span><span class="p">(</span><span class="nx">pp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span>
	<span class="kd">var</span> <span class="nx">inheritTime</span> <span class="kt">bool</span>

	<span class="nx">tryWakeP</span> <span class="o">:=</span> <span class="kc">false</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="o">||</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">shutdown</span> <span class="p">{</span>
		<span class="nx">gp</span> <span class="p">=</span> <span class="nf">traceReader</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
			<span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
			<span class="nx">tryWakeP</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">gp</span> <span class="p">=</span> <span class="nx">gcController</span><span class="p">.</span><span class="nf">findRunnableGCWorker</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
		<span class="nx">tryWakeP</span> <span class="p">=</span> <span class="nx">tryWakeP</span> <span class="o">||</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span>
	<span class="p">}</span>
        <span class="c1">// 初始化肯定是nil
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// schedule函数调度每61次就 取一次全局队列的g,防止饿死
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">schedtick</span><span class="o">%</span><span class="mi">61</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
                        <span class="c1">// 这里第一个参数是本地p,第二个参数是需要从全局取多少个g, 详细见后面
</span><span class="c1"></span>			<span class="nx">gp</span> <span class="p">=</span> <span class="nf">globrunqget</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
        <span class="c1">// 如果gp还是nil
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="c1">// 本地取,详细见后面
</span><span class="c1"></span>		<span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="p">=</span> <span class="nf">runqget</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>

	<span class="p">}</span>
        <span class="c1">// 如果还是nil
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="c1">// 是时候去偷一点了, 详细见后面
</span><span class="c1"></span>		<span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="p">=</span> <span class="nf">findrunnable</span><span class="p">()</span> <span class="c1">// blocks until work is available
</span><span class="c1"></span>	<span class="p">}</span>
        <span class="c1">// m如果是自旋
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">{</span>
		<span class="nf">resetspinning</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">disable</span><span class="p">.</span><span class="nx">user</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nf">schedEnabled</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// Scheduling of this goroutine is disabled. Put it on
</span><span class="c1"></span>		<span class="c1">// the list of pending runnable goroutines for when we
</span><span class="c1"></span>		<span class="c1">// re-enable user scheduling and look again.
</span><span class="c1"></span>		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">if</span> <span class="nf">schedEnabled</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// Something re-enabled scheduling while we
</span><span class="c1"></span>			<span class="c1">// were acquiring the lock.
</span><span class="c1"></span>			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">sched</span><span class="p">.</span><span class="nx">disable</span><span class="p">.</span><span class="nx">runnable</span><span class="p">.</span><span class="nf">pushBack</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
			<span class="nx">sched</span><span class="p">.</span><span class="nx">disable</span><span class="p">.</span><span class="nx">n</span><span class="o">++</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="k">goto</span> <span class="nx">top</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">tryWakeP</span> <span class="p">{</span>
		<span class="nf">wakep</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">lockedm</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Hands off own p to the locked m,
</span><span class="c1"></span>		<span class="c1">// then blocks waiting for a new p.
</span><span class="c1"></span>		<span class="nf">startlockedm</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="nx">top</span>
	<span class="p">}</span>
        <span class="c1">// 当前的schedule() 是g0
</span><span class="c1"></span>        <span class="c1">// 调度,看下如何切换到gp去执行 详细见后面
</span><span class="c1"></span>	<span class="nf">execute</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>globrunqget 全局队列获取g</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">globrunqget</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">max</span> <span class="kt">int32</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
	<span class="nf">assertLockHeld</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="c1">// 全局队列有没有
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
        <span class="c1">// 设置默认n
</span><span class="c1"></span>	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span><span class="o">/</span><span class="nx">gomaxprocs</span> <span class="o">+</span> <span class="mi">1</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="p">{</span>
		<span class="nx">n</span> <span class="p">=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span>
	<span class="p">}</span>
        <span class="c1">// 只需要get 最大max个g
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">max</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="nx">max</span> <span class="p">{</span>
		<span class="nx">n</span> <span class="p">=</span> <span class="nx">max</span>
	<span class="p">}</span>
        <span class="c1">// n不能超过当前p的队列长度的一半
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span> <span class="p">{</span>
		<span class="nx">n</span> <span class="p">=</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
	<span class="p">}</span>
        <span class="c1">// 全局减去 n
</span><span class="c1"></span>	<span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="o">-=</span> <span class="nx">n</span>
        <span class="c1">// 全局出队列
</span><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runq</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
	<span class="nx">n</span><span class="o">--</span>
        <span class="c1">// 批量出队列
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">;</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span><span class="o">--</span> <span class="p">{</span>
		<span class="nx">gp1</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runq</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
                <span class="c1">// n&gt;1的情况, 从全局取出g加入到本地p队列的队尾
</span><span class="c1"></span>		<span class="nf">runqput</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">gp1</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
	<span class="p">}</span>
        <span class="c1">// 从全局只取一个返回
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">gp</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>runqget</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">runqget</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
                <span class="c1">// p队列的下一个
</span><span class="c1"></span>		<span class="nx">next</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span>
		<span class="k">if</span> <span class="nx">next</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
                <span class="c1">// 再次确定是否有变化
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span><span class="p">.</span><span class="nf">cas</span><span class="p">(</span><span class="nx">next</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">next</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="kc">true</span>
		<span class="p">}</span>
	<span class="p">}</span>
        <span class="c1">// 如果next == 0
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
                <span class="c1">// 原子取 p队列头地址的值
</span><span class="c1"></span>		<span class="nx">h</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadAcq</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">)</span> <span class="c1">// load-acquire, synchronize with other consumers
</span><span class="c1"></span>                <span class="c1">// p队列尾
</span><span class="c1"></span>		<span class="nx">t</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span>
                <span class="c1">// 如果相等就是空队列了
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">t</span> <span class="o">==</span> <span class="nx">h</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span>
		<span class="p">}</span>
                <span class="c1">// 如果队列中有 g , 就从开头拿一个
</span><span class="c1"></span>		<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">[</span><span class="nx">h</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))].</span><span class="nf">ptr</span><span class="p">()</span>
                <span class="c1">// 原子操作，防止这中间被其他线程因为偷工作而修改
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CasRel</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">h</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// cas-release, commits consume
</span><span class="c1"></span>			<span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>findrunnable</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">findrunnable</span><span class="p">()</span> <span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

<span class="nx">top</span><span class="p">:</span>
	<span class="nx">_p_</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
        <span class="c1">// 这里要停止当前的m
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">gcstopm</span><span class="p">()</span>
		<span class="k">goto</span> <span class="nx">top</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runSafePointFn</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">runSafePointFn</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="nx">now</span><span class="p">,</span> <span class="nx">pollUntil</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nf">checkTimers</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">fingwait</span> <span class="o">&amp;&amp;</span> <span class="nx">fingwake</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">wakefing</span><span class="p">();</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">ready</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="o">*</span><span class="nx">cgo_yield</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">asmcgocall</span><span class="p">(</span><span class="o">*</span><span class="nx">cgo_yield</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 从本地找一个g
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="o">:=</span> <span class="nf">runqget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">);</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span>
	<span class="p">}</span>

	<span class="c1">// 从全局找一个g
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">globrunqget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nf">netpollinited</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">netpollWaiters</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">list</span> <span class="o">:=</span> <span class="nf">netpoll</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="p">!</span><span class="nx">list</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// non-blocking
</span><span class="c1"></span>			<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">list</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
			<span class="nf">injectglist</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">list</span><span class="p">)</span>
			<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
				<span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 从其他的p中偷取
</span><span class="c1"></span>	<span class="nx">procs</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">)</span>
	<span class="nx">ranTimer</span> <span class="o">:=</span> <span class="kc">false</span>
	<span class="c1">// 当前m现在不在自旋状态 并且
</span><span class="c1"></span>        <span class="c1">// 自旋的m数量 超过 idle的p数量的一半, 说明有很多m在找工作, 那我就停一下
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="o">&amp;&amp;</span> <span class="mi">2</span><span class="o">*</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nx">procs</span><span class="o">-</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="nx">stop</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">{</span>
                <span class="c1">// 设置为自旋状态
</span><span class="c1"></span>		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">=</span> <span class="kc">true</span>
                <span class="c1">// 原子操作, 让全局的自旋状态m到总数加一
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
        <span class="c1">// 偷的次数
</span><span class="c1"></span>	<span class="kd">const</span> <span class="nx">stealTries</span> <span class="p">=</span> <span class="mi">4</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">stealTries</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">stealTimersOrRunNextG</span> <span class="o">:=</span> <span class="nx">i</span> <span class="o">==</span> <span class="nx">stealTries</span><span class="o">-</span><span class="mi">1</span>
                <span class="c1">// 每次偷的过程 也是一个for循环
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">enum</span> <span class="o">:=</span> <span class="nx">stealOrder</span><span class="p">.</span><span class="nf">start</span><span class="p">(</span><span class="nf">fastrand</span><span class="p">());</span> <span class="p">!</span><span class="nx">enum</span><span class="p">.</span><span class="nf">done</span><span class="p">();</span> <span class="nx">enum</span><span class="p">.</span><span class="nf">next</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="nx">top</span>
			<span class="p">}</span>
                        <span class="c1">// 随机找一个p2
</span><span class="c1"></span>			<span class="nx">p2</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="nx">enum</span><span class="p">.</span><span class="nf">position</span><span class="p">()]</span>
                        <span class="c1">// 不能是自己
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">_p_</span> <span class="o">==</span> <span class="nx">p2</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">stealTimersOrRunNextG</span> <span class="o">&amp;&amp;</span> <span class="nx">timerpMask</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="nx">enum</span><span class="p">.</span><span class="nf">position</span><span class="p">())</span> <span class="p">{</span>
				<span class="nx">tnow</span><span class="p">,</span> <span class="nx">w</span><span class="p">,</span> <span class="nx">ran</span> <span class="o">:=</span> <span class="nf">checkTimers</span><span class="p">(</span><span class="nx">p2</span><span class="p">,</span> <span class="nx">now</span><span class="p">)</span>
				<span class="nx">now</span> <span class="p">=</span> <span class="nx">tnow</span>
				<span class="k">if</span> <span class="nx">w</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">pollUntil</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">w</span> <span class="p">&lt;</span> <span class="nx">pollUntil</span><span class="p">)</span> <span class="p">{</span>
					<span class="nx">pollUntil</span> <span class="p">=</span> <span class="nx">w</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">ran</span> <span class="p">{</span>
					<span class="k">if</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="o">:=</span> <span class="nf">runqget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">);</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
						<span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span>
					<span class="p">}</span>
					<span class="nx">ranTimer</span> <span class="p">=</span> <span class="kc">true</span>
				<span class="p">}</span>
			<span class="p">}</span>
                        <span class="c1">// p如果是idle就不用浪费时间去偷了
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">!</span><span class="nx">idlepMask</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="nx">enum</span><span class="p">.</span><span class="nf">position</span><span class="p">())</span> <span class="p">{</span>
                                <span class="c1">// 真正的偷, 详细见后面
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">runqsteal</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">p2</span><span class="p">,</span> <span class="nx">stealTimersOrRunNextG</span><span class="p">);</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">ranTimer</span> <span class="p">{</span>
		<span class="c1">// Running a timer may have made some goroutine ready.
</span><span class="c1"></span>		<span class="k">goto</span> <span class="nx">top</span>
	<span class="p">}</span>

<span class="c1">// 几种情况会走到stop
</span><span class="c1">// 1. 如果很多的m都在偷取
</span><span class="c1">// 2. 本地g空, 全局也是空, 偷也没偷到...
</span><span class="c1"></span><span class="nx">stop</span><span class="p">:</span>
        <span class="o">...</span>

	<span class="nx">delta</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">pollUntil</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// checkTimers ensures that polluntil &gt; now.
</span><span class="c1"></span>		<span class="nx">delta</span> <span class="p">=</span> <span class="nx">pollUntil</span> <span class="o">-</span> <span class="nx">now</span>
	<span class="p">}</span>
        <span class="c1">// 返回一个nil g
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">,</span> <span class="nx">otherReady</span> <span class="o">:=</span> <span class="nf">beforeIdle</span><span class="p">(</span><span class="nx">delta</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="c1">// 修改为可运行
</span><span class="c1"></span>		<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
			<span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">otherReady</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="nx">top</span>
	<span class="p">}</span>
        <span class="c1">// 快照
</span><span class="c1"></span>	<span class="nx">allpSnapshot</span> <span class="o">:=</span> <span class="nx">allp</span>
	<span class="nx">idlepMaskSnapshot</span> <span class="o">:=</span> <span class="nx">idlepMask</span>
	<span class="nx">timerpMaskSnapshot</span> <span class="o">:=</span> <span class="nx">timerpMask</span>

	<span class="c1">// return P and block
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runSafePointFn</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">goto</span> <span class="nx">top</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">globrunqget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
	<span class="p">}</span>
        <span class="c1">// 解除绑定,g与p,m与p, 并且设置p为idle, 详细见后面
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">releasep</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">_p_</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;findrunnable: wrong p&#34;</span><span class="p">)</span>
	<span class="p">}</span>
        <span class="c1">// 放入空闲列表, 详细见后面
</span><span class="c1"></span>	<span class="nf">pidleput</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="c1">// m的自旋状态
</span><span class="c1"></span>	<span class="nx">wasSpinning</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">{</span>
                <span class="c1">// 改为 非自旋
</span><span class="c1"></span>		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">=</span> <span class="kc">false</span>
		<span class="k">if</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;findrunnable: negative nmspinning&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 再一次检查所有的p队列
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">_p_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allpSnapshot</span> <span class="p">{</span>
                <span class="c1">// 任何一个p队列不为空的话
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">idlepMaskSnapshot</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="nb">uint32</span><span class="p">(</span><span class="nx">id</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nf">runqempty</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="p">{</span>
			<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
                        <span class="c1">// 就从全局取一个p
</span><span class="c1"></span>			<span class="nx">_p_</span> <span class="p">=</span> <span class="nf">pidleget</span><span class="p">()</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">_p_</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                                <span class="c1">// p和m,g绑定起来
</span><span class="c1"></span>				<span class="nf">acquirep</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
				<span class="k">if</span> <span class="nx">wasSpinning</span> <span class="p">{</span>
					<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">=</span> <span class="kc">true</span>
					<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
				<span class="p">}</span>
                                <span class="c1">// 继续
</span><span class="c1"></span>				<span class="k">goto</span> <span class="nx">top</span>
			<span class="p">}</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>
        <span class="o">...</span>
        <span class="c1">// 实在没办法了, stop m , 详细见后面
</span><span class="c1"></span>	<span class="nf">stopm</span><span class="p">()</span>
	<span class="k">goto</span> <span class="nx">top</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>randomEnum</li>
</ul>
<pre><code>// 以上的这个for循环
for enum := stealOrder.start(fastrand()); !enum.done(); enum.next() {
}

type randomEnum struct {
	i     uint32
	count uint32
	pos   uint32
	inc   uint32
}
type randomOrder struct {
	count    uint32
	coprimes []uint32
}
// start函数
func (ord *randomOrder) start(i uint32) randomEnum {
	return randomEnum{
		count: ord.count,
		pos:   i % ord.count,         // pos是i对count的取余
		inc:   ord.coprimes[i%uint32(len(ord.coprimes))],
	}
}
func (enum *randomEnum) done() bool {
	return enum.i == enum.count
}
func (enum *randomEnum) next() {
     enum.i++
     enum.pos = (enum.pos + enum.inc) % enum.count
}
</code></pre><ul>
<li>runqsteal</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">runqsteal</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">p2</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">stealRunNextG</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
        <span class="c1">// 偷取者的队列尾, 执行到这里_p_队列有可能还是空, 但也有可能不是空了
</span><span class="c1"></span>	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span>
        <span class="c1">// 这里第一个参数是被偷者, 第二个是偷取者的队列地址, 第三个是偷取者的队尾, 第四个是否偷取下一个
</span><span class="c1"></span>	<span class="nx">n</span> <span class="o">:=</span> <span class="nf">runqgrab</span><span class="p">(</span><span class="nx">p2</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">,</span> <span class="nx">t</span><span class="p">,</span> <span class="nx">stealRunNextG</span><span class="p">)</span>
        <span class="c1">// runqgrab 返回0 , 说明p2队列是空的
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nx">n</span><span class="o">--</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">[(</span><span class="nx">t</span><span class="o">+</span><span class="nx">n</span><span class="p">)</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))].</span><span class="nf">ptr</span><span class="p">()</span>
        <span class="c1">// runqgrab 返回1
</span><span class="c1"></span>        <span class="c1">// 1. 可能是p2队列是空的, 但是next不空, 所以取到了一个
</span><span class="c1"></span>        <span class="c1">// 2. 可能是只一半刚好就是1
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">gp</span>
	<span class="p">}</span>
        <span class="c1">// 得到_p_.runqhead的值
</span><span class="c1"></span>	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadAcq</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">)</span> <span class="c1">// load-acquire, synchronize with consumers
</span><span class="c1"></span>        <span class="c1">// 不能偷的自己都放不下了
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">t</span><span class="o">-</span><span class="nx">h</span><span class="o">+</span><span class="nx">n</span> <span class="o">&gt;=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runqsteal: runq overflow&#34;</span><span class="p">)</span>
	<span class="p">}</span>
        <span class="c1">// 偷来了这么多, 更新一下自己的队列尾
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreRel</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span><span class="p">,</span> <span class="nx">t</span><span class="o">+</span><span class="nx">n</span><span class="p">)</span> <span class="c1">// store-release, makes the item available for consumption
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">gp</span>
<span class="p">}</span>

<span class="c1">// batch是一个ringbuffer, 你p本地队列肯定是不会超过256, batchHead就是偷取者的tail
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">runqgrab</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">batch</span> <span class="o">*</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="nx">guintptr</span><span class="p">,</span> <span class="nx">batchHead</span> <span class="kt">uint32</span><span class="p">,</span> <span class="nx">stealRunNextG</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">uint32</span> <span class="p">{</span>
        <span class="c1">// 这里的_p_ 是被偷者
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
                <span class="c1">// 被偷者p2的本地队列头
</span><span class="c1"></span>		<span class="nx">h</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadAcq</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">)</span> <span class="c1">// load-acquire, synchronize with other consumers
</span><span class="c1"></span>                <span class="c1">// 被偷者p2的本地队列尾
</span><span class="c1"></span>		<span class="nx">t</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadAcq</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span><span class="p">)</span> <span class="c1">// load-acquire, synchronize with the producer
</span><span class="c1"></span>		<span class="nx">n</span> <span class="o">:=</span> <span class="nx">t</span> <span class="o">-</span> <span class="nx">h</span>
		<span class="nx">n</span> <span class="p">=</span> <span class="nx">n</span> <span class="o">-</span> <span class="nx">n</span><span class="o">/</span><span class="mi">2</span>
                <span class="c1">// 被偷者也是个空的?
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                        <span class="c1">// 偷不偷下一个
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">stealRunNextG</span> <span class="p">{</span>
				<span class="c1">// 偷
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">next</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span><span class="p">;</span> <span class="nx">next</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
					<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span> <span class="o">==</span> <span class="nx">_Prunning</span> <span class="p">{</span>
                                                <span class="c1">// next的g如果正在执行的话, 那就给他们一点时间
</span><span class="c1"></span>						<span class="k">if</span> <span class="nx">GOOS</span> <span class="o">!=</span> <span class="s">&#34;windows&#34;</span> <span class="p">{</span>
                                                        <span class="c1">// 非windows, 给3us, channel 一次同步的的接收发送需要 50ns 左右
</span><span class="c1"></span>							<span class="nf">usleep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
						<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                                                        <span class="c1">// windows的给1us
</span><span class="c1"></span>							<span class="nf">osyield</span><span class="p">()</span>
						<span class="p">}</span>
					<span class="p">}</span>
					<span class="k">if</span> <span class="p">!</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span><span class="p">.</span><span class="nf">cas</span><span class="p">(</span><span class="nx">next</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
						<span class="k">continue</span>
					<span class="p">}</span>
                                        <span class="c1">// 把偷取者的队列的队尾 设置为p2的下一个
</span><span class="c1"></span>					<span class="nx">batch</span><span class="p">[</span><span class="nx">batchHead</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">batch</span><span class="p">))]</span> <span class="p">=</span> <span class="nx">next</span>
                                        <span class="c1">// 偷到了一个
</span><span class="c1"></span>					<span class="k">return</span> <span class="mi">1</span>
				<span class="p">}</span>
			<span class="p">}</span>
                        <span class="c1">// 返回0 , 说明啥也没偷到
</span><span class="c1"></span>			<span class="k">return</span> <span class="mi">0</span>
		<span class="p">}</span>
                <span class="c1">// 偷的数量不能超过 被偷者队列的一半, 毕竟是别人的东西不能太过分
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// read inconsistent h and t
</span><span class="c1"></span>			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
                        <span class="c1">// 从被偷者的队列中取出g
</span><span class="c1"></span>			<span class="nx">g</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">[(</span><span class="nx">h</span><span class="o">+</span><span class="nx">i</span><span class="p">)</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))]</span>
                        <span class="c1">// 设置到偷取者的队列中
</span><span class="c1"></span>			<span class="nx">batch</span><span class="p">[(</span><span class="nx">batchHead</span><span class="o">+</span><span class="nx">i</span><span class="p">)</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">batch</span><span class="p">))]</span> <span class="p">=</span> <span class="nx">g</span>
		<span class="p">}</span>
                <span class="c1">// 偷走了一半, 要更新一个被偷者的队列头指针
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CasRel</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">h</span><span class="o">+</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// cas-release, commits consume
</span><span class="c1"></span>                        <span class="c1">// 偷到了n个
</span><span class="c1"></span>			<span class="k">return</span> <span class="nx">n</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>releasep</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">releasep</span><span class="p">()</span> <span class="o">*</span><span class="nx">p</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;releasep: invalid arg&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">_p_</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span> <span class="o">||</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span> <span class="o">!=</span> <span class="nx">_Prunning</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;releasep: m=&#34;</span><span class="p">,</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">,</span> <span class="s">&#34; m-&gt;p=&#34;</span><span class="p">,</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="s">&#34; p-&gt;m=&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">),</span> <span class="s">&#34; p-&gt;status=&#34;</span><span class="p">,</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;releasep: invalid p state&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceProcStop</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
	<span class="p">}</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pidle</span>
	<span class="k">return</span> <span class="nx">_p_</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>pidleget</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">pidleget</span><span class="p">()</span> <span class="o">*</span><span class="nx">p</span> <span class="p">{</span>
	<span class="nf">assertLockHeld</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">_p_</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">pidle</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">_p_</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// Timer may get added at any time now.
</span><span class="c1"></span>		<span class="nx">timerpMask</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span>
		<span class="nx">idlepMask</span><span class="p">.</span><span class="nf">clear</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span>
                <span class="c1">// 全局的idle p链表改成 当前p的link, 也就是上一个
</span><span class="c1"></span>		<span class="nx">sched</span><span class="p">.</span><span class="nx">pidle</span> <span class="p">=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">link</span>
                <span class="c1">// 全局的idle p链表减一
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// TODO: fast atomic
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">_p_</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>stopm</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">stopm</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;stopm holding locks&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;stopm holding p&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;stopm spinning&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="c1">// m放到全局空闲队列
</span><span class="c1"></span>	<span class="nf">mput</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">)</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="c1">// 休眠
</span><span class="c1"></span>	<span class="nf">mPark</span><span class="p">()</span>
	<span class="nf">acquirep</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">nextp</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">nextp</span> <span class="p">=</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">mput</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">assertLockHeld</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">schedlink</span> <span class="p">=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">midle</span>
	<span class="nx">sched</span><span class="p">.</span><span class="nx">midle</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
	<span class="nx">sched</span><span class="p">.</span><span class="nx">nmidle</span><span class="o">++</span>
	<span class="nf">checkdead</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">mPark</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">g</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nf">notesleep</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">g</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">park</span><span class="p">)</span>
		<span class="nf">noteclear</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">g</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">park</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">!</span><span class="nf">mDoFixup</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>notesleep</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">notesleep</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">note</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;notesleep not on g0&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">semacreate</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Casuintptr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">n</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">)))</span> <span class="p">{</span>
		<span class="c1">// Must be locked (got wakeup).
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">key</span> <span class="o">!=</span> <span class="nx">locked</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;notesleep - waitm out of sync&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// Queued. Sleep.
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">blocked</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="k">if</span> <span class="o">*</span><span class="nx">cgo_yield</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="c1">// 休眠, mac和linux版本会不一样
</span><span class="c1"></span>                <span class="c1">// linux是futexsleep()
</span><span class="c1"></span>		<span class="nf">semasleep</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// Sleep for an arbitrary-but-moderate interval to poll libc interceptors.
</span><span class="c1"></span>		<span class="kd">const</span> <span class="nx">ns</span> <span class="p">=</span> <span class="mf">10e6</span>
		<span class="k">for</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Loaduintptr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">n</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">semasleep</span><span class="p">(</span><span class="nx">ns</span><span class="p">)</span>
			<span class="nf">asmcgocall</span><span class="p">(</span><span class="o">*</span><span class="nx">cgo_yield</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">blocked</span> <span class="p">=</span> <span class="kc">false</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>semasleep mac</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/os_darwin.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">semasleep</span><span class="p">(</span><span class="nx">ns</span> <span class="kt">int64</span><span class="p">)</span> <span class="kt">int32</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">start</span> <span class="kt">int64</span>
	<span class="k">if</span> <span class="nx">ns</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">start</span> <span class="p">=</span> <span class="nf">nanotime</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span>
	<span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">mutex</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">count</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">mp</span><span class="p">.</span><span class="nx">count</span><span class="o">--</span>
			<span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">mutex</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">ns</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">spent</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span> <span class="o">-</span> <span class="nx">start</span>
			<span class="k">if</span> <span class="nx">spent</span> <span class="o">&gt;=</span> <span class="nx">ns</span> <span class="p">{</span>
				<span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">mutex</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
			<span class="p">}</span>
			<span class="kd">var</span> <span class="nx">t</span> <span class="nx">timespec</span>
			<span class="nx">t</span><span class="p">.</span><span class="nf">setNsec</span><span class="p">(</span><span class="nx">ns</span> <span class="o">-</span> <span class="nx">spent</span><span class="p">)</span>
			<span class="nx">err</span> <span class="o">:=</span> <span class="nf">pthread_cond_timedwait_relative_np</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">mutex</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">t</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">_ETIMEDOUT</span> <span class="p">{</span>
				<span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">mutex</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nf">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">mutex</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>futexsleep linux</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/os_linux.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">futexsleep</span><span class="p">(</span><span class="nx">addr</span> <span class="o">*</span><span class="kt">uint32</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">uint32</span><span class="p">,</span> <span class="nx">ns</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">ns</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">futex</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">addr</span><span class="p">),</span> <span class="nx">_FUTEX_WAIT_PRIVATE</span><span class="p">,</span> <span class="nx">val</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">ts</span> <span class="nx">timespec</span>
	<span class="nx">ts</span><span class="p">.</span><span class="nf">setNsec</span><span class="p">(</span><span class="nx">ns</span><span class="p">)</span>
	<span class="nf">futex</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">addr</span><span class="p">),</span> <span class="nx">_FUTEX_WAIT_PRIVATE</span><span class="p">,</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ts</span><span class="p">),</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>execute 执行goroutine</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">execute</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 这个还是g0
</span><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
        <span class="c1">// 修改当前的g为gp
</span><span class="c1"></span>	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span> <span class="p">=</span> <span class="nx">gp</span>
        <span class="c1">// 把gp.m 设置为g0.m
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span>
        <span class="c1">// 设置gp为running
</span><span class="c1"></span>	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">waitsince</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="c1">// 抢占标识
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">=</span> <span class="kc">false</span>
        <span class="c1">// gp的堆
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
        <span class="c1">// inheritTime = false,说明是新的时间片
</span><span class="c1"></span>        <span class="c1">// 当为true的时候, 是说明gp是抢过来的nextG
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">inheritTime</span> <span class="p">{</span>
                <span class="c1">// 调度次数, 前面每61次调度 就会从全局取一次 用到了
</span><span class="c1"></span>		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">schedtick</span><span class="o">++</span>
	<span class="p">}</span>

	<span class="c1">// Check whether the profiler needs to be turned on or off.
</span><span class="c1"></span>	<span class="nx">hz</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">profilehz</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">profilehz</span> <span class="o">!=</span> <span class="nx">hz</span> <span class="p">{</span>
		<span class="nf">setThreadCPUProfiler</span><span class="p">(</span><span class="nx">hz</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="c1">// GoSysExit has to happen when we have a P, but before GoStart.
</span><span class="c1"></span>		<span class="c1">// So we emit it here.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">syscallsp</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">sysblocktraced</span> <span class="p">{</span>
			<span class="nf">traceGoSysExit</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sysexitticks</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nf">traceGoStart</span><span class="p">()</span>
	<span class="p">}</span>
        <span class="c1">// gogo才是从g0的栈空间切换到gp的堆的实现, 这里是plan9汇编代码调用寄存器实现的 , 详细见后面
</span><span class="c1"></span>	<span class="nf">gogo</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>gogo</li>
</ul>
<pre><code class="language-assembly" data-lang="assembly">TEXT runtime·gogo(SB), NOSPLIT, $16-8
        // BX = &amp;gp.sched
	MOVQ	buf+0(FP), BX
        // DX = gp.sched.g
	MOVQ	gobuf_g(BX), DX
        // 将 g 放入到 tls[0]
        // 把要运行的 g 的指针放入线程本地存储
        // 等到runtime·systemstack中, 我们就能通过tls获取到g 结构体对象，从而找到与之关联的 m 和 p
        // 运行这条指令之前，线程本地存储存放的是 g0 的地址
        // DX偏移0的地址, CX = gp.sched.g
	MOVQ	0(DX), CX		// make sure g != nil
        // 获取fs段基地址放入CX,其实就是m0.tls[1]的地址,CX的地址=m0.tls[1],
        // 就是为了找到fs段基地址, 这样偏移-8就能找到m0.tls[0]
	get_tls(CX)
        // 再将DX(gp.sched.g) 写入到CX偏移-8的位置, 也就是m0.tls[0]
	MOVQ	DX, g(CX)
        // 对gobuf的sp,ret,ctxt,bp字段保存到寄存器
	MOVQ	gobuf_sp(BX), SP
	MOVQ	gobuf_ret(BX), AX
	MOVQ	gobuf_ctxt(BX), DX
	MOVQ	gobuf_bp(BX), BP
        // 清理,上面已经保存了, 帮助gc
	MOVQ	$0, gobuf_sp(BX)
	MOVQ	$0, gobuf_ret(BX)
	MOVQ	$0, gobuf_ctxt(BX)
	MOVQ	$0, gobuf_bp(BX)
        // &amp;gp.sched的pc存入BX
	MOVQ	gobuf_pc(BX), BX
        // 跳到到BX地址开始执行
	JMP	BX

</code></pre><p>现在调度的流程如下图, 来自<img src="https://qcrao.com/ishare/go-scheduler" alt="https://qcrao.com">的图:</p>
<p><img src="/images/golang/gmp-3.png" alt=""></p>
<h3 id="终于到main了">终于到main()了<a href="#终于到main了" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/proc.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// gp了, 这个不是g0了,因为通过gogo已经切换了
</span><span class="c1"></span>	<span class="nx">g</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="c1">// Racectx of m0-&gt;g0 is used only as the parent of the main goroutine.
</span><span class="c1"></span>	<span class="c1">// It must not be used for anything else.
</span><span class="c1"></span>	<span class="nx">g</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span><span class="p">.</span><span class="nx">racectx</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="c1">// maxstacksize 设置
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="o">==</span> <span class="mi">8</span> <span class="p">{</span>
		<span class="nx">maxstacksize</span> <span class="p">=</span> <span class="mi">1000000000</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">maxstacksize</span> <span class="p">=</span> <span class="mi">250000000</span>
	<span class="p">}</span>

	<span class="nx">maxstackceiling</span> <span class="p">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">maxstacksize</span>

	<span class="c1">// Allow newproc to start new Ms.
</span><span class="c1"></span>	<span class="nx">mainStarted</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="k">if</span> <span class="nx">GOARCH</span> <span class="o">!=</span> <span class="s">&#34;wasm&#34;</span> <span class="p">{</span> <span class="c1">// no threads on wasm yet, so no sysmon
</span><span class="c1"></span>		<span class="c1">// For runtime_syscall_doAllThreadsSyscall, we
</span><span class="c1"></span>		<span class="c1">// register sysmon is not ready for the world to be
</span><span class="c1"></span>		<span class="c1">// stopped.
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonStarting</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="c1">// 通过g0来新建m
</span><span class="c1"></span>		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
                        <span class="c1">// sysmon监控线程 详细见后面
</span><span class="c1"></span>			<span class="nf">newm</span><span class="p">(</span><span class="nx">sysmon</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="p">})</span>
	<span class="p">}</span>


	<span class="nf">lockOSThread</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">g</span><span class="p">.</span><span class="nx">m</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="nx">m0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime.main not on m0&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">m0</span><span class="p">.</span><span class="nx">doesPark</span> <span class="p">=</span> <span class="kc">true</span>

	<span class="nx">runtimeInitTime</span> <span class="p">=</span> <span class="nf">nanotime</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">runtimeInitTime</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;nanotime returning zero&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">inittrace</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">inittrace</span><span class="p">.</span><span class="nx">id</span> <span class="p">=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">goid</span>
		<span class="nx">inittrace</span><span class="p">.</span><span class="nx">active</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>
        <span class="c1">// runtime包初始化, 详细见后面
</span><span class="c1"></span>	<span class="nf">doInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">runtime_inittask</span><span class="p">)</span> <span class="c1">// Must be before defer.
</span><span class="c1"></span>
	<span class="c1">// Defer unlock so that runtime.Goexit during init does the unlock too.
</span><span class="c1"></span>	<span class="nx">needUnlock</span> <span class="o">:=</span> <span class="kc">true</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">needUnlock</span> <span class="p">{</span>
			<span class="nf">unlockOSThread</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}()</span>
        <span class="c1">// 开启gc
</span><span class="c1"></span>	<span class="nf">gcenable</span><span class="p">()</span>

	<span class="nx">main_init_done</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">iscgo</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">_cgo_thread_start</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;_cgo_thread_start missing&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">GOOS</span> <span class="o">!=</span> <span class="s">&#34;windows&#34;</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">_cgo_setenv</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;_cgo_setenv missing&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">_cgo_unsetenv</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;_cgo_unsetenv missing&#34;</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">_cgo_notify_runtime_init_done</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;_cgo_notify_runtime_init_done missing&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// Start the template thread in case we enter Go from
</span><span class="c1"></span>		<span class="c1">// a C-created thread and need to create a new thread.
</span><span class="c1"></span>		<span class="nf">startTemplateThread</span><span class="p">()</span>
		<span class="nf">cgocall</span><span class="p">(</span><span class="nx">_cgo_notify_runtime_init_done</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="p">}</span>
        <span class="c1">// main包初始化,递归
</span><span class="c1"></span>	<span class="nf">doInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">main_inittask</span><span class="p">)</span>

	<span class="c1">// Disable init tracing after main init done to avoid overhead
</span><span class="c1"></span>	<span class="c1">// of collecting statistics in malloc and newproc
</span><span class="c1"></span>	<span class="nx">inittrace</span><span class="p">.</span><span class="nx">active</span> <span class="p">=</span> <span class="kc">false</span>

	<span class="nb">close</span><span class="p">(</span><span class="nx">main_init_done</span><span class="p">)</span>

	<span class="nx">needUnlock</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="nf">unlockOSThread</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">isarchive</span> <span class="o">||</span> <span class="nx">islibrary</span> <span class="p">{</span>
		<span class="c1">// A program compiled with -buildmode=c-archive or c-shared
</span><span class="c1"></span>		<span class="c1">// has a main, but it is not executed.
</span><span class="c1"></span>		<span class="k">return</span>
	<span class="p">}</span>
        <span class="c1">// go:linkname main_main main.main
</span><span class="c1"></span>        <span class="c1">// func main_main()
</span><span class="c1"></span>	<span class="nx">fn</span> <span class="o">:=</span> <span class="nx">main_main</span> <span class="c1">// make an indirect call, as the linker doesn&#39;t know the address of the main package when laying down the runtime
</span><span class="c1"></span>        <span class="c1">// 执行main.main, 就是我们写的代码了
</span><span class="c1"></span>        <span class="nf">fn</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nf">racefini</span><span class="p">()</span>
	<span class="p">}</span>
        <span class="c1">// 函数执行完之后
</span><span class="c1"></span>        <span class="c1">// 如果有defer
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">runningPanicDefers</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Running deferred functions should not take long.
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">c</span> <span class="p">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="nx">c</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">runningPanicDefers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
                        <span class="c1">// 继续调度
</span><span class="c1"></span>			<span class="nf">Gosched</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">panicking</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">gopark</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">waitReasonPanicWait</span><span class="p">,</span> <span class="nx">traceEvGoStop</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
        <span class="c1">// main的话直接退出
</span><span class="c1"></span>	<span class="nf">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1">// 这里肯定是执行不到的
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
                <span class="c1">// 如果执行到这里, 也会报nil错误
</span><span class="c1"></span>		<span class="kd">var</span> <span class="nx">x</span> <span class="o">*</span><span class="kt">int32</span>
		<span class="o">*</span><span class="nx">x</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>doInit</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">doInit</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">initTask</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="nx">t</span><span class="p">.</span><span class="nx">state</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">2</span><span class="p">:</span> <span class="c1">// fully initialized
</span><span class="c1"></span>		<span class="k">return</span>
	<span class="k">case</span> <span class="mi">1</span><span class="p">:</span> <span class="c1">// initialization in progress
</span><span class="c1"></span>		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;recursive call during initialization - linker skew&#34;</span><span class="p">)</span>
	<span class="k">default</span><span class="p">:</span> <span class="c1">// not initialized yet
</span><span class="c1"></span>		<span class="nx">t</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// initialization in progress
</span><span class="c1"></span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">t</span><span class="p">.</span><span class="nx">ndeps</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">p</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">t</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="nx">i</span><span class="p">)</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span>
			<span class="nx">t2</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="nx">initTask</span><span class="p">)(</span><span class="nx">p</span><span class="p">)</span>
			<span class="nf">doInit</span><span class="p">(</span><span class="nx">t2</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">nfns</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">t</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="mi">2</span> <span class="c1">// initialization done
</span><span class="c1"></span>			<span class="k">return</span>
		<span class="p">}</span>

		<span class="kd">var</span> <span class="p">(</span>
			<span class="nx">start</span>  <span class="kt">int64</span>
			<span class="nx">before</span> <span class="nx">tracestat</span>
		<span class="p">)</span>

		<span class="k">if</span> <span class="nx">inittrace</span><span class="p">.</span><span class="nx">active</span> <span class="p">{</span>
			<span class="nx">start</span> <span class="p">=</span> <span class="nf">nanotime</span><span class="p">()</span>
			<span class="c1">// Load stats non-atomically since tracinit is updated only by this init go routine.
</span><span class="c1"></span>			<span class="nx">before</span> <span class="p">=</span> <span class="nx">inittrace</span>
		<span class="p">}</span>

		<span class="nx">firstFunc</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">t</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="nx">t</span><span class="p">.</span><span class="nx">ndeps</span><span class="p">)</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">t</span><span class="p">.</span><span class="nx">nfns</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">p</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">firstFunc</span><span class="p">,</span> <span class="nx">i</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span>
			<span class="nx">f</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kd">func</span><span class="p">())(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">))</span>
			<span class="nf">f</span><span class="p">()</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">inittrace</span><span class="p">.</span><span class="nx">active</span> <span class="p">{</span>
			<span class="nx">end</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>
			<span class="c1">// Load stats non-atomically since tracinit is updated only by this init go routine.
</span><span class="c1"></span>			<span class="nx">after</span> <span class="o">:=</span> <span class="nx">inittrace</span>

			<span class="nx">pkg</span> <span class="o">:=</span> <span class="nf">funcpkgpath</span><span class="p">(</span><span class="nf">findfunc</span><span class="p">(</span><span class="nf">funcPC</span><span class="p">(</span><span class="nx">firstFunc</span><span class="p">)))</span>

			<span class="kd">var</span> <span class="nx">sbuf</span> <span class="p">[</span><span class="mi">24</span><span class="p">]</span><span class="kt">byte</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;init &#34;</span><span class="p">,</span> <span class="nx">pkg</span><span class="p">,</span> <span class="s">&#34; @&#34;</span><span class="p">)</span>
			<span class="nb">print</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nf">fmtNSAsMS</span><span class="p">(</span><span class="nx">sbuf</span><span class="p">[:],</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">start</span><span class="o">-</span><span class="nx">runtimeInitTime</span><span class="p">))),</span> <span class="s">&#34; ms, &#34;</span><span class="p">)</span>
			<span class="nb">print</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nf">fmtNSAsMS</span><span class="p">(</span><span class="nx">sbuf</span><span class="p">[:],</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">end</span><span class="o">-</span><span class="nx">start</span><span class="p">))),</span> <span class="s">&#34; ms clock, &#34;</span><span class="p">)</span>
			<span class="nb">print</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nf">itoa</span><span class="p">(</span><span class="nx">sbuf</span><span class="p">[:],</span> <span class="nx">after</span><span class="p">.</span><span class="nx">bytes</span><span class="o">-</span><span class="nx">before</span><span class="p">.</span><span class="nx">bytes</span><span class="p">)),</span> <span class="s">&#34; bytes, &#34;</span><span class="p">)</span>
			<span class="nb">print</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nf">itoa</span><span class="p">(</span><span class="nx">sbuf</span><span class="p">[:],</span> <span class="nx">after</span><span class="p">.</span><span class="nx">allocs</span><span class="o">-</span><span class="nx">before</span><span class="p">.</span><span class="nx">allocs</span><span class="p">)),</span> <span class="s">&#34; allocs&#34;</span><span class="p">)</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="nx">t</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="mi">2</span> <span class="c1">// initialization done
</span><span class="c1"></span>	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><blockquote>
<p>看到这里, 我们发现main.main执行完之后就 exit(0)退出了, 我们想起来之前设置了goexit() 来假装作为goroutine的调用者, 希望调用完返回后来执行goexit() 继续处理</p>
<p>显然这里并不是这样, main goroutine函数是应该执行完的退出, 在gogo函数中我们看到的确是JMP BX跳过去执行的, 并非CALL
如果是其他的goroutine会调用goexit() , 也就是执行 newg.sched.pc = funcPC(goexit) + sys.PCQuantum</p>
</blockquote>
<ul>
<li>runtime.goexit</li>
</ul>
<pre><code class="language-assembly" data-lang="assembly">// src/runtime/asm_amd64.s
TEXT runtime·goexit&lt;ABIInternal&gt;(SB),NOSPLIT,$0-0
	BYTE	$0x90	// NOP
	CALL	runtime·goexit1(SB)	// does not return
	// traceback from goexit1 must hit code range of goexit
	BYTE	$0x90	// NOP
</code></pre><ul>
<li>goexit1</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">goexit1</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nf">racegoend</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGoEnd</span><span class="p">()</span>
	<span class="p">}</span>
        <span class="c1">// 切换到g0然后执行goexit0 函数
</span><span class="c1"></span>	<span class="nf">mcall</span><span class="p">(</span><span class="nx">goexit0</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>mcall</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// runtime/asm_amd64.s
</span><span class="c1">// 切换到m-&gt;g0的栈上,调用fn(g)函数
</span><span class="c1"></span><span class="nx">TEXT</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">mcall</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">NOSPLIT</span><span class="p">,</span> <span class="err">$</span><span class="mi">0</span><span class="o">-</span><span class="mi">8</span>
	<span class="nx">MOVQ</span>	<span class="nx">fn</span><span class="o">+</span><span class="mi">0</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">DI</span>  <span class="c1">//FP是当前栈帧起始地址, fn(goexit0)函数指针存到DI寄存器
</span><span class="c1"></span>	<span class="nf">get_tls</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>    <span class="c1">//tls 是线程局部存储，将这个存储的开始位置存到 CX
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">),</span> <span class="nx">AX</span>	<span class="c1">// g(CX)还是宏，在tls上可以拿到g，也就是当前正在跑的g，把这个g的地址存到AX寄存器
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="mi">0</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">BX</span>	<span class="c1">// caller&#39;s PC
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nx">BX</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_pc</span><span class="p">)(</span><span class="nx">AX</span><span class="p">)</span>    <span class="c1">//把BX(caller&#39;s PC)存入到AX的g-&gt;sched的gobuf-&gt;pc字段
</span><span class="c1"></span>	<span class="nx">LEAQ</span>	<span class="nx">fn</span><span class="o">+</span><span class="mi">0</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">BX</span>	<span class="c1">// caller&#39;s SP, fn函数
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nx">BX</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_sp</span><span class="p">)(</span><span class="nx">AX</span><span class="p">)</span>    <span class="c1">//把BX(caller&#39;s SP)存入到AX的g-&gt;sched的gobuf-&gt;sp字段
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nx">AX</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_g</span><span class="p">)(</span><span class="nx">AX</span><span class="p">)</span>     <span class="c1">//把g本身也存起来
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nx">BP</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_bp</span><span class="p">)(</span><span class="nx">AX</span><span class="p">)</span>    <span class="c1">//把BP(当前栈底)存入到AX的g-&gt;sched的gobuf-&gt;bp字段
</span><span class="c1"></span>
	<span class="c1">// switch to m-&gt;g0 &amp; its stack, call fn
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">),</span> <span class="nx">BX</span>     <span class="c1">//把g存入BX
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nf">g_m</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">BX</span>   <span class="c1">//根据g得到m存入BX
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nf">m_g0</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">SI</span>  <span class="c1">//根据m得到g0存入SI
</span><span class="c1"></span>	<span class="nx">CMPQ</span>	<span class="nx">SI</span><span class="p">,</span> <span class="nx">AX</span>	<span class="c1">// if g == m-&gt;g0 call badmcall
</span><span class="c1"></span>	<span class="nx">JNE</span>	<span class="mi">3</span><span class="p">(</span><span class="nx">PC</span><span class="p">)</span>      <span class="c1">//JNE表示不等于的时候转移, if g != m-&gt;g0 , 那就跳3行
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="err">$</span><span class="nx">runtime</span><span class="err">·</span><span class="nf">badmcall</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>         
	<span class="nx">JMP</span>	<span class="nx">AX</span>
	<span class="nx">MOVQ</span>	<span class="nx">SI</span><span class="p">,</span> <span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>	<span class="c1">// g = m-&gt;g0, 直接把SI的m-&gt;g0 复制给g, 那现在的g就是m-&gt;g0, 成功切换到g0
</span><span class="c1"></span>	<span class="nf">MOVQ</span>	<span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_sp</span><span class="p">)(</span><span class="nx">SI</span><span class="p">),</span> <span class="nx">SP</span>	<span class="c1">// sp = m-&gt;g0-&gt;sched.sp, 直接拿g0中的sp值给SP寄存器了
</span><span class="c1"></span>	<span class="nx">PUSHQ</span>	<span class="nx">AX</span>        <span class="c1">//AX就是g,将g入栈保存
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nx">DI</span><span class="p">,</span> <span class="nx">DX</span>    <span class="c1">//DI里面保存的是fn函数, 现在存入到DX
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="mi">0</span><span class="p">(</span><span class="nx">DI</span><span class="p">),</span> <span class="nx">DI</span>
	<span class="nx">CALL</span>	<span class="nx">DI</span>        <span class="c1">//调用fn
</span><span class="c1"></span>	<span class="nx">POPQ</span>	<span class="nx">AX</span>        <span class="c1">//将g出栈
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="err">$</span><span class="nx">runtime</span><span class="err">·</span><span class="nf">badmcall2</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>
	<span class="nx">JMP</span>	<span class="nx">AX</span>
	<span class="nx">RET</span>    <span class="c1">//return
</span></code></pre></div><ul>
<li>goexit0</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">goexit0</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// g0
</span><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
        <span class="c1">// gp切换到dead状态
</span><span class="c1"></span>	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gdead</span><span class="p">)</span>
	<span class="k">if</span> <span class="nf">isSystemGoroutine</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ngsys</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
        <span class="c1">// 清理数据
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">locked</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">lockedm</span> <span class="o">!=</span> <span class="mi">0</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">lockedm</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedg</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">preemptStop</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">paniconfault</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span> <span class="p">=</span> <span class="kc">nil</span> <span class="c1">// should be true already but just in case.
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span> <span class="p">=</span> <span class="kc">nil</span> <span class="c1">// non-nil for Goexit during panic. points at stack-allocated data.
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">writebuf</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">waitreason</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">labels</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">timer</span> <span class="p">=</span> <span class="kc">nil</span>

	<span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Flush assist credit to the global pool. This gives
</span><span class="c1"></span>		<span class="c1">// better information to pacing if the application is
</span><span class="c1"></span>		<span class="c1">// rapidly creating an exiting goroutines.
</span><span class="c1"></span>		<span class="nx">assistWorkPerByte</span> <span class="o">:=</span> <span class="nf">float64frombits</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">assistWorkPerByte</span><span class="p">))</span>
		<span class="nx">scanCredit</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">assistWorkPerByte</span> <span class="o">*</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span><span class="p">))</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">bgScanCredit</span><span class="p">,</span> <span class="nx">scanCredit</span><span class="p">)</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
        <span class="c1">// 解绑g和m,清理curg
</span><span class="c1"></span>	<span class="nf">dropg</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">GOARCH</span> <span class="o">==</span> <span class="s">&#34;wasm&#34;</span> <span class="p">{</span> <span class="c1">// no threads yet on wasm
</span><span class="c1"></span>		<span class="nf">gfput</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="nx">gp</span><span class="p">)</span>
		<span class="nf">schedule</span><span class="p">()</span> <span class="c1">// never returns
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedInt</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;invalid m-&gt;lockedInt = &#34;</span><span class="p">,</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedInt</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;internal lockOSThread error&#34;</span><span class="p">)</span>
	<span class="p">}</span>
        <span class="c1">// gp放到gfree list中,详细见后面
</span><span class="c1"></span>	<span class="nf">gfput</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="nx">gp</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">locked</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">GOOS</span> <span class="o">!=</span> <span class="s">&#34;plan9&#34;</span> <span class="p">{</span> <span class="c1">// See golang.org/issue/22227.
</span><span class="c1"></span>			<span class="nf">gogo</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span><span class="p">.</span><span class="nx">sched</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedExt</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">schedule</span><span class="p">()</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>gfput</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gfput</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// gfree里面放的都是dead
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">_Gdead</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gfput: bad status (not Gdead)&#34;</span><span class="p">)</span>
	<span class="p">}</span>
        <span class="c1">// 堆大小
</span><span class="c1"></span>	<span class="nx">stksize</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="o">-</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span>
        <span class="c1">// _FixedStack 通常就是2048, 可能和系统相关
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">stksize</span> <span class="o">!=</span> <span class="nx">_FixedStack</span> <span class="p">{</span>
		<span class="c1">// 这种不是2k的goroutine就释放了
</span><span class="c1"></span>		<span class="nf">stackfree</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">)</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
        <span class="c1">// 否则, 2k大小的g 堆是保留的, 放入到gfree队列中
</span><span class="c1"></span>	<span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
	<span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span><span class="o">++</span>
        <span class="c1">// 如果本地p的gfree长度超过64
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span> <span class="o">&gt;=</span> <span class="mi">64</span> <span class="p">{</span>
                <span class="c1">// 那么就加锁, 塞给全局gfree
</span><span class="c1"></span>		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
                <span class="c1">// 只保留31个
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span> <span class="o">&gt;=</span> <span class="mi">32</span> <span class="p">{</span>
			<span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span><span class="o">--</span>
			<span class="nx">gp</span> <span class="p">=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">noStack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><p>实际上还有一个sysmon进程, 这个进程会后台一直执行, 通过newm直接创建, 并不需要g和p的协作</p>
<p>&hellip;</p>
<h3 id="附录">附录<a href="#附录" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<ul>
<li><a href="https://qcrao.com/ishare/go-scheduler/#true%E8%B0%83%E5%BA%A6%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%BB%BA%E7%AB%8B">qcrao分享 go调度详细源码分析</a></li>
<li><a href="http://mp.weixin.qq.com/mp/homepage?__biz=MzU1OTg5NDkzOA==&amp;hid=1&amp;sn=8fc2b63f53559bc0cee292ce629c4788&amp;scene=18#wechat_redirect">go语言调度器源代码情景分析</a></li>
<li><a href="https://eddycjy.com/posts/go/go-bootstrap0/">详解 Go 程序的启动流程，你知道 g0，m0 是什么吗？</a></li>
<li><a href="https://golang.design/under-the-hood/zh-cn/part2runtime/ch06sched/schedule/">go语言原本 调度</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/344842279">g0</a></li>
<li><a href="https://talkgo.org/t/topic/31">golang 中 goroutine 的调度</a></li>
<li>rancher_rancher_net</li>
</ul>

			</div>
   

			<hr class="post-end">
			<footer class="post-info">
				<p>
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="https://www.ngirl.xyz/tags/golang">golang</a></span>
				</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>6289 Words</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2021-11-17 09:31 &#43;0800</p>
			</footer>
		</article>
		<aside id="toc" class="show-toc">
			<div class="toc-title">→Go学习 Gmp模型←</div>
			<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#gmp模型">GMP模型</a></li>
        <li><a href="#go函数真正的入口">go函数真正的入口</a></li>
        <li><a href="#schedinit-运行时初始化">schedinit 运行时初始化</a></li>
        <li><a href="#创建g-newproc">创建g newproc</a></li>
        <li><a href="#开始调度-mstart">开始调度 mstart()</a></li>
        <li><a href="#终于到main了">终于到main()了</a></li>
        <li><a href="#附录">附录</a></li>
      </ul>
    </li>
  </ul>
</nav>
		</aside>
		<div class="post-nav thin">
			<a class="next-post" href="https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-map%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">
				<span class="post-nav-label"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>&nbsp;Newer</span><br><span>Go学习 Map源码分析</span>
			</a>
			<a class="prev-post" href="https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-go%E6%B1%87%E7%BC%96plan9/">
				<span class="post-nav-label">Older&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><br><span>Go学习 Go汇编plan9</span>
			</a>
		</div>
		<div id="comments" class="thin">
						<script src="https://utteranc.es/client.js"
							repo="zhangzw001/blog-hugo"
							issue-term="pathname"
							theme="github-light"
							crossorigin="anonymous"
							async>
			</script>

		</div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2019 - 2022 <a href="https://www.ngirl.xyz">zhangzw</a> &#183; <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://www.ngirl.xyz/post/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>


	<script src="https://www.ngirl.xyz/js/main.min.784417f5847151f848c339cf0acb13a06cbb648b1483435a28ed4556c4ead69b.js"></script>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-180942795-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


</body>

</html>
