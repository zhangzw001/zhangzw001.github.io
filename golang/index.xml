<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Golangs on zhangzw</title>
		<link>https://www.ngirl.xyz/golang/</link>
		<description>Recent content in Golangs on zhangzw</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>zh-hans</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Mon, 22 Nov 2021 13:59:53 +0800</lastBuildDate>
		<atom:link href="https://www.ngirl.xyz/golang/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Go学习 Map源码分析</title>
			<link>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-map%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
			<pubDate>Mon, 22 Nov 2021 13:59:53 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-map%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
			<description>在看map之前,我们从一个简单的代码开始 1 package main 2 func main() { 3	a := make(map[int]int,209) 4	a[1] = 1 5	print(a[1]) 6 }  以上代码我们看下编译的map相关调用  go tool compile -S map源码分析.go|egrep &amp;quot;map源码分析.*CALL.*map&amp;quot; 0x0051 00081 (map源码分析.go:3)	CALL	runtime.makemap(SB)	// 显然第3行是初始化 0x0079 00121 (map源码分析.go:4)	CALL	runtime.mapassign_fast64(SB) //第4行是写入 0x00a8 00168 (map源码分析.go:5)	CALL	runtime.mapaccess1_fast64(SB) //第5行是读取 首先看下相关结构体hmap type hmap struct { // Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go. 	// Make sure this stays in sync with the compiler&amp;#39;s definition.</description>
			<content type="html"><![CDATA[<h3 id="在看map之前我们从一个简单的代码开始">在看map之前,我们从一个简单的代码开始</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="mi">1</span> <span class="kn">package</span> <span class="nx">main</span>
<span class="mi">2</span> <span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="mi">3</span>	<span class="nx">a</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span><span class="mi">209</span><span class="p">)</span>
<span class="mi">4</span>	<span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
<span class="mi">5</span>	<span class="nb">print</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="mi">6</span> <span class="p">}</span>
</code></pre></div><ul>
<li>以上代码我们看下编译的map相关调用</li>
</ul>
<pre><code>go tool compile -S map源码分析.go|egrep &quot;map源码分析.*CALL.*map&quot;
	0x0051 00081 (map源码分析.go:3)	CALL	runtime.makemap(SB)	   // 显然第3行是初始化
	0x0079 00121 (map源码分析.go:4)	CALL	runtime.mapassign_fast64(SB)  //第4行是写入
	0x00a8 00168 (map源码分析.go:5)	CALL	runtime.mapaccess1_fast64(SB) //第5行是读取
</code></pre><h3 id="首先看下相关结构体hmap">首先看下相关结构体hmap</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">hmap</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.
</span><span class="c1"></span>	<span class="c1">// Make sure this stays in sync with the compiler&#39;s definition.
</span><span class="c1"></span>	<span class="nx">count</span>      <span class="kt">int</span>            <span class="c1">// # 已经在使用的键值对总数, len(map)的值
</span><span class="c1"></span>	<span class="nx">flags</span>      <span class="kt">uint8</span>          <span class="c1">// 标志位
</span><span class="c1"></span>	<span class="nx">B</span>          <span class="kt">uint8</span>          <span class="c1">// 装载因子, 2^B = 桶的大小
</span><span class="c1"></span>	<span class="nx">noverflow</span>  <span class="kt">uint16</span>         <span class="c1">// overflow 的 bucket 近似数
</span><span class="c1"></span>	<span class="nx">hash0</span>      <span class="kt">uint32</span>         <span class="c1">// 哈希因子
</span><span class="c1"></span>	<span class="nx">buckets</span>    <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 桶的大小 , may be nil if count==0.
</span><span class="c1"></span>	<span class="nx">oldbuckets</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 通常是nil, 如果在扩容,就是旧的桶
</span><span class="c1"></span>	<span class="nx">nevacuate</span>  <span class="kt">uintptr</span>        <span class="c1">// 指示扩容进度，小于此地址的 buckets 迁移完成
</span><span class="c1"></span>	<span class="nx">extra</span>      <span class="o">*</span><span class="nx">mapextra</span>      <span class="c1">// 存储溢出桶
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">mapextra</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">overflow</span>     <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span>
	<span class="nx">oldoverflow</span>  <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span>
	<span class="nx">nextOverflow</span> <span class="o">*</span><span class="nx">bmap</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">bmap</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">tophash</span> <span class="p">[</span><span class="nx">bucketCnt</span><span class="p">]</span><span class="kt">uint8</span> <span class="c1">//生成的hash值的高8位
</span><span class="c1"></span>	<span class="c1">//在src/cmd/compile/internal/gc/reflect.go里面bmap函数会添加该字段,以及后续几个字段
</span><span class="c1"></span>	<span class="c1">//keys Type		  // key类型
</span><span class="c1"></span>	<span class="c1">//elems Type	          // value类型
</span><span class="c1"></span>	<span class="c1">//overflow unsafe.Pointer // 解决冲突的链表指针
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h3 id="runtimemakemap-代码">runtime.makemap 代码</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/map.go
</span><span class="c1">// 以上示例 hint=209
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">makemap</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">hint</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">)</span> <span class="o">*</span><span class="nx">hmap</span> <span class="p">{</span>
	<span class="c1">// 判断 hint * size 是否溢出
</span><span class="c1"></span>	<span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">hint</span><span class="p">),</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">mem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span> <span class="p">{</span>
		<span class="nx">hint</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="c1">// 初始化Hmap
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">h</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">hmap</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 生成哈希因子
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span> <span class="p">=</span> <span class="nf">fastrand</span><span class="p">()</span>

	<span class="nx">B</span> <span class="o">:=</span> <span class="nb">uint8</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="c1">// 找到一个 B，使得 map 的装载因子在正常范围内
</span><span class="c1"></span>	<span class="c1">// 这里hint=209,因此B=5
</span><span class="c1"></span>	<span class="k">for</span> <span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">hint</span><span class="p">,</span> <span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">B</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="p">=</span> <span class="nx">B</span>
	<span class="c1">// 如果hint&gt;8,那么h.B就一定不等于0了
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">nextOverflow</span> <span class="o">*</span><span class="nx">bmap</span>
		<span class="c1">// 这里显然就是生成桶了
</span><span class="c1"></span>		<span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">nextOverflow</span> <span class="p">=</span> <span class="nf">makeBucketArray</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="c1">// 如果需要生成extra桶
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">nextOverflow</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">mapextra</span><span class="p">)</span>
			<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">nextOverflow</span> <span class="p">=</span> <span class="nx">nextOverflow</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">h</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>overLoadFactor</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">count</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">B</span> <span class="kt">uint8</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// bucketCnt = 8
</span><span class="c1"></span>	<span class="c1">// loadFactorNum = 13
</span><span class="c1"></span>	<span class="c1">// loadFactorDen = 2
</span><span class="c1"></span>	<span class="c1">// 如果 B = 0
</span><span class="c1"></span>	<span class="c1">// count &gt; 8 &amp;&amp; count &gt; 13 * (1 &lt;&lt; ( 0 &amp; 63)) / 2
</span><span class="c1"></span>	<span class="c1">// B = 0 :  count &gt; 8 &amp;&amp; count &gt; 6.5
</span><span class="c1"></span>	<span class="c1">// B = 1 :  count &gt; 8 &amp;&amp; count &gt; 13
</span><span class="c1"></span>	<span class="c1">// B = 2 :  count &gt; 8 &amp;&amp; count &gt; 26
</span><span class="c1"></span>	<span class="c1">// B = 3 :  count &gt; 8 &amp;&amp; count &gt; 52
</span><span class="c1"></span>	<span class="c1">// B = 4 :  count &gt; 8 &amp;&amp; count &gt; 104
</span><span class="c1"></span>	<span class="c1">// B = 5 :  count &gt; 8 &amp;&amp; count &gt; 208
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">count</span> <span class="p">&gt;</span> <span class="nx">bucketCnt</span> <span class="o">&amp;&amp;</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">loadFactorNum</span><span class="o">*</span><span class="p">(</span><span class="nf">bucketShift</span><span class="p">(</span><span class="nx">B</span><span class="p">)</span><span class="o">/</span><span class="nx">loadFactorDen</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">bucketShift</span><span class="p">(</span><span class="nx">b</span> <span class="kt">uint8</span><span class="p">)</span> <span class="kt">uintptr</span> <span class="p">{</span>
	<span class="c1">// const PtrSize = 4 &lt;&lt; (^uintptr(0) &gt;&gt; 63)
</span><span class="c1"></span>	<span class="c1">// 这里对0取反 == math.MaxUint64, 然后向右位移63那么结果就是1,所以PtrSize = 8
</span><span class="c1"></span>	<span class="c1">// 1 &lt;&lt; ( b &amp; 8*8-1)
</span><span class="c1"></span>	<span class="c1">// 也就是b对一个8位的全是1的与运算, 就是取低八位
</span><span class="c1"></span>	<span class="k">return</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nx">b</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="o">*</span><span class="mi">8</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>makeBucketArray</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">makeBucketArray</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">uint8</span><span class="p">,</span> <span class="nx">dirtyalloc</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">(</span><span class="nx">buckets</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">nextOverflow</span> <span class="o">*</span><span class="nx">bmap</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 假设b=5, base = 1 &lt;&lt; 5 = 32
</span><span class="c1"></span>	<span class="nx">base</span> <span class="o">:=</span> <span class="nf">bucketShift</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
	<span class="nx">nbuckets</span> <span class="o">:=</span> <span class="nx">base</span>
	<span class="k">if</span> <span class="nx">b</span> <span class="o">&gt;=</span> <span class="mi">4</span> <span class="p">{</span>
		<span class="c1">// nbuckets = 32+2
</span><span class="c1"></span>		<span class="nx">nbuckets</span> <span class="o">+=</span> <span class="nf">bucketShift</span><span class="p">(</span><span class="nx">b</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span>
		<span class="nx">sz</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">size</span> <span class="o">*</span> <span class="nx">nbuckets</span>
		<span class="nx">up</span> <span class="o">:=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nx">sz</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">up</span> <span class="o">!=</span> <span class="nx">sz</span> <span class="p">{</span>
			<span class="nx">nbuckets</span> <span class="p">=</span> <span class="nx">up</span> <span class="o">/</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">size</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">dirtyalloc</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">buckets</span> <span class="p">=</span> <span class="nf">newarray</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">nbuckets</span><span class="p">))</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">buckets</span> <span class="p">=</span> <span class="nx">dirtyalloc</span>
		<span class="nx">size</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">size</span> <span class="o">*</span> <span class="nx">nbuckets</span>
		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">memclrHasPointers</span><span class="p">(</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">base</span> <span class="o">!=</span> <span class="nx">nbuckets</span> <span class="p">{</span>
		<span class="nx">nextOverflow</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">base</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
		<span class="nx">last</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">buckets</span><span class="p">,</span> <span class="p">(</span><span class="nx">nbuckets</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
		<span class="nx">last</span><span class="p">.</span><span class="nf">setoverflow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nx">buckets</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">buckets</span><span class="p">,</span> <span class="nx">nextOverflow</span>
<span class="p">}</span>

</code></pre></div><h3 id="runtimemapassign-map写入">runtime.mapassign map写入</h3>
<blockquote>
<p>runtime.mapassign_fast64 或runtime.mapassign_fast32类似runtime.mapassign, 我们这里直接看mapassign</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mapassign</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">h</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;assignment to entry in nil map&#34;</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="o">...</span>
	<span class="c1">// 这里说明map并发不安全
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">hashWriting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;concurrent map writes&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 根据key 和哈希因子生成哈希
</span><span class="c1"></span>	<span class="nx">hash</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span><span class="p">))</span>
	<span class="c1">// 异或之后下次两个肯定不同了, 就会 throw(&#34;concurrent map writes&#34;)
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="p">^=</span> <span class="nx">hashWriting</span>

	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span> <span class="p">=</span> <span class="nf">newobject</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">)</span> <span class="c1">// newarray(t.bucket, 1)
</span><span class="c1"></span>	<span class="p">}</span>
<span class="c1">// 核心代码
</span><span class="c1"></span><span class="nx">again</span><span class="p">:</span>
	<span class="c1">// bucketMask(h.B) = 2^h.B -1
</span><span class="c1"></span>	<span class="c1">// bucket就是得到hash值的 低B位, 就是要放到哪个桶的索引
</span><span class="c1"></span>	<span class="nx">bucket</span> <span class="o">:=</span> <span class="nx">hash</span> <span class="o">&amp;</span> <span class="nf">bucketMask</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span>
	<span class="c1">// 是否扩容
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nf">growing</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// 迁移数据
</span><span class="c1"></span>		<span class="nf">growWork</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">bucket</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// h.buckets 是桶的初始地址
</span><span class="c1"></span>	<span class="c1">// add就可以找到需要放入的桶的 地址
</span><span class="c1"></span>	<span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">bucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
	<span class="c1">// 根据hash得到高8位
</span><span class="c1"></span>	<span class="nx">top</span> <span class="o">:=</span> <span class="nf">tophash</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">inserti</span> <span class="o">*</span><span class="kt">uint8</span>
	<span class="kd">var</span> <span class="nx">insertk</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
	<span class="kd">var</span> <span class="nx">elem</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="nx">bucketloop</span><span class="p">:</span>
	<span class="c1">// 这里两层循环
</span><span class="c1"></span>	<span class="c1">// 外层是对 overflow的溢出链表进行循环
</span><span class="c1"></span>	<span class="c1">// 内层是对 当个bmap的bucketCnt个数组进行循环
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
		<span class="c1">// 内层
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="c1">// 先比较看tophash是否相同
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">top</span> <span class="p">{</span> <span class="c1">// 不相同
</span><span class="c1"></span>				<span class="c1">// tophash为空的
</span><span class="c1"></span>				<span class="k">if</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="nx">inserti</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="c1">// 保留该桶的槽点地址,后续如果没有找到key,是需要写入到该地址的
</span><span class="c1"></span>					<span class="nx">inserti</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
					<span class="c1">// 根据bmap结构体结构 计算出key的地址
</span><span class="c1"></span>					<span class="nx">insertk</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
					<span class="c1">// 根据bmap结构体结构 计算出value的地址, 多一个bucketCnt*uintptr(t.keysize)的偏移量
</span><span class="c1"></span>					<span class="nx">elem</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">emptyRest</span> <span class="p">{</span>
					<span class="k">break</span> <span class="nx">bucketloop</span>
				<span class="p">}</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="c1">// 如果tophash相同
</span><span class="c1"></span>			<span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">k</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="c1">// 如果不是我们需要找的key,就继续内层循环
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">!</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="c1">// 走到这里说明,找到了我们要的key, 你们就要更新它
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">needkeyupdate</span><span class="p">()</span> <span class="p">{</span>
				<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="c1">// 得到elem的地址
</span><span class="c1"></span>			<span class="nx">elem</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
			<span class="c1">// 找到了就可以去done了, 不需要继续循环
</span><span class="c1"></span>			<span class="k">goto</span> <span class="nx">done</span>
		<span class="p">}</span>
		<span class="c1">// 链表下一个节点
</span><span class="c1"></span>		<span class="nx">ovf</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
		<span class="c1">// 已经是链表的尾巴
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">ovf</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="c1">// 递归
</span><span class="c1"></span>		<span class="nx">b</span> <span class="p">=</span> <span class="nx">ovf</span>
	<span class="p">}</span>

	<span class="c1">// 走到这里说明 没有找到我们要找的key
</span><span class="c1"></span>
	<span class="c1">// 做一次扩容判断, 两个条件会扩容
</span><span class="c1"></span>	<span class="c1">// 1. h.count+1 &gt; 8 &amp;&amp; h.count+1 &gt; 6.5 * 2^h.B ,这种情况说明桶快要满了, 因为满的情况就是h.count = 8 * 2^h.B
</span><span class="c1"></span>	<span class="c1">// 2. h.noverflow &gt;= 2 ^ h.B (B超过15会被赋值为15) , 这种情况说明溢出链表过长, 性能很差
</span><span class="c1"></span>	<span class="c1">// 以上情况如果满足, 并且当前没有正在扩容
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">growing</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">count</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="o">||</span> <span class="nf">tooManyOverflowBuckets</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">noverflow</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">))</span> <span class="p">{</span>
		<span class="c1">// 开始扩容, 详细见下方
</span><span class="c1"></span>		<span class="nf">hashGrow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">)</span>
		<span class="k">goto</span> <span class="nx">again</span> <span class="c1">// Growing the table invalidates everything, so try again
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="c1">// 如果前面没有找到空槽位, 那么就需要添加链表了, 因为前面break的时候 b.overflow(t) == nil了, 已经找到尾巴了
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">inserti</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 新建一个bmap
</span><span class="c1"></span>		<span class="nx">newb</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">newoverflow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
		<span class="c1">// 插入第一个槽点, index=0
</span><span class="c1"></span>		<span class="nx">inserti</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">newb</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="c1">// 找到插入的key的地址
</span><span class="c1"></span>		<span class="nx">insertk</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">newb</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="p">)</span>
		<span class="c1">// 根据key的地址继续偏移 找到value的地址
</span><span class="c1"></span>		<span class="nx">elem</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">insertk</span><span class="p">,</span> <span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="c1">// key是指针的话需要取值
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">kmem</span> <span class="o">:=</span> <span class="nf">newobject</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span>
		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">insertk</span><span class="p">)</span> <span class="p">=</span> <span class="nx">kmem</span>
		<span class="nx">insertk</span> <span class="p">=</span> <span class="nx">kmem</span>
	<span class="p">}</span>
	<span class="c1">// value是指针的话需要取值
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectelem</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">vmem</span> <span class="o">:=</span> <span class="nf">newobject</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elem</span><span class="p">)</span>
		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">elem</span><span class="p">)</span> <span class="p">=</span> <span class="nx">vmem</span>
	<span class="p">}</span>
	<span class="c1">// key写到insertk的位置
</span><span class="c1"></span>	<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">insertk</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
	<span class="o">*</span><span class="nx">inserti</span> <span class="p">=</span> <span class="nx">top</span>
	<span class="c1">// count++
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">count</span><span class="o">++</span>

<span class="nx">done</span><span class="p">:</span>
	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">hashWriting</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;concurrent map writes&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;^=</span> <span class="nx">hashWriting</span>
	<span class="c1">// 如果elem是指针,就做一次取值
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectelem</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">elem</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">elem</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">elem</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>tophash</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">tophash</span><span class="p">(</span><span class="nx">hash</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">uint8</span> <span class="p">{</span>
	<span class="c1">// 把hash结果向右移动 8*8-8位, 也就是只保留高8位
</span><span class="c1"></span>	<span class="nx">top</span> <span class="o">:=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">hash</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="o">*</span><span class="mi">8</span> <span class="o">-</span> <span class="mi">8</span><span class="p">))</span>
	<span class="c1">// minTopHash = 5
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">top</span> <span class="p">&lt;</span> <span class="nx">minTopHash</span> <span class="p">{</span>
		<span class="nx">top</span> <span class="o">+=</span> <span class="nx">minTopHash</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">top</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>tooManyOverflowBuckets</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">tooManyOverflowBuckets</span><span class="p">(</span><span class="nx">noverflow</span> <span class="kt">uint16</span><span class="p">,</span> <span class="nx">B</span> <span class="kt">uint8</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">B</span> <span class="p">&gt;</span> <span class="mi">15</span> <span class="p">{</span>
		<span class="nx">B</span> <span class="p">=</span> <span class="mi">15</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">noverflow</span> <span class="o">&gt;=</span> <span class="nb">uint16</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="nx">B</span><span class="o">&amp;</span><span class="mi">15</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h4 id="hashgrow-扩容">hashGrow 扩容</h4>
<p><img src="/images/golang/map-1.png" alt=""></p>
<ul>
<li>首先做一个简单的说明</li>
</ul>
<pre><code>扩容的两个条件已经说过了,
第一个条件是因为桶都快要满了, 我们知道一个bmap中的kv最多可以是8个, 剩下的通过overflow链表保存, 装载因子达到6.5说明已经很满了,8的话就是已经满了
这种情况是翻倍扩容, 我们直接对h.B +1 即可, buckets长度会翻倍, 由 2^B -&gt; 2^(B+1)

第二个条件是对第一点的补充, 当我们插入很多的kv,然后又删除了很多的kv,可能会出现很长的overflow链表, 但是有很多的桶的槽点是空的, 这种情况我们h.count是不大的,导致我们的装载因子不一定会大于6.5,无法触发第一条扩容, 所以我们需要通过另一个统计数 h.noveflow , 就是overflow的大小的近似值, 如果 h.noverflow &gt;= 2 ^ h.B, 我们认为链表过长, 性能很差, 需要扩容
这种情况是等量扩容, 我们生成一个新的buckets数组, 将结果copy过去即可

当出现另外一种极端情况时, 以上扩容都将无效:
如果插入了大量的哈希值相同的key,他们因为哈希值相同都会落入同一个bucket中, 因此当超过8就会使用到overflow
这种情况就由 哈希表 变是一个单链表...

废话不多说... 我们先了解下如何翻倍扩容
首先我们知道,假如B=5,那么我们的buckets数组的索引就是[0~31]
我们先取得hash值,然后与2^B-1(31) 做与运算, 得到低B(5)位, 然后就找到了要放入的桶了
那扩容的时候由于B++变成了6, 因此hash值需要与2^6-1(63)做与运算, 得到低6位
例如hash值低8位是 00100011
1. 当B=5时, 它是落入到索引为3的桶
2. 当B=6时, 它是落入到索引为35(32+2+1)的桶
因此我们知道扩容是需要对原本的桶数据进行数据迁移的

接下来我们继续看看扩容的代码

</code></pre><blockquote>
<p>先看看hashGrow() 做了哪些准备工作, 然后在看看growWork() 如果搬迁数据</p>
</blockquote>
<ul>
<li>hashGrow 仅分配好新的buckets</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">hashGrow</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">bigger</span> <span class="o">:=</span> <span class="nb">uint8</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="c1">// 如果不是因为 大于哈希因子 6.5*2^h.B的原因
</span><span class="c1"></span>	<span class="c1">// 那就是 太多的溢出桶
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">count</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// 这里就是等量扩容
</span><span class="c1"></span>		<span class="nx">bigger</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="c1">// sameSizeGrow = 8 (1000), 或运算会把该位置为1
</span><span class="c1"></span>		<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="o">|=</span> <span class="nx">sameSizeGrow</span>
	<span class="p">}</span>
	<span class="c1">// 赋值旧的buckets
</span><span class="c1"></span>	<span class="nx">oldbuckets</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span>
	<span class="c1">// 创建新的bucket,并且设置h.B+1
</span><span class="c1"></span>	<span class="nx">newbuckets</span><span class="p">,</span> <span class="nx">nextOverflow</span> <span class="o">:=</span> <span class="nf">makeBucketArray</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="o">+</span><span class="nx">bigger</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="c1">// &amp;^ 按位置0运算, 先进行异或,然后与运算
</span><span class="c1"></span>	<span class="c1">// 右侧数的二进制位为1,
</span><span class="c1"></span>	<span class="c1">// 1. 左侧如果是0,那么异或是1,与之后是0
</span><span class="c1"></span>	<span class="c1">// 2. 左侧如果是1,那么异或是0,与之后也是0
</span><span class="c1"></span>	<span class="c1">// 右侧数的二进制位为0,
</span><span class="c1"></span>	<span class="c1">// 1. 左侧如果是0,那么异或是0,与之后是0
</span><span class="c1"></span>	<span class="c1">// 2. 左侧如果是1,那么异或是1,与之后也是1
</span><span class="c1"></span>	<span class="c1">// 所以只有左侧是1,右侧是0 结果才会为1
</span><span class="c1"></span>	<span class="c1">// 这里 iterator=1,oldIterator=2
</span><span class="c1"></span>	<span class="c1">// 所以低2位都会置为0
</span><span class="c1"></span>	<span class="nx">flags</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;^</span> <span class="p">(</span><span class="nx">iterator</span> <span class="p">|</span> <span class="nx">oldIterator</span><span class="p">)</span>
	<span class="c1">// 如果低位第1位不是0
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">iterator</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// 把flags的 低位第2位置为1
</span><span class="c1"></span>		<span class="nx">flags</span> <span class="o">|=</span> <span class="nx">oldIterator</span>
	<span class="p">}</span>
	<span class="c1">// 可能等量扩容,可能翻倍扩容
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="o">+=</span> <span class="nx">bigger</span>
	<span class="c1">// 标志位
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="p">=</span> <span class="nx">flags</span>
	<span class="c1">// 旧桶
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span> <span class="p">=</span> <span class="nx">oldbuckets</span>
	<span class="c1">// 新桶
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span> <span class="p">=</span> <span class="nx">newbuckets</span>
	<span class="c1">// 扩容进度为0, 还未迁移
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="c1">// 新buckets还没有数据
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">noverflow</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="c1">// 设置extra桶
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// Promote current overflow buckets to the old generation.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">oldoverflow</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;oldoverflow is not nil&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">oldoverflow</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">nextOverflow</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">mapextra</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">nextOverflow</span> <span class="p">=</span> <span class="nx">nextOverflow</span>
	<span class="p">}</span>
	<span class="c1">// 显然这里并没有对哈希表数据进行copy, 实际是在growWork() and evacuate()中进行
</span><span class="c1"></span><span class="p">}</span>

</code></pre></div><ul>
<li>growWork 实际的迁移数据</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 这里bucket是 hash的低B(6)位,已经是扩容了
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">growWork</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">bucket</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// evacuate 传入的是新的bucket和旧的2^B-1进行与的结果, 所以是扩容前的低B(5)位
</span><span class="c1"></span>	<span class="nf">evacuate</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">bucket</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nf">oldbucketmask</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nf">growing</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// 扩容进度
</span><span class="c1"></span>		<span class="nf">evacuate</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>evacuate 迁移</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">evacuate</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">oldbucket</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// oldbucket是旧的低5位哈希值,桶的索引, 找到旧桶的第一个bmap
</span><span class="c1"></span>	<span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span><span class="p">,</span> <span class="nx">oldbucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
	<span class="c1">// newbit = 2^5   = 32
</span><span class="c1"></span>	<span class="nx">newbit</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">noldbuckets</span><span class="p">()</span>
	<span class="c1">// 第一次肯定是没有迁移, true的条件: 1 &lt; b.tophash[0] &lt; 5
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nf">evacuated</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// type evacDst struct {
</span><span class="c1"></span>		<span class="c1">//	b *bmap		  // current destination bucket
</span><span class="c1"></span>		<span class="c1">//	i int			// key/elem index into b
</span><span class="c1"></span>		<span class="c1">//	k unsafe.Pointer // pointer to current key storage
</span><span class="c1"></span>		<span class="c1">//	e unsafe.Pointer // pointer to current elem storage
</span><span class="c1"></span>		<span class="c1">// }
</span><span class="c1"></span>		<span class="kd">var</span> <span class="nx">xy</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="nx">evacDst</span>
		<span class="nx">x</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="c1">// 新的bmap
</span><span class="c1"></span>		<span class="nx">x</span><span class="p">.</span><span class="nx">b</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">oldbucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
		<span class="c1">// 根据bmap得到key的地址,先保存作为目标地址
</span><span class="c1"></span>		<span class="nx">x</span><span class="p">.</span><span class="nx">k</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="p">)</span>
		<span class="c1">// 根据bmap得到value的地址
</span><span class="c1"></span>		<span class="nx">x</span><span class="p">.</span><span class="nx">e</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">k</span><span class="p">,</span> <span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
		<span class="c1">// 不是等量扩容的情况,那就是翻倍扩容
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">sameSizeGrow</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">y</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
			<span class="c1">// 比如前面的例子哈希值低8位: 00100011
</span><span class="c1"></span>			<span class="c1">// oldbucket=3,newbit=32
</span><span class="c1"></span>			<span class="c1">// 所以该哈希值会被迁移到 索引为35的桶位置
</span><span class="c1"></span>			<span class="nx">y</span><span class="p">.</span><span class="nx">b</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="p">(</span><span class="nx">oldbucket</span><span class="o">+</span><span class="nx">newbit</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
			<span class="c1">// key value的地址, 先保存作为目标地址
</span><span class="c1"></span>			<span class="nx">y</span><span class="p">.</span><span class="nx">k</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">y</span><span class="p">.</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="p">)</span>
			<span class="nx">y</span><span class="p">.</span><span class="nx">e</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">y</span><span class="p">.</span><span class="nx">k</span><span class="p">,</span> <span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
		<span class="p">}</span>
		<span class="c1">// 这里同样是两层for循环
</span><span class="c1"></span>		<span class="k">for</span> <span class="p">;</span> <span class="nx">b</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="p">)</span>
			<span class="nx">e</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
			<span class="c1">// 内层循环
</span><span class="c1"></span>			<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">e</span> <span class="p">=</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nf">add</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)),</span> <span class="nf">add</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span> <span class="p">{</span>
				<span class="nx">top</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
				<span class="k">if</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="nx">top</span><span class="p">)</span> <span class="p">{</span>
					<span class="c1">// evacuatedX	 = 2 // k/v是有效的, 并且是分配到前半部分桶(3)
</span><span class="c1"></span>					<span class="c1">// evacuatedY	 = 3 // k/v是有效的, 并且是分配到后半部分桶(3+32)
</span><span class="c1"></span>					<span class="c1">// evacuatedEmpty = 4 // 本身就是空槽, 这里只是作为标记位,标记已经迁移了
</span><span class="c1"></span>					<span class="c1">// minTopHash	 = 5 // minimum tophash for a normal filled cell.
</span><span class="c1"></span>					<span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">evacuatedEmpty</span>
					<span class="k">continue</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">top</span> <span class="p">&lt;</span> <span class="nx">minTopHash</span> <span class="p">{</span>
					<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad map state&#34;</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="nx">k2</span> <span class="o">:=</span> <span class="nx">k</span>
				<span class="c1">//指针
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>
					<span class="nx">k2</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k2</span><span class="p">))</span>
				<span class="p">}</span>
				<span class="kd">var</span> <span class="nx">useY</span> <span class="kt">uint8</span>
				<span class="c1">// 不是等量扩容
</span><span class="c1"></span>				<span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">sameSizeGrow</span><span class="p">()</span> <span class="p">{</span>
					<span class="c1">// 计算哈希
</span><span class="c1"></span>					<span class="nx">hash</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">k2</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span><span class="p">))</span>
					<span class="c1">// 正在迭代 ; 相同的key但是哈希不通
</span><span class="c1"></span>					<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">iterator</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">t</span><span class="p">.</span><span class="nf">reflexivekey</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">k2</span><span class="p">,</span> <span class="nx">k2</span><span class="p">)</span> <span class="p">{</span>
						<span class="c1">// NaNs
</span><span class="c1"></span>						<span class="nx">useY</span> <span class="p">=</span> <span class="nx">top</span> <span class="o">&amp;</span> <span class="mi">1</span>
						<span class="nx">top</span> <span class="p">=</span> <span class="nf">tophash</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="c1">// newbit是32
</span><span class="c1"></span>						<span class="k">if</span> <span class="nx">hash</span><span class="o">&amp;</span><span class="nx">newbit</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
							<span class="c1">// 最高位是1的话就要去 后半部分桶
</span><span class="c1"></span>							<span class="nx">useY</span> <span class="p">=</span> <span class="mi">1</span>
						<span class="p">}</span>
					<span class="p">}</span>
				<span class="p">}</span>

				<span class="k">if</span> <span class="nx">evacuatedX</span><span class="o">+</span><span class="mi">1</span> <span class="o">!=</span> <span class="nx">evacuatedY</span> <span class="o">||</span> <span class="nx">evacuatedX</span><span class="p">^</span><span class="mi">1</span> <span class="o">!=</span> <span class="nx">evacuatedY</span> <span class="p">{</span>
					<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad evacuatedN&#34;</span><span class="p">)</span>
				<span class="p">}</span>

				<span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">evacuatedX</span> <span class="o">+</span> <span class="nx">useY</span> <span class="c1">// evacuatedX + 1 == evacuatedY
</span><span class="c1"></span>				<span class="nx">dst</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">xy</span><span class="p">[</span><span class="nx">useY</span><span class="p">]</span>				 <span class="c1">// evacuation destination
</span><span class="c1"></span>				<span class="c1">// 如果等于8,说明满了
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">dst</span><span class="p">.</span><span class="nx">i</span> <span class="o">==</span> <span class="nx">bucketCnt</span> <span class="p">{</span>
					<span class="c1">// 放到链表去
</span><span class="c1"></span>					<span class="nx">dst</span><span class="p">.</span><span class="nx">b</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">newoverflow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">dst</span><span class="p">.</span><span class="nx">b</span><span class="p">)</span>
					<span class="nx">dst</span><span class="p">.</span><span class="nx">i</span> <span class="p">=</span> <span class="mi">0</span>
					<span class="nx">dst</span><span class="p">.</span><span class="nx">k</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">dst</span><span class="p">.</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="p">)</span>
					<span class="nx">dst</span><span class="p">.</span><span class="nx">e</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">dst</span><span class="p">.</span><span class="nx">k</span><span class="p">,</span> <span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
				<span class="p">}</span>
				<span class="nx">dst</span><span class="p">.</span><span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">dst</span><span class="p">.</span><span class="nx">i</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">bucketCnt</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="p">=</span> <span class="nx">top</span> <span class="c1">// mask dst.i as an optimization, to avoid a bounds check
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>
					<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">dst</span><span class="p">.</span><span class="nx">k</span><span class="p">)</span> <span class="p">=</span> <span class="nx">k2</span> <span class="c1">// copy pointer
</span><span class="c1"></span>				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">dst</span><span class="p">.</span><span class="nx">k</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="c1">// copy elem
</span><span class="c1"></span>				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectelem</span><span class="p">()</span> <span class="p">{</span>
					<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">dst</span><span class="p">.</span><span class="nx">e</span><span class="p">)</span> <span class="p">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">e</span><span class="p">)</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">dst</span><span class="p">.</span><span class="nx">e</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="nx">dst</span><span class="p">.</span><span class="nx">i</span><span class="o">++</span>
				<span class="nx">dst</span><span class="p">.</span><span class="nx">k</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">dst</span><span class="p">.</span><span class="nx">k</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
				<span class="nx">dst</span><span class="p">.</span><span class="nx">e</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">dst</span><span class="p">.</span><span class="nx">e</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="c1">// 如果没有正在迭代老的桶, 就清除buckets, 帮助gc
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">oldIterator</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">b</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span><span class="p">,</span> <span class="nx">oldbucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">))</span>
			<span class="nx">ptr</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">dataOffset</span><span class="p">)</span>
			<span class="nx">n</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)</span> <span class="o">-</span> <span class="nx">dataOffset</span>
			<span class="nf">memclrHasPointers</span><span class="p">(</span><span class="nx">ptr</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">//
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">oldbucket</span> <span class="o">==</span> <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span> <span class="p">{</span>
		<span class="nf">advanceEvacuationMark</span><span class="p">(</span><span class="nx">h</span><span class="p">,</span> <span class="nx">t</span><span class="p">,</span> <span class="nx">newbit</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>sameSizeGrow</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">)</span> <span class="nf">sameSizeGrow</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// sameSizeGrow = 8 (1000)
</span><span class="c1"></span>	<span class="c1">// 扩容标志位进行与运算, 如果都是1, 说明是等量扩容
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">sameSizeGrow</span> <span class="o">!=</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>advanceEvacuationMark</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">advanceEvacuationMark</span><span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">newbit</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span><span class="o">++</span>
	<span class="nx">stop</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span> <span class="o">+</span> <span class="mi">1024</span>
	<span class="k">if</span> <span class="nx">stop</span> <span class="p">&gt;</span> <span class="nx">newbit</span> <span class="p">{</span>
		<span class="nx">stop</span> <span class="p">=</span> <span class="nx">newbit</span>
	<span class="p">}</span>
	<span class="c1">// 寻找没有搬迁的bucket
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span> <span class="o">!=</span> <span class="nx">stop</span> <span class="o">&amp;&amp;</span> <span class="nf">bucketEvacuated</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="c1">// 如果已经等于 2^B了,当然是全部的桶都搬迁完了
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span> <span class="o">==</span> <span class="nx">newbit</span> <span class="p">{</span> <span class="c1">// newbit == # of oldbuckets
</span><span class="c1"></span>		<span class="c1">// 搬迁结束
</span><span class="c1"></span>		<span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">oldoverflow</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="c1">// sameSizeGrow =8 (1000) 所以是把第4位置0 , 下次sameSizeGrow() 函数就是false了
</span><span class="c1"></span>		<span class="c1">// 清除正在扩容的标识
</span><span class="c1"></span>		<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;^=</span> <span class="nx">sameSizeGrow</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h3 id="mapaccess1-map读取">mapaccess1 map读取</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mapaccess1</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">callerpc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
		<span class="nx">pc</span> <span class="o">:=</span> <span class="nf">funcPC</span><span class="p">(</span><span class="nx">mapaccess1</span><span class="p">)</span>
		<span class="nf">racereadpc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">h</span><span class="p">),</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
		<span class="nf">raceReadObjectPC</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">msanenabled</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">msanread</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">h</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">h</span><span class="p">.</span><span class="nx">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hashMightPanic</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// see issue 23734
</span><span class="c1"></span>		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">zeroVal</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">hashWriting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;concurrent map read and map write&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 算一下哈希值
</span><span class="c1"></span>	<span class="nx">hash</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span><span class="p">))</span>
	<span class="c1">// m = 2^B -1
</span><span class="c1"></span>	<span class="nx">m</span> <span class="o">:=</span> <span class="nf">bucketMask</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span>
	<span class="c1">// bmap
</span><span class="c1"></span>	<span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="p">(</span><span class="nx">hash</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
	<span class="c1">// 如果存在oldbuckets, 说明可能在扩容 搬迁
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span><span class="p">;</span> <span class="nx">c</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 不是等量扩容
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">sameSizeGrow</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// 翻倍扩容 需要缩小一倍m
</span><span class="c1"></span>			<span class="nx">m</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
		<span class="p">}</span>
		<span class="c1">// old bmap
</span><span class="c1"></span>		<span class="nx">oldb</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="p">(</span><span class="nx">hash</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
		<span class="c1">// 如果不在搬迁
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nf">evacuated</span><span class="p">(</span><span class="nx">oldb</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// 那就开始读oldb
</span><span class="c1"></span>			<span class="nx">b</span> <span class="p">=</span> <span class="nx">oldb</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 得到哈希的高8位
</span><span class="c1"></span>	<span class="nx">top</span> <span class="o">:=</span> <span class="nf">tophash</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span>
<span class="nx">bucketloop</span><span class="p">:</span>
	<span class="c1">// 两层循环
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">;</span> <span class="nx">b</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="c1">// 高8位如果都不同,那就可以继续下一个
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">top</span> <span class="p">{</span>
				<span class="c1">// 如果是空槽就break
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">emptyRest</span> <span class="p">{</span>
					<span class="k">break</span> <span class="nx">bucketloop</span>
				<span class="p">}</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">k</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="c1">// 如果找到了key
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">// 得到value的地址
</span><span class="c1"></span>				<span class="nx">e</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
				<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectelem</span><span class="p">()</span> <span class="p">{</span>
					<span class="nx">e</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">e</span><span class="p">))</span>
				<span class="p">}</span>
				<span class="c1">// 返回
</span><span class="c1"></span>				<span class="k">return</span> <span class="nx">e</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 找不到就返回0
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">zeroVal</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="p">}</span>

</code></pre></div><ul>
<li><a href="https://juejin.cn/post/6844903848587296781">深度解密Go语言之 map</a></li>
<li><a href="https://www.bilibili.com/video/BV1Q4411W7MR">Go夜读 map 源码阅读分析（20190529第44期）</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Go学习 Gmp模型</title>
			<link>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-gmp%E6%A8%A1%E5%9E%8B/</link>
			<pubDate>Wed, 17 Nov 2021 09:31:09 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-gmp%E6%A8%A1%E5%9E%8B/</guid>
			<description>在此之前我们先看一下go启动的入口 通过gdb调试, 找到入口文件 # GOFLAGS=&amp;#34;-ldflags=-compressdwarf=false&amp;#34; go build gdb-main.go # gdb gdb-main (gdb) info files Symbols from &amp;#34;/Users/zhangzw/work/go/github.com/zhangzw001/learngo/basic/gdb/gdb-main&amp;#34;. Local exec file: `/Users/zhangzw/work/go/github.com/zhangzw001/learngo/basic/gdb/gdb-main&amp;#39;, file type mach-o-x86-64. Entry point: 0x1065600 0x0000000001001000 - 0x00000000010a2e8a is .text 0x00000000010a2ea0 - 0x00000000010a2fa2 is __TEXT.__symbol_stub1 ... (gdb) b *0x1065600 // 上面的Entry point后面的地址 Breakpoint 1 at 0x1065600: file /usr/local/go/src/runtime/rt0_darwin_amd64.s, line 8. // 这里是mac 继续查看 // src/runtime/rt0_darwin_amd64.s TEXT _rt0_amd64_darwin(SB),NOSPLIT,$-8 JMP	_rt0_amd64(SB) //跳转到 _rt0_amd64 TEXT _rt0_amd64(SB),NOSPLIT,$-8 MOVQ	0(SP), DI	// argc LEAQ	8(SP), SI	// argv JMP	runtime·rt0_go(SB) // 又跳转到runtime·rt0_go 来到核心代码 TEXT runtime·rt0_go(SB),NOSPLIT|NOFRAME,$0 // Copy arguments forward on an even stack.</description>
			<content type="html"><![CDATA[<h3 id="在此之前我们先看一下go启动的入口">在此之前我们先看一下go启动的入口</h3>
<h4 id="通过gdb调试-找到入口文件">通过gdb调试, 找到入口文件</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="err">#</span> <span class="nx">GOFLAGS</span><span class="p">=</span><span class="s">&#34;-ldflags=-compressdwarf=false&#34;</span> <span class="k">go</span> <span class="nx">build</span> <span class="nx">gdb</span><span class="o">-</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span>

<span class="err">#</span> <span class="nx">gdb</span> <span class="nx">gdb</span><span class="o">-</span><span class="nf">main</span>
<span class="p">(</span><span class="nx">gdb</span><span class="p">)</span> <span class="nx">info</span> <span class="nx">files</span>
<span class="nx">Symbols</span> <span class="nx">from</span> <span class="s">&#34;/Users/zhangzw/work/go/github.com/zhangzw001/learngo/basic/gdb/gdb-main&#34;</span><span class="p">.</span>
<span class="nx">Local</span> <span class="nx">exec</span> <span class="nx">file</span><span class="p">:</span>
	<span class="err">`</span><span class="o">/</span><span class="nx">Users</span><span class="o">/</span><span class="nx">zhangzw</span><span class="o">/</span><span class="nx">work</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="nx">github</span><span class="p">.</span><span class="nx">com</span><span class="o">/</span><span class="nx">zhangzw001</span><span class="o">/</span><span class="nx">learngo</span><span class="o">/</span><span class="nx">basic</span><span class="o">/</span><span class="nx">gdb</span><span class="o">/</span><span class="nx">gdb</span><span class="o">-</span><span class="nx">main</span><span class="err">&#39;</span><span class="p">,</span> <span class="nx">file</span> <span class="kd">type</span> <span class="nx">mach</span><span class="o">-</span><span class="nx">o</span><span class="o">-</span><span class="nx">x86</span><span class="o">-</span><span class="mf">64.</span>
	<span class="nx">Entry</span> <span class="nx">point</span><span class="p">:</span> <span class="mh">0x1065600</span>
	<span class="mh">0x0000000001001000</span> <span class="o">-</span> <span class="mh">0x00000000010a2e8a</span> <span class="nx">is</span> <span class="p">.</span><span class="nx">text</span>
	<span class="mh">0x00000000010a2ea0</span> <span class="o">-</span> <span class="mh">0x00000000010a2fa2</span> <span class="nx">is</span> <span class="nx">__TEXT</span><span class="p">.</span><span class="nx">__symbol_stub1</span>
    <span class="o">...</span>
<span class="p">(</span><span class="nx">gdb</span><span class="p">)</span> <span class="nx">b</span> <span class="o">*</span><span class="mh">0x1065600</span>  <span class="c1">// 上面的Entry point后面的地址
</span><span class="c1"></span><span class="nx">Breakpoint</span> <span class="mi">1</span> <span class="nx">at</span> <span class="mh">0x1065600</span><span class="p">:</span> <span class="nx">file</span> <span class="o">/</span><span class="nx">usr</span><span class="o">/</span><span class="nx">local</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">runtime</span><span class="o">/</span><span class="nx">rt0_darwin_amd64</span><span class="p">.</span><span class="nx">s</span><span class="p">,</span> <span class="nx">line</span> <span class="mf">8.</span>   <span class="c1">// 这里是mac
</span></code></pre></div><h4 id="继续查看">继续查看</h4>
<pre><code>// src/runtime/rt0_darwin_amd64.s
TEXT _rt0_amd64_darwin(SB),NOSPLIT,$-8
	JMP	_rt0_amd64(SB) //跳转到 _rt0_amd64

TEXT _rt0_amd64(SB),NOSPLIT,$-8
	MOVQ	0(SP), DI	// argc
	LEAQ	8(SP), SI	// argv
	JMP	runtime·rt0_go(SB) // 又跳转到runtime·rt0_go
</code></pre><h4 id="来到核心代码">来到核心代码</h4>
<pre><code>TEXT runtime·rt0_go(SB),NOSPLIT|NOFRAME,$0
	// Copy arguments forward on an even stack.
	// Users of this function jump to it, they don't call it.
	MOVL	0(SP), AX
	MOVL	4(SP), BX
	SUBL	$128, SP		// plenty of scratch
	ANDL	$~15, SP
	MOVL	AX, 120(SP)		// save argc, argv away
	MOVL	BX, 124(SP)
    ...
ok:
	// set up m and g &quot;registers&quot;
    // 程序刚刚启动, 此时位于主线程
    // 当前栈与资源保存在g0
    // 线程保存在m0
	get_tls(BX)
	LEAL	runtime·g0(SB), DX
	MOVL	DX, g(BX)
	LEAL	runtime·m0(SB), AX

	// save m-&gt;g0 = g0
	MOVL	DX, m_g0(AX)
	// save g0-&gt;m = m0
	MOVL	AX, g_m(DX)

	CALL	runtime·check(SB) //运行时类型检查，主要是校验编译器的翻译工作是否正确
	MOVL	120(SP), AX       // copy argc
	MOVL	AX, 0(SP)
	MOVL	124(SP), AX       // copy argv
	MOVL	AX, 4(SP)
	CALL	runtime·args(SB)      //系统参数传递，主要是将系统参数转换传递给程序使用
	CALL	runtime·osinit(SB)    //系统基本参数设置，主要是获取 CPU 核心数和内存物理页大小
	CALL	runtime·schedinit(SB) //进行各种运行时组件的初始化，包含调度器、内存分配器、堆、栈、GC 等一大堆初始化工作。会进行 p 的初始化，并将 m0 和某一个 p 进行绑定。

	// 创建一个新的goroutine来运行程序
	PUSHL	$runtime·mainPC(SB)	  // entry ,主要工作是运行 main goroutine，虽然在runtime·rt0_go 中指向的是$runtime·mainPC，但实质指向的是 runtime.main。
	PUSHL	$0	// arg size
	CALL	runtime·newproc(SB)   //创建一个新的 goroutine，且绑定 runtime.main 方法（也就是应用程序中的入口 main 方法）。并将其放入 m0 绑定的p的本地队列中去，以便后续调度。
	POPL	AX
	POPL	AX

	// start this M
	CALL	runtime·mstart(SB)

	CALL	runtime·abort(SB)
	RET
</code></pre><h4 id="mstart">mstart()</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/proc.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">mstart</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// g0
</span><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
    <span class="p">..</span>
	<span class="nf">mstart1</span><span class="p">()</span>

	<span class="c1">// 退出线程
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">mStackIsSystemAllocated</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">osStack</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="nf">mexit</span><span class="p">(</span><span class="nx">osStack</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h4 id="实质逻辑mstart1">实质逻辑mstart1()</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/proc.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">mstart1</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 必须是g0
</span><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">_g_</span> <span class="o">!=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad runtime·mstart&#34;</span><span class="p">)</span>
	<span class="p">}</span>
    <span class="c1">// 初始化m, 并记录pc,sp
</span><span class="c1"></span>	<span class="nf">save</span><span class="p">(</span><span class="nf">getcallerpc</span><span class="p">(),</span> <span class="nf">getcallersp</span><span class="p">())</span>
	<span class="nf">asminit</span><span class="p">()</span>  
	<span class="nf">minit</span><span class="p">()</span>
	<span class="c1">// 若当前 g 所绑定的 m 是 m0，
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nx">m0</span> <span class="p">{</span>
		<span class="nf">mstartm0</span><span class="p">()</span>
	<span class="p">}</span>
    <span class="c1">// 运行启动函数
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">fn</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mstartfn</span><span class="p">;</span> <span class="nx">fn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">fn</span><span class="p">()</span>
	<span class="p">}</span>
    <span class="c1">//若当前 g 所绑定的 m 不是 m0，
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="nx">m0</span> <span class="p">{</span>
        <span class="c1">//则需要调用 acquirep 方法获取并绑定 p，也就是 m 与 p 绑定。
</span><span class="c1"></span>		<span class="nf">acquirep</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">nextp</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">nextp</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="nf">schedule</span><span class="p">()</span> <span class="c1">// 调度
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h4 id="真正的调度-schedule">真正的调度 schedule()</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
</code></pre></div><h3 id="为什么需要p">为什么需要P</h3>
<ul>
<li>如果没有P, 所有的G都必须在一个全局的队列中, 然后M一个个从全局队列中获取, 这种共享内存的方式并发必须需要加锁</li>
<li>如果没有P, 当前g1中包含了创建新协程g2(go func)时, 当前的M1还得继续执行g1, 因此M1必须主动转义g2给另外一个线程M2去执行,这就造成了不必要的转移,浪费cpu资源, 因为g1 g2是相关的, 如果都在本地M1上执行更好, 而不是调度出去执行</li>
</ul>
<h3 id="gmp模型">GMP模型</h3>
<p><img src="images/golang/gmp-jiagou.png" alt=""></p>
<h4 id="简介">简介</h4>
<ul>
<li>全局队列（Global Queue）：存放等待运行的G。</li>
<li>P的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G&rsquo;时，G&rsquo;优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。</li>
<li>P列表：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS(可配置)个。</li>
<li>M：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列拿一批G放到P的本地队列，或从其他P的本地队列偷一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。</li>
<li>g0: 一个比一比g大的多栈, 可以用于 创建goroutine, deferproc函数里新建_defer,垃圾回收相关工资</li>
</ul>
<h4 id="何时会创建">何时会创建</h4>
<pre><code>P : 由启动时环境变量$GOMAXPROCS或者是由runtime的方法GOMAXPROCS()决定, 运行时系统就会创建
M : 如果P找不到空闲的M去绑定,就会创建M
</code></pre><h4 id="调度器策略">调度器策略</h4>
<pre><code>work stealing : 当本地G队列为空时, 尝试从全局队列或者其他的线程绑定的P偷取G,而不是销毁线程
hand off : 当g阻塞时,实际是当前M线程会阻塞,那么
</code></pre><p><img src="images/golang/gmp.jpeg" alt=""></p>
<h3 id="gmp结构体">gmp结构体</h3>
<ul>
<li>m</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/runtime2.go
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">m</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">g0</span>         <span class="o">*</span><span class="nx">g</span>          <span class="c1">// 用于执行调度指令的 Goroutine
</span><span class="c1"></span>	<span class="nx">gsignal</span>    <span class="o">*</span><span class="nx">g</span>          <span class="c1">// 处理 signal 的 g
</span><span class="c1"></span>	<span class="nx">tls</span>        <span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="kt">uintptr</span>  <span class="c1">// 线程本地存储
</span><span class="c1"></span>	<span class="nx">curg</span>       <span class="o">*</span><span class="nx">g</span>          <span class="c1">// 当前运行的用户 Goroutine
</span><span class="c1"></span>	<span class="nx">p</span>          <span class="nx">puintptr</span>    <span class="c1">// 执行 go 代码时持有的 p (如果没有执行则为 nil)
</span><span class="c1"></span>	<span class="nx">preemptoff</span> <span class="kt">string</span>      <span class="c1">// if != &#34;&#34;, keep curg running on this m
</span><span class="c1"></span>	<span class="nx">spinning</span>   <span class="kt">bool</span>        <span class="c1">// m 当前没有运行 work 且正处于寻找 work 的活跃状态,自旋和非自旋状态
</span><span class="c1"></span>	<span class="nx">blocked</span>    <span class="kt">bool</span>        <span class="c1">// m is blocked on a note
</span><span class="c1"></span>	<span class="nx">freeWait</span>   <span class="kt">uint32</span>      <span class="c1">// if == 0, safe to free g0 and delete m (atomic)
</span><span class="c1"></span>	<span class="nx">cgoCallers</span> <span class="o">*</span><span class="nx">cgoCallers</span> <span class="c1">// cgo 调用崩溃的 cgo 回溯
</span><span class="c1"></span>	<span class="nx">alllink</span>    <span class="o">*</span><span class="nx">m</span>          <span class="c1">// 在 allm 上
</span><span class="c1"></span>	<span class="nx">mcache</span>     <span class="o">*</span><span class="nx">mcache</span>     <span class="c1">// 当前线程上进行内存分配的本地缓存 mcache
</span><span class="c1"></span>    <span class="nx">freelink</span>   <span class="o">*</span><span class="nx">m</span>          <span class="c1">// on sched.freem
</span><span class="c1"></span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>p</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/runtime2.go
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">p</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">id</span>           <span class="kt">int32</span>
	<span class="nx">status</span>       <span class="kt">uint32</span>        <span class="c1">// p 的状态 pidle/prunning/...
</span><span class="c1"></span>	<span class="nx">link</span>         <span class="nx">puintptr</span>
	<span class="nx">m</span>            <span class="nx">muintptr</span>      <span class="c1">// 反向链接到关联的 m （nil 则表示 idle）
</span><span class="c1"></span>	<span class="nx">mcache</span>       <span class="o">*</span><span class="nx">mcache</span>
	<span class="nx">pcache</span>       <span class="nx">pageCache</span>
	<span class="nx">deferpool</span>    <span class="p">[</span><span class="mi">5</span><span class="p">][]</span><span class="o">*</span><span class="nx">_defer</span>  <span class="c1">// 不同大小的可用的 defer 结构池
</span><span class="c1"></span>	<span class="nx">deferpoolbuf</span> <span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">32</span><span class="p">]</span><span class="o">*</span><span class="nx">_defer</span>
	<span class="nx">runqhead</span>     <span class="kt">uint32</span>	       <span class="c1">// 可运行的 Goroutine 队列，可无锁访问
</span><span class="c1"></span>	<span class="nx">runqtail</span>     <span class="kt">uint32</span>
	<span class="nx">runq</span>         <span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="nx">guintptr</span>
	<span class="nx">runnext</span>      <span class="nx">guintptr</span>
	<span class="nx">timersLock</span>   <span class="nx">mutex</span>
	<span class="nx">timers</span>       <span class="p">[]</span><span class="o">*</span><span class="nx">timer</span>
	<span class="nx">preempt</span>      <span class="kt">bool</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>g</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/runtime2.go
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">g</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">stack</span> <span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">lo</span> <span class="kt">uintptr</span>
		<span class="nx">hi</span> <span class="kt">uintptr</span>
	<span class="p">}</span> 							<span class="c1">// 栈内存：[stack.lo, stack.hi)
</span><span class="c1"></span>	<span class="nx">stackguard0</span>	<span class="kt">uintptr</span>
	<span class="nx">stackguard1</span> <span class="kt">uintptr</span>

	<span class="nx">_panic</span>       <span class="o">*</span><span class="nx">_panic</span>
	<span class="nx">_defer</span>       <span class="o">*</span><span class="nx">_defer</span>
	<span class="nx">m</span>            <span class="o">*</span><span class="nx">m</span>				<span class="c1">// 当前的 m
</span><span class="c1"></span>	<span class="nx">sched</span>        <span class="nx">gobuf</span>
	<span class="nx">stktopsp</span>     <span class="kt">uintptr</span>		<span class="c1">// 期望 sp 位于栈顶，用于回溯检查
</span><span class="c1"></span>	<span class="nx">param</span>        <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// wakeup 唤醒时候传递的参数
</span><span class="c1"></span>	<span class="nx">atomicstatus</span> <span class="kt">uint32</span>
	<span class="nx">goid</span>         <span class="kt">int64</span>
	<span class="nx">preempt</span>      <span class="kt">bool</span>       	<span class="c1">// 抢占信号，stackguard0 = stackpreempt 的副本
</span><span class="c1"></span>	<span class="nx">timer</span>        <span class="o">*</span><span class="nx">timer</span>         <span class="c1">// 为 time.Sleep 缓存的计时器
</span><span class="c1"></span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>调度器
<ul>
<li>管理了能够将 G 和 M 进行绑定的 M 队列</li>
<li>管理了空闲的 P 链表（队列）</li>
<li>管理了 G 的全局队列</li>
<li>管理了可被复用的 G 的全局缓存</li>
<li>管理了 defer 池</li>
</ul>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/runtime2.go
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">schedt</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">lock</span> <span class="nx">mutex</span>
    <span class="nx">ngsys</span> <span class="kt">uint32</span>        <span class="c1">// 系统 goroutine的数量; 自增
</span><span class="c1"></span>	<span class="nx">pidle</span>      <span class="nx">puintptr</span> <span class="c1">// 空闲 p 链表
</span><span class="c1"></span>	<span class="nx">npidle</span>     <span class="kt">uint32</span>   <span class="c1">// 空闲 p 数量
</span><span class="c1"></span>	<span class="nx">nmspinning</span> <span class="kt">uint32</span>   <span class="c1">// 自旋状态的 M 的数量
</span><span class="c1"></span>	<span class="nx">runq</span>       <span class="nx">gQueue</span>   <span class="c1">// 全局 G 队列
</span><span class="c1"></span>	<span class="nx">runqsize</span>   <span class="kt">int32</span>    <span class="c1">// 全局队列大小
</span><span class="c1"></span>	<span class="nx">gFree</span>      <span class="kd">struct</span> <span class="p">{</span> <span class="c1">// 有效 dead G 的全局缓存.
</span><span class="c1"></span>		<span class="nx">lock</span>    <span class="nx">mutex</span> <span class="c1">// 锁
</span><span class="c1"></span>		<span class="nx">stack</span>   <span class="nx">gList</span> <span class="c1">// 包含栈的 Gs
</span><span class="c1"></span>		<span class="nx">noStack</span> <span class="nx">gList</span> <span class="c1">// 没有栈的 Gs
</span><span class="c1"></span>		<span class="nx">n</span>       <span class="kt">int32</span>
	<span class="p">}</span>
	<span class="nx">sudoglock</span>  <span class="nx">mutex</span>  <span class="c1">// sudog 锁
</span><span class="c1"></span>	<span class="nx">sudogcache</span> <span class="o">*</span><span class="nx">sudog</span> <span class="c1">// sudog 结构的集中缓存
</span><span class="c1"></span>	<span class="nx">deferlock</span>  <span class="nx">mutex</span>  <span class="c1">// 不同大小的有效的 defer 结构的池
</span><span class="c1"></span>	<span class="nx">deferpool</span>  <span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">*</span><span class="nx">_defer</span>

	<span class="o">...</span>
<span class="p">}</span>
</code></pre></div><h3 id="附录">附录</h3>
<ul>
<li><a href="https://eddycjy.com/posts/go/go-bootstrap0/">详解 Go 程序的启动流程，你知道 g0，m0 是什么吗？</a></li>
<li><a href="https://golang.design/under-the-hood/zh-cn/part2runtime/ch06sched/schedule/">go语言原本 调度</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/344842279">g0</a></li>
<li><a href="https://talkgo.org/t/topic/31">golang 中 goroutine 的调度</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Go学习 Go汇编plan9</title>
			<link>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-go%E6%B1%87%E7%BC%96plan9/</link>
			<pubDate>Fri, 12 Nov 2021 10:19:57 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-go%E6%B1%87%E7%BC%96plan9/</guid>
			<description>在此之前,什么是函数栈? 先了解下几个汇编寄存器 通用寄存器包括: 1. 数据寄存器 AX:累加寄存器 BX:基地址寄存器 CX:计数器寄存器 DX:数据寄存器 2. 指针寄存器 SP:堆栈指针, 栈顶 BP:基址指针, 栈底 IP:指令指针, cpu下一条要执行指令的内存地址 3. 变址寄存器 SI:源变址 DI:目的变址 golang伪寄存器: FP: Frame pointer: arguments and locals.(指向当前frame的起始位置) FP+0 使用形如 symbol+offset(FP) 的方式，引用函数的输入参数。例如 arg0+0(FP)，arg1+8(FP)，使用 FP 不加 symbol 时，无法通过编译，在汇编层面来讲，symbol 并没有什么用，加 symbol 主要是为了提升代码可读性。另外，官方文档虽然将伪寄存器 FP 称之为 frame pointer，实际上它根本不是 frame pointer，按照传统的 x86 的习惯来讲，frame pointer 是指向整个 stack frame 底部的 BP 寄存器。假如当前的 callee 函数是 add，在 add 的代码中引用 FP，该 FP 指向的位置不在 callee 的 stack frame 之内，而是在 caller 的 stack frame 上。 PC: Program counter: jumps and branches.</description>
			<content type="html"><![CDATA[<h3 id="在此之前什么是函数栈">在此之前,什么是函数栈?</h3>
<h3 id="先了解下几个汇编寄存器">先了解下几个汇编寄存器</h3>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">通用寄存器包括:
1. 数据寄存器
    AX:累加寄存器
    BX:基地址寄存器
    CX:计数器寄存器
    DX:数据寄存器
2. 指针寄存器
    SP:堆栈指针, 栈顶
    BP:基址指针, 栈底
    IP:指令指针, cpu下一条要执行指令的内存地址
3. 变址寄存器
    SI:源变址
    DI:目的变址

golang伪寄存器:
FP: Frame pointer: arguments and locals.<span class="o">(</span>指向当前frame的起始位置<span class="o">)</span> FP+0
    使用形如 symbol+offset<span class="o">(</span>FP<span class="o">)</span> 的方式，引用函数的输入参数。例如 arg0+0<span class="o">(</span>FP<span class="o">)</span>，arg1+8<span class="o">(</span>FP<span class="o">)</span>，使用 FP 不加 symbol 时，无法通过编译，在汇编层面来讲，symbol 并没有什么用，加 symbol 主要是为了提升代码可读性。另外，官方文档虽然将伪寄存器 FP 称之为 frame pointer，实际上它根本不是 frame pointer，按照传统的 x86 的习惯来讲，frame pointer 是指向整个 stack frame 底部的 BP 寄存器。假如当前的 callee 函数是 add，在 add 的代码中引用 FP，该 FP 指向的位置不在 callee 的 stack frame 之内，而是在 <span class="nb">caller</span> 的 stack frame 上。
PC: Program counter: jumps and branches.<span class="o">(</span>指向下一条要执行的指令的位置<span class="o">)</span>
    实际上就是在体系结构的知识中常见的 pc 寄存器，在 x86 平台下对应 ip 寄存器，amd64 上则是 rip。除了个别跳转之外，手写 plan9 代码与 PC 寄存器打交道的情况较少。
SB: Static base pointer: global symbols.<span class="o">(</span>指向全局变量的位置,可以看着是程序的起始地址<span class="o">)</span>
    全局静态基指针，一般用来声明函数或全局变量，在之后的函数知识和示例部分会看到具体用法
SP: Stack pointer: top of stack.<span class="o">(</span>指向当前栈顶<span class="o">)</span>
    plan9 的这个 SP 寄存器指向当前栈帧的局部变量的开始位置，使用形如 symbol+offset<span class="o">(</span>SP<span class="o">)</span> 的方式，引用函数的局部变量。offset 的合法取值是 <span class="o">[</span>-framesize, 0<span class="o">)</span>，注意是个左闭右开的区间。假如局部变量都是 <span class="m">8</span> 字节，那么第一个局部变量就可以用 localvar0-8<span class="o">(</span>SP<span class="o">)</span> 来表示。这也是一个词不表意的寄存器。与硬件寄存器 SP 是两个不同的东西，在栈帧 size 为 <span class="m">0</span> 的情况下，伪寄存器 SP 和硬件寄存器 SP 指向同一位置。手写汇编代码时，如果是 symbol+offset<span class="o">(</span>SP<span class="o">)</span> 形式，则表示伪寄存器 SP。如果是 offset<span class="o">(</span>SP<span class="o">)</span> 则表示硬件寄存器 SP。务必注意。对于编译输出<span class="o">(</span>go tool compile -S / go tool objdump<span class="o">)</span>的代码来讲，目前所有的 SP 都是硬件寄存器 SP，无论是否带 symbol。

汇编指令:
PUSH: 入栈, 将内容保存栈中,并且SP下移<span class="o">(</span>减小<span class="o">)</span>
POP: 出栈,读取栈中结果,并且SP上移<span class="o">(</span>增加<span class="o">)</span>
CALL: 函数调用,这里记录A为调用者,B为被调用者, 代码段读到call指令时,call后面跟的是B的地址,
    1. call: 入栈call下一条指令地址<span class="o">(</span>因为call执行完,你还得接着call后面的指令继续执行<span class="o">)</span>,同时SP下移<span class="o">(</span>入栈了肯定要下移<span class="o">)</span>
    2. call: IP指令指针跳转到B的地址处
    3. 执行B函数: 分配B需要的栈大小,比如24字节,直接将SP下移SP-24,分配B函数栈帧大小
    4. 执行B函数: 入栈BP寄存器中保存的A函数的栈底地址, A的栈底BP值保存在SP+16的位置,后续用于恢复
    5. 执行B函数: BP改为SP+16,这里假定16个字节是B函数的剩下的指令
RET: 函数返回
    6. 执行B函数: 首先需要恢复调用者A的BP,我们第4步入栈了,此时出栈就能得到A函数之前入栈保存的BP值
    7. 执行B函数: B函数执行完了,肯定要释放栈空间,所以SP+24
    8. RET: 继续出栈,此时就是第1步入栈的内容,
    9. RET: 跳转到出栈的地址,就是call调用后的位置
</code></pre></div><ul>
<li><a href="https://www.zhihu.com/zvideo/1308359170928799744">函数栈视频讲解</a></li>
<li><a href="https://blog.csdn.net/u011555996/article/details/80153141">x86汇编指令说明</a></li>
</ul>
<h3 id="函数栈">函数栈</h3>
<ul>
<li>栈,每个goroutine都有自己的栈, 一般顺序为 SP栈顶(低地址)-&gt;存储参数,返回值,局部变量-&gt;BP栈底(高地址)</li>
<li>栈帧,一个栈由多个栈帧组成, 每个函数对应一段栈帧,栈帧表示着函数间的调用关系</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
                                       <span class="nx">caller</span>                                                                                 
                                 <span class="o">+------------------+</span>                                                                         
                                 <span class="p">|</span>                  <span class="p">|</span>                                                                         
       <span class="o">+----------------------</span><span class="p">&gt;</span>  <span class="o">--------------------</span>                                                                         
       <span class="p">|</span>                         <span class="p">|</span>                  <span class="p">|</span>                                                                         
       <span class="p">|</span>                         <span class="p">|</span> <span class="nx">caller</span> <span class="nx">parent</span> <span class="nx">BP</span> <span class="p">|</span>                                                                         
       <span class="p">|</span>           <span class="nf">BP</span><span class="p">(</span><span class="nx">pseudo</span> <span class="nx">SP</span><span class="p">)</span> <span class="o">--------------------</span>                                                                         
       <span class="p">|</span>                         <span class="p">|</span>                  <span class="p">|</span>                                                                         
       <span class="p">|</span>                         <span class="p">|</span>   <span class="nx">Local</span> <span class="nx">VarX</span>     <span class="p">|</span>                                                                         
       <span class="p">|</span>                         <span class="o">--------------------</span>                                                                         
       <span class="p">|</span>                         <span class="p">|</span>                  <span class="p">|</span>                                                                         
       <span class="p">|</span>                         <span class="p">|</span>   <span class="o">......</span><span class="p">.</span>        <span class="p">|</span>                                                                         
       <span class="p">|</span>                         <span class="o">--------------------</span>                                                                         
       <span class="p">|</span>                         <span class="p">|</span>                  <span class="p">|</span>                                                                         
       <span class="p">|</span>                         <span class="p">|</span>   <span class="nx">Local</span> <span class="nx">VarN</span>     <span class="p">|</span>                                                                         
                                 <span class="o">--------------------</span>                                                                         
 <span class="nx">caller</span> <span class="nx">stack</span> <span class="nx">frame</span>              <span class="p">|</span>                  <span class="p">|</span>                                                                         
                                 <span class="p">|</span>   <span class="nx">callee</span> <span class="nx">arg2</span>    <span class="p">|</span>                                                                         
       <span class="p">|</span>                         <span class="p">|</span><span class="o">------------------</span><span class="p">|</span>                                                                         
       <span class="p">|</span>                         <span class="p">|</span>                  <span class="p">|</span>                                                                         
       <span class="p">|</span>                         <span class="p">|</span>   <span class="nx">callee</span> <span class="nx">arg1</span>    <span class="p">|</span>                                                                         
       <span class="p">|</span>                         <span class="p">|</span><span class="o">------------------</span><span class="p">|</span>                                                                         
       <span class="p">|</span>                         <span class="p">|</span>                  <span class="p">|</span>                                                                         
       <span class="p">|</span>                         <span class="p">|</span>   <span class="nx">callee</span> <span class="nx">arg0</span>    <span class="p">|</span>                                                                         
       <span class="p">|</span>                         <span class="o">----------------------------------------------+</span>   <span class="nf">FP</span><span class="p">(</span><span class="nx">virtual</span> <span class="nx">register</span><span class="p">)</span>                       
       <span class="p">|</span>                         <span class="p">|</span>                  <span class="p">|</span>                          <span class="p">|</span>                                              
       <span class="p">|</span>                         <span class="p">|</span>   <span class="k">return</span> <span class="nx">addr</span>    <span class="p">|</span>  <span class="nx">parent</span> <span class="k">return</span> <span class="nx">address</span>   <span class="p">|</span>                                              
       <span class="o">+----------------------</span><span class="p">&gt;</span>  <span class="o">+------------------+---------------------------</span>    <span class="o">&lt;-------------------------------+</span>         
                                                    <span class="p">|</span>  <span class="nx">caller</span> <span class="nx">BP</span>               <span class="p">|</span>                                    <span class="p">|</span>         
                                                    <span class="p">|</span>  <span class="p">(</span><span class="nx">caller</span> <span class="nx">frame</span> <span class="nx">pointer</span><span class="p">)</span>  <span class="p">|</span>                                    <span class="p">|</span>         
                                     <span class="nf">BP</span><span class="p">(</span><span class="nx">pseudo</span> <span class="nx">SP</span><span class="p">)</span>  <span class="o">----------------------------</span>                                    <span class="p">|</span>         
                                                    <span class="p">|</span>                          <span class="p">|</span>                                    <span class="p">|</span>         
                                                    <span class="p">|</span>     <span class="nx">Local</span> <span class="nx">Var0</span>           <span class="p">|</span>                                    <span class="p">|</span>         
                                                    <span class="o">----------------------------</span>                                    <span class="p">|</span>         
                                                    <span class="p">|</span>                          <span class="p">|</span>                                              
                                                    <span class="p">|</span>     <span class="nx">Local</span> <span class="nx">Var1</span>           <span class="p">|</span>                                              
                                                    <span class="o">----------------------------</span>                            <span class="nx">callee</span> <span class="nx">stack</span> <span class="nx">frame</span>
                                                    <span class="p">|</span>                          <span class="p">|</span>                                              
                                                    <span class="p">|</span>       <span class="o">...</span><span class="p">..</span>              <span class="p">|</span>                                              
                                                    <span class="o">----------------------------</span>                                    <span class="p">|</span>         
                                                    <span class="p">|</span>                          <span class="p">|</span>                                    <span class="p">|</span>         
                                                    <span class="p">|</span>     <span class="nx">Local</span> <span class="nx">VarN</span>           <span class="p">|</span>                                    <span class="p">|</span>         
                                  <span class="nf">SP</span><span class="p">(</span><span class="nx">Real</span> <span class="nx">Register</span><span class="p">)</span> <span class="o">----------------------------</span>                                    <span class="p">|</span>         
                                                    <span class="p">|</span>                          <span class="p">|</span>                                    <span class="p">|</span>         
                                                    <span class="p">|</span>                          <span class="p">|</span>                                    <span class="p">|</span>         
                                                    <span class="p">|</span>                          <span class="p">|</span>                                    <span class="p">|</span>         
                                                    <span class="p">|</span>                          <span class="p">|</span>                                    <span class="p">|</span>         
                                                    <span class="p">|</span>                          <span class="p">|</span>                                    <span class="p">|</span>         
                                                    <span class="o">+--------------------------+</span>    <span class="o">&lt;-------------------------------+</span>         

                                                              <span class="nx">callee</span>
</code></pre></div><ul>
<li><a href="https://www.bilibili.com/video/BV1Xb411J7Yk">曹大讲解go plan9汇编 视频</a></li>
<li><a href="https://github.com/cch123/asmshare/blob/master/layout.md">曹大讲解go plan9汇编 资料</a></li>
</ul>
<h3 id="例子1">例子1</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="err">#</span> <span class="nx">cat</span> <span class="nx">函数栈</span><span class="p">.</span><span class="k">go</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="c1">// go代码直接实现累加
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sumGo</span><span class="p">(</span><span class="nx">rl</span>  <span class="p">[]</span><span class="kt">int64</span><span class="p">)</span> <span class="kt">int64</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">a</span> <span class="kt">int64</span>
	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span> <span class="p">;</span><span class="nx">i</span> <span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">rl</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">a</span> <span class="o">+=</span> <span class="nx">rl</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">a</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">l</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int64</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">}</span>
	<span class="nf">sumGo</span><span class="p">(</span><span class="nx">l</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><blockquote>
<p>反编译或者编译的汇编结果看其一即可, 差别不大</p>
</blockquote>
<ul>
<li>反编译看汇编</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="err">#</span> <span class="nx">先build生成二进制</span>
<span class="k">go</span> <span class="nx">build</span> <span class="nx">函数栈</span><span class="p">.</span><span class="k">go</span>
<span class="err">#</span> <span class="nx">在反编译</span>
<span class="k">go</span> <span class="nx">tool</span> <span class="nx">objdump</span> <span class="nx">函数栈</span><span class="p">|</span><span class="nx">grep</span> <span class="s">&#34;函数栈.go&#34;</span>
</code></pre></div><ul>
<li>编译看汇编</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//MOV 指令有有好几种后缀 MOVB MOVW MOVL MOVQ 分别对应的是 1 字节 、2 字节 、4 字节、8 字节
</span><span class="c1"></span>
<span class="k">go</span> <span class="nx">tool</span> <span class="nx">compile</span> <span class="o">-</span><span class="nx">S</span> <span class="nx">函数栈</span><span class="p">.</span><span class="k">go</span><span class="p">|</span><span class="nx">egrep</span> <span class="s">&#34;函数栈.go|funcid&#34;</span>
<span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">sumGo</span> <span class="nx">STEXT</span> <span class="nx">nosplit</span> <span class="nx">size</span><span class="p">=</span><span class="mi">43</span> <span class="nx">args</span><span class="p">=</span><span class="mh">0x20</span> <span class="nx">locals</span><span class="p">=</span><span class="mh">0x0</span> <span class="nx">funcid</span><span class="p">=</span><span class="mh">0x0</span>
	<span class="mh">0x0000</span> <span class="mo">00000</span> <span class="p">(</span><span class="nx">函数栈</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">4</span><span class="p">)</span>	<span class="nx">TEXT</span>	<span class="s">&#34;&#34;</span><span class="p">.</span><span class="nf">sumGo</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">NOSPLIT</span><span class="p">|</span><span class="nx">ABIInternal</span><span class="p">,</span> <span class="err">$</span><span class="mi">0</span><span class="o">-</span><span class="mi">32</span>
	<span class="mh">0x0000</span> <span class="mo">00000</span> <span class="p">(</span><span class="nx">函数栈</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>	<span class="nx">MOVQ</span>	<span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">rl</span><span class="o">+</span><span class="mi">16</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span>  <span class="c1">// 这里都是物理sp寄存器, AX=len(rl),我们知道slice结构体是struct{array,len,cap},每个字段都是8字节
</span><span class="c1"></span>	<span class="mh">0x0005</span> <span class="mo">00005</span> <span class="p">(</span><span class="nx">函数栈</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>	<span class="nx">MOVQ</span>	<span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">rl</span><span class="o">+</span><span class="mi">8</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">CX</span>   <span class="c1">// CX=&amp;rl[0]
</span><span class="c1"></span>	<span class="mh">0x000a</span> <span class="mo">00010</span> <span class="p">(</span><span class="nx">函数栈</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>	<span class="nx">XORL</span>	<span class="nx">DX</span><span class="p">,</span> <span class="nx">DX</span>            <span class="c1">// 相同的值异或肯定都是0,DX=0
</span><span class="c1"></span>	<span class="mh">0x000c</span> <span class="mo">00012</span> <span class="p">(</span><span class="nx">函数栈</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>	<span class="nx">XORL</span>	<span class="nx">BX</span><span class="p">,</span> <span class="nx">BX</span>            <span class="c1">// BX=0
</span><span class="c1"></span>	<span class="mh">0x000e</span> <span class="mo">00014</span> <span class="p">(</span><span class="nx">函数栈</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>	<span class="nx">JMP</span>	<span class="mi">32</span>                    <span class="c1">// 跳到 32行 CMPQ	DX, AX
</span><span class="c1"></span>	<span class="mh">0x0010</span> <span class="mo">00016</span> <span class="p">(</span><span class="nx">函数栈</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>	<span class="nx">LEAQ</span>	<span class="mi">1</span><span class="p">(</span><span class="nx">DX</span><span class="p">),</span> <span class="nx">SI</span>         <span class="c1">//装入有效地址, 1(DX)偏移地址存入SI, SI= DX+1 ~ i+1
</span><span class="c1"></span>	<span class="mh">0x0014</span> <span class="mo">00020</span> <span class="p">(</span><span class="nx">函数栈</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>	<span class="nf">MOVQ</span>	<span class="p">(</span><span class="nx">CX</span><span class="p">)(</span><span class="nx">DX</span><span class="o">*</span><span class="mi">8</span><span class="p">),</span> <span class="nx">DI</span>    <span class="c1">// 指针*CX移动i*8字节? 所以 DI=rl[i]
</span><span class="c1"></span>	<span class="mh">0x0018</span> <span class="mo">00024</span> <span class="p">(</span><span class="nx">函数栈</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>	<span class="nx">ADDQ</span>	<span class="nx">DI</span><span class="p">,</span> <span class="nx">BX</span>            <span class="c1">// BX += DI  ~ += rl[i]
</span><span class="c1"></span>	<span class="mh">0x001b</span> <span class="mo">00027</span> <span class="p">(</span><span class="nx">函数栈</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>	<span class="nx">MOVQ</span>	<span class="nx">SI</span><span class="p">,</span> <span class="nx">DX</span>            <span class="c1">// DX = SI ~ i
</span><span class="c1"></span>	<span class="mh">0x001e</span> <span class="mo">00030</span> <span class="p">(</span><span class="nx">函数栈</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>	<span class="nx">NOP</span>                       <span class="c1">// 空操作?
</span><span class="c1"></span>	<span class="mh">0x0020</span> <span class="mo">00032</span> <span class="p">(</span><span class="nx">函数栈</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>	<span class="nx">CMPQ</span>	<span class="nx">DX</span><span class="p">,</span> <span class="nx">AX</span>            <span class="c1">// 比较DX是否小于AX ?
</span><span class="c1"></span>	<span class="mh">0x0023</span> <span class="mo">00035</span> <span class="p">(</span><span class="nx">函数栈</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>	<span class="nx">JLT</span>	<span class="mi">16</span>                    <span class="c1">// 小于 就跳转到16行
</span><span class="c1"></span>	<span class="mh">0x0025</span> <span class="mo">00037</span> <span class="p">(</span><span class="nx">函数栈</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">9</span><span class="p">)</span>	<span class="nx">MOVQ</span>	<span class="nx">BX</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">.</span><span class="err">~</span><span class="nx">r1</span><span class="o">+</span><span class="mi">32</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span> <span class="c1">// 否则 BX结果写到 32(SP)的栈中
</span><span class="c1"></span>	<span class="mh">0x002a</span> <span class="mo">00042</span> <span class="p">(</span><span class="nx">函数栈</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">9</span><span class="p">)</span>	<span class="nx">RET</span>
<span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">main</span> <span class="nx">STEXT</span> <span class="nx">nosplit</span> <span class="nx">size</span><span class="p">=</span><span class="mi">14</span> <span class="nx">args</span><span class="p">=</span><span class="mh">0x0</span> <span class="nx">locals</span><span class="p">=</span><span class="mh">0x0</span> <span class="nx">funcid</span><span class="p">=</span><span class="mh">0x0</span>
	<span class="mh">0x0000</span> <span class="mo">00000</span> <span class="p">(</span><span class="nx">函数栈</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">14</span><span class="p">)</span>	<span class="nx">TEXT</span>	<span class="s">&#34;&#34;</span><span class="p">.</span><span class="nf">main</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">NOSPLIT</span><span class="p">|</span><span class="nx">ABIInternal</span><span class="p">,</span> <span class="err">$</span><span class="mi">0</span><span class="o">-</span><span class="mi">0</span>
	<span class="mh">0x0000</span> <span class="mo">00000</span> <span class="p">(</span><span class="nx">函数栈</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">16</span><span class="p">)</span>	<span class="nx">XORL</span>	<span class="nx">AX</span><span class="p">,</span> <span class="nx">AX</span>
	<span class="mh">0x0002</span> <span class="mo">00002</span> <span class="p">(</span><span class="nx">函数栈</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>	<span class="nx">JMP</span>	<span class="mi">7</span>
	<span class="mh">0x0004</span> <span class="mo">00004</span> <span class="p">(</span><span class="nx">函数栈</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>	<span class="nx">INCQ</span>	<span class="nx">AX</span>
	<span class="mh">0x0007</span> <span class="mo">00007</span> <span class="p">(</span><span class="nx">函数栈</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>	<span class="nx">CMPQ</span>	<span class="nx">AX</span><span class="p">,</span> <span class="err">$</span><span class="mi">3</span>
	<span class="mh">0x000b</span> <span class="mo">00011</span> <span class="p">(</span><span class="nx">函数栈</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>	<span class="nx">JLT</span>	<span class="mi">4</span>
	<span class="mh">0x000d</span> <span class="mo">00013</span> <span class="p">(</span><span class="nx">函数栈</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">16</span><span class="p">)</span>	<span class="nx">RET</span>
</code></pre></div><h3 id="例子2">例子2</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//sum_amd64.s
</span><span class="c1"></span><span class="err">#</span><span class="nx">include</span> <span class="s">&#34;textflag.h&#34;</span>

<span class="c1">// func sumAsm(sl []int64) int64
</span><span class="c1"></span><span class="nx">TEXT</span> <span class="err">·</span><span class="nf">sumAsm</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">NOSPLIT</span><span class="p">,</span> <span class="err">$</span><span class="mi">0</span><span class="o">-</span><span class="mi">32</span>
    <span class="nx">MOVQ</span> <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nx">SI</span>
    <span class="nx">MOVQ</span> <span class="nx">sl</span><span class="o">+</span><span class="mi">0</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">BX</span> <span class="c1">// &amp;sl[0], addr of the first elem
</span><span class="c1"></span>    <span class="nx">MOVQ</span> <span class="nx">sl</span><span class="o">+</span><span class="mi">8</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">CX</span> <span class="c1">// len(sl)
</span><span class="c1"></span>    <span class="nx">INCQ</span> <span class="nx">CX</span>           <span class="c1">// CX++, 因为要循环 len 次
</span><span class="c1"></span>
<span class="nx">start</span><span class="p">:</span>
    <span class="nx">DECQ</span> <span class="nx">CX</span>       <span class="c1">// CX--
</span><span class="c1"></span>    <span class="nx">JZ</span>   <span class="nx">done</span>
    <span class="nf">ADDQ</span> <span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">SI</span> <span class="c1">// SI += *BX
</span><span class="c1"></span>    <span class="nx">ADDQ</span> <span class="err">$</span><span class="mi">8</span><span class="p">,</span> <span class="nx">BX</span>   <span class="c1">// 指针移动
</span><span class="c1"></span>    <span class="nx">JMP</span>  <span class="nx">start</span>

<span class="nx">done</span><span class="p">:</span>
    <span class="nx">MOVQ</span> <span class="nx">SI</span><span class="p">,</span> <span class="nx">ret</span><span class="o">+</span><span class="mi">24</span><span class="p">(</span><span class="nx">FP</span><span class="p">)</span>
    <span class="nx">RET</span>

<span class="c1">// 函数栈.go
</span><span class="c1">// go plan9实现累加
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sumAsm</span><span class="p">(</span><span class="nx">rl</span> <span class="p">[]</span><span class="kt">int64</span><span class="p">)</span> <span class="kt">int64</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">l</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int64</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">}</span>
	<span class="c1">// 当前目录执行 go build . , 然后执行二进制文件即可
</span><span class="c1"></span>	<span class="nf">sumAsm</span><span class="p">(</span><span class="nx">l</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3 id="plan9汇编的编写格式">plan9汇编的编写格式</h3>
<pre><code>                              参数及返回值大小
                                  |
 TEXT pkgname·add(SB),NOSPLIT,$32-32
       |        |               |
      包名     函数名         栈帧大小(局部变量+可能需要的额外调用函数的参数空间的总大小，但不包括调用其它函数时的 ret address 的大小)
</code></pre><h3 id="附录">附录</h3>
<ul>
<li><a href="https://golang.design/under-the-hood/zh-cn/part1basic/ch01basic/asm/">go语言原本</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Go学习 Channel源码分析</title>
			<link>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-channel%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
			<pubDate>Wed, 10 Nov 2021 15:18:42 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-channel%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
			<description>根据以下代码我们逐个看下channel的实现 package main /* $ go tool compile -S channel源码分析.go|grep runtime|grep chan|grep -v &amp;#34;print&amp;#34; 0x003a 00058 (channel源码分析.go:32)	CALL	runtime.newobject(SB) 0x0060 00096 (channel源码分析.go:32)	CALL	runtime.makechan(SB) 0x006a 00106 (channel源码分析.go:32)	CMPL	runtime.writeBarrier(SB), $0 0x0097 00151 (channel源码分析.go:34)	CALL	runtime.newproc(SB) 0x00b1 00177 (channel源码分析.go:40)	CALL	runtime.chanrecv1(SB) 0x00cb 00203 (channel源码分析.go:42)	CALL	runtime.chanrecv2(SB) 0x0100 00256 (channel源码分析.go:44)	CALL	runtime.chanrecv2(SB) 0x0120 00288 (channel源码分析.go:47)	CALL	runtime.makechan(SB) 0x012a 00298 (channel源码分析.go:47)	CMPL	runtime.writeBarrier(SB), $0 0x01eb 00491 (channel源码分析.go:50)	CALL	runtime.selectgo(SB) 0x02c0 00704 (channel源码分析.go:47)	CALL	runtime.</description>
			<content type="html"><![CDATA[<h3 id="根据以下代码我们逐个看下channel的实现">根据以下代码我们逐个看下channel的实现</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="cm">/*
</span><span class="cm">$ go tool compile -S channel源码分析.go|grep runtime|grep chan|grep -v &#34;print&#34;
</span><span class="cm">	0x003a 00058 (channel源码分析.go:32)	CALL	runtime.newobject(SB)
</span><span class="cm">	0x0060 00096 (channel源码分析.go:32)	CALL	runtime.makechan(SB)
</span><span class="cm">	0x006a 00106 (channel源码分析.go:32)	CMPL	runtime.writeBarrier(SB), $0
</span><span class="cm">	0x0097 00151 (channel源码分析.go:34)	CALL	runtime.newproc(SB)
</span><span class="cm">	0x00b1 00177 (channel源码分析.go:40)	CALL	runtime.chanrecv1(SB)
</span><span class="cm">	0x00cb 00203 (channel源码分析.go:42)	CALL	runtime.chanrecv2(SB)
</span><span class="cm">	0x0100 00256 (channel源码分析.go:44)	CALL	runtime.chanrecv2(SB)
</span><span class="cm">	0x0120 00288 (channel源码分析.go:47)	CALL	runtime.makechan(SB)
</span><span class="cm">	0x012a 00298 (channel源码分析.go:47)	CMPL	runtime.writeBarrier(SB), $0
</span><span class="cm">	0x01eb 00491 (channel源码分析.go:50)	CALL	runtime.selectgo(SB)
</span><span class="cm">	0x02c0 00704 (channel源码分析.go:47)	CALL	runtime.gcWriteBarrier(SB)
</span><span class="cm">	0x02d2 00722 (channel源码分析.go:32)	CALL	runtime.gcWriteBarrier(SB)
</span><span class="cm">	0x02e0 00736 (channel源码分析.go:30)	CALL	runtime.morestack_noctxt(SB)
</span><span class="cm">	rel 97+4 t=8 runtime.makechan+0
</span><span class="cm">	rel 178+4 t=8 runtime.chanrecv1+0
</span><span class="cm">	rel 204+4 t=8 runtime.chanrecv2+0
</span><span class="cm">	rel 257+4 t=8 runtime.chanrecv2+0
</span><span class="cm">	rel 289+4 t=8 runtime.makechan+0
</span><span class="cm">	0x0035 00053 (channel源码分析.go:35)	CALL	runtime.chansend1(SB)
</span><span class="cm">	0x0052 00082 (channel源码分析.go:36)	CALL	runtime.chansend1(SB)
</span><span class="cm">	0x0063 00099 (channel源码分析.go:37)	CALL	runtime.closechan(SB)
</span><span class="cm">	0x0072 00114 (channel源码分析.go:34)	CALL	runtime.morestack_noctxt(SB)
</span><span class="cm">	rel 54+4 t=8 runtime.chansend1+0
</span><span class="cm">	rel 83+4 t=8 runtime.chansend1+0
</span><span class="cm">	rel 100+4 t=8 runtime.closechan+0
</span><span class="cm">*/</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 1 runtime.makechan
</span><span class="c1"></span>	<span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span><span class="nb">int64</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">31</span><span class="p">))</span>
	<span class="c1">// 2 runtime.chansend1
</span><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">c</span> <span class="o">&lt;-</span> <span class="mi">1</span>
		<span class="nx">c</span> <span class="o">&lt;-</span> <span class="mi">2</span>
		<span class="nb">close</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
	<span class="p">}()</span>
	<span class="c1">// 3 runtime.chanrecv1
</span><span class="c1"></span>	<span class="o">&lt;-</span><span class="nx">c</span>
	<span class="c1">// 4 runtime.chanrecv2
</span><span class="c1"></span>	<span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="o">&lt;-</span><span class="nx">c</span>
	<span class="c1">//   runtime.chanrecv2
</span><span class="c1"></span>	<span class="k">for</span> <span class="k">range</span>  <span class="nx">c</span> <span class="p">{</span>
	<span class="p">}</span>
	<span class="c1">//print(a, ok)
</span><span class="c1"></span>	<span class="nx">c</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="nx">Loop</span><span class="p">:</span>
	<span class="c1">// 5 runtime.selectgo
</span><span class="c1"></span>	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">c</span> <span class="o">&lt;-</span> <span class="mi">1</span><span class="p">:</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;write\n&#34;</span><span class="p">)</span>
		<span class="k">goto</span> <span class="nx">Loop</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">c</span><span class="p">:</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;read1\n&#34;</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">c</span><span class="p">:</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;read2 &#34;</span><span class="p">,</span> <span class="nx">ok</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;default\n&#34;</span><span class="p">)</span>
	<span class="p">}</span>

<span class="p">}</span>


</code></pre></div><h3 id="1-channel的初始化和内存分配-runtimemakechan">1. channel的初始化和内存分配-runtime.makechan</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">hchan</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">qcount</span>   <span class="kt">uint</span>           <span class="c1">// queue 里面有效用户元素，这个字段是在元素出对，入队改变的；
</span><span class="c1"></span>    <span class="nx">dataqsiz</span> <span class="kt">uint</span>           <span class="c1">// 环大小,初始化的时候赋值，之后不再改变，指明数组 buffer 的大小；
</span><span class="c1"></span>    <span class="nx">buf</span>      <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 指明 buffer 数组的地址，初始化赋值，之后不会再改变；
</span><span class="c1"></span>    <span class="nx">elemsize</span> <span class="kt">uint16</span>         <span class="c1">// 指明元素的大小，和 dataqsiz 配合使用就能知道 buffer 内存块的大小了；
</span><span class="c1"></span>    <span class="nx">closed</span>   <span class="kt">uint32</span>
    <span class="nx">elemtype</span> <span class="o">*</span><span class="nx">_type</span>         <span class="c1">// 元素类型，初始化赋值；
</span><span class="c1"></span>    <span class="nx">sendx</span>    <span class="kt">uint</span>           <span class="c1">// send index
</span><span class="c1"></span>    <span class="nx">recvx</span>    <span class="kt">uint</span>           <span class="c1">// receive index
</span><span class="c1"></span>    <span class="nx">recvq</span>    <span class="nx">waitq</span>          <span class="c1">// 等待 recv 响应的对象列表，抽象成 waiters
</span><span class="c1"></span>    <span class="nx">sendq</span>    <span class="nx">waitq</span>          <span class="c1">// 等待 sedn 响应的对象列表，抽象成 waiters
</span><span class="c1"></span>    <span class="nx">lock</span>     <span class="nx">mutex</span>          <span class="c1">// 锁
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">waitq</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">first</span> <span class="o">*</span><span class="nx">sudog</span>       <span class="c1">//
</span><span class="c1"></span>	<span class="nx">last</span>  <span class="o">*</span><span class="nx">sudog</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">sudog</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">g</span> <span class="o">*</span><span class="nx">g</span>
	<span class="nx">next</span> <span class="o">*</span><span class="nx">sudog</span>        <span class="c1">// 链表下一个
</span><span class="c1"></span>	<span class="nx">prev</span> <span class="o">*</span><span class="nx">sudog</span>        <span class="c1">// 链表上一个
</span><span class="c1"></span>	<span class="nx">elem</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// data element (may point to stack)
</span><span class="c1"></span>    <span class="o">...</span>
	<span class="nx">isSelect</span> <span class="kt">bool</span>
	<span class="nx">success</span> <span class="kt">bool</span>
	<span class="nx">parent</span>   <span class="o">*</span><span class="nx">sudog</span> <span class="c1">// semaRoot binary tree
</span><span class="c1"></span>	<span class="nx">waitlink</span> <span class="o">*</span><span class="nx">sudog</span> <span class="c1">// g.waiting list or semaRoot
</span><span class="c1"></span>	<span class="nx">waittail</span> <span class="o">*</span><span class="nx">sudog</span> <span class="c1">// semaRoot
</span><span class="c1"></span>	<span class="nx">c</span>        <span class="o">*</span><span class="nx">hchan</span> <span class="c1">// channel
</span><span class="c1"></span><span class="p">}</span>

</code></pre></div><blockquote>
<p>这是我们初始化channel使用的make方法</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// makechan需要传入的参数也很明显, 就是make(chan int, 2) 中的两个参数
</span><span class="c1">// chantype=int 和 size=2
</span><span class="c1">// 这里返回的 *hchan 就是channel的结构体
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">makechan</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">chantype</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">hchan</span> <span class="p">{</span>
	<span class="nx">elem</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">elem</span>
    <span class="o">...</span>
    <span class="c1">// 这里mem 是 elem.size * uintptr(size)
</span><span class="c1"></span>	<span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">))</span>
    <span class="o">...</span>

	<span class="kd">var</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span>
	<span class="k">switch</span> <span class="p">{</span>
    <span class="c1">// size == 0
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">mem</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
		<span class="c1">// 这里hchanSize=0, 所以mallocgc函数直接返回了unsafe.Pointer(&amp;zerobase)
</span><span class="c1"></span>		<span class="nx">c</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">hchan</span><span class="p">)(</span><span class="nf">mallocgc</span><span class="p">(</span><span class="nx">hchanSize</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">()</span>

	<span class="k">case</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
		<span class="c1">// 元素不包括指针类型
</span><span class="c1"></span>		<span class="nx">c</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">hchan</span><span class="p">)(</span><span class="nf">mallocgc</span><span class="p">(</span><span class="nx">hchanSize</span><span class="o">+</span><span class="nx">mem</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">c</span><span class="p">),</span> <span class="nx">hchanSize</span><span class="p">)</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="c1">// 元素包含指针类型
</span><span class="c1"></span>		<span class="nx">c</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">hchan</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">mem</span><span class="p">,</span> <span class="nx">elem</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
	<span class="p">}</span>
    <span class="c1">// channel 元素大小，如果是 int，那么就是 8 字节；
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">elemsize</span> <span class="p">=</span> <span class="nb">uint16</span><span class="p">(</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
    <span class="c1">// channel的类型就是make的时候传入的类型, 例如chantype=int时,elem就是int的*_type
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span> <span class="p">=</span> <span class="nx">elem</span>
    <span class="c1">// channel的数组大小, cap容量
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">=</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span>
	<span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">lockRankHchan</span><span class="p">)</span>

    <span class="o">...</span>
	<span class="k">return</span> <span class="nx">c</span>
<span class="p">}</span>

</code></pre></div><h3 id="2-channel的接收方法-chanrecv">2. channel的接收方法-chanrecv</h3>
<ul>
<li>runtime.chanrecv1 其实是chanrecv的封装</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">chanrecv1</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">elem</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">chanrecv</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">elem</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>runtime.chanrecv2 也是chanrecv的封装</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">chanrecv2</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">elem</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">(</span><span class="nx">received</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">received</span> <span class="p">=</span> <span class="nf">chanrecv</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">elem</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></div><p>显而易见的是,他们传参都是一样, 只不过chanrecv2接收了bool的返回值
那另外一个true是什么意义呢?</p>
<ul>
<li>runtime.chanrecv</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">chanrecv</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">ep</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">block</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">(</span><span class="nx">selected</span><span class="p">,</span> <span class="nx">received</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">...</span>
    <span class="c1">// 如果没有make分配内存
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nf">gopark</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">waitReasonChanReceiveNilChan</span><span class="p">,</span> <span class="nx">traceEvGoStop</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;unreachable&#34;</span><span class="p">)</span>
	<span class="p">}</span>

    <span class="c1">// 如果block=false并且channel为空
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="o">&amp;&amp;</span> <span class="nf">empty</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 继续判断是否已经关闭了
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">closed</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
        <span class="c1">// 再次判断是防止判断是否关闭的时间段内 channel有数据
</span><span class="c1"></span>		<span class="k">if</span> <span class="nf">empty</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
				<span class="nf">raceacquire</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">ep</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>
    <span class="o">...</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
    <span class="c1">// 已经关闭的channel,但是并没有读到数据, 所以return true ,false
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
			<span class="nf">raceacquire</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
		<span class="p">}</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">ep</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span>
	<span class="p">}</span>
    <span class="c1">// 正常读取到数据的情况, 能从发送的队列中获取到非空, return true,true
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">();</span> <span class="nx">sg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">recv</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="nx">ep</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span> <span class="p">},</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span>
	<span class="p">}</span>
    <span class="c1">// channel数组长度大于0,有buf,说明队列可以接收
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="c1">// 从buf中取
</span><span class="c1"></span>		<span class="nx">qp</span> <span class="o">:=</span> <span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
			<span class="nf">racenotify</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">ep</span><span class="p">,</span> <span class="nx">qp</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">qp</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="o">++</span>
        <span class="c1">// 环
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span><span class="o">--</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span>
	<span class="p">}</span>
    <span class="c1">// block=false,也就是在select{} 中,所以return false,false 直接跳过
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span>
	<span class="p">}</span>
    <span class="c1">// 获取当前的g
</span><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
    <span class="c1">// 需要一个sudog
</span><span class="c1"></span>	<span class="nx">mysg</span> <span class="o">:=</span> <span class="nf">acquireSudog</span><span class="p">()</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="k">if</span> <span class="nx">t0</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
	<span class="p">}</span>
    <span class="c1">// 把当前这个接收方ep保存到sudog的elem中
</span><span class="c1"></span>	<span class="nx">mysg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="nx">ep</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">waitlink</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="nx">mysg</span>
    <span class="c1">// 设置sudog的g
</span><span class="c1"></span>	<span class="nx">mysg</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nx">gp</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">isSelect</span> <span class="p">=</span> <span class="kc">false</span>
    <span class="c1">// 设置sudog的channel
</span><span class="c1"></span>	<span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="nx">c</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="c1">// 把这个sudog放到 接收双向队列中,所以sudog这个等待队列中是保存了阻塞的g 和channel的
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>

	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store8</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">parkingOnChan</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1">// goroutine切换,下面会具体分析, 这里会阻塞
</span><span class="c1"></span>	<span class="nf">gopark</span><span class="p">(</span><span class="nx">chanparkcommit</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">),</span> <span class="nx">waitReasonChanReceive</span><span class="p">,</span> <span class="nx">traceEvGoBlockRecv</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

	<span class="c1">// 切换goroutine的时候会保留现场, 当恢复是可以继续执行
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">mysg</span> <span class="o">!=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;G waiting list is corrupted&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">activeStackChans</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="k">if</span> <span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">blockevent</span><span class="p">(</span><span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span><span class="o">-</span><span class="nx">t0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">success</span> <span class="o">:=</span> <span class="nx">mysg</span><span class="p">.</span><span class="nx">success</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="c1">// 从sudog队列删除
</span><span class="c1"></span>	<span class="nf">releaseSudog</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">success</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>recv</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">recv</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">sg</span> <span class="o">*</span><span class="nx">sudog</span><span class="p">,</span> <span class="nx">ep</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">unlockf</span> <span class="kd">func</span><span class="p">(),</span> <span class="nx">skip</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>   <span class="c1">// 如果是同步的
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
			<span class="nf">racesync</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">sg</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>    <span class="c1">//并且接受者不等于nil
</span><span class="c1"></span>			<span class="c1">// copy data from sender
</span><span class="c1"></span>            <span class="c1">// sg 是发送方队列
</span><span class="c1"></span>            <span class="c1">// ep 是接收方
</span><span class="c1"></span>            <span class="c1">// 直接从发送方 copy到接收方, 不通过channel buf
</span><span class="c1"></span>			<span class="nf">recvDirect</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="nx">ep</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 根据索引得到缓存队列的buf
</span><span class="c1"></span>		<span class="nx">qp</span> <span class="o">:=</span> <span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
			<span class="nf">racenotify</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
			<span class="nf">racenotify</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">,</span> <span class="nx">sg</span><span class="p">)</span>
		<span class="p">}</span>
        <span class="c1">// 从channel的buf队列拷贝数据到接收方
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">ep</span><span class="p">,</span> <span class="nx">qp</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// 如果ep是nil,说明buf没有元素了
</span><span class="c1"></span>		<span class="c1">// 直接从发送方的sudog队列 写到 buf中
</span><span class="c1"></span>		<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">qp</span><span class="p">,</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="o">++</span>
		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="c1">// c.sendx = (c.sendx+1) % c.dataqsiz
</span><span class="c1"></span>	<span class="p">}</span>
    <span class="c1">// 发送方已经读过了, 设置为nil
</span><span class="c1"></span>	<span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="c1">// 得到发送方的goroutine
</span><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">g</span>
    <span class="c1">// 释放锁
</span><span class="c1"></span>	<span class="nf">unlockf</span><span class="p">()</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sg</span><span class="p">)</span>
	<span class="nx">sg</span><span class="p">.</span><span class="nx">success</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="k">if</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nf">goready</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">skip</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>    <span class="c1">//将 gp 作为下一个立即被执行的 Goroutine
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">recvDirect</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">sg</span> <span class="o">*</span><span class="nx">sudog</span><span class="p">,</span> <span class="nx">dst</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// dst is on our stack or the heap, src is on another stack.
</span><span class="c1"></span>	<span class="c1">// The channel is locked, so src will not move during this
</span><span class="c1"></span>	<span class="c1">// operation.
</span><span class="c1"></span>	<span class="nx">src</span> <span class="o">:=</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span>
	<span class="nf">typeBitsBulkBarrier</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">dst</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">src</span><span class="p">),</span> <span class="nx">t</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
	<span class="nf">memmove</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">src</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>gopark</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gopark</span><span class="p">(</span><span class="nx">unlockf</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">lock</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">reason</span> <span class="nx">waitReason</span><span class="p">,</span> <span class="nx">traceEv</span> <span class="kt">byte</span><span class="p">,</span> <span class="nx">traceskip</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">reason</span> <span class="o">!=</span> <span class="nx">waitReasonSleep</span> <span class="p">{</span>
		<span class="nf">checkTimeouts</span><span class="p">()</span> <span class="c1">// timeouts may expire while two goroutines keep the scheduler busy
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">curg</span>
	<span class="nx">status</span> <span class="o">:=</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">status</span> <span class="o">!=</span> <span class="nx">_Grunning</span> <span class="o">&amp;&amp;</span> <span class="nx">status</span> <span class="o">!=</span> <span class="nx">_Gscanrunning</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gopark: bad g status&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">waitlock</span> <span class="p">=</span> <span class="nx">lock</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">waitunlockf</span> <span class="p">=</span> <span class="nx">unlockf</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">waitreason</span> <span class="p">=</span> <span class="nx">reason</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">waittraceev</span> <span class="p">=</span> <span class="nx">traceEv</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">waittraceskip</span> <span class="p">=</span> <span class="nx">traceskip</span>
	<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
	<span class="nf">mcall</span><span class="p">(</span><span class="nx">park_m</span><span class="p">)</span>  <span class="c1">// 这是核心代码
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><ul>
<li>park_m</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// park continuation on g0.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">park_m</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
    <span class="c1">// 更新gp状态由_Grunning 为 _Gwaiting
</span><span class="c1"></span>	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">)</span>
    <span class="c1">// 移除gp与m的绑定关系
</span><span class="c1"></span>	<span class="nf">dropg</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">fn</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">waitunlockf</span><span class="p">;</span> <span class="nx">fn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">ok</span> <span class="o">:=</span> <span class="nf">fn</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">waitlock</span><span class="p">)</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">waitunlockf</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">waitlock</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
				<span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
			<span class="nf">execute</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span> <span class="c1">// Schedule it back, never returns.
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>
    <span class="c1">// 重新调度goroutine
</span><span class="c1"></span>	<span class="nf">schedule</span><span class="p">()</span> <span class="c1">// schedule() -&gt; execute() -&gt; gogo
</span><span class="c1"></span><span class="p">}</span>

</code></pre></div><ul>
<li>gogo 通过gobuf恢复g</li>
</ul>
<pre><code>// func gogo(buf *gobuf)
// restore state from Gobuf; longjmp
TEXT runtime·gogo(SB), NOSPLIT, $16-8
	MOVQ	buf+0(FP), BX		// gobuf
	MOVQ	gobuf_g(BX), DX
	MOVQ	0(DX), CX		// make sure g != nil
	get_tls(CX)
	MOVQ	DX, g(CX)
	MOVQ	gobuf_sp(BX), SP	// restore SP
	MOVQ	gobuf_ret(BX), AX
	MOVQ	gobuf_ctxt(BX), DX
	MOVQ	gobuf_bp(BX), BP
	MOVQ	$0, gobuf_sp(BX)	// clear to help garbage collector
	MOVQ	$0, gobuf_ret(BX)
	MOVQ	$0, gobuf_ctxt(BX)
	MOVQ	$0, gobuf_bp(BX)
	MOVQ	gobuf_pc(BX), BX
	JMP	BX
</code></pre><ul>
<li>mcall</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 在.go文件中,如下没有函数体, 所以asm定义的$0表示没有内部变量,只有一个参数没有返回值,所以是$8
</span><span class="c1">// runtime/asm_amd64.s
</span><span class="c1">// func mcall(fn func(*g))
</span><span class="c1">// 切换到m-&gt;g0的栈上,调用fn(g)函数
</span><span class="c1">// fn函数不能返回,它应该调用gogo(&amp;g-&gt;sched)来运行g
</span><span class="c1">// 注意这个·是UTF8值=U+00B7,并不是英文的.
</span><span class="c1"></span><span class="nx">TEXT</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">mcall</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">NOSPLIT</span><span class="p">,</span> <span class="err">$</span><span class="mi">0</span><span class="o">-</span><span class="mi">8</span>
	<span class="nx">MOVQ</span>	<span class="nx">fn</span><span class="o">+</span><span class="mi">0</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">DI</span>  <span class="c1">//FP是当前栈帧起始地址, fn函数指针存到DI寄存器
</span><span class="c1"></span>	<span class="nf">get_tls</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>    <span class="c1">//tls 是线程局部存储，将这个存储的开始位置存到 CX
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">),</span> <span class="nx">AX</span>	<span class="c1">// g(CX)还是宏，在tls上可以拿到g，也就是当前正在跑的g，把这个g的地址存到AX寄存器
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="mi">0</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">BX</span>	<span class="c1">// caller&#39;s PC
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nx">BX</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_pc</span><span class="p">)(</span><span class="nx">AX</span><span class="p">)</span>    <span class="c1">//把BX(caller&#39;s PC)存入到AX的g-&gt;sched的gobuf-&gt;pc字段
</span><span class="c1"></span>	<span class="nx">LEAQ</span>	<span class="nx">fn</span><span class="o">+</span><span class="mi">0</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">BX</span>	<span class="c1">// caller&#39;s SP, fn函数
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nx">BX</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_sp</span><span class="p">)(</span><span class="nx">AX</span><span class="p">)</span>    <span class="c1">//把BX(caller&#39;s SP)存入到AX的g-&gt;sched的gobuf-&gt;sp字段
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nx">AX</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_g</span><span class="p">)(</span><span class="nx">AX</span><span class="p">)</span>     <span class="c1">//把g本身也存起来
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nx">BP</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_bp</span><span class="p">)(</span><span class="nx">AX</span><span class="p">)</span>    <span class="c1">//把BP(当前栈底)存入到AX的g-&gt;sched的gobuf-&gt;bp字段
</span><span class="c1"></span>
	<span class="c1">// switch to m-&gt;g0 &amp; its stack, call fn
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">),</span> <span class="nx">BX</span>     <span class="c1">//把g存入BX
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nf">g_m</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">BX</span>   <span class="c1">//根据g得到m存入BX
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nf">m_g0</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">SI</span>  <span class="c1">//根据m得到g0存入SI
</span><span class="c1"></span>	<span class="nx">CMPQ</span>	<span class="nx">SI</span><span class="p">,</span> <span class="nx">AX</span>	<span class="c1">// if g == m-&gt;g0 call badmcall
</span><span class="c1"></span>	<span class="nx">JNE</span>	<span class="mi">3</span><span class="p">(</span><span class="nx">PC</span><span class="p">)</span>      <span class="c1">//JNE表示不等于的时候转移, if g != m-&gt;g0 , 那就跳3行
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="err">$</span><span class="nx">runtime</span><span class="err">·</span><span class="nf">badmcall</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>         
	<span class="nx">JMP</span>	<span class="nx">AX</span>
	<span class="nx">MOVQ</span>	<span class="nx">SI</span><span class="p">,</span> <span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>	<span class="c1">// g = m-&gt;g0, 直接把SI的m-&gt;g0 复制给g, 那现在的g就是m-&gt;g0, 成功切换到g0
</span><span class="c1"></span>	<span class="nf">MOVQ</span>	<span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_sp</span><span class="p">)(</span><span class="nx">SI</span><span class="p">),</span> <span class="nx">SP</span>	<span class="c1">// sp = m-&gt;g0-&gt;sched.sp, 直接拿g0中的sp值给SP寄存器了
</span><span class="c1"></span>	<span class="nx">PUSHQ</span>	<span class="nx">AX</span>        <span class="c1">//AX就是g,将g入栈保存
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nx">DI</span><span class="p">,</span> <span class="nx">DX</span>    <span class="c1">//DI里面保存的是fn函数, 现在存入到DX
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="mi">0</span><span class="p">(</span><span class="nx">DI</span><span class="p">),</span> <span class="nx">DI</span>
	<span class="nx">CALL</span>	<span class="nx">DI</span>        <span class="c1">//调用fn
</span><span class="c1"></span>	<span class="nx">POPQ</span>	<span class="nx">AX</span>        <span class="c1">//将g出栈
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="err">$</span><span class="nx">runtime</span><span class="err">·</span><span class="nf">badmcall2</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>
	<span class="nx">JMP</span>	<span class="nx">AX</span>
	<span class="nx">RET</span>    <span class="c1">//return
</span></code></pre></div><h3 id="3-channel的发送方法-chansend">3. channel的发送方法-chansend</h3>
<ul>
<li>runtime.chansend1 是对runtime.chansend的封装</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">chansend1</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">elem</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">chansend</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">elem</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="nf">getcallerpc</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>runtime.chansend</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">chansend</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">ep</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">block</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">callerpc</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c1">// 如果是个nil的channel
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="c1">// 如果是在select中, 那么直接返回false,不会选中
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
        <span class="c1">// goroutine切换
</span><span class="c1"></span>		<span class="nf">gopark</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">waitReasonChanSendNilChan</span><span class="p">,</span> <span class="nx">traceEvGoStop</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;unreachable&#34;</span><span class="p">)</span>
	<span class="p">}</span>
    <span class="o">...</span>
    <span class="c1">// block=fasle 并且c没有关闭 并且 c满了, 此时也不能发送成功的
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nf">full</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">t0</span> <span class="kt">int64</span>
	<span class="k">if</span> <span class="nx">blockprofilerate</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">t0</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
	<span class="p">}</span>
    <span class="c1">// 开启锁
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
    <span class="c1">// 关闭了的channel不能send
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;send on closed channel&#34;</span><span class="p">))</span>
	<span class="p">}</span>
    <span class="c1">// 能从接受的队列返回非空,dequeue()是从链表首部取出
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">();</span> <span class="nx">sg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="c1">// 这里send -&gt; goready -&gt; ready
</span><span class="c1"></span>		<span class="nf">send</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="nx">ep</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span> <span class="p">},</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>
    <span class="c1">// qcount还没有达到最大值, channel未满
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="p">&lt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
        <span class="c1">// sendx是索引, chanbuf会通过c.buf初始地址+索引*c.elemsize(元素类型大小)得到 send的地址
</span><span class="c1"></span>		<span class="nx">qp</span> <span class="o">:=</span> <span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
			<span class="nf">racenotify</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">qp</span><span class="p">,</span> <span class="nx">ep</span><span class="p">)</span>
        <span class="c1">// 索引递增
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="o">++</span>
        <span class="c1">// 环
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span>
        <span class="c1">//len()递增
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span><span class="o">++</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>
    <span class="c1">// 如果block=false, select的情况时间return false跳过case情况即可
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">mysg</span> <span class="o">:=</span> <span class="nf">acquireSudog</span><span class="p">()</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="k">if</span> <span class="nx">t0</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
	<span class="p">}</span>
	<span class="c1">// No stack splits between assigning elem and enqueuing mysg
</span><span class="c1"></span>	<span class="c1">// on gp.waiting where copystack can find it.
</span><span class="c1"></span>	<span class="nx">mysg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="nx">ep</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">waitlink</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nx">gp</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">isSelect</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="nx">c</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="nx">mysg</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store8</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">parkingOnChan</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1">// 这里阻塞
</span><span class="c1"></span>	<span class="nf">gopark</span><span class="p">(</span><span class="nx">chanparkcommit</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">),</span> <span class="nx">waitReasonChanSend</span><span class="p">,</span> <span class="nx">traceEvGoBlockSend</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

	<span class="nf">KeepAlive</span><span class="p">(</span><span class="nx">ep</span><span class="p">)</span>

	<span class="c1">// 唤醒逻辑
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">mysg</span> <span class="o">!=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;G waiting list is corrupted&#34;</span><span class="p">)</span>
	<span class="p">}</span>
    <span class="c1">//
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">activeStackChans</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="nx">closed</span> <span class="o">:=</span> <span class="p">!</span><span class="nx">mysg</span><span class="p">.</span><span class="nx">success</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="k">if</span> <span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">blockevent</span><span class="p">(</span><span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span><span class="o">-</span><span class="nx">t0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nf">releaseSudog</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">closed</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;chansend: spurious wakeup&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;send on closed channel&#34;</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

</code></pre></div><h3 id="4-channel的关闭方法-chanclose">4. channel的关闭方法-chanclose</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 传参是个channel
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">closechan</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// nil的会panic
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;close of nil channel&#34;</span><span class="p">))</span>
	<span class="p">}</span>
    <span class="c1">// 锁
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
    <span class="c1">// 已经close的不能再次close
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;close of closed channel&#34;</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="o">...</span>
    <span class="c1">// 设置为已经关闭
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="p">=</span> <span class="mi">1</span>
    <span class="c1">// glist用于保存g
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">glist</span> <span class="nx">gList</span>
    <span class="c1">// 释放接收方
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
        <span class="c1">// 循环取 接收方队列
</span><span class="c1"></span>		<span class="nx">sg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>
        <span class="c1">// 如果第一个都是nil了, 直接break
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">sg</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
        <span class="c1">// 清理
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span><span class="p">)</span>
			<span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">g</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sg</span><span class="p">)</span>
		<span class="nx">sg</span><span class="p">.</span><span class="nx">success</span> <span class="p">=</span> <span class="kc">false</span>
		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
			<span class="nf">raceacquireg</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
		<span class="p">}</span>
		<span class="nx">glist</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
	<span class="p">}</span>
    <span class="c1">// 是否发送方, 可能导致panic
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">sg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">sg</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="k">if</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">g</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sg</span><span class="p">)</span>
		<span class="nx">sg</span><span class="p">.</span><span class="nx">success</span> <span class="p">=</span> <span class="kc">false</span>
		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
			<span class="nf">raceacquireg</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
		<span class="p">}</span>
		<span class="nx">glist</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// Ready all Gs now that we&#39;ve dropped the channel lock.
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">!</span><span class="nx">glist</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">glist</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">schedlink</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nf">goready</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>    <span class="c1">//将 gp 作为下一个立即被执行的 Goroutine
</span><span class="c1"></span>	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h3 id="5-select-的逻辑">5. select 的逻辑</h3>
<ul>
<li>首先看下空的select</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">select</span> <span class="p">{}</span>
<span class="p">}</span>
<span class="c1">// 这里直接被优化为block
</span><span class="c1"></span><span class="k">go</span> <span class="nx">tool</span> <span class="nx">compile</span> <span class="o">-</span><span class="nx">S</span> <span class="k">select</span><span class="o">/</span><span class="nx">select源码分析</span><span class="p">.</span><span class="k">go</span><span class="p">|</span><span class="nx">grep</span> <span class="nx">runtime</span>
	<span class="mh">0x0020</span> <span class="mo">00032</span> <span class="p">(</span><span class="k">select</span><span class="o">/</span><span class="nx">select源码分析</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">4</span><span class="p">)</span>	<span class="nx">CALL</span>	<span class="nx">runtime</span><span class="p">.</span><span class="nf">block</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
	<span class="mh">0x0026</span> <span class="mo">0003</span><span class="mi">8</span> <span class="p">(</span><span class="k">select</span><span class="o">/</span><span class="nx">select源码分析</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">3</span><span class="p">)</span>	<span class="nx">CALL</span>	<span class="nx">runtime</span><span class="p">.</span><span class="nf">morestack_noctxt</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
	<span class="nx">rel</span> <span class="mi">33</span><span class="o">+</span><span class="mi">4</span> <span class="nx">t</span><span class="p">=</span><span class="mi">8</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">block</span><span class="o">+</span><span class="mi">0</span>
	<span class="nx">rel</span> <span class="mi">39</span><span class="o">+</span><span class="mi">4</span> <span class="nx">t</span><span class="p">=</span><span class="mi">8</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">morestack_noctxt</span><span class="o">+</span><span class="mi">0</span>
</code></pre></div><ul>
<li>仅default,没有case的情况</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">select</span> <span class="p">{</span>
	<span class="k">default</span><span class="p">:</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 这里更是优化什么也没执行
</span><span class="c1"></span><span class="k">go</span> <span class="nx">tool</span> <span class="nx">compile</span> <span class="o">-</span><span class="nx">S</span> <span class="k">select</span><span class="o">/</span><span class="nx">select源码分析</span><span class="p">.</span><span class="k">go</span>
<span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">main</span> <span class="nx">STEXT</span> <span class="nx">nosplit</span> <span class="nx">size</span><span class="p">=</span><span class="mi">1</span> <span class="nx">args</span><span class="p">=</span><span class="mh">0x0</span> <span class="nx">locals</span><span class="p">=</span><span class="mh">0x0</span> <span class="nx">funcid</span><span class="p">=</span><span class="mh">0x0</span>
	<span class="mh">0x0000</span> <span class="mo">00000</span> <span class="p">(</span><span class="k">select</span><span class="o">/</span><span class="nx">select源码分析</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">3</span><span class="p">)</span>	<span class="nx">TEXT</span>	<span class="s">&#34;&#34;</span><span class="p">.</span><span class="nf">main</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">NOSPLIT</span><span class="p">|</span><span class="nx">ABIInternal</span><span class="p">,</span> <span class="err">$</span><span class="mi">0</span><span class="o">-</span><span class="mi">0</span>
	<span class="mh">0x0000</span> <span class="mo">00000</span> <span class="p">(</span><span class="k">select</span><span class="o">/</span><span class="nx">select源码分析</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>	<span class="nx">RET</span>
</code></pre></div><ul>
<li>仅一个case的时候</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">c</span> <span class="o">&lt;-</span> <span class="mi">1</span><span class="p">:</span>   <span class="c1">// 会优化为if c &lt;- 1 {}
</span><span class="c1"></span>	<span class="k">default</span><span class="p">:</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 这里会直接调用到 runtime.selectnbsend ,如果是读就调用 runtime.selectnbrecv
</span><span class="c1"></span><span class="k">go</span> <span class="nx">tool</span> <span class="nx">compile</span> <span class="o">-</span><span class="nx">S</span> <span class="k">select</span><span class="o">/</span><span class="nx">select源码分析</span><span class="p">.</span><span class="k">go</span><span class="p">|</span><span class="nx">grep</span> <span class="nx">runtime</span>
	<span class="mh">0x0031</span> <span class="mo">0004</span><span class="mi">9</span> <span class="p">(</span><span class="k">select</span><span class="o">/</span><span class="nx">select源码分析</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">4</span><span class="p">)</span>	<span class="nx">CALL</span>	<span class="nx">runtime</span><span class="p">.</span><span class="nf">makechan</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
	<span class="mh">0x0057</span> <span class="mo">000</span><span class="mi">87</span> <span class="p">(</span><span class="k">select</span><span class="o">/</span><span class="nx">select源码分析</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>	<span class="nx">CALL</span>	<span class="nx">runtime</span><span class="p">.</span><span class="nf">selectnbsend</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
	<span class="mh">0x0080</span> <span class="mo">0012</span><span class="mi">8</span> <span class="p">(</span><span class="k">select</span><span class="o">/</span><span class="nx">select源码分析</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">3</span><span class="p">)</span>	<span class="nx">CALL</span>	<span class="nx">runtime</span><span class="p">.</span><span class="nf">morestack_noctxt</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>

<span class="c1">// selectnbsend是一个带bool返回值的chansend的封装
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">selectnbsend</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">elem</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">(</span><span class="nx">selected</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">chansend</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">elem</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="nf">getcallerpc</span><span class="p">())</span>
<span class="p">}</span>

<span class="c1">// selectnbrecv同样是一个带bool返回值的chanrecv的封装
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">selectnbrecv</span><span class="p">(</span><span class="nx">elem</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">)</span> <span class="p">(</span><span class="nx">selected</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">selected</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nf">chanrecv</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">elem</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>超过一个case的时候</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">c</span> <span class="o">&lt;-</span> <span class="mi">1</span><span class="p">:</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">c</span><span class="p">:</span>
	<span class="k">default</span><span class="p">:</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 这里会直接调用到selectgo, heap sort随机化分支的触发顺序
</span><span class="c1"></span><span class="k">go</span> <span class="nx">tool</span> <span class="nx">compile</span> <span class="o">-</span><span class="nx">S</span> <span class="k">select</span><span class="o">/</span><span class="nx">select源码分析</span><span class="p">.</span><span class="k">go</span><span class="p">|</span><span class="nx">grep</span> <span class="nx">runtime</span>
	<span class="mh">0x0035</span> <span class="mo">00053</span> <span class="p">(</span><span class="k">select</span><span class="o">/</span><span class="nx">select源码分析</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">4</span><span class="p">)</span>	<span class="nx">CALL</span>	<span class="nx">runtime</span><span class="p">.</span><span class="nf">makechan</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
	<span class="mh">0x00a1</span> <span class="mo">00161</span> <span class="p">(</span><span class="k">select</span><span class="o">/</span><span class="nx">select源码分析</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>	<span class="nx">CALL</span>	<span class="nx">runtime</span><span class="p">.</span><span class="nf">selectgo</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
	<span class="mh">0x00d5</span> <span class="mo">00213</span> <span class="p">(</span><span class="k">select</span><span class="o">/</span><span class="nx">select源码分析</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">3</span><span class="p">)</span>	<span class="nx">CALL</span>	<span class="nx">runtime</span><span class="p">.</span><span class="nf">morestack_noctxt</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
</code></pre></div><ul>
<li>selectgo</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">scase</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">c</span>    <span class="o">*</span><span class="nx">hchan</span>         <span class="c1">// chan
</span><span class="c1"></span>	<span class="nx">elem</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// data element
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">selectgo</span><span class="p">(</span><span class="nx">cas0</span> <span class="o">*</span><span class="nx">scase</span><span class="p">,</span> <span class="nx">order0</span> <span class="o">*</span><span class="kt">uint16</span><span class="p">,</span> <span class="nx">pc0</span> <span class="o">*</span><span class="kt">uintptr</span><span class="p">,</span> <span class="nx">nsends</span><span class="p">,</span> <span class="nx">nrecvs</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">block</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">..</span>
	<span class="c1">// NOTE: In order to maintain a lean stack size, the number of scases
</span><span class="c1"></span>	<span class="c1">// is capped at 65536.
</span><span class="c1"></span>	<span class="nx">cas1</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">]</span><span class="nx">scase</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">cas0</span><span class="p">))</span>
	<span class="nx">order1</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">17</span><span class="p">]</span><span class="kt">uint16</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">order0</span><span class="p">))</span>
    <span class="c1">// 用于记录chan和data
</span><span class="c1"></span>	<span class="nx">ncases</span> <span class="o">:=</span> <span class="nx">nsends</span> <span class="o">+</span> <span class="nx">nrecvs</span>
	<span class="nx">scases</span> <span class="o">:=</span> <span class="nx">cas1</span><span class="p">[:</span><span class="nx">ncases</span><span class="p">:</span><span class="nx">ncases</span><span class="p">]</span>
    <span class="c1">// 存储channel的scases数组的索引,控制channel执行顺序
</span><span class="c1"></span>	<span class="nx">pollorder</span> <span class="o">:=</span> <span class="nx">order1</span><span class="p">[:</span><span class="nx">ncases</span><span class="p">:</span><span class="nx">ncases</span><span class="p">]</span>
    <span class="c1">// 随机锁
</span><span class="c1"></span>	<span class="nx">lockorder</span> <span class="o">:=</span> <span class="nx">order1</span><span class="p">[</span><span class="nx">ncases</span><span class="p">:][:</span><span class="nx">ncases</span><span class="p">:</span><span class="nx">ncases</span><span class="p">]</span>
    <span class="o">...</span>
    <span class="c1">// 这里主要是对scase中的chan判断是否nil,做一个elem初始化
</span><span class="c1"></span>    <span class="c1">// 另外对pollorder 进行随机处理
</span><span class="c1"></span>    <span class="nx">norder</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">scases</span> <span class="p">{</span>
		<span class="nx">cas</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">scases</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>

		<span class="c1">// Omit cases without channels from the poll and lock orders.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="kc">nil</span> <span class="c1">// allow GC
</span><span class="c1"></span>			<span class="k">continue</span>
		<span class="p">}</span>
        <span class="c1">// 首先随机生成一个uint32的j
</span><span class="c1"></span>		<span class="nx">j</span> <span class="o">:=</span> <span class="nf">fastrandn</span><span class="p">(</span><span class="nb">uint32</span><span class="p">(</span><span class="nx">norder</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="c1">// 然后从pollorder从把j索引的值覆盖给 norder的位置
</span><span class="c1"></span>		<span class="nx">pollorder</span><span class="p">[</span><span class="nx">norder</span><span class="p">]</span> <span class="p">=</span> <span class="nx">pollorder</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
        <span class="c1">// 把scases数组的索引, 存入到pollorder数组中
</span><span class="c1"></span>		<span class="nx">pollorder</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint16</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
        <span class="c1">// norder &lt;= i
</span><span class="c1"></span>		<span class="nx">norder</span><span class="o">++</span>
	<span class="p">}</span>
    <span class="c1">// norder &lt;= i的, 所以pollorder中不包括cas.c==nil的chan
</span><span class="c1"></span>	<span class="nx">pollorder</span> <span class="p">=</span> <span class="nx">pollorder</span><span class="p">[:</span><span class="nx">norder</span><span class="p">]</span>
	<span class="nx">lockorder</span> <span class="p">=</span> <span class="nx">lockorder</span><span class="p">[:</span><span class="nx">norder</span><span class="p">]</span>

    <span class="c1">// 堆排
</span><span class="c1"></span>	<span class="c1">// sort the cases by Hchan address to get the locking order.
</span><span class="c1"></span>	<span class="c1">// simple heap sort, to guarantee n log n time and constant stack footprint.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">lockorder</span> <span class="p">{</span>
		<span class="nx">j</span> <span class="o">:=</span> <span class="nx">i</span>
		<span class="c1">// Start with the pollorder to permute cases on the same channel.
</span><span class="c1"></span>		<span class="nx">c</span> <span class="o">:=</span> <span class="nx">scases</span><span class="p">[</span><span class="nx">pollorder</span><span class="p">[</span><span class="nx">i</span><span class="p">]].</span><span class="nx">c</span>
        <span class="c1">// 这里的sortkey() 就是hchan的地址
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">j</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">scases</span><span class="p">[</span><span class="nx">lockorder</span><span class="p">[(</span><span class="nx">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">]].</span><span class="nx">c</span><span class="p">.</span><span class="nf">sortkey</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">c</span><span class="p">.</span><span class="nf">sortkey</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">k</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
			<span class="nx">lockorder</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">lockorder</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span>
			<span class="nx">j</span> <span class="p">=</span> <span class="nx">k</span>
		<span class="p">}</span>
		<span class="nx">lockorder</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">pollorder</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">lockorder</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="nx">o</span> <span class="o">:=</span> <span class="nx">lockorder</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">c</span> <span class="o">:=</span> <span class="nx">scases</span><span class="p">[</span><span class="nx">o</span><span class="p">].</span><span class="nx">c</span>
		<span class="nx">lockorder</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">lockorder</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="nx">k</span> <span class="o">:=</span> <span class="nx">j</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
			<span class="k">if</span> <span class="nx">k</span> <span class="o">&gt;=</span> <span class="nx">i</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">k</span><span class="o">+</span><span class="mi">1</span> <span class="p">&lt;</span> <span class="nx">i</span> <span class="o">&amp;&amp;</span> <span class="nx">scases</span><span class="p">[</span><span class="nx">lockorder</span><span class="p">[</span><span class="nx">k</span><span class="p">]].</span><span class="nx">c</span><span class="p">.</span><span class="nf">sortkey</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">scases</span><span class="p">[</span><span class="nx">lockorder</span><span class="p">[</span><span class="nx">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]].</span><span class="nx">c</span><span class="p">.</span><span class="nf">sortkey</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">k</span><span class="o">++</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nf">sortkey</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">scases</span><span class="p">[</span><span class="nx">lockorder</span><span class="p">[</span><span class="nx">k</span><span class="p">]].</span><span class="nx">c</span><span class="p">.</span><span class="nf">sortkey</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">lockorder</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">lockorder</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span>
				<span class="nx">j</span> <span class="p">=</span> <span class="nx">k</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">lockorder</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">o</span>
	<span class="p">}</span>
    <span class="o">...</span>
	<span class="c1">// 所有chan加锁
</span><span class="c1"></span>	<span class="nf">sellock</span><span class="p">(</span><span class="nx">scases</span><span class="p">,</span> <span class="nx">lockorder</span><span class="p">)</span>

	<span class="kd">var</span> <span class="p">(</span>
		<span class="nx">gp</span>     <span class="o">*</span><span class="nx">g</span>
		<span class="nx">sg</span>     <span class="o">*</span><span class="nx">sudog</span>
		<span class="nx">c</span>      <span class="o">*</span><span class="nx">hchan</span>
		<span class="nx">k</span>      <span class="o">*</span><span class="nx">scase</span>
		<span class="nx">sglist</span> <span class="o">*</span><span class="nx">sudog</span>
		<span class="nx">sgnext</span> <span class="o">*</span><span class="nx">sudog</span>
		<span class="nx">qp</span>     <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
		<span class="nx">nextp</span>  <span class="o">**</span><span class="nx">sudog</span>
	<span class="p">)</span>

	<span class="c1">// 1  检查chan是否就绪(可send or recv)
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">casi</span> <span class="kt">int</span>
	<span class="kd">var</span> <span class="nx">cas</span> <span class="o">*</span><span class="nx">scase</span>
	<span class="kd">var</span> <span class="nx">caseSuccess</span> <span class="kt">bool</span>
	<span class="kd">var</span> <span class="nx">caseReleaseTime</span> <span class="kt">int64</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
	<span class="kd">var</span> <span class="nx">recvOK</span> <span class="kt">bool</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">casei</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">pollorder</span> <span class="p">{</span>
        <span class="c1">//
</span><span class="c1"></span>		<span class="nx">casi</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">casei</span><span class="p">)</span>
		<span class="nx">cas</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">scases</span><span class="p">[</span><span class="nx">casi</span><span class="p">]</span>
		<span class="nx">c</span> <span class="p">=</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">c</span>

		<span class="k">if</span> <span class="nx">casi</span> <span class="o">&gt;=</span> <span class="nx">nsends</span> <span class="p">{</span>
			<span class="nx">sg</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">sg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="nx">recv</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="nx">bufrecv</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="nx">rclose</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
				<span class="nf">racereadpc</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">(),</span> <span class="nf">casePC</span><span class="p">(</span><span class="nx">casi</span><span class="p">),</span> <span class="nx">chansendpc</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="nx">sclose</span>
			<span class="p">}</span>
			<span class="nx">sg</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">sg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="nx">send</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="p">&lt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="nx">bufsend</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
    <span class="c1">// 这里block是通过reflect_rselect函数中判断dflt==-1传入的, dflt只有在case default存在的时候才被修改
</span><span class="c1"></span>    <span class="c1">// 所以如果select中没有写default, 到这里后续就要阻塞了
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
		<span class="nf">selunlock</span><span class="p">(</span><span class="nx">scases</span><span class="p">,</span> <span class="nx">lockorder</span><span class="p">)</span>
		<span class="nx">casi</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
		<span class="k">goto</span> <span class="nx">retc</span>
	<span class="p">}</span>

	<span class="c1">// 2 入队所有的chan, 阻塞之前当然要保留case后阻塞的channel
</span><span class="c1"></span>	<span class="nx">gp</span> <span class="p">=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gp.waiting != nil&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">nextp</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">casei</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">lockorder</span> <span class="p">{</span>
		<span class="nx">casi</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">casei</span><span class="p">)</span>
		<span class="nx">cas</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">scases</span><span class="p">[</span><span class="nx">casi</span><span class="p">]</span>
		<span class="nx">c</span> <span class="p">=</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">c</span>
		<span class="nx">sg</span> <span class="o">:=</span> <span class="nf">acquireSudog</span><span class="p">()</span>
		<span class="nx">sg</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nx">gp</span>
		<span class="nx">sg</span><span class="p">.</span><span class="nx">isSelect</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="c1">// No stack splits between assigning elem and enqueuing
</span><span class="c1"></span>		<span class="c1">// sg on gp.waiting where copystack can find it.
</span><span class="c1"></span>		<span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span>
		<span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="k">if</span> <span class="nx">t0</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
		<span class="p">}</span>
		<span class="nx">sg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="nx">c</span>
		<span class="c1">// Construct waiting list in lock order.
</span><span class="c1"></span>		<span class="o">*</span><span class="nx">nextp</span> <span class="p">=</span> <span class="nx">sg</span>
		<span class="nx">nextp</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">sg</span><span class="p">.</span><span class="nx">waitlink</span>
        <span class="c1">// 对channel进行入队保存
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">casi</span> <span class="p">&lt;</span> <span class="nx">nsends</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="nx">sg</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="nx">sg</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store8</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">parkingOnChan</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1">// 阻塞
</span><span class="c1"></span>	<span class="nf">gopark</span><span class="p">(</span><span class="nx">selparkcommit</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">waitReasonSelect</span><span class="p">,</span> <span class="nx">traceEvGoBlockSelect</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">activeStackChans</span> <span class="p">=</span> <span class="kc">false</span>

	<span class="nf">sellock</span><span class="p">(</span><span class="nx">scases</span><span class="p">,</span> <span class="nx">lockorder</span><span class="p">)</span>

	<span class="nx">gp</span><span class="p">.</span><span class="nx">selectDone</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">sg</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">sudog</span><span class="p">)(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">param</span><span class="p">)</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>

	<span class="c1">// pass 3 - dequeue from unsuccessful chans
</span><span class="c1"></span>	<span class="c1">// otherwise they stack up on quiet channels
</span><span class="c1"></span>	<span class="c1">// record the successful case, if any.
</span><span class="c1"></span>	<span class="c1">// We singly-linked up the SudoGs in lock order.
</span><span class="c1"></span>	<span class="nx">casi</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
	<span class="nx">cas</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">caseSuccess</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="nx">sglist</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span>
	<span class="c1">// Clear all elem before unlinking from gp.waiting.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">sg1</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span><span class="p">;</span> <span class="nx">sg1</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">sg1</span> <span class="p">=</span> <span class="nx">sg1</span><span class="p">.</span><span class="nx">waitlink</span> <span class="p">{</span>
		<span class="nx">sg1</span><span class="p">.</span><span class="nx">isSelect</span> <span class="p">=</span> <span class="kc">false</span>
		<span class="nx">sg1</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="nx">sg1</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="kc">nil</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">casei</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">lockorder</span> <span class="p">{</span>
		<span class="nx">k</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">scases</span><span class="p">[</span><span class="nx">casei</span><span class="p">]</span>
		<span class="k">if</span> <span class="nx">sg</span> <span class="o">==</span> <span class="nx">sglist</span> <span class="p">{</span>
			<span class="c1">// sg has already been dequeued by the G that woke us up.
</span><span class="c1"></span>			<span class="nx">casi</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">casei</span><span class="p">)</span>
			<span class="nx">cas</span> <span class="p">=</span> <span class="nx">k</span>
			<span class="nx">caseSuccess</span> <span class="p">=</span> <span class="nx">sglist</span><span class="p">.</span><span class="nx">success</span>
			<span class="k">if</span> <span class="nx">sglist</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">caseReleaseTime</span> <span class="p">=</span> <span class="nx">sglist</span><span class="p">.</span><span class="nx">releasetime</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">c</span> <span class="p">=</span> <span class="nx">k</span><span class="p">.</span><span class="nx">c</span>
			<span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="nx">casei</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">nsends</span> <span class="p">{</span>
				<span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">dequeueSudoG</span><span class="p">(</span><span class="nx">sglist</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">dequeueSudoG</span><span class="p">(</span><span class="nx">sglist</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">sgnext</span> <span class="p">=</span> <span class="nx">sglist</span><span class="p">.</span><span class="nx">waitlink</span>
		<span class="nx">sglist</span><span class="p">.</span><span class="nx">waitlink</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="nf">releaseSudog</span><span class="p">(</span><span class="nx">sglist</span><span class="p">)</span>
		<span class="nx">sglist</span> <span class="p">=</span> <span class="nx">sgnext</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">cas</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;selectgo: bad wakeup&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">c</span> <span class="p">=</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">c</span>

	<span class="k">if</span> <span class="nx">debugSelect</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;wait-return: cas0=&#34;</span><span class="p">,</span> <span class="nx">cas0</span><span class="p">,</span> <span class="s">&#34; c=&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="s">&#34; cas=&#34;</span><span class="p">,</span> <span class="nx">cas</span><span class="p">,</span> <span class="s">&#34; send=&#34;</span><span class="p">,</span> <span class="nx">casi</span> <span class="p">&lt;</span> <span class="nx">nsends</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">casi</span> <span class="p">&lt;</span> <span class="nx">nsends</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">caseSuccess</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="nx">sclose</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">recvOK</span> <span class="p">=</span> <span class="nx">caseSuccess</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">casi</span> <span class="p">&lt;</span> <span class="nx">nsends</span> <span class="p">{</span>
			<span class="nf">raceReadObjectPC</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nf">casePC</span><span class="p">(</span><span class="nx">casi</span><span class="p">),</span> <span class="nx">chansendpc</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">raceWriteObjectPC</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nf">casePC</span><span class="p">(</span><span class="nx">casi</span><span class="p">),</span> <span class="nx">chanrecvpc</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">msanenabled</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">casi</span> <span class="p">&lt;</span> <span class="nx">nsends</span> <span class="p">{</span>
			<span class="nf">msanread</span><span class="p">(</span><span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">msanwrite</span><span class="p">(</span><span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nf">selunlock</span><span class="p">(</span><span class="nx">scases</span><span class="p">,</span> <span class="nx">lockorder</span><span class="p">)</span>
	<span class="k">goto</span> <span class="nx">retc</span>

<span class="nx">bufrecv</span><span class="p">:</span>
	<span class="c1">// can receive from buffer
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">raceWriteObjectPC</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nf">casePC</span><span class="p">(</span><span class="nx">casi</span><span class="p">),</span> <span class="nx">chanrecvpc</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nf">racenotify</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">msanenabled</span> <span class="o">&amp;&amp;</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">msanwrite</span><span class="p">(</span><span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">recvOK</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="nx">qp</span> <span class="p">=</span> <span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">qp</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">qp</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="o">++</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span><span class="o">--</span>
	<span class="nf">selunlock</span><span class="p">(</span><span class="nx">scases</span><span class="p">,</span> <span class="nx">lockorder</span><span class="p">)</span>
	<span class="k">goto</span> <span class="nx">retc</span>

<span class="nx">bufsend</span><span class="p">:</span>
	<span class="c1">// can send to buffer
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nf">racenotify</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="nf">raceReadObjectPC</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nf">casePC</span><span class="p">(</span><span class="nx">casi</span><span class="p">),</span> <span class="nx">chansendpc</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">msanenabled</span> <span class="p">{</span>
		<span class="nf">msanread</span><span class="p">(</span><span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="p">),</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="o">++</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span><span class="o">++</span>
	<span class="nf">selunlock</span><span class="p">(</span><span class="nx">scases</span><span class="p">,</span> <span class="nx">lockorder</span><span class="p">)</span>
	<span class="k">goto</span> <span class="nx">retc</span>

<span class="nx">recv</span><span class="p">:</span>
	<span class="c1">// can receive from sleeping sender (sg)
</span><span class="c1"></span>	<span class="nf">recv</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nf">selunlock</span><span class="p">(</span><span class="nx">scases</span><span class="p">,</span> <span class="nx">lockorder</span><span class="p">)</span> <span class="p">},</span> <span class="mi">2</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">debugSelect</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;syncrecv: cas0=&#34;</span><span class="p">,</span> <span class="nx">cas0</span><span class="p">,</span> <span class="s">&#34; c=&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">recvOK</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="k">goto</span> <span class="nx">retc</span>

<span class="nx">rclose</span><span class="p">:</span>
	<span class="c1">// read at end of closed channel
</span><span class="c1"></span>	<span class="nf">selunlock</span><span class="p">(</span><span class="nx">scases</span><span class="p">,</span> <span class="nx">lockorder</span><span class="p">)</span>
	<span class="nx">recvOK</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="k">if</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nf">raceacquire</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
	<span class="p">}</span>
	<span class="k">goto</span> <span class="nx">retc</span>

<span class="nx">send</span><span class="p">:</span>
	<span class="c1">// can send to a sleeping receiver (sg)
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nf">raceReadObjectPC</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nf">casePC</span><span class="p">(</span><span class="nx">casi</span><span class="p">),</span> <span class="nx">chansendpc</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">msanenabled</span> <span class="p">{</span>
		<span class="nf">msanread</span><span class="p">(</span><span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">send</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nf">selunlock</span><span class="p">(</span><span class="nx">scases</span><span class="p">,</span> <span class="nx">lockorder</span><span class="p">)</span> <span class="p">},</span> <span class="mi">2</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">debugSelect</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;syncsend: cas0=&#34;</span><span class="p">,</span> <span class="nx">cas0</span><span class="p">,</span> <span class="s">&#34; c=&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">goto</span> <span class="nx">retc</span>

<span class="nx">retc</span><span class="p">:</span>
	<span class="k">if</span> <span class="nx">caseReleaseTime</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">blockevent</span><span class="p">(</span><span class="nx">caseReleaseTime</span><span class="o">-</span><span class="nx">t0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">casi</span><span class="p">,</span> <span class="nx">recvOK</span>

<span class="nx">sclose</span><span class="p">:</span>
	<span class="c1">// send on closed channel
</span><span class="c1"></span>	<span class="nf">selunlock</span><span class="p">(</span><span class="nx">scases</span><span class="p">,</span> <span class="nx">lockorder</span><span class="p">)</span>
	<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;send on closed channel&#34;</span><span class="p">))</span>
<span class="p">}</span>

</code></pre></div><blockquote>
<p>具体的select如果优化可以查看 <code>cmd/compile/internal/gc/select.go</code>的<code>walkselectcases</code>函数</p>
</blockquote>
<h3 id="简单总结">简单总结</h3>
<ul>
<li>
<p>channel</p>
<ul>
<li>
<ol>
<li>channel的实现核心结构体hchan, 主要实现是一个环型buf数组,阻塞的时候会添加到一个waitq的双向链表中</li>
</ol>
</li>
<li>
<ol start="2">
<li>双向链表通过sudog实现,sudog会记录goroutine,elem,channel等状态,等到非阻塞时直接将elem地址的内容给发送者或接受者,或者添加到对应channel的buf中</li>
</ol>
</li>
<li>
<ol start="3">
<li>channel的底层都是通过chanrecv和chansend来实现, selectgo主要是通过block的设置来实现非阻塞操作</li>
</ol>
</li>
<li>
<ol start="4">
<li>chanrecv和chansend都是需要通过锁来操作的, 本质是通过共享内存的方式实现的</li>
</ol>
</li>
</ul>
</li>
<li>
<p>select</p>
<ul>
<li>
<ol>
<li>select的selectgo的实现主要是通过block参数设置调用chanrecv或chansend 实现非阻塞操作, 当select中存在default分支时,block在为false,其他情况都是阻塞操作</li>
</ol>
</li>
<li>
<ol start="2">
<li>selectgo 会将每个case的channel索引组成的数组pollorder 进行随机排序 并同时剔除nil channel, 如果存在可发送或者可读取的case 就直接跳转, 如果都没有就判断是否block(即走default),最后会阻塞等待</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="附录">附录</h3>
<blockquote>
<p>bilibili的声音延迟需要设置, youtube正常</p>
</blockquote>
<ul>
<li><a href="https://www.youtube.com/watch?v=d7fFCGGn0Wc">go夜读 channel和select源码分析 youtube</a></li>
<li><a href="https://www.bilibili.com/video/av64926593/">go夜读 channel和select源码分析 bilibili</a></li>
<li><a href="https://docs.google.com/presentation/d/18_9LcMc8u93aITZ6DqeUfRvOcHQYj2gwxhskf0XPX2U/edit#slide=id.g5f3bb3206c_0_5">go夜读 channel和select源码分析 ppt文档</a></li>
<li><a href="https://golang.design/under-the-hood/zh-cn/part1basic/ch03lang/chan/">go语言原本</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/297053654">golang channel 最详细的源码剖析</a></li>
<li><a href="https://blog.csdn.net/a52219600830369/article/details/101143124">golang mcall</a></li>
<li><a href="https://blog.csdn.net/u010853261/article/details/85887948">gopark和goready函数</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Go算法学习 链表 设计链表</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E9%93%BE%E8%A1%A8-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</link>
			<pubDate>Fri, 16 Jul 2021 14:07:27 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E9%93%BE%E8%A1%A8-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</guid>
			<description>show me the code package main import ( &amp;#34;fmt&amp;#34; ) // https://leetcode-cn.com/problems/design-linked-list/  type MyLinkedList struct { Len int // 判断索引是否有效 	Dummy *Node // 伪头, 第-1号索引, .Next 才是 MyLinkedList的第0号索引的内容 } type Node struct { Val int // value 	Next *Node // 链 } // Constructor Initialize your data structure here. func Constructor() MyLinkedList { return MyLinkedList{ Len: 0, // 不包括伪头, 所以是0 	Dummy: &amp;amp;Node{}, // 初始化伪头 	} } // Get the value of the index-th node in the linked list.</description>
			<content type="html"><![CDATA[<h3 id="show-me-the-code">show me the code</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="c1">// https://leetcode-cn.com/problems/design-linked-list/
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">MyLinkedList</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Len</span>   <span class="kt">int</span>   <span class="c1">// 判断索引是否有效
</span><span class="c1"></span>	<span class="nx">Dummy</span> <span class="o">*</span><span class="nx">Node</span> <span class="c1">// 伪头, 第-1号索引, .Next 才是 MyLinkedList的第0号索引的内容
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">Node</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Val</span>  <span class="kt">int</span>   <span class="c1">// value
</span><span class="c1"></span>	<span class="nx">Next</span> <span class="o">*</span><span class="nx">Node</span> <span class="c1">// 链
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// Constructor Initialize your data structure here.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Constructor</span><span class="p">()</span> <span class="nx">MyLinkedList</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">MyLinkedList</span><span class="p">{</span>
		<span class="nx">Len</span><span class="p">:</span>   <span class="mi">0</span><span class="p">,</span>       <span class="c1">// 不包括伪头, 所以是0
</span><span class="c1"></span>		<span class="nx">Dummy</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">Node</span><span class="p">{},</span> <span class="c1">// 初始化伪头
</span><span class="c1"></span>	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Get the value of the index-th node in the linked list. If the index is invalid, return -1.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">my</span> <span class="o">*</span><span class="nx">MyLinkedList</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">index</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c1">// 索引范围是 [0,my.Len),左闭右开
</span><span class="c1"></span>	<span class="c1">// 所以需要小于my.Len
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">index</span> <span class="o">&gt;=</span> <span class="nx">my</span><span class="p">.</span><span class="nx">Len</span> <span class="o">&amp;&amp;</span> <span class="nx">index</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
	<span class="p">}</span>
	<span class="c1">// 指向第0号元素
</span><span class="c1"></span>	<span class="nx">curr</span> <span class="o">:=</span> <span class="nx">my</span><span class="p">.</span><span class="nx">Dummy</span><span class="p">.</span><span class="nx">Next</span>
	<span class="c1">// 找到索引位置
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">;</span> <span class="nx">index</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">index</span><span class="o">--</span> <span class="p">{</span>
		<span class="nx">curr</span> <span class="p">=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Next</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Val</span>
<span class="p">}</span>

<span class="c1">// AddAtHead Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">my</span> <span class="o">*</span><span class="nx">MyLinkedList</span><span class="p">)</span> <span class="nf">AddAtHead</span><span class="p">(</span><span class="nx">val</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">my</span><span class="p">.</span><span class="nf">AddAtIndex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// AddAtTail Append a node of value val to the last element of the linked list. */
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">my</span> <span class="o">*</span><span class="nx">MyLinkedList</span><span class="p">)</span> <span class="nf">AddAtTail</span><span class="p">(</span><span class="nx">val</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">my</span><span class="p">.</span><span class="nf">AddAtIndex</span><span class="p">(</span><span class="nx">my</span><span class="p">.</span><span class="nx">Len</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// AddAtIndex  Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">my</span> <span class="o">*</span><span class="nx">MyLinkedList</span><span class="p">)</span> <span class="nf">AddAtIndex</span><span class="p">(</span><span class="nx">index</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">index</span> <span class="p">&gt;</span> <span class="nx">my</span><span class="p">.</span><span class="nx">Len</span> <span class="o">||</span> <span class="nx">index</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">//  指向第-1号元素(伪头)
</span><span class="c1"></span>	<span class="nx">pre</span> <span class="o">:=</span> <span class="nx">my</span><span class="p">.</span><span class="nx">Dummy</span>
	<span class="c1">// 找到需要删除的索引位置的前置节点pre
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">;</span> <span class="nx">index</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">index</span><span class="o">--</span> <span class="p">{</span>
		<span class="nx">pre</span> <span class="p">=</span> <span class="nx">pre</span><span class="p">.</span><span class="nx">Next</span>
	<span class="p">}</span>
	<span class="c1">// 插入
</span><span class="c1"></span>	<span class="nx">pre</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Node</span><span class="p">{</span><span class="nx">val</span><span class="p">,</span> <span class="nx">pre</span><span class="p">.</span><span class="nx">Next</span><span class="p">}</span>
	<span class="nx">my</span><span class="p">.</span><span class="nx">Len</span><span class="o">++</span>

<span class="p">}</span>

<span class="c1">// DeleteAtIndex Delete the index-th node in the linked list, if the index is valid.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">my</span> <span class="o">*</span><span class="nx">MyLinkedList</span><span class="p">)</span> <span class="nf">DeleteAtIndex</span><span class="p">(</span><span class="nx">index</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 索引是从0到my.Len-1的, 所以大于等于 都是直接return
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">index</span> <span class="o">&gt;=</span> <span class="nx">my</span><span class="p">.</span><span class="nx">Len</span> <span class="o">&amp;&amp;</span> <span class="nx">index</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// 指向第-1号元素(伪头)
</span><span class="c1"></span>	<span class="nx">pre</span> <span class="o">:=</span> <span class="nx">my</span><span class="p">.</span><span class="nx">Dummy</span>
	<span class="c1">// 找到需要删除的索引位置的前置节点pre
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">;</span> <span class="nx">index</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">index</span><span class="o">--</span> <span class="p">{</span>
		<span class="nx">pre</span> <span class="p">=</span> <span class="nx">pre</span><span class="p">.</span><span class="nx">Next</span>
	<span class="p">}</span>
	<span class="c1">// 通过前置节点pre 直接删除对应索引的节点
</span><span class="c1"></span>	<span class="nx">pre</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">pre</span><span class="p">.</span><span class="nx">Next</span><span class="p">.</span><span class="nx">Next</span>
	<span class="nx">my</span><span class="p">.</span><span class="nx">Len</span><span class="o">--</span>
<span class="p">}</span>

<span class="cm">/**
</span><span class="cm"> * Your MyLinkedList object will be instantiated and called as such:
</span><span class="cm"> * obj := Constructor();
</span><span class="cm"> * param_1 := obj.Get(index);
</span><span class="cm"> * obj.AddAtHead(val);
</span><span class="cm"> * obj.AddAtTail(val);
</span><span class="cm"> * obj.AddAtIndex(index,val);
</span><span class="cm"> * obj.DeleteAtIndex(index);
</span><span class="cm"> */</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">my</span> <span class="o">*</span><span class="nx">MyLinkedList</span><span class="p">)</span> <span class="nf">Print</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">curr</span> <span class="o">:=</span> <span class="nx">my</span><span class="p">.</span><span class="nx">Dummy</span><span class="p">.</span><span class="nx">Next</span>
	<span class="k">for</span> <span class="nx">curr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v &#34;</span><span class="p">,</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
		<span class="nx">curr</span> <span class="p">=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Next</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">my</span> <span class="o">*</span><span class="nx">MyLinkedList</span><span class="p">)</span> <span class="nf">Run</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">val</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="nx">s</span> <span class="p">{</span>
	<span class="k">case</span> <span class="s">&#34;addAtHead&#34;</span><span class="p">:</span>
		<span class="nx">my</span><span class="p">.</span><span class="nf">AddAtHead</span><span class="p">(</span><span class="nx">val</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="k">case</span> <span class="s">&#34;addAtTail&#34;</span><span class="p">:</span>
		<span class="nx">my</span><span class="p">.</span><span class="nf">AddAtTail</span><span class="p">(</span><span class="nx">val</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="k">case</span> <span class="s">&#34;addAtIndex&#34;</span><span class="p">:</span>
		<span class="nx">my</span><span class="p">.</span><span class="nf">AddAtIndex</span><span class="p">(</span><span class="nx">val</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">val</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
	<span class="k">case</span> <span class="s">&#34;deleteAtIndex&#34;</span><span class="p">:</span>
		<span class="nx">my</span><span class="p">.</span><span class="nf">DeleteAtIndex</span><span class="p">(</span><span class="nx">val</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="k">case</span> <span class="s">&#34;get&#34;</span><span class="p">:</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">my</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;unknown function &#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Run function :&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="s">&#34;args :&#34;</span><span class="p">,</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">my</span><span class="p">.</span><span class="nx">Len</span><span class="p">)</span>

<span class="p">}</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">func1</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;addAtHead&#34;</span><span class="p">,</span> <span class="s">&#34;addAtTail&#34;</span><span class="p">,</span> <span class="s">&#34;addAtIndex&#34;</span><span class="p">,</span> <span class="s">&#34;get&#34;</span><span class="p">,</span> <span class="s">&#34;deleteAtIndex&#34;</span><span class="p">,</span> <span class="s">&#34;get&#34;</span><span class="p">}</span>
	<span class="nx">args1</span> <span class="o">:=</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">{{</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">3</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">}}</span>

	<span class="nx">myLink</span> <span class="o">:=</span> <span class="nf">Constructor</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">func1</span> <span class="p">{</span>
		<span class="nx">myLink</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="nx">func1</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">args1</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="nx">myLink</span><span class="p">.</span><span class="nf">Print</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go算法学习 动态规划 01背包基础</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-01%E8%83%8C%E5%8C%85%E5%9F%BA%E7%A1%80/</link>
			<pubDate>Mon, 07 Jun 2021 10:06:09 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-01%E8%83%8C%E5%8C%85%E5%9F%BA%E7%A1%80/</guid>
			<description>参考文档  carl 背包理论基础01背包 二维dp carl 背包理论基础01背包 一维dp  背包问题分类 01背包例子 题目说明: 有一堆物品, 背包的容量只有j,想要拿走最贵的东西,怎么装? weight := []int{1,3,4} //kg price := []int{15,20,30} //¥  01背包说明: 每个物品只能使用一次
 动态规划五部曲 1. 定义dp数组 这里我们定义一个dp[i][j]的数组 i代表 物品的下标,0,1,2&amp;hellip; j代表 背包的容量,1kg,3kg,4kg&amp;hellip; dp[i][j]代表 可选的i个物品中,容量为j的背包能装下最大为dp[i][j]的价值
 这里i个物品 是有两种状态, 选择 和不选择
 2. 确定推导公式 首先我们可以想到i个物品的dp[i][j] 是可以由 i-1个物品的情况下, 选择i转入背包 和不装入背包两种情况得到的 那不装入物品i的价值 = dp[i-1][j] 那装入了物品i的价值 = dp[i-1][j-weight[i]] + price[i], 显然装了东西, 背包容量肯定减少, 总价值肯定是增加 那我们dp[i][j] 应该选择哪种情况呢? 答案是选择更大价值的 dp[i][j] = max(dp[i-1][j] , dp[i-1][j-weight[i]] + price[i] ) 3.</description>
			<content type="html"><![CDATA[<h3 id="参考文档">参考文档</h3>
<ul>
<li><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.md">carl 背包理论基础01背包 二维dp</a></li>
<li><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.md">carl 背包理论基础01背包 一维dp</a></li>
</ul>
<h3 id="背包问题分类">背包问题分类</h3>
<p><img src="/assets/markdown-img-paste-20210607100754609.png" alt=""></p>
<h3 id="01背包例子">01背包例子</h3>
<h4 id="题目说明">题目说明:</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">有一堆物品</span><span class="p">,</span> <span class="nx">背包的容量只有j</span><span class="p">,</span><span class="nx">想要拿走最贵的东西</span><span class="p">,</span><span class="nx">怎么装</span><span class="err">?</span>
<span class="nx">weight</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">}</span>  <span class="c1">//kg
</span><span class="c1"></span><span class="nx">price</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">15</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">}</span>    <span class="c1">//¥
</span></code></pre></div><blockquote>
<p>01背包说明: 每个物品只能使用一次</p>
</blockquote>
<h3 id="动态规划五部曲">动态规划五部曲</h3>
<h4 id="1-定义dp数组">1. 定义dp数组</h4>
<p>这里我们定义一个dp[i][j]的数组
i代表 物品的下标,0,1,2&hellip;
j代表 背包的容量,1kg,3kg,4kg&hellip;
dp[i][j]代表 可选的i个物品中,容量为j的背包能装下最大为dp[i][j]的价值</p>
<blockquote>
<p>这里i个物品 是有两种状态, 选择 和不选择</p>
</blockquote>
<h4 id="2-确定推导公式">2. 确定推导公式</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">首先我们可以想到i个物品的dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="nx">是可以由</span> <span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="nx">个物品的情况下</span><span class="p">,</span> <span class="nx">选择i转入背包</span> <span class="nx">和不装入背包两种情况得到的</span>
<span class="nx">那不装入物品i的价值</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span>
<span class="nx">那装入了物品i的价值</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">+</span> <span class="nx">price</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">显然装了东西</span><span class="p">,</span> <span class="nx">背包容量肯定减少</span><span class="p">,</span> <span class="nx">总价值肯定是增加</span>
<span class="nx">那我们dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="nx">应该选择哪种情况呢</span><span class="err">?</span>
<span class="nx">答案是选择更大价值的</span>
<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">,</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">+</span> <span class="nx">price</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">)</span>
</code></pre></div><h4 id="3-初始化">3. 初始化</h4>
<ul>
<li>dp[0][0]</li>
</ul>
<pre><code>现在有i=0 这一个物品可以选择,j=0 说明背包大小是0
那我们只能不选择 重量为weight[0]的物品, 因为装不下嘛
那么什么也没装, 我们的dp[0][0] = 0
</code></pre><ul>
<li>dp[i][0]</li>
</ul>
<pre><code>这种情况, 背包容量都是0, 所以dp[i][0] = 0
</code></pre><ul>
<li>dp[0][j]</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">对于这种情况</span><span class="p">,</span><span class="nx">我们要判断背包容量j</span> <span class="nx">是否大于等于</span> <span class="nx">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">只要大于就装入背包</span>
<span class="k">for</span> <span class="nx">j</span><span class="o">:=</span> <span class="nx">bagWeight</span> <span class="p">;</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="nx">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">;</span> <span class="nx">j</span><span class="o">--</span> <span class="p">{</span>
    <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="nx">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">+</span> <span class="nx">price</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div><h4 id="4-遍历的顺序">4. 遍历的顺序</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">从3</span><span class="p">.</span><span class="nx">初始化</span> <span class="nx">步骤我们可以看到</span><span class="p">,</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span><span class="nx">的遍历是倒序的</span><span class="p">,</span> <span class="nx">为啥需要倒序呢</span><span class="err">?</span>

<span class="nx">首先我们看下如果正序会怎么样</span><span class="p">:</span>
<span class="k">for</span> <span class="nx">j</span><span class="o">:=</span> <span class="nx">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">bagWeight</span> <span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="nx">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">+</span> <span class="nx">price</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span>
<span class="c1">//weight := []int{1,3,4}  //kg
</span><span class="c1">//price := []int{15,20,30}    //¥
</span><span class="c1"></span>
<span class="nx">这里weight</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">bagWeight</span> <span class="p">=</span><span class="mi">4</span>
<span class="nx">当j</span><span class="p">=</span><span class="mi">1</span><span class="nx">时</span>      <span class="p">,</span>  <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">15</span> <span class="p">=</span> <span class="mi">15</span>
<span class="nx">当j</span><span class="p">=</span><span class="mi">2</span><span class="nx">时</span>      <span class="p">,</span>  <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">15</span> <span class="p">=</span><span class="mi">30</span> <span class="c1">// 显然这里price[0]被取了两次
</span><span class="c1"></span>

<span class="nx">我们再来看下倒序的过程</span><span class="p">:</span>
<span class="k">for</span> <span class="nx">j</span><span class="o">:=</span> <span class="nx">bagWeight</span> <span class="p">;</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="nx">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">;</span> <span class="nx">j</span><span class="o">--</span> <span class="p">{</span>
    <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="nx">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">+</span> <span class="nx">price</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span>

<span class="nx">j</span><span class="p">=</span><span class="mi">4</span>       <span class="p">,</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="mi">15</span> <span class="p">=</span> <span class="mi">15</span>
<span class="nx">j</span><span class="p">=</span><span class="mi">3</span>       <span class="p">,</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">15</span> <span class="p">=</span> <span class="mi">15</span>
<span class="nx">j</span><span class="p">=</span><span class="mi">2</span>       <span class="p">,</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">15</span> <span class="p">=</span> <span class="mi">15</span>
<span class="nx">j</span><span class="p">=</span><span class="mi">1</span>       <span class="p">,</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">15</span> <span class="p">=</span> <span class="mi">15</span>

<span class="nx">因为我们的推导公式遍历的顺序</span> <span class="nx">同样倒序遍历j会更方便</span>
</code></pre></div><h4 id="5-自己手工写一下结果是否正确">5. 自己手工写一下结果是否正确</h4>
<p><img src="/assets/markdown-img-paste-20210607112304945.png" alt=""></p>
<h3 id="show-me-the-code">show me the code</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">test_2_wei_bag_problem</span><span class="p">(</span><span class="nx">weight</span><span class="p">,</span> <span class="nx">price</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">target</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c1">// 定义dp数组
</span><span class="c1"></span>	<span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">weight</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dp</span> <span class="p">{</span>
		<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">target</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 初始化
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">weight</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="nx">target</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="nx">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="nx">j</span><span class="o">--</span> <span class="p">{</span>
		<span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="nx">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="nx">price</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="c1">// 推导公式
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">weight</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// 正序, j从0 开始
</span><span class="c1"></span>		<span class="c1">//[0 15 15 15 15]
</span><span class="c1"></span>		<span class="c1">//[0 15 15 20 35]
</span><span class="c1"></span>		<span class="c1">//[0 15 15 20 35]
</span><span class="c1"></span>		<span class="c1">//for  j := 0;j&lt;= target ; j++ {
</span><span class="c1"></span>		<span class="c1">//	if j &lt; weight[i] {
</span><span class="c1"></span>		<span class="c1">//		// 因为只有这一种情况, 没办法拿到dp[i-1][j-weight[i]]
</span><span class="c1"></span>		<span class="c1">//		dp[i][j] = dp[i-1][j]
</span><span class="c1"></span>		<span class="c1">//	}else {
</span><span class="c1"></span>		<span class="c1">//		dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+price[i])
</span><span class="c1"></span>		<span class="c1">//	}
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">//}
</span><span class="c1"></span>		<span class="c1">// 正序, 舍弃无用的遍历
</span><span class="c1"></span>		<span class="c1">//[0 15 15 15 15]
</span><span class="c1"></span>		<span class="c1">//[0 0  0  20 35]
</span><span class="c1"></span>		<span class="c1">//[0 0  0  0  35]
</span><span class="c1"></span>		<span class="k">for</span>  <span class="nx">j</span> <span class="o">:=</span> <span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span><span class="nx">j</span><span class="o">&lt;=</span> <span class="nx">target</span> <span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="o">+</span><span class="nx">price</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="p">}</span>
		<span class="c1">// 倒序
</span><span class="c1"></span>		<span class="c1">//[0 15 15 15 15]
</span><span class="c1"></span>		<span class="c1">//[0 0  0  20 35]
</span><span class="c1"></span>		<span class="c1">//[0 0  0  0  35]
</span><span class="c1"></span>		<span class="c1">//for j := target; j &gt;= weight[i]; j-- {
</span><span class="c1"></span>		<span class="c1">//	dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+price[i])
</span><span class="c1"></span>		<span class="c1">//}
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span> <span class="p">;</span><span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">dp</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">weight</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">target</span><span class="p">]</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">weight</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">}</span>
	<span class="nx">price</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">15</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">}</span>
	<span class="nf">bag01</span><span class="p">(</span><span class="nx">weight</span><span class="p">,</span><span class="nx">price</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><h3 id="dp数组优化">dp数组优化</h3>
<pre><code>//[0 15 15 15 15]
//[0 0  0  20 35]
//[0 0  0  0  35]
</code></pre><p>推导公式:  <code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+price[i])</code>
这里我们发现i 主要是用来保留了状态,  我们可以将i层的覆盖到i-1层, 因此状态压缩后的推导公式:
<code>dp[j] = max(dp[j], dp[j-weight[i]]+price[i])</code></p>
<h3 id="动态规划五部曲-1">动态规划五部曲</h3>
<h4 id="1-dp数组定义">1. dp数组定义</h4>
<p>dp[j] 表示背包容量为j,装的物品最大价值为dp[j]</p>
<h4 id="2-dp推导公式">2. dp推导公式</h4>
<p><code>dp[j] = max(dp[j], dp[j-weight[i]]+price[i])</code></p>
<h4 id="3-初始化-1">3. 初始化</h4>
<p>dp[0] 背包容量为0的话, 装的物品最大价值当然也是0</p>
<h4 id="4-遍历的顺序-1">4. 遍历的顺序</h4>
<p>推导遍历的i顺序 当然是从0&lt;=i &lt;len(weight)
那么推导的j顺序呢?</p>
<p>首先我们看一下正序:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span> <span class="p">;</span><span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">weight</span><span class="p">)</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="c1">// 这里必须倒序
</span><span class="c1"></span>    <span class="c1">//for j:= target; j &gt;= weight[i] ; j-- {
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">j</span><span class="o">:=</span> <span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">target</span> <span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
        <span class="c1">// 递推公式
</span><span class="c1"></span>        <span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="o">+</span><span class="nx">price</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">dp</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 结果
</span><span class="c1"></span><span class="p">[</span><span class="mi">0</span> <span class="mi">15</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">15</span> <span class="mi">30</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">15</span> <span class="mi">30</span> <span class="mi">45</span> <span class="mi">0</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">15</span> <span class="mi">30</span> <span class="mi">45</span> <span class="mi">60</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">15</span> <span class="mi">30</span> <span class="mi">45</span> <span class="mi">60</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">15</span> <span class="mi">30</span> <span class="mi">45</span> <span class="mi">60</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">15</span> <span class="mi">30</span> <span class="mi">45</span> <span class="mi">60</span><span class="p">]</span>
</code></pre></div><p>在j的循环内部对price[i]进行了多次累加</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">当i</span><span class="p">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">j</span><span class="p">=</span><span class="nx">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">]=</span><span class="mi">1</span><span class="p">;</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]=</span><span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="nx">price</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">15</span><span class="p">)</span> <span class="p">=</span> <span class="mi">15</span>
<span class="nx">当i</span><span class="p">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">j</span><span class="p">=</span><span class="nx">j</span><span class="o">++</span><span class="p">=</span><span class="mi">2</span><span class="p">;</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">]=</span><span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="nx">price</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">15</span><span class="o">+</span><span class="mi">15</span><span class="p">)</span> <span class="p">=</span> <span class="mi">30</span>
<span class="nx">当i</span><span class="p">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">j</span><span class="p">=</span><span class="nx">j</span><span class="o">++</span><span class="p">=</span><span class="mi">3</span><span class="p">;</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">3</span><span class="p">]=</span><span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">3</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="nx">price</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">30</span><span class="o">+</span><span class="mi">15</span><span class="p">)</span> <span class="p">=</span> <span class="mi">45</span>
<span class="nx">当i</span><span class="p">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">j</span><span class="p">=</span><span class="nx">j</span><span class="o">++</span><span class="p">=</span><span class="mi">4</span><span class="p">;</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">4</span><span class="p">]=</span><span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">4</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="nx">price</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">45</span><span class="o">+</span><span class="mi">15</span><span class="p">)</span> <span class="p">=</span> <span class="mi">60</span>
</code></pre></div><p>显然这不符合我们的预期, 单个物品只能选取一次</p>
<p>因此这里我们应该使用倒序的方式</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span> <span class="p">;</span><span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">weight</span><span class="p">)</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="c1">// 这里必须倒序
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">j</span><span class="o">:=</span> <span class="nx">target</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">;</span> <span class="nx">j</span><span class="o">--</span> <span class="p">{</span>
        <span class="c1">// 递推公式
</span><span class="c1"></span>        <span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="o">+</span><span class="nx">price</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">dp</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//结果
</span><span class="c1"></span><span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">15</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">15</span> <span class="mi">15</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">15</span> <span class="mi">15</span> <span class="mi">15</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">15</span> <span class="mi">15</span> <span class="mi">15</span> <span class="mi">15</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">15</span> <span class="mi">15</span> <span class="mi">15</span> <span class="mi">35</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">15</span> <span class="mi">15</span> <span class="mi">20</span> <span class="mi">35</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">15</span> <span class="mi">15</span> <span class="mi">20</span> <span class="mi">35</span><span class="p">]</span>
</code></pre></div><h4 id="5-举例推导dp数组">5. 举例推导dp数组</h4>
<p>上面的结果就包含了举例:</p>
<pre><code>i=0, dp=[0 15 15 15 15]
i=1, dp=[0 15 15 20 35]
i=2, dp=[0 15 15 20 35]
</code></pre><h3 id="show-me-the-code-1">show me the code</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">test_1_wei_bag_problem</span><span class="p">(</span><span class="nx">weight</span><span class="p">,</span> <span class="nx">price</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">target</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c1">// 定义 and 初始化
</span><span class="c1"></span>	<span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nx">target</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="c1">// 递推顺序
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span> <span class="p">;</span><span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">weight</span><span class="p">)</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// 这里必须倒序
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">j</span><span class="o">:=</span> <span class="nx">target</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">;</span> <span class="nx">j</span><span class="o">--</span> <span class="p">{</span>
			<span class="c1">// 递推公式
</span><span class="c1"></span>			<span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="o">+</span><span class="nx">price</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="p">}</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">dp</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">target</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">weight</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">}</span>
	<span class="nx">price</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">15</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">test_1_wei_bag_problem</span><span class="p">(</span><span class="nx">weight</span><span class="p">,</span><span class="nx">price</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go算法学习 动态规划 分割等和子集</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</link>
			<pubDate>Thu, 27 May 2021 18:36:38 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</guid>
			<description>dp 一维数组模板  例一
    \ 重量 价值     物品0 1 15   物品1 3 20   物品2 4 30    for i:=0;i&amp;lt; 物品重量列表长度;i++ { for j:= 背包容量;j &amp;gt;= i物品的重量;j-- { dp[j] = max(dp[j], dp[j- 物品i的重量] + 物品i的价值) } } 物品重量: weight := []int{1,3,4} 物品价值: value := []int{15,20,30} for i:=0;i&amp;lt; len(weight);i++ { for j:= target ;j &amp;gt;= weight[i];j-- { dp[j] = max(dp[j], dp[j- weight[i]] + value[i]) } } # 背包问题简单测试 func bag01() { weight := []int{1, 3, 4} value := []int{15, 20, 30} target := 10 dp := make([]int,target+1) for i := 0; i &amp;lt; len(weight); i++ { for j := target; j &amp;gt;= weight[i]; j-- { dp[j] = max(dp[j], dp[j-weight[i]]+value[i]) } } fmt.</description>
			<content type="html"><![CDATA[<h3 id="dp-一维数组模板">dp 一维数组模板</h3>
<blockquote>
<p>例一</p>
</blockquote>
<table>
<thead>
<tr>
<th>\</th>
<th>重量</th>
<th>价值</th>
</tr>
</thead>
<tbody>
<tr>
<td>物品0</td>
<td>1</td>
<td>15</td>
</tr>
<tr>
<td>物品1</td>
<td>3</td>
<td>20</td>
</tr>
<tr>
<td>物品2</td>
<td>4</td>
<td>30</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span> <span class="nx">物品重量列表长度</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">j</span><span class="o">:=</span> <span class="nx">背包容量</span><span class="p">;</span><span class="nx">j</span> <span class="o">&gt;=</span> <span class="nx">i物品的重量</span><span class="p">;</span><span class="nx">j</span><span class="o">--</span> <span class="p">{</span>
        <span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span> <span class="nx">物品i的重量</span><span class="p">]</span> <span class="o">+</span> <span class="nx">物品i的价值</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">物品重量</span><span class="p">:</span>   <span class="nx">weight</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">}</span>
<span class="nx">物品价值</span><span class="p">:</span>   <span class="nx">value</span>  <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">15</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">}</span>

<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">weight</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">j</span><span class="o">:=</span> <span class="nx">target</span> <span class="p">;</span><span class="nx">j</span> <span class="o">&gt;=</span> <span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span><span class="nx">j</span><span class="o">--</span> <span class="p">{</span>
        <span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span> <span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">+</span> <span class="nx">value</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="err">#</span> <span class="nx">背包问题简单测试</span>
<span class="kd">func</span> <span class="nf">bag01</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">weight</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
	<span class="nx">value</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">}</span>
	<span class="nx">target</span> <span class="o">:=</span> <span class="mi">10</span>
	<span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nx">target</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">weight</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="nx">target</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span> <span class="nx">j</span><span class="o">--</span> <span class="p">{</span>
			<span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="o">+</span><span class="nx">value</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">dp</span><span class="p">)</span>    <span class="c1">//[0 15 15 20 35 45 45 50 65 65 65]
</span><span class="c1"></span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>  <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>

</code></pre></div><h3 id="show-me-the-code">show me the code</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="c1">//https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.md
</span><span class="c1">//416. 分割等和子集
</span><span class="c1">//题目链接：https://leetcode-cn.com/problems/partition-equal-subset-sum/
</span><span class="c1">//
</span><span class="c1">//题目难易：中等
</span><span class="c1">//
</span><span class="c1">//给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
</span><span class="c1">//
</span><span class="c1">//注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200
</span><span class="c1">//
</span><span class="c1">//示例 1: 输入: [1, 5, 11, 5] 输出: true 解释: 数组可以分割成 [1, 5, 5] 和 [11].   示例 2: 输入: [1, 2, 3, 5] 输出: false 解释: 数组不能分割成两个元素和相等的子集.
</span><span class="c1"></span>
<span class="c1">// 1. 暴力回溯法
</span><span class="c1">// 1,5,11,5
</span><span class="c1">// 找到所有和=22, 取一半 = 11
</span><span class="c1">// 先取第一个数字: 1,1+5,1+11,1+5|1+5+11,1+5+5|1+11+5  存在==11
</span><span class="c1">// 先取第二个数字: 5+11,5+5
</span><span class="c1">// 先取第三个数字: 11+5
</span><span class="c1">// 先取第四个数字: 5
</span><span class="c1">// 回溯遍历可以得到结果, 但是会超时
</span><span class="c1">// 时间复杂度: O(n*n!) ?
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">canPartition</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">sum</span> <span class="o">+=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">sum</span><span class="o">%</span><span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="c1">// 回溯三部曲
</span><span class="c1"></span>	<span class="c1">// 1. 传参:
</span><span class="c1"></span>	<span class="c1">// 2. 终止条件
</span><span class="c1"></span>	<span class="c1">// 3. 单次循环
</span><span class="c1"></span>	<span class="nx">part</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="kc">false</span>
	<span class="kd">var</span> <span class="nx">dfs</span> <span class="kd">func</span><span class="p">(</span><span class="nx">index</span> <span class="kt">int</span><span class="p">)</span>
	<span class="nx">dfs</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">index</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// 终止条件
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">part</span> <span class="p">&gt;</span> <span class="nx">sum</span><span class="o">/</span><span class="mi">2</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">part</span> <span class="o">==</span> <span class="nx">sum</span><span class="o">/</span><span class="mi">2</span> <span class="p">{</span>
			<span class="nx">result</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="c1">// 单次循环,每次取值进行累加
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">index</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">part</span> <span class="o">+=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
			<span class="c1">// 递归
</span><span class="c1"></span>			<span class="nf">dfs</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
			<span class="c1">// 回溯
</span><span class="c1"></span>			<span class="nx">part</span> <span class="o">-=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="c1">// 01背包问题, 元素只能使用一次
</span><span class="c1">// 本次是要求找出 元素和 等于总和/2
</span><span class="c1">// 1. dp数组的定义
</span><span class="c1">// dp[value] 表示 容量为value的背包,所背的物品价值为dp[value]
</span><span class="c1">// 在这里
</span><span class="c1">// dp[value] 表示 容量为value的背包,所存储的最大的值 dp[value]
</span><span class="c1">// 2. dp数组的推导公式
</span><span class="c1">// dp[value] = max(dp[value], dp[value-nums[j]]+nums[j]
</span><span class="c1">// 3. dp数组初始化
</span><span class="c1">// dp[0] = 0
</span><span class="c1">// 4. dp数组的顺序
</span><span class="c1">// 在动态规划：关于01背包问题，你该了解这些！（滚动数组）中就已经说明：如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒叙遍历！
</span><span class="c1">// 5. 举例数组
</span><span class="c1">// dp[value]的数值一定小于等于value, 肯定不能超过最大容量
</span><span class="c1">// 如果dp[value]== value,说明子集合刚好可以凑成总和i, 这里我们的i上限 其实等于 sum/2
</span><span class="c1">// 例如 输入[1,5,11,5], sum/2 = 11
</span><span class="c1">// dp[value] = 0,1,1,1,1,5,6,6,6,6,10,11
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">canPartition2</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">sum</span> <span class="o">+=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">sum</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span>  <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="c1">// max方法
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">max</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
	<span class="nx">max</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
		<span class="k">return</span> <span class="nx">b</span>
	<span class="p">}</span>

	<span class="nx">target</span> <span class="o">:=</span> <span class="nx">sum</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
	<span class="c1">// 1. 定义dp数组
</span><span class="c1"></span>	<span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">target</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="c1">// 3. 初始化
</span><span class="c1"></span>	<span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="c1">// 4. dp数组的顺序
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// 每一个元素一定是不可重复放入，所以从大到小遍历
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">value</span> <span class="o">:=</span> <span class="nx">target</span><span class="p">;</span> <span class="nx">value</span> <span class="o">&gt;=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span> <span class="nx">value</span><span class="o">--</span> <span class="p">{</span>
			<span class="nx">dp</span><span class="p">[</span><span class="nx">value</span><span class="p">]</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">value</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">value</span><span class="o">-</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="o">+</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 等于target 说明整合凑成
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">target</span><span class="p">]</span> <span class="o">==</span> <span class="nx">target</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>



<span class="c1">// 优化版本, 不需要计算值
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">canPartition3</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">sum</span> <span class="o">+=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">sum</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span>  <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="nx">target</span> <span class="o">:=</span> <span class="nx">sum</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
	<span class="c1">// 1. 定义dp数组
</span><span class="c1"></span>	<span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">bool</span><span class="p">,</span> <span class="nx">target</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="c1">// 3. 初始化
</span><span class="c1"></span>	<span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="c1">// 4. dp数组的顺序
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// 每一个元素一定是不可重复放入，所以从大到小遍历
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">value</span> <span class="o">:=</span> <span class="nx">target</span><span class="p">;</span> <span class="nx">value</span> <span class="o">&gt;=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span> <span class="nx">value</span><span class="o">--</span> <span class="p">{</span>
			<span class="nx">dp</span><span class="p">[</span><span class="nx">value</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">value</span><span class="p">]</span><span class="o">||</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">value</span><span class="o">-</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span>
		<span class="p">}</span>
		<span class="c1">// 一旦等于target
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">target</span><span class="p">]</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">true</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>




<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">canPartition</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">5</span><span class="p">}))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">canPartition</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">}))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">canPartition</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">}))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">canPartition</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mi">97</span><span class="p">}))</span>
<span class="p">}</span>


</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go算法学习 动态规划 整数拆分</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/</link>
			<pubDate>Thu, 27 May 2021 11:07:46 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/</guid>
			<description>show me the code package main //https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0343.%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86.md //343. 整数拆分 //题目链接：https://leetcode-cn.com/problems/integer-break/ // //给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 // //示例 1: 输入: 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1。 // //示例 2: 输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 说明: 你可以假设 n 不小于 2 且不大于 58。  // dp[i] 代表 i这个数 拆分得到最大的乘积 // 看看示例 // dp[0],dp[1] 不用考虑, 题目是n大于等于2 // dp[2] = 1 * 1 = 1 只有一个结果  // 1.</description>
			<content type="html"><![CDATA[<h3 id="show-me-the-code">show me the code</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="c1">//https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0343.%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86.md
</span><span class="c1">//343. 整数拆分
</span><span class="c1">//题目链接：https://leetcode-cn.com/problems/integer-break/
</span><span class="c1">//
</span><span class="c1">//给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。
</span><span class="c1">//
</span><span class="c1">//示例 1: 输入: 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1。
</span><span class="c1">//
</span><span class="c1">//示例 2: 输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 说明: 你可以假设 n 不小于 2 且不大于 58。
</span><span class="c1"></span>


<span class="c1">// dp[i] 代表 i这个数 拆分得到最大的乘积
</span><span class="c1">// 看看示例
</span><span class="c1">// dp[0],dp[1] 不用考虑, 题目是n大于等于2
</span><span class="c1">// dp[2] = 1 * 1  = 1 只有一个结果
</span><span class="c1"></span>
<span class="c1">// 1.dp[3] 可以如下拆分
</span><span class="c1">// 	1.1 (3-1) * 1 = 2
</span><span class="c1">// 	1.2 dp[3-1] * 1 = 1	 =&gt; 局部最优: 1 * 1 * 1 = 1
</span><span class="c1">//  这里的dp[3-1] 其实就是我们在对2拆分获取最大乘积
</span><span class="c1">//  1.3 (3-2) * 2 = 2
</span><span class="c1">//  不存在dp[3-2]了
</span><span class="c1">//  所以 dp[3] = 2
</span><span class="c1"></span>
<span class="c1">// 2. dp[4] 可以如下拆分
</span><span class="c1">// 	2.1 (4-1) * 1 = 3
</span><span class="c1">//  2.2 dp[4-1] * 1 = 2	=&gt; 局部最优: 1 * 2 * 1 = 2
</span><span class="c1">//  2.3 (4-2) * 2 = 4
</span><span class="c1">//  2.4 dp[4-2] * 2 = 2 =&gt; 局部最优: 1 * 1 * 2 = 2
</span><span class="c1">//  2.5 (4-3) * 3 = 3
</span><span class="c1">//  所以dp[4] = 4
</span><span class="c1"></span>
<span class="c1">// 3. dp[5] 可以拆分
</span><span class="c1">//  3.1 (5-1) * 1 = 4
</span><span class="c1">//  3.2 dp[5-1] * 1 = 4	=&gt; 局部最优: 2 * 2 * 1 = 4
</span><span class="c1">//  3.3 (5-2) * 2 = 6
</span><span class="c1">//  3.4 dp[5-2] * 2 = 4 =&gt; 局部最优: 1 * 2 * 2 = 4
</span><span class="c1">//  3.5 (5-3) * 3 = 6
</span><span class="c1">//  3.6 dp[5-3] * 3 = 3 =&gt; 局部最优: 1 * 1 * 3 = 3
</span><span class="c1">//  3.7 (5-4) * 4 = 4
</span><span class="c1">//  所以dp[5] = 6
</span><span class="c1"></span>
<span class="c1">// 因此dp[i] 可以得到如下
</span><span class="c1">// 	1. (i-j) * j  拆成两个数字
</span><span class="c1">//  2. dp[i-j] * j ,dp[i-j] 代表i-j可以得到的最大乘积
</span><span class="c1">// 所以dp[i] = max(dp[i], dp[i-j] * j , (i-j)*j)
</span><span class="c1"></span>
<span class="c1">// 1. dp[i]数组定义: i这个正整数可以拆分的最大乘积
</span><span class="c1">// 2. dp数组初始化: dp[2] = 1
</span><span class="c1">// 3. dp推导公式: dp[i] = max(dp[i], dp[i-j] * j , (i-j)*j)
</span><span class="c1">// 4. 顺序: 同样从前往后
</span><span class="c1">// 5. 举例: dp[i] = 0,0,1,2,4,6,9,12,18,27,36
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">integerBreak</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c1">// 1.定义dp数组
</span><span class="c1"></span>	<span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="c1">// 3. 初始化
</span><span class="c1"></span>	<span class="nx">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="c1">// 4. 遍历顺序
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="c1">// 2. dp推导公式
</span><span class="c1"></span>			<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="nx">j</span><span class="p">]</span><span class="o">*</span><span class="nx">j</span><span class="p">,</span> <span class="p">(</span><span class="nx">i</span><span class="o">-</span><span class="nx">j</span><span class="p">)</span><span class="o">*</span><span class="nx">j</span><span class="p">))</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">integerBreak</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="p">}</span>


</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go算法学习 动态规划 不同路径2</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%842/</link>
			<pubDate>Wed, 26 May 2021 18:01:37 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%842/</guid>
			<description>show me the code package main import &amp;#34;fmt&amp;#34; //https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0063.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II.md //63. 不同路径 II //题目链接：https://leetcode-cn.com/problems/unique-paths-ii/ // //一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 // //机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 // //现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？  // 同样根据我们 &amp;lt;&amp;lt; 62. 不同路径&amp;gt;&amp;gt; 的分析可以指定 // dp[i][j] 代表的是 (i,j) 坐标到达的所有路径数 // 显然(i,j) 如果是路障, 那么dp[i][j] = 0 是肯定的, 因为无法到达哈  // 那我们先来举例演示一下 // obstacleGrid = [[0,0,0,0],[0,1,0,1],[1,0,0,0],[0,0,0,0]] // [0,0,0,0] // [0,1,0,1] // [1,0,0,0] // [0,0,0,0] // 我们的dp数组同样初始化为: // 二维数组如下: //[1 1 1 1] //[1 0 0 0] //[0 0 0 0] //[0 0 0 0] // 根据有障碍的数组, 按照dp[i][j] = dp[i][j-1] + dp[i-1][j] 来计算可以得到如下: //[1 1 1 1] //[1 0 1 0] //[0 0 1 1] //[0 0 1 2]  // 动态规划五部曲 // 1.</description>
			<content type="html"><![CDATA[<h3 id="show-me-the-code">show me the code</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="c1">//https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0063.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II.md
</span><span class="c1">//63. 不同路径 II
</span><span class="c1">//题目链接：https://leetcode-cn.com/problems/unique-paths-ii/
</span><span class="c1">//
</span><span class="c1">//一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
</span><span class="c1">//
</span><span class="c1">//机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
</span><span class="c1">//
</span><span class="c1">//现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
</span><span class="c1"></span>
<span class="c1">// 同样根据我们 &lt;&lt; 62. 不同路径&gt;&gt; 的分析可以指定
</span><span class="c1">// dp[i][j] 代表的是 (i,j) 坐标到达的所有路径数
</span><span class="c1">// 显然(i,j) 如果是路障, 那么dp[i][j] = 0 是肯定的, 因为无法到达哈
</span><span class="c1"></span>
<span class="c1">// 那我们先来举例演示一下
</span><span class="c1">// obstacleGrid = [[0,0,0,0],[0,1,0,1],[1,0,0,0],[0,0,0,0]]
</span><span class="c1">// [0,0,0,0]
</span><span class="c1">// [0,1,0,1]
</span><span class="c1">// [1,0,0,0]
</span><span class="c1">// [0,0,0,0]
</span><span class="c1">// 我们的dp数组同样初始化为:
</span><span class="c1">// 二维数组如下:
</span><span class="c1">//[1 1 1 1]
</span><span class="c1">//[1 0 0 0]
</span><span class="c1">//[0 0 0 0]
</span><span class="c1">//[0 0 0 0]
</span><span class="c1">// 根据有障碍的数组, 按照dp[i][j] = dp[i][j-1] + dp[i-1][j] 来计算可以得到如下:
</span><span class="c1">//[1 1 1 1]
</span><span class="c1">//[1 0 1 0]
</span><span class="c1">//[0 0 1 1]
</span><span class="c1">//[0 0 1 2]
</span><span class="c1"></span>
<span class="c1">// 动态规划五部曲
</span><span class="c1">// 1. dp数组定义和含义 : dp[i][j] 同样代表该位置(i,j) 所有路线总和
</span><span class="c1">// 2. dp的推导过程: 同样是 dp[i][j] = dp[i][j-1] +  dp[i-1][j]
</span><span class="c1">// 3. dp数组初始化:
</span><span class="c1">//    3.1 同样是第一行或第一列都初始化为1
</span><span class="c1">//    3.2 但是如果该行有障碍物, 后面的都将是0, 因为不可能到达
</span><span class="c1">// 4. 顺序
</span><span class="c1">// 5. 举例dp数组
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">uniquePathsWithObstacles</span><span class="p">(</span><span class="nx">obstacleGrid</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">,</span><span class="nx">n</span><span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">obstacleGrid</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="nx">obstacleGrid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="c1">// 定义一个dp数组
</span><span class="c1"></span>	<span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span><span class="nx">m</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span><span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dp</span> <span class="p">{</span>
		<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nx">n</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 初始化
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">m</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// 如果是障碍物, 后面的就都是0, 不用循环了
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">obstacleGrid</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]=</span><span class="mi">1</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">n</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">obstacleGrid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">i</span><span class="p">]=</span><span class="mi">1</span>
	<span class="p">}</span>
	<span class="c1">// dp数组推导过程
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">m</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span><span class="o">:=</span><span class="mi">1</span><span class="p">;</span><span class="nx">j</span><span class="p">&lt;</span><span class="nx">n</span><span class="p">;</span><span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="c1">// 如果obstacleGrid[i][j]这个点是障碍物, 那么我们的dp[i][j]保持为0
</span><span class="c1"></span>            <span class="k">if</span> <span class="nx">obstacleGrid</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span> <span class="p">{</span>
				<span class="c1">// 否则我们需要计算当前点可以到达的路径数
</span><span class="c1"></span>				<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span><span class="o">+</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// debug遍历dp
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span><span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dp</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span><span class="p">,</span><span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%.2v,&#34;</span><span class="p">,</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">])</span>
		<span class="p">}</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">m</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">obstacleGrid</span> <span class="o">:=</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">{{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">},{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">},{</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">},{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">}}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">uniquePathsWithObstacles</span><span class="p">(</span><span class="nx">obstacleGrid</span><span class="p">))</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go算法学习 动态规划 不同路径</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</link>
			<pubDate>Wed, 26 May 2021 17:17:21 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</guid>
			<description>show me the code package main import &amp;#34;fmt&amp;#34; //https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.md //62.不同路径 //题目链接：https://leetcode-cn.com/problems/unique-paths/ // //一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 // //机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 // //问总共有多少条不同的路径？ //输入：m = 3, n = 7 输出：28 // //示例 2： 输入：m = 2, n = 3 输出：3 解释： 从左上角开始，总共有 3 条路径可以到达右下角。 // //向右 -&amp;gt; 向右 -&amp;gt; 向下 //向右 -&amp;gt; 向下 -&amp;gt; 向右 //向下 -&amp;gt; 向右 -&amp;gt; 向右 //示例 3： 输入：m = 7, n = 3 输出：28 // //示例 4： 输入：m = 3, n = 3 输出：6 提示： // //1 &amp;lt;= m, n &amp;lt;= 100 //题目数据保证答案小于等于 2 * 10^9  // 动态规划五部曲 // 1.</description>
			<content type="html"><![CDATA[<h3 id="show-me-the-code">show me the code</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="c1">//https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.md
</span><span class="c1">//62.不同路径
</span><span class="c1">//题目链接：https://leetcode-cn.com/problems/unique-paths/
</span><span class="c1">//
</span><span class="c1">//一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
</span><span class="c1">//
</span><span class="c1">//机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
</span><span class="c1">//
</span><span class="c1">//问总共有多少条不同的路径？
</span><span class="c1">//输入：m = 3, n = 7 输出：28
</span><span class="c1">//
</span><span class="c1">//示例 2： 输入：m = 2, n = 3 输出：3 解释： 从左上角开始，总共有 3 条路径可以到达右下角。
</span><span class="c1">//
</span><span class="c1">//向右 -&gt; 向右 -&gt; 向下
</span><span class="c1">//向右 -&gt; 向下 -&gt; 向右
</span><span class="c1">//向下 -&gt; 向右 -&gt; 向右
</span><span class="c1">//示例 3： 输入：m = 7, n = 3 输出：28
</span><span class="c1">//
</span><span class="c1">//示例 4： 输入：m = 3, n = 3 输出：6   提示：
</span><span class="c1">//
</span><span class="c1">//1 &lt;= m, n &lt;= 100
</span><span class="c1">//题目数据保证答案小于等于 2 * 10^9
</span><span class="c1"></span>

<span class="c1">// 动态规划五部曲
</span><span class="c1">// 1. dp数组定义 dp[i][j]
</span><span class="c1">//  从左上角(0,0) 出发到达(i,j) 所有的不同路径: dp[i][j]
</span><span class="c1">// 2. dp推导公式
</span><span class="c1">//  显然  dp[i][j] 有两种情况可以到达
</span><span class="c1">//   1. dp[i][j-1] 向右走一步
</span><span class="c1">//   2. dp[i-1][j] 向下走一步
</span><span class="c1">//  dp[i][j] = dp[i][j-1] +  dp[i-1][j]
</span><span class="c1">// 3. dp数组初始化
</span><span class="c1">//  dp[0][0] = 1
</span><span class="c1">//  dp[0][1] = 1
</span><span class="c1">//  dp[1][0] = 1
</span><span class="c1">//  是这样吗? 错误哈!
</span><span class="c1">//  应该初始化第一排和第一列
</span><span class="c1">//  dp[0][0] = 1
</span><span class="c1">//  dp[0][i] = 1
</span><span class="c1">//  dp[i][0] = 1
</span><span class="c1">// 4. 顺序
</span><span class="c1">// 5. dp数组举例
</span><span class="c1">//  dp[0][0] = 1
</span><span class="c1">//  dp[0][1] = 1
</span><span class="c1">//  dp[1][0] = 1
</span><span class="c1">//  dp[1][1] = dp[0][1] + dp[1][0] = 2
</span><span class="c1">//  dp[1][2] = dp[1][1] + dp[0][2] = 3
</span><span class="c1">//
</span><span class="c1">//  01,01,01,01,01,01,01,
</span><span class="c1">//  01,02,03,04,05,06,07,
</span><span class="c1">//  01,03,06,10,15,21,28,
</span><span class="c1"></span>

<span class="kd">func</span> <span class="nf">uniquePaths</span><span class="p">(</span><span class="nx">m</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c1">// 定义dp数组
</span><span class="c1"></span>	<span class="c1">// 这里的m代表m行, n代表n列
</span><span class="c1"></span>	<span class="c1">// m =3, n = 7
</span><span class="c1"></span>	<span class="c1">// 二维数组如下:
</span><span class="c1"></span>	<span class="c1">//[0 0 0 0 0 0 0]
</span><span class="c1"></span>	<span class="c1">//[0 0 0 0 0 0 0]
</span><span class="c1"></span>	<span class="c1">//[0 0 0 0 0 0 0]
</span><span class="c1"></span>	<span class="c1">// 首先定义dp的行
</span><span class="c1"></span>	<span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span><span class="nx">m</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span><span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dp</span> <span class="p">{</span>
		<span class="c1">// 然后定义每个元素的长度, 也就是二维数组的宽
</span><span class="c1"></span>		<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nx">n</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 初始化dp, 初始化为如下:
</span><span class="c1"></span>	<span class="c1">// 二维数组如下:
</span><span class="c1"></span>	<span class="c1">//[1 1 1 1 1 1 1]
</span><span class="c1"></span>	<span class="c1">//[1 0 0 0 0 0 0]
</span><span class="c1"></span>	<span class="c1">//[1 0 0 0 0 0 0]
</span><span class="c1"></span>	<span class="c1">// 一开始初始化有问题, 只初始化了三个值
</span><span class="c1"></span>	<span class="c1">//dp[1][0] = 1
</span><span class="c1"></span>	<span class="c1">//dp[0][1] = 1
</span><span class="c1"></span>	<span class="c1">// 纠正后如下, 应该初始化第一排和第一列
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">m</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">n</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="p">}</span>
	<span class="c1">// 这里是dp推导过程
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span> <span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">m</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span><span class="o">:=</span><span class="mi">1</span><span class="p">;</span><span class="nx">j</span><span class="p">&lt;</span><span class="nx">n</span><span class="p">;</span><span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 遍历dp来debug哪里出现问题, 比如我开始初始化有问题, 通过dp打印就能发现
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span><span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dp</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span><span class="p">,</span><span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%.2v,&#34;</span><span class="p">,</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">])</span>
		<span class="p">}</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">m</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">uniquePaths</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">))</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go算法学习 二叉树 迭代统一遍历写法</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E4%BA%8C%E5%8F%89%E6%A0%91-%E8%BF%AD%E4%BB%A3%E7%BB%9F%E4%B8%80%E9%81%8D%E5%8E%86%E5%86%99%E6%B3%95/</link>
			<pubDate>Tue, 27 Apr 2021 11:21:41 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E4%BA%8C%E5%8F%89%E6%A0%91-%E8%BF%AD%E4%BB%A3%E7%BB%9F%E4%B8%80%E9%81%8D%E5%8E%86%E5%86%99%E6%B3%95/</guid>
			<description>说明 首先二叉树有三种遍历,针对根节点遍历顺序分别是 前序,中序, 后续
 前序: 中 左 右 中序: 左 中 右 后续: 左 右 中  遍历的写法分为两种:
 递归 迭代  二叉树结构体 type TreeNode struct { Val int Left *TreeNode Right *TreeNode } 1. 递归  递归比较简单, 代码如下:
  1.1 前序遍历 (中 左 右)  func preorderTraversal(root *TreeNode) []int { var result []int var Traversal func( *TreeNode) Traversal = func(node *TreeNode) { if node == nil { return } result = append(result, node.</description>
			<content type="html"><![CDATA[<h3 id="说明">说明</h3>
<p>首先二叉树有三种遍历,针对根节点遍历顺序分别是 前序,中序, 后续</p>
<ul>
<li>前序: 中 左 右</li>
<li>中序: 左 中 右</li>
<li>后续: 左 右 中</li>
</ul>
<p>遍历的写法分为两种:</p>
<ul>
<li>递归</li>
<li>迭代</li>
</ul>
<h3 id="二叉树结构体">二叉树结构体</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">TreeNode</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Val</span>   <span class="kt">int</span>
	<span class="nx">Left</span>  <span class="o">*</span><span class="nx">TreeNode</span>
	<span class="nx">Right</span> <span class="o">*</span><span class="nx">TreeNode</span>
<span class="p">}</span>

</code></pre></div><h3 id="1-递归">1. 递归</h3>
<blockquote>
<p>递归比较简单, 代码如下:</p>
</blockquote>
<ul>
<li>1.1 前序遍历 (中 左 右)</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">preorderTraversal</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">result</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="kd">var</span> <span class="nx">Traversal</span> <span class="kd">func</span><span class="p">(</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span>
	<span class="nx">Traversal</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">node</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">node</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span> <span class="c1">//1 中
</span><span class="c1"></span>		<span class="nf">Traversal</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>              <span class="c1">//2 左
</span><span class="c1"></span>		<span class="nf">Traversal</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>             <span class="c1">//3 右
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="nf">Traversal</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</code></pre></div><p><strong>根据1.1 前序遍历 很容易能写出中序遍历 和后序遍历</strong></p>
<hr>
<h3 id="2-迭代法">2. 迭代法</h3>
<blockquote>
<p>首先这里使用一般的迭代方法</p>
</blockquote>
<ul>
<li>2.1 前序遍历 (中 左 右)</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">preorderTraversal</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">result</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">result</span>
	<span class="p">}</span>
	<span class="nx">stack</span> <span class="o">:=</span> <span class="p">[]</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">{</span><span class="nx">root</span><span class="p">}</span>
	<span class="c1">// 迭代循环
</span><span class="c1"></span>	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// 处理当前节点
</span><span class="c1"></span>		<span class="nx">node</span> <span class="o">:=</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="c1">// 访问的节点就是 结果集的节点
</span><span class="c1"></span>		<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
		<span class="c1">// 先将右节点 入栈
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// 再将左节点 入栈
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</code></pre></div><blockquote>
<p>前序遍历比较简单, 因为前序遍历的节点 就是结果集的节点, 如果是中序遍历呢?</p>
<p>由于中序遍历需要找的最左边的节点, 所以每次访问的节点并不是结果集的节点, 那应该怎么弄呢?</p>
</blockquote>
<ul>
<li>2.1 中序遍历 (左 中 右)</li>
</ul>
<blockquote>
<p>由于每次访问的节点并不是要处理的节点, 访问到左边最后一个节点才开始处理
因此需要将每次遇到的右节点保存到堆栈中</p>
</blockquote>
<blockquote>
<ol>
<li>
<p>第一步先找到最左边的节点,并且将访问的节点都存到堆栈中</p>
</li>
<li>
<p>当发现已经到最左边的节点(==nil) 时, 就需要从堆栈中取出最后一个节点(最左边的节点) ,遍历该节点, 并处理他的右节点</p>
</li>
<li>
<p>然后就拿着右节点 继续遍历 1 2步骤</p>
</li>
</ol>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">inorderTraversal</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">result</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">stack</span> <span class="p">[]</span><span class="o">*</span><span class="nx">TreeNode</span>
	<span class="nx">node</span> <span class="o">:=</span> <span class="nx">root</span>
	<span class="k">for</span> <span class="nx">node</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">node</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span>
			<span class="nx">node</span> <span class="p">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// 已经是最左边的节点了, 就可以推出栈元素了
</span><span class="c1"></span>			<span class="c1">// 栈最后一个元素, 就是左节点
</span><span class="c1"></span>			<span class="nx">node</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="c1">// 添加左节点的
</span><span class="c1"></span>			<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
			<span class="c1">// 再去遍历右节点
</span><span class="c1"></span>			<span class="nx">node</span> <span class="p">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>2.1 后序遍历 (左 右 中)</li>
</ul>
<blockquote>
<p>对比前序遍历 中 左 右 -&gt; 稍作修改为: 中 右 左, 然后倒序输出</p>
<ol>
<li>
<p>把根节点加入堆栈 , 弹出</p>
</li>
<li>
<p>每次判断先判断右边是否nil,然后判断左边是否nil, 把 右左 顺序加入堆栈, 左右顺序弹出</p>
</li>
</ol>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">postorderTraversal</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">result</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">result</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">stack</span> <span class="p">[]</span><span class="o">*</span><span class="nx">TreeNode</span>
	<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">root</span><span class="p">)</span>
	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">cur</span> <span class="o">:=</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">j</span><span class="p">;</span> <span class="p">{</span>
		<span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">result</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">result</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">i</span><span class="o">++</span>
		<span class="nx">j</span><span class="o">--</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</code></pre></div><hr>
<p>经过以上比较,我们发现<strong>递归写法比较统一,迭代写法很不统一,是否有统一的迭代写法呢?</strong></p>
<blockquote>
<p>参考文档</p>
</blockquote>
<ul>
<li><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/bang-ni-dui-er-cha-shu-bu-zai-mi-mang-che-di-chi-t/">来自leetcode 代码随想录 分享</a></li>
</ul>
<h3 id="3-迭代法-统一写法版本">3. 迭代法 统一写法版本</h3>
<ul>
<li>3.1 先序遍历 ( 中 左 右)</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 统一写法  先序遍历 ( 中 左 右)
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">preorderTraversal</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">result</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="nx">stack</span> <span class="o">:=</span> <span class="p">[]</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">{</span><span class="nx">root</span><span class="p">}</span>
	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// 先取一个节点来处理
</span><span class="c1"></span>		<span class="nx">node</span> <span class="o">:=</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="c1">// 判断是否用nil标记了
</span><span class="c1"></span>
		<span class="k">if</span> <span class="nx">node</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// 不是标记节点, 就处理该节点
</span><span class="c1"></span>			<span class="c1">// 怎么处理呢? 就是按照顺序加入到队列中
</span><span class="c1"></span>			<span class="c1">// 右节点入栈
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="c1">// 左节点入栈
</span><span class="c1"></span>
			<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="c1">// 中节点入栈
</span><span class="c1"></span>			<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span>
			<span class="c1">// 中节点以及处理,所以标记
</span><span class="c1"></span>			<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>

		<span class="p">}</span><span class="k">else</span> <span class="p">{</span><span class="c1">// 如果遇到nil,就弹出并加入结果集
</span><span class="c1"></span>			<span class="nx">node</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>3.2 中序遍历(左 中 右)</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 迭代的统一写法 , 中序遍历(左 中 右)
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">inorderTraversal11</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">result</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="nx">stack</span> <span class="o">:=</span>  <span class="p">[]</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">{</span><span class="nx">root</span><span class="p">}</span>
	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// 首先从队列取出一个接地
</span><span class="c1"></span>		<span class="nx">inorder</span> <span class="o">:=</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="c1">// 判断是否为 nil , 不是空说明没有处理过, 因为处理过的节点 紧跟着都加了 nil 标记
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">inorder</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// 如果右边不是 nil, 就加入到队列
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">inorder</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">inorder</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="c1">// 中间节点加入队列
</span><span class="c1"></span>			<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">inorder</span><span class="p">)</span>
			<span class="c1">// 中节点访问过，但是还没有处理，加入空节点做为标记。
</span><span class="c1"></span>			<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span><span class="kc">nil</span> <span class="p">)</span>
			<span class="c1">// 如果左边不是 nil, 就加入到队列
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">inorder</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">inorder</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span> <span class="c1">// 空节点, 说明 nil前面的节点是处理过的, 直接添加到 result即可
</span><span class="c1"></span>			<span class="nx">inorder</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="c1">// 结果集
</span><span class="c1"></span>			<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">inorder</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>

<span class="p">}</span>
</code></pre></div><ul>
<li>3.3 后序遍历( 左 右 中)</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 统一写法 后序遍历( 左 右 中)
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">postorderTraversal</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">result</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="nx">stack</span> <span class="o">:=</span> <span class="p">[]</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">{</span><span class="nx">root</span><span class="p">}</span>
	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">node</span> <span class="o">:=</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="k">if</span> <span class="nx">node</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// 中节点, nil用于标记
</span><span class="c1"></span>			<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">node</span><span class="p">,</span><span class="kc">nil</span> <span class="p">)</span>
			<span class="c1">// 右节点
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="c1">// 左节点
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span><span class="c1">// 遇到标记节点
</span><span class="c1"></span>			<span class="c1">// 在取一次, 标记节点前面的节点就是需要加入结果集的内容
</span><span class="c1"></span>			<span class="nx">node</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>

<span class="p">}</span>
</code></pre></div><hr>
<blockquote>
<p>参考文档</p>
</blockquote>
<ul>
<li><a href="https://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html">Morris Traversal方法遍历二叉树</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/101321696">神级遍历——morris</a></li>
</ul>
<h3 id="4-morris-遍历-o1空间复杂度">4. morris 遍历 (O(1)空间复杂度)</h3>
<ul>
<li>4.1 先序遍历</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// morris 前序遍历写法
</span><span class="c1">// 规则: (规则的目的主要是能找到回溯的路径)
</span><span class="c1">// 1. curr 无左孩子, 那么输出curr 并且右移 (curr = curr.right)
</span><span class="c1">// 2. curr 有左孩子, 那么记录左孩子的最右节点 mostright (所以这里是循环找)
</span><span class="c1">//   2.1 如果mostright.right == nil(找到最右节点), 那么就让他指向curr 并且curr 左移, mostright.right = curr (这就是回溯的路线),curr = curr.left
</span><span class="c1">//   2.2 如果mostright.right == curr(说明已经遍历过),那么就让他指向nil并且curr 右移,mostright.right = nil (还原二叉树),curr = curr.right
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">preorderTraversalMorris</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">curr</span> <span class="o">:=</span> <span class="nx">root</span>
	<span class="k">for</span> <span class="nx">curr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 1. 无左孩子
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Left</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">curr</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
			<span class="nx">curr</span> <span class="p">=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Right</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span>	<span class="c1">// 2. 有左孩子
</span><span class="c1"></span>			<span class="c1">// 先记录一个mostRight
</span><span class="c1"></span>			<span class="nx">mostRight</span> <span class="o">:=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Left</span>
			<span class="c1">// 一直循环找 curr.Left 的最右节点
</span><span class="c1"></span>			<span class="k">for</span> <span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="nx">curr</span> <span class="p">{</span>
				<span class="nx">mostRight</span> <span class="p">=</span> <span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span>
			<span class="p">}</span>
			<span class="c1">// 2.1 如果找到了
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">curr</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>		
				<span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="p">=</span> <span class="nx">curr</span>
				<span class="nx">curr</span> <span class="p">=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Left</span>
			<span class="p">}</span>
			<span class="c1">// 2.2 如果遍历过
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="o">==</span> <span class="nx">curr</span> <span class="p">{</span>
				<span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="p">=</span> <span class="kc">nil</span>
				<span class="nx">curr</span> <span class="p">=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Right</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div><ul>
<li>4.2 中序遍历</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// morris中序遍历
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">inorderTraversalMorris</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">curr</span> <span class="o">:=</span> <span class="nx">root</span>
	<span class="k">for</span> <span class="nx">curr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 1. 无左孩子
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Left</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">curr</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
			<span class="nx">curr</span> <span class="p">=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Right</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span>	<span class="c1">// 2. 有左孩子
</span><span class="c1"></span>			<span class="c1">// 先记录一个mostRight
</span><span class="c1"></span>			<span class="nx">mostRight</span> <span class="o">:=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Left</span>
			<span class="c1">// 一直循环找 curr.Left 的最右节点
</span><span class="c1"></span>			<span class="k">for</span> <span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="nx">curr</span> <span class="p">{</span>
				<span class="nx">mostRight</span> <span class="p">=</span> <span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span>
			<span class="p">}</span>
			<span class="c1">// 2.1 如果找到了
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="p">=</span> <span class="nx">curr</span>
				<span class="nx">curr</span> <span class="p">=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Left</span>
			<span class="p">}</span>
			<span class="c1">// 2.2 如果遍历过
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="o">==</span> <span class="nx">curr</span> <span class="p">{</span>
				<span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="p">=</span> <span class="kc">nil</span>
				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">curr</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span> <span class="c1">// 和前序遍历的区别, 在这里输出是因为已经遍历过左子树
</span><span class="c1"></span>				<span class="nx">curr</span> <span class="p">=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Right</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go算法学习 回溯 分割回文串</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%9B%9E%E6%BA%AF-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/</link>
			<pubDate>Fri, 23 Apr 2021 09:27:50 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%9B%9E%E6%BA%AF-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/</guid>
			<description>说明  纯暴力搜索, 通常可以抽象为N叉树, 树的深度就是递归的深度
  组合问题(不强调顺序) 1234 =&amp;gt; 12,13,14,23,24,34 切割问题(分割回文串) aab =&amp;gt; [a,a,b],[aa,b] 子集问题 排列问题(强调顺序) 1234 =&amp;gt; 12,13,14,21,23,24&amp;hellip; 棋盘问题(N皇后,数独)  回溯算法模板 func backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归  回溯，撤销处理结果 } } 参考文献  力扣题目: 77.组合 力扣题目: 39.组合总和 力扣题目: 131.分割回文串 代码随想录视频 回溯算法-理论（对应力扣题目：77.组合） 代码随想录视频 回溯算法-组合（对应力扣题目：77.组合） 代码随想录视频 回溯算法-组合剪枝（对应力扣题目：77.组合） 代码随想录视频 回溯算法-分割回文串（对应力扣题目：131.分割回文串） 代码随想录图文 回溯算法：分割回文串  例一 77. 组合 //77. 组合 //给定两个整数 n 和 k，返回 1 .</description>
			<content type="html"><![CDATA[<h3 id="说明">说明</h3>
<blockquote>
<p>纯暴力搜索, 通常可以抽象为N叉树, 树的深度就是递归的深度</p>
</blockquote>
<ul>
<li>组合问题(不强调顺序)   1234 =&gt;  12,13,14,23,24,34</li>
<li>切割问题(分割回文串)   aab  =&gt;  [a,a,b],[aa,b]</li>
<li>子集问题</li>
<li>排列问题(强调顺序)     1234 =&gt; 12,13,14,21,23,24&hellip;</li>
<li>棋盘问题(N皇后,数独)</li>
</ul>
<h3 id="回溯算法模板">回溯算法模板</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">backtracking</span><span class="p">(</span><span class="nx">参数</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">终止条件</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">存放结果</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="nx">选择</span><span class="err">：</span><span class="nx">本层集合中元素</span><span class="err">（</span><span class="nx">树中节点孩子的数量就是集合的大小</span><span class="err">）</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">处理节点</span><span class="p">;</span>
        <span class="nf">backtracking</span><span class="p">(</span><span class="nx">路径</span><span class="err">，</span><span class="nx">选择列表</span><span class="p">);</span> <span class="c1">// 递归
</span><span class="c1"></span>        <span class="nx">回溯</span><span class="err">，</span><span class="nx">撤销处理结果</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h3 id="参考文献">参考文献</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/combinations/">力扣题目: 77.组合</a></li>
<li><a href="https://leetcode-cn.com/problems/combination-sum/">力扣题目: 39.组合总和</a></li>
<li><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">力扣题目: 131.分割回文串</a></li>
<li><a href="https://www.bilibili.com/video/BV1cy4y167mM">代码随想录视频 回溯算法-理论（对应力扣题目：77.组合）</a></li>
<li><a href="https://www.bilibili.com/video/BV1ti4y1L7cv">代码随想录视频 回溯算法-组合（对应力扣题目：77.组合）</a></li>
<li><a href="https://www.bilibili.com/video/BV1wi4y157er/?spm_id_from=autoNext">代码随想录视频 回溯算法-组合剪枝（对应力扣题目：77.组合）</a></li>
<li><a href="https://www.bilibili.com/video/BV1c54y1e7k6">代码随想录视频 回溯算法-分割回文串（对应力扣题目：131.分割回文串）</a></li>
<li><a href="https://mp.weixin.qq.com/s/Pb1epUTbU8fHIht-g_MS5Q">代码随想录图文 回溯算法：分割回文串</a></li>
</ul>
<h3 id="例一-77-组合">例一 77. 组合</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">//77. 组合
</span><span class="c1">//给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。
</span><span class="c1">//
</span><span class="c1">//示例:
</span><span class="c1">//
</span><span class="c1">//输入: n = 4, k = 2
</span><span class="c1">//输出:
</span><span class="c1">//[
</span><span class="c1">//  [2,4],
</span><span class="c1">//  [3,4],
</span><span class="c1">//  [2,3],
</span><span class="c1">//  [1,2],
</span><span class="c1">//  [1,3],
</span><span class="c1">//  [1,4],
</span><span class="c1">//]
</span><span class="c1">//https://leetcode-cn.com/problems/combinations/
</span><span class="c1">// bilibili视频: https://www.bilibili.com/video/BV1ti4y1L7cv/?spm_id_from=autoNext
</span><span class="c1"></span>
<span class="c1">// 思路
</span><span class="c1">// 首先根据回溯算法的模板,这里n代表的就是横向的循环, k影响递归的深度
</span><span class="c1">// n = 4, k = 2
</span><span class="c1">//
</span><span class="c1">// 	  1       2     3   4
</span><span class="c1">//  2 3 4     3 4   4
</span><span class="c1">// 12|13|14 23|24   34
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">combine</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="nx">path</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>

	<span class="c1">// 1. 递归参数和返回值
</span><span class="c1"></span>	<span class="c1">// 2. 递归的终止条件
</span><span class="c1"></span>	<span class="c1">// 3. 单词递归的逻辑
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">backtracking</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
	<span class="nx">backtracking</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">startIndex</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">{</span>
		<span class="c1">// 递归的终止条件
</span><span class="c1"></span>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span> <span class="o">==</span> <span class="nx">k</span> <span class="p">{</span>
			<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nb">append</span><span class="p">([]</span><span class="kt">int</span><span class="p">{},</span><span class="nx">path</span><span class="o">...</span><span class="p">))</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span> <span class="nx">startIndex</span><span class="p">;</span><span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span> <span class="p">;</span><span class="nx">i</span> <span class="o">++</span> <span class="p">{</span>
			<span class="c1">// 寻找组合
</span><span class="c1"></span>			<span class="nx">path</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
			<span class="nf">backtracking</span><span class="p">(</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
			<span class="c1">// 回溯过程
</span><span class="c1"></span>			<span class="nx">path</span> <span class="p">=</span> <span class="nx">path</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">backtracking</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>


</code></pre></div><h3 id="例二-39组合总和">例二: 39.组合总和</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// 思路
</span><span class="c1">//  candidates = [2,3,5], target = 8,
</span><span class="c1">//    		  2     		  3	    	 5
</span><span class="c1">//   	2	  3 	5       3   5 		 5
</span><span class="c1">// 	  235     35    5       35  
</span><span class="c1">// 235 35 5  35 5   
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">combinationSum</span><span class="p">(</span><span class="nx">candidates</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">target</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="nx">path</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="nx">pathInt</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="kd">var</span> <span class="nx">backTracking</span> <span class="kd">func</span><span class="p">(</span><span class="nx">startIndex</span> <span class="kt">int</span><span class="p">)</span>
	<span class="c1">// 递归三部曲
</span><span class="c1"></span>	<span class="c1">// 1. 递归参数, 这里需要开始位置
</span><span class="c1"></span>	<span class="c1">// 2. 终止条件, path的结果和等于target, 或者大于
</span><span class="c1"></span>	<span class="c1">// 3. 单次递归逻辑, 往path里添加结果 , 只要小于target
</span><span class="c1"></span>	<span class="nx">backTracking</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">startIndex</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">pathInt</span> <span class="o">==</span> <span class="nx">target</span> <span class="p">{</span>
			<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nb">append</span><span class="p">([]</span><span class="kt">int</span><span class="p">{},</span><span class="nx">path</span><span class="o">...</span><span class="p">))</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="c1">// 超过target也需要返回, 但是不用保存数据
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">pathInt</span> <span class="p">&gt;</span> <span class="nx">target</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
        <span class="c1">// 可以遍历同一个数字, 但不使用startIndex 前面的值, 应该组合是不可重复的
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span> <span class="nx">startIndex</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">candidates</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>

			<span class="k">if</span> <span class="nx">pathInt</span> <span class="p">&lt;</span> <span class="nx">target</span> <span class="p">{</span>
				<span class="nx">pathInt</span> <span class="o">+=</span> <span class="nx">candidates</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
				<span class="nx">path</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">candidates</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">)</span>
			<span class="p">}</span>
			<span class="c1">// 可以无限使用同一个
</span><span class="c1"></span>			<span class="nf">backTracking</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
			<span class="c1">// 回溯
</span><span class="c1"></span>			<span class="nx">path</span> <span class="p">=</span> <span class="nx">path</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">pathInt</span> <span class="o">-=</span> <span class="nx">candidates</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">backTracking</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>


</code></pre></div><h3 id="例三-131分割回文串">例三: 131.分割回文串</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="c1">// 简单思路
</span><span class="c1">// 切割方式, 按照树的方式:
</span><span class="c1">// 横向→循环,  纵向↓递归
</span><span class="c1">//            		aab
</span><span class="c1">//      a/      	|aa   	\aab 		//第一次切割分成三个节点, a后切割,aa后切割,aab后切割 ,对应代码的 i=0,1,2,其中分割后的结果append到path切片中
</span><span class="c1">//    a/   \b    	|b    	(aab|)		//第二次切割分成四个节点, a|a|,(a|ab|),(aa|b|),(aab|)  带括号的已经是叶子节点,该情况结束,本次递归可以返回
</span><span class="c1">//   b|    (a|ab|) (aa|b|)				//第三次切割分成四个节点, (a|a|b|),(a|ab|),(aa|b|),(aab|)
</span><span class="c1">//  (a|a|b|)
</span><span class="c1">// 以上所有方案为四种切割方式: (a|a|b|) (a|ab|) (aa|b|) (aab|)
</span><span class="c1">// 代码部分需要注意, 在切割a|a|b| 之后需要回溯,想要回溯到 a|ab|,需将path中 a|a|b|的 后面(a|b|)删除, 当path=a,则可以继续切割出 (a|ab|)节点, 后续回溯同样
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">partition</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">result</span> <span class="p">[][]</span><span class="kt">string</span>
	<span class="c1">// 判断是否回文
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">isPalindrome</span> <span class="kd">func</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span>
	<span class="nx">isPalindrome</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">true</span>
		<span class="p">}</span>
		<span class="nx">head</span><span class="p">,</span> <span class="nx">tail</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
		<span class="k">for</span> <span class="nx">head</span> <span class="p">&lt;</span> <span class="nx">tail</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">s</span><span class="p">[</span><span class="nx">head</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">tail</span><span class="p">]</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">false</span>
			<span class="p">}</span>
			<span class="nx">head</span><span class="o">++</span>
			<span class="nx">tail</span><span class="o">--</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">backtracking</span> <span class="kd">func</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">startIndex</span> <span class="kt">int</span><span class="p">)</span>
	<span class="c1">//startIndex 就是切割的位置
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">path</span> <span class="p">[]</span><span class="kt">string</span>
	<span class="nx">backtracking</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">startIndex</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">startIndex</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// 为什么要这样添加, 是因为path这个函数外slice 会最终被修改,导致最后append是相同的数据
</span><span class="c1"></span>			<span class="c1">//var newPath []string
</span><span class="c1"></span>			<span class="c1">//newPath = append(newPath,path...)
</span><span class="c1"></span>			<span class="c1">//result = append(result, newPath)
</span><span class="c1"></span>			<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nb">append</span><span class="p">([]</span><span class="nb">string</span><span class="p">(</span><span class="kc">nil</span><span class="p">),</span> <span class="nx">path</span><span class="o">...</span><span class="p">))</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">startIndex</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="c1">// 假如这里startIndex = 0 , 切割到第一个a后面
</span><span class="c1"></span>			<span class="c1">// i=1 [startIndex:i+1] = [0:1] = a 是回文
</span><span class="c1"></span>			<span class="c1">// i=2 [startIndex:i+1] = [1:2] = a 是回文
</span><span class="c1"></span>			<span class="c1">// i=3 [startIndex:i+1] = [2:3] = b 是回文
</span><span class="c1"></span>			<span class="c1">//fmt.Println(s[startIndex:i+1])
</span><span class="c1"></span>			<span class="k">if</span> <span class="nf">isPalindrome</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">startIndex</span> <span class="p">:</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
				<span class="nx">path</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">s</span><span class="p">[</span><span class="nx">startIndex</span><span class="p">:</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
				<span class="c1">//fmt.Println(&#34;backtracking前&#34;,startIndex,s[startIndex:i+1],path)
</span><span class="c1"></span>
				<span class="c1">// 寻找 i =1 的切割点
</span><span class="c1"></span>				<span class="nf">backtracking</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

				<span class="c1">// 回溯  重要!!!
</span><span class="c1"></span>				<span class="c1">// 每次 backtracking 函数执行返回的时候就是 startIndex == len(s)的时候, 也就是结果path已经添加到result中了
</span><span class="c1"></span>				<span class="c1">// 由于在isPalindrome 中, 所以前面path append了几次, backtracking函数退出的时候这里就会删除几次
</span><span class="c1"></span>				<span class="c1">// 因为是回溯, 当然是要每次删除一个尾部内容
</span><span class="c1"></span>				<span class="nx">path</span> <span class="p">=</span> <span class="nx">path</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
				<span class="c1">//fmt.Println(&#34;backtracking后&#34;,startIndex,s[startIndex:i+1],path)
</span><span class="c1"></span>			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">backtracking</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">partition</span><span class="p">(</span><span class="s">&#34;aab&#34;</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">partition</span><span class="p">(</span><span class="s">&#34;cdadad&#34;</span><span class="p">))</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go算法学习 辗转相除法</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95/</link>
			<pubDate>Fri, 16 Apr 2021 15:56:59 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95/</guid>
			<description></description>
			<content type="html"><![CDATA[<p>原文: <a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653189913&amp;idx=1&amp;sn=8667ba0170aef9b6c34713ce8cea60a8&amp;chksm=8c9905c3bbee8cd56d079bb0a436a46a18eb43061bc9390483f6cca692760f01cb575241ffff&amp;scene=21#wechat_redirect">程序员小灰 辗转相除法 更相减损术</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="c1">// 求最大公约数, 两个数都能整除的最大整数
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">MaxMin</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">a</span>
<span class="p">}</span>

<span class="c1">// 1. 暴力 O(min(a,b))
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">getGreatestCommonDivisor</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">max</span><span class="p">,</span> <span class="nx">min</span> <span class="o">:=</span> <span class="nf">MaxMin</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">max</span><span class="o">%</span><span class="nx">min</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">min</span>
	<span class="p">}</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="nx">min</span>
	<span class="k">for</span> <span class="nx">a</span><span class="o">%</span><span class="nx">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">b</span><span class="o">%</span><span class="nx">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">i</span><span class="o">--</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">i</span>
<span class="p">}</span>

<span class="c1">// 2. 辗转相除法 O(log(max(a,b)))
</span><span class="c1">// 两个数的最大公约数 = 大数对小数取余结果 和小数 的最大公约数
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">getGreatestCommonDivisor2</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nf">MaxMin</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
	<span class="c1">//取余
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">m</span><span class="o">%</span><span class="nx">n</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">m</span><span class="p">,</span> <span class="nx">n</span> <span class="p">=</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">m</span><span class="o">%</span><span class="nx">n</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">n</span>
<span class="p">}</span>

<span class="c1">// 3. 更相减损术(出自算术九章) O(max(a,b))
</span><span class="c1">// 两个数的最大公约数 = 大数减小数结果 和小数的最大公约数
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">getGreatestCommonDivisor3</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nf">MaxMin</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">m</span><span class="o">!=</span><span class="nx">n</span>  <span class="p">{</span>
		<span class="nx">m</span><span class="p">,</span> <span class="nx">n</span> <span class="p">=</span> <span class="nf">MaxMin</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">m</span><span class="o">-</span><span class="nx">n</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">n</span>
<span class="p">}</span>

<span class="c1">// 4. 更相减损术+移位操作
</span><span class="c1">// gcb(a,b)代表 a,b的最大公约数
</span><span class="c1">// 4.1 a,b都是偶数: 	gcb(a,b) = 2 * gcb(a/2,b/2)	= 2 * gcb(a&gt;&gt;1,b&gt;&gt;1)
</span><span class="c1">// 4.2 a,b是奇偶: 	gcb(a,b) = gcb(a,b/2)		= gcb(a,b&gt;&gt;1)
</span><span class="c1">// 4.3 a,b是偶奇: 	gcb(a,b) = 2 * gcb(a/2,b)	= gcb(a&gt;&gt;1,b)
</span><span class="c1">// 4.4 a,b都是奇数: 	gcb(a,b) = gcb((a-b)/2,b)	= gcb((a-b)&gt;&gt;1,b)  因为a-b必然是偶数
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">getGreatestCommonDivisor4</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nf">MaxMin</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">gcb</span> <span class="kd">func</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
	<span class="nx">gcb</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">m</span> <span class="o">==</span> <span class="nx">n</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">n</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">m</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// 偶 偶
</span><span class="c1"></span>				<span class="k">return</span> <span class="nf">gcb</span><span class="p">(</span><span class="nx">m</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">,</span><span class="nx">n</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">m</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// 奇 偶
</span><span class="c1"></span>				<span class="k">return</span> <span class="nf">gcb</span><span class="p">(</span><span class="nf">MaxMin</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span><span class="nx">n</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">))</span>
			<span class="p">}</span><span class="k">else</span> <span class="k">if</span> <span class="nx">m</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>	<span class="c1">// 偶 奇
</span><span class="c1"></span>				<span class="k">return</span> <span class="nf">gcb</span><span class="p">(</span><span class="nf">MaxMin</span><span class="p">(</span><span class="nx">m</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">,</span><span class="nx">n</span><span class="p">))</span>
			<span class="p">}</span><span class="k">else</span> <span class="p">{</span>	<span class="c1">// 奇 奇
</span><span class="c1"></span>				<span class="k">return</span> <span class="nf">gcb</span><span class="p">(</span><span class="nf">MaxMin</span><span class="p">((</span><span class="nx">m</span><span class="o">-</span><span class="nx">n</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">,</span><span class="nx">n</span><span class="p">))</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">n</span> <span class="p">=</span> <span class="nf">gcb</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span><span class="nx">n</span> <span class="p">)</span>
	<span class="k">return</span> <span class="nx">n</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">getGreatestCommonDivisor</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">768</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">getGreatestCommonDivisor2</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">768</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">getGreatestCommonDivisor3</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">248</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">getGreatestCommonDivisor4</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">248</span><span class="p">))</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go算法学习 最小栈的实现</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%9C%80%E5%B0%8F%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
			<pubDate>Fri, 16 Apr 2021 10:09:37 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%9C%80%E5%B0%8F%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
			<description></description>
			<content type="html"><![CDATA[<p>原文: <a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653190073&amp;idx=1&amp;sn=c20c002127e2ce3fe0c71a00aee70806&amp;chksm=8c990563bbee8c75521c54ea8eb44b009ad07266b1e5fbf22926baf9a7b7302c7e4f7657dbb8&amp;scene=21#wechat_redirect">程序员小灰 最小栈的实现</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>


<span class="c1">//题目：实现一个栈，带有出栈（pop），入栈（push），取最小元素（getMin）三个方法。要保证这三个方法的时间复杂度都是O（1）。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">stack</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">V</span> <span class="p">[]</span><span class="kt">int</span>	<span class="c1">// 栈存储
</span><span class="c1"></span>	<span class="nx">Min</span> <span class="p">[]</span><span class="kt">int</span>	<span class="c1">//栈最小值下标存储
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// 入栈
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">stack</span><span class="p">)</span> <span class="nf">Pop</span><span class="p">(</span><span class="nx">a</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 入栈
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nx">V</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
	<span class="c1">// 判断min是否为空
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">Min</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 如果比最小栈 栈顶值小, 就入栈
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">a</span> <span class="p">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">[</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">Min</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 出栈
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">stack</span><span class="p">)</span> <span class="nf">Push</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c1">// 出栈
</span><span class="c1"></span>	<span class="nx">a1</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="c1">// 如果出栈的下标等于最小栈栈顶的值,就删除最小栈栈顶
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">Min</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="c1">// 在删除栈顶
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nx">V</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

	<span class="k">return</span> <span class="nx">a1</span>
<span class="p">}</span>

<span class="c1">//新建堆
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewStack</span><span class="p">(</span><span class="nx">l</span> <span class="o">...</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">stack</span><span class="p">{</span>
	<span class="nx">stack1</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">stack</span><span class="p">{}</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">l</span> <span class="p">{</span>
		<span class="nx">stack1</span><span class="p">.</span><span class="nf">Pop</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">stack1</span>
<span class="p">}</span>

<span class="c1">// 查询最小值
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">stack</span><span class="p">)</span> <span class="nf">GetMin</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">min</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">Min</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="k">return</span> <span class="nx">min</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">stack1</span> <span class="o">:=</span> <span class="nf">NewStack</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">14</span><span class="p">}</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">stack1</span><span class="p">.</span><span class="nf">Pop</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">stack1</span><span class="p">)</span>
	<span class="nx">stack1</span><span class="p">.</span><span class="nf">Pop</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">stack1</span><span class="p">)</span>
	<span class="nx">stack1</span><span class="p">.</span><span class="nf">Pop</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">stack1</span><span class="p">)</span>
	<span class="nx">stack1</span><span class="p">.</span><span class="nf">Push</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">stack1</span><span class="p">)</span>

<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go算法学习 找出缺失的整数</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%89%BE%E5%87%BA%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B4%E6%95%B0/</link>
			<pubDate>Thu, 15 Apr 2021 18:09:46 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%89%BE%E5%87%BA%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B4%E6%95%B0/</guid>
			<description>原文: 程序员小灰 找出缺失的整数
实现代码 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;math/rand&amp;#34; &amp;#34;time&amp;#34; ) var ( a []int b []int c []int l = 100 r = rand.New(rand.NewSource(time.Now().UnixNano())) ) func init() { // 1~10 随机数 	tmp := r.Intn(l-1)+1 // 在生成一个不等于tmp的随机数 	var tmp2 int for tmp2 == 0 || tmp2 == tmp { tmp2 = r.Intn(l-1)+1 } fmt.Println(tmp,tmp2) for i:=1 ;i &amp;lt;=l;i++ { if i == tmp { b = append(b, i) continue } a = append(a, i) b = append(b, i) b = append(b, i) } for i:=1 ;i &amp;lt;=l;i++ { if i == tmp ||i == tmp2 { c = append(c,i) continue } c = append(c,i) c = append(c,i) } //fmt.</description>
			<content type="html"><![CDATA[<p>原文: <a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653189951&amp;idx=1&amp;sn=0181c95484b67d108672235b14e5ebbb&amp;chksm=8c9905e5bbee8cf3362ccc4c7e091caa18b5783183ce4475b6f011c09c1cb03847ea4cb5220c&amp;scene=21#wechat_redirect">程序员小灰 找出缺失的整数</a></p>
<h3 id="实现代码">实现代码</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;math/rand&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">a</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="nx">b</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="nx">c</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="nx">l</span> <span class="p">=</span> <span class="mi">100</span>
	<span class="nx">r</span> <span class="p">=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nf">NewSource</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UnixNano</span><span class="p">()))</span>

<span class="p">)</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 1~10 随机数
</span><span class="c1"></span>	<span class="nx">tmp</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="nx">l</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
	<span class="c1">// 在生成一个不等于tmp的随机数
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">tmp2</span> <span class="kt">int</span>
	<span class="k">for</span> <span class="nx">tmp2</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">tmp2</span> <span class="o">==</span> <span class="nx">tmp</span> <span class="p">{</span>
		<span class="nx">tmp2</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="nx">l</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
	<span class="p">}</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">tmp</span><span class="p">,</span><span class="nx">tmp2</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">1</span> <span class="p">;</span><span class="nx">i</span> <span class="o">&lt;=</span><span class="nx">l</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="nx">tmp</span> <span class="p">{</span>
			<span class="nx">b</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">a</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
		<span class="nx">b</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
		<span class="nx">b</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>

	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">1</span> <span class="p">;</span><span class="nx">i</span> <span class="o">&lt;=</span><span class="nx">l</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="nx">tmp</span> <span class="o">||</span><span class="nx">i</span> <span class="o">==</span> <span class="nx">tmp2</span>  <span class="p">{</span>
			<span class="nx">c</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">c</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span>
		<span class="nx">c</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">//fmt.Println(&#34;&gt;&gt;&gt; 有序数组&#34;)
</span><span class="c1"></span>	<span class="c1">//fmt.Println(a)
</span><span class="c1"></span>	<span class="c1">//fmt.Println(b)
</span><span class="c1"></span>	<span class="c1">//fmt.Println(c)
</span><span class="c1"></span>	<span class="nf">random</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
	<span class="nf">random</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
	<span class="nf">random</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
	<span class="c1">//fmt.Println(&#34;&gt;&gt;&gt; 无序数组&#34;)
</span><span class="c1"></span>	<span class="c1">//fmt.Println(a)
</span><span class="c1"></span>	<span class="c1">//fmt.Println(b)
</span><span class="c1"></span>	<span class="c1">//fmt.Println(c)
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// 随机打乱字符串算法
</span><span class="c1">//Fisher-Yates随机置乱算法
</span><span class="c1">//也称高纳德置乱算法
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">random</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)&gt;</span><span class="mi">0</span> <span class="p">{</span>
		<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>
		<span class="nx">tmp</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
		<span class="nx">nums</span><span class="p">[</span><span class="nx">tmp</span><span class="p">]</span> <span class="p">,</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">tmp</span><span class="p">]</span>
		<span class="c1">//对前n-1进行替换
</span><span class="c1"></span>		<span class="nx">nums</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[:</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">//题目：一个无序数组里有99个不重复正整数，范围从1到100，唯独缺少一个整数。如何找出这个缺失的整数？
</span><span class="c1"></span><span class="kd">func</span>  <span class="nf">findInt1</span><span class="p">(</span><span class="nx">a</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">)</span> <span class="kt">int</span>  <span class="p">{</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span> <span class="mi">0</span> <span class="p">;</span><span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">l</span><span class="o">-</span><span class="mi">1</span> <span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">sum</span><span class="o">+=</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="nx">l</span><span class="p">)</span><span class="o">*</span><span class="nx">l</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="nx">sum</span>
<span class="p">}</span>

<span class="c1">//题目扩展：一个无序数组里有若干个正整数，范围从1到100，其中99个整数都出现了偶数次，
</span><span class="c1">//只有一个整数出现了奇数次（比如1,1,2,2,3,3,4,5,5），如何找到这个出现奇数次的整数？
</span><span class="c1">// 思路: 所有的数做 异或
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">findInt2</span><span class="p">(</span><span class="nx">a</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">rst</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span> <span class="mi">1</span> <span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
		<span class="nx">rst</span> <span class="p">^=</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">rst</span>
<span class="p">}</span>

<span class="c1">//题目第二次扩展：一个无序数组里有若干个正整数，范围从1到100，其中98个整数都出现了偶数次，
</span><span class="c1">//只有两个整数出现了奇数次（比如1,1,2,2,3,4,5,5），如何找到这个出现奇数次的整数？
</span><span class="c1">// 思路:
</span><span class="c1">// 1. 先对所有数异或, 异或的结果就是两个奇数的异或结果, 这个数二进制位必定有一位是1
</span><span class="c1">// 2. 按异或结果其中一个1的位置, 将无序数组分成两个数组
</span><span class="c1">//
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">findInt3</span><span class="p">(</span><span class="nx">a</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">a1</span> <span class="o">:=</span> <span class="nf">findInt2</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
	<span class="c1">//fmt.Println(a1)
</span><span class="c1"></span>	<span class="nx">m</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">a1</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">a1</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
		<span class="nx">m</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="c1">//fmt.Println(m)
</span><span class="c1"></span>	<span class="nx">odd</span><span class="p">,</span><span class="nx">even</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// 说明该位 是1
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="nx">m</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
			<span class="nx">odd</span> <span class="p">^=</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
			<span class="nx">even</span> <span class="p">^=</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">odd</span><span class="p">,</span><span class="nx">even</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">findInt1</span><span class="p">(</span><span class="nx">a</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">findInt2</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">findInt3</span><span class="p">(</span><span class="nx">c</span><span class="p">))</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go学习 Goroutine泄露</title>
			<link>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-goroutine%E6%B3%84%E9%9C%B2/</link>
			<pubDate>Thu, 25 Feb 2021 10:43:52 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-goroutine%E6%B3%84%E9%9C%B2/</guid>
			<description>&lt;p&gt;goroutine 泄露常见说明&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>goroutine 泄露常见说明</p>
<blockquote>
<p>参考文档</p>
</blockquote>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/74090074">Go 笔记之如何防止 goroutine 泄露</a></li>
<li><a href="https://juejin.cn/post/6844903901410361358">Go 笔记之如何防止 goroutine 泄露（二）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/68921032">Go 译文之如何构建并发 Pipeline</a></li>
</ul>
<h3 id="泄露情况分类">泄露情况分类</h3>
<ul>
<li>
<ol>
<li>死循环导致goroutine 无法退出</li>
</ol>
</li>
<li>
<ol start="2">
<li>channel泄露</li>
</ol>
<ul>
<li>发送无接收</li>
<li>接收无发送</li>
<li>nil channel 发送和接收都会阻塞, 通过select方式, nil channel不会被select</li>
</ul>
</li>
<li>
<ol start="3">
<li>传统同步机制</li>
</ol>
<ul>
<li>sync.Mutex 使用未释放, 建议Lock 后执行defer  Unlock</li>
<li>sync.WaitGroup 设置的任务数错误导致一直 wait阻塞, 建议每次wg.Add(1)</li>
</ul>
</li>
</ul>
<h3 id="简单实例">简单实例</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="kd">func</span> <span class="nf">Test4</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
	<span class="nx">count</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">())</span>
	<span class="nx">timeout</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">{</span>
            <span class="k">select</span> <span class="p">{</span>
        	<span class="k">case</span> <span class="nx">c</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}:</span>
        		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
        	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
        		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;停止写入 ... &#34;</span><span class="p">)</span>
        		<span class="k">return</span>
        	<span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}()</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">c</span><span class="p">:</span>
			<span class="nx">count</span><span class="o">++</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">timeout</span><span class="p">:</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;timeout ... &#34;</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="mi">50</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">count</span> <span class="p">&gt;</span> <span class="mi">3</span> <span class="p">{</span>
				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;已经写入三次, 准备停止...&#34;</span><span class="p">)</span>
				<span class="nf">cancel</span><span class="p">()</span>
				<span class="k">return</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div><h3 id="自动化测试泄露">自动化测试泄露</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">TestTest4</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">//defer goleak.VerifyNone(t)
</span><span class="c1"></span>	<span class="k">defer</span> <span class="nx">leaktest</span><span class="p">.</span><span class="nf">Check</span><span class="p">(</span><span class="nx">t</span><span class="p">)()</span>
	<span class="nf">Test4</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><h3 id="通过-runtimenumgoroutine-函数计数">通过 runtime.NumGoroutine() 函数计数</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;runtime.NumGoroutine : &#34;</span><span class="p">,</span><span class="nx">runtime</span><span class="p">.</span><span class="nf">NumGoroutine</span><span class="p">())</span>
			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="mi">500</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">test1</span><span class="p">.</span><span class="nf">Test3</span><span class="p">()</span>
	<span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go源码学习 Sort包Search方法</title>
			<link>https://www.ngirl.xyz/golang/go%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-sort%E5%8C%85search%E6%96%B9%E6%B3%95/</link>
			<pubDate>Mon, 25 Jan 2021 14:54:22 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-sort%E5%8C%85search%E6%96%B9%E6%B3%95/</guid>
			<description>&lt;p&gt;Sort包Search方法的实践说明&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>Sort包Search方法的实践说明</p>
<h3 id="首先查看示例">首先查看示例</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;sort&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">data</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span>
	<span class="nx">sort</span><span class="p">.</span><span class="nf">Ints</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
	<span class="c1">// Search 会查询已排序数列 满足条件的最小索引
</span><span class="c1"></span>	<span class="nx">i</span> <span class="o">:=</span> <span class="nx">sort</span><span class="p">.</span><span class="nf">Search</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">),</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;当前查询的index: %v, 查询的结果data[%v]: %v&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="c1">// 因为该列表已经排序, 满足二分条件(即左边全部小于右边)
</span><span class="c1"></span>		<span class="c1">// 当满足条件的时候, 向前查询
</span><span class="c1"></span>		<span class="c1">// 只要满足条件, 前面就可能还有更小的满足条件的值
</span><span class="c1"></span>		<span class="k">return</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">23</span>
	<span class="p">})</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;最终的结果为&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="c1">// 1
</span><span class="c1"></span><span class="p">}</span>

</code></pre></div><h3 id="sort的search源码">sort的Search源码</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Search</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c1">// Define f(-1) == false and f(n) == true.
</span><span class="c1"></span>	<span class="c1">// Invariant: f(i-1) == false, f(j) == true.
</span><span class="c1"></span>	<span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">n</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">j</span> <span class="p">{</span>
		<span class="c1">// 这里左移 实现二分 h = (i+j) / 2
</span><span class="c1"></span>		<span class="nx">h</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">uint</span><span class="p">(</span><span class="nx">i</span><span class="o">+</span><span class="nx">j</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// avoid overflow when computing h
</span><span class="c1"></span>		<span class="c1">// i ≤ h &lt; j
</span><span class="c1"></span>		<span class="c1">// 如果f(h) 为false, 那么就执行 i = h + 1 , 查看 中间位置的下一个值, 向后查询
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nf">f</span><span class="p">(</span><span class="nx">h</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">i</span> <span class="p">=</span> <span class="nx">h</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// preserves f(i-1) == false
</span><span class="c1"></span>		<span class="c1">// 否则f(h) 为true , 那么执行 j = h , 查询的区间由 (i,n) 变成 (i,h) , 向前查询
</span><span class="c1"></span>		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">j</span> <span class="p">=</span> <span class="nx">h</span> <span class="c1">// preserves f(j) == true
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// i == j, f(i-1) == false, and f(j) (= f(i)) == true  =&gt;  answer is i.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">i</span>
<span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go学习 并发的实现原理</title>
			<link>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-%E5%B9%B6%E5%8F%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
			<pubDate>Thu, 14 Jan 2021 17:49:48 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-%E5%B9%B6%E5%8F%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
			<description>&lt;p&gt;go&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>go</p>
<ul>
<li><a href="https://studygolang.com/articles/22390?fr=sidebar">【深度知识】GO语言的goroutine并发原理和调度机制</a></li>
</ul>
<h3 id="go并发的模型">go并发的模型</h3>
<ul>
<li>多线程共享内存</li>
<li>CSP(communicating sequential processes)   - 以通信的方式来共享内存</li>
</ul>
<h3 id="go的csp并发模型是通过goroutine和channel来实现的">Go的CSP并发模型，是通过goroutine和channel来实现的。</h3>
<ul>
<li>goroutine 是Go语言中并发的执行单位。有点抽象，其实就是和传统概念上的&quot;线程“类似，可以理解为&quot;线程“。</li>
<li>channel是Go语言中各个并发结构体(goroutine)之前的通信机制。 通俗的讲，就是各个goroutine之间通信的&quot;管道“，有点类似于Linux中的管道。</li>
</ul>
<h3 id="go线程实现模型mpg">Go线程实现模型MPG</h3>
<ul>
<li>M指的是Machine，一个M直接关联了一个内核线程。由操作系统管理。</li>
<li>P指的是&quot;processor&quot;，代表了M所需的上下文环境，也是处理用户级代码逻辑的处理器。它负责衔接M和G的调度上下文，将等待执行的G与M对接。</li>
<li>G指的是Goroutine，其实本质上也是一种轻量级的线程。包括了调用栈，重要的调度信息，例如channel等。</li>
</ul>
<p><img src="/assets/markdown-img-paste-20210114180539724.png" alt=""></p>
<h3 id="goroutine-小结">Goroutine 小结</h3>
<h4 id="优点">优点：</h4>
<ul>
<li>
<p>1、开销小
POSIX的thread API虽然能够提供丰富的API，例如配置自己的CPU亲和性，申请资源等等，线程在得到了很多与进程相同的控制权的同时，开销也非常的大，在Goroutine中则不需这些额外的开销，所以一个Golang的程序中可以支持10w级别的Goroutine。
每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少（goroutine：2KB ，线程：8MB）</p>
</li>
<li>
<p>2、调度性能好
在Golang的程序中，操作系统级别的线程调度，通常不会做出合适的调度决策。例如在GC时，内存必须要达到一个一致的状态。在Goroutine机制里，Golang可以控制Goroutine的调度，从而在一个合适的时间进行GC。
在应用层模拟的线程，它避免了上下文切换的额外耗费，兼顾了多线程的优点。简化了高并发程序的复杂度。</p>
</li>
</ul>
<h4 id="缺点">缺点：</h4>
<p>协程调度机制无法实现公平调度。</p>]]></content>
		</item>
		
		<item>
			<title>Gee学习-路由trie测试编写</title>
			<link>https://www.ngirl.xyz/golang/gee%E5%AD%A6%E4%B9%A0-%E8%B7%AF%E7%94%B1trie%E6%B5%8B%E8%AF%95%E7%BC%96%E5%86%99/</link>
			<pubDate>Thu, 14 Jan 2021 11:32:54 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/gee%E5%AD%A6%E4%B9%A0-%E8%B7%AF%E7%94%B1trie%E6%B5%8B%E8%AF%95%E7%BC%96%E5%86%99/</guid>
			<description>github地址: github.com/zhangzw001/learnGee
 路由分析测试 package gee import ( &amp;#34;reflect&amp;#34; &amp;#34;testing&amp;#34; ) func TestParsePattern(t *testing.T) { tests := []struct { patterns string parts []string ok bool }{ {&amp;#34;/test/v1/add&amp;#34;, []string{&amp;#34;test&amp;#34;, &amp;#34;v1&amp;#34;, &amp;#34;add&amp;#34;},true }, {&amp;#34;/test/*name/add&amp;#34;, []string{&amp;#34;test&amp;#34;, &amp;#34;*name&amp;#34;},true}, {&amp;#34;/test/:name&amp;#34;, []string{&amp;#34;test&amp;#34;, &amp;#34;:name&amp;#34;},true }, {&amp;#34;/test/:name/abc&amp;#34;, []string{&amp;#34;test&amp;#34;, &amp;#34;:name&amp;#34;, &amp;#34;abc&amp;#34;},true}, {&amp;#34;/test/v1/add&amp;#34;, []string{&amp;#34;testv1&amp;#34;, &amp;#34;add&amp;#34;},false }, {&amp;#34;/test/*name/add&amp;#34;, []string{&amp;#34;test&amp;#34;, &amp;#34;*name&amp;#34;,&amp;#34;add&amp;#34;},false}, {&amp;#34;/test/:name&amp;#34;, []string{&amp;#34;test&amp;#34;, &amp;#34;:&amp;#34;,&amp;#34;name&amp;#34;},false }, {&amp;#34;/test/:name/abc&amp;#34;, []string{&amp;#34;test&amp;#34;, &amp;#34;:name&amp;#34;},false}, } m := make(map[string][]string) for _, test := range tests { m[test.patterns] = test.parts p := parsePattern(test.</description>
			<content type="html"><![CDATA[<p>github地址: <a href="github.com/zhangzw001/learnGee">github.com/zhangzw001/learnGee</a></p>
<hr>
<h3 id="路由分析测试">路由分析测试</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">gee</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;reflect&#34;</span>
	<span class="s">&#34;testing&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">TestParsePattern</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">tests</span> <span class="o">:=</span> <span class="p">[]</span><span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">patterns</span> <span class="kt">string</span>
		<span class="nx">parts</span>    <span class="p">[]</span><span class="kt">string</span>
		<span class="nx">ok</span> <span class="kt">bool</span>
	<span class="p">}{</span>
		<span class="p">{</span><span class="s">&#34;/test/v1/add&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="s">&#34;v1&#34;</span><span class="p">,</span> <span class="s">&#34;add&#34;</span><span class="p">},</span><span class="kc">true</span> <span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;/test/*name/add&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="s">&#34;*name&#34;</span><span class="p">},</span><span class="kc">true</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;/test/:name&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="s">&#34;:name&#34;</span><span class="p">},</span><span class="kc">true</span> <span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;/test/:name/abc&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="s">&#34;:name&#34;</span><span class="p">,</span> <span class="s">&#34;abc&#34;</span><span class="p">},</span><span class="kc">true</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;/test/v1/add&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;testv1&#34;</span><span class="p">,</span> <span class="s">&#34;add&#34;</span><span class="p">},</span><span class="kc">false</span> <span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;/test/*name/add&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="s">&#34;*name&#34;</span><span class="p">,</span><span class="s">&#34;add&#34;</span><span class="p">},</span><span class="kc">false</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;/test/:name&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="s">&#34;:&#34;</span><span class="p">,</span><span class="s">&#34;name&#34;</span><span class="p">},</span><span class="kc">false</span> <span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;/test/:name/abc&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="s">&#34;:name&#34;</span><span class="p">},</span><span class="kc">false</span><span class="p">},</span>
	<span class="p">}</span>

	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">test</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tests</span> <span class="p">{</span>
		<span class="nx">m</span><span class="p">[</span><span class="nx">test</span><span class="p">.</span><span class="nx">patterns</span><span class="p">]</span> <span class="p">=</span> <span class="nx">test</span><span class="p">.</span><span class="nx">parts</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nf">parsePattern</span><span class="p">(</span><span class="nx">test</span><span class="p">.</span><span class="nx">patterns</span><span class="p">)</span>

		<span class="k">if</span> <span class="nx">test</span><span class="p">.</span><span class="nx">ok</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">DeepEqual</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">m</span><span class="p">[</span><span class="nx">test</span><span class="p">.</span><span class="nx">patterns</span><span class="p">])</span> <span class="p">{</span>
				<span class="nx">t</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;expect %v, but actual %v\n&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">[</span><span class="nx">test</span><span class="p">.</span><span class="nx">patterns</span><span class="p">],</span> <span class="nx">p</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">DeepEqual</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">m</span><span class="p">[</span><span class="nx">test</span><span class="p">.</span><span class="nx">patterns</span><span class="p">])</span> <span class="p">{</span>
				<span class="nx">t</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;not expect %v, but actual %v\n&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">[</span><span class="nx">test</span><span class="p">.</span><span class="nx">patterns</span><span class="p">],</span> <span class="nx">p</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>


	<span class="p">}</span>

<span class="p">}</span>


<span class="kd">func</span> <span class="nf">Testrouter_GET</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">tests</span> <span class="o">:=</span> <span class="p">[]</span><span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">method</span>  <span class="kt">string</span>
		<span class="nx">pattern</span> <span class="kt">string</span>
		<span class="nx">parts</span>   <span class="p">[]</span><span class="kt">string</span>
		<span class="nx">ok</span>      <span class="kt">bool</span>
	<span class="p">}{</span>
		<span class="p">{</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="s">&#34;/test1/v1/add&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;/test1/v1/add&#34;</span><span class="p">},</span> <span class="kc">true</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="s">&#34;/test2/*name&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;/test2/name1&#34;</span><span class="p">,</span> <span class="s">&#34;/test2/name1/name2&#34;</span><span class="p">},</span> <span class="kc">true</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="s">&#34;/test3/:file/add&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;/test3/file123/add&#34;</span><span class="p">,</span> <span class="s">&#34;/test3/file_!@#$/add&#34;</span><span class="p">,</span> <span class="s">&#34;/test3/123431/add&#34;</span><span class="p">},</span> <span class="kc">true</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="s">&#34;/test4/:file/add&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;/test4/file123&#34;</span><span class="p">,</span> <span class="s">&#34;/test3/file_!@#$/add123&#34;</span><span class="p">,</span> <span class="s">&#34;/test3/123431/123_@#&#34;</span><span class="p">},</span> <span class="kc">false</span><span class="p">},</span>
		<span class="c1">// 这两条 应该怎么走呢?
</span><span class="c1"></span>		<span class="p">{</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="s">&#34;/hello/*name&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;/hello/geektutu/a/b&#34;</span><span class="p">,</span><span class="s">&#34;hello/geektutu&#34;</span><span class="p">},</span> <span class="kc">true</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="s">&#34;/hello/geektutu&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;hello/geektutu&#34;</span><span class="p">},</span> <span class="kc">true</span><span class="p">},</span>

	<span class="p">}</span>

	<span class="nx">r</span> <span class="o">:=</span> <span class="nf">newRouter</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">test</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tests</span> <span class="p">{</span>
		<span class="nx">r</span><span class="p">.</span><span class="nf">addRoute</span><span class="p">(</span><span class="nx">test</span><span class="p">.</span><span class="nx">method</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">pattern</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">test</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tests</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">part</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">test</span><span class="p">.</span><span class="nx">parts</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">test</span><span class="p">.</span><span class="nx">ok</span> <span class="p">{</span>
				<span class="nx">node</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">getRoute</span><span class="p">(</span><span class="nx">test</span><span class="p">.</span><span class="nx">method</span><span class="p">,</span> <span class="nx">part</span><span class="p">)</span>
				<span class="k">if</span> <span class="nx">node</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nx">t</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;url Path %s, expected : %s, but actual : %s\n&#34;</span><span class="p">,</span> <span class="nx">part</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">pattern</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">)</span>
					<span class="k">continue</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">pattern</span> <span class="o">!=</span> <span class="nx">test</span><span class="p">.</span><span class="nx">pattern</span> <span class="o">&amp;&amp;</span> <span class="nx">test</span><span class="p">.</span><span class="nx">ok</span> <span class="p">{</span>
					<span class="nx">t</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;url Path %s, expected : %s, but actual : %s\n&#34;</span><span class="p">,</span> <span class="nx">part</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">pattern</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">pattern</span><span class="p">)</span>
				<span class="p">}</span>
			<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
				<span class="nx">node</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">getRoute</span><span class="p">(</span><span class="nx">test</span><span class="p">.</span><span class="nx">method</span><span class="p">,</span> <span class="nx">part</span><span class="p">)</span>
				<span class="k">if</span> <span class="nx">node</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="k">continue</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">pattern</span> <span class="o">==</span> <span class="nx">test</span><span class="p">.</span><span class="nx">pattern</span> <span class="p">{</span>
					<span class="nx">t</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;url Path %s, not expected : %s, but actual : %s\n&#34;</span><span class="p">,</span> <span class="nx">part</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">pattern</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">pattern</span><span class="p">)</span>
				<span class="p">}</span>
			<span class="p">}</span>

		<span class="p">}</span>
	<span class="p">}</span>

<span class="p">}</span>

</code></pre></div><h3 id="路由代码">路由代码</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">gee</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;net/http&#34;</span>
	<span class="s">&#34;strings&#34;</span>
<span class="p">)</span>

<span class="c1">// 这里包装router
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">router</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">roots</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">node</span>
	<span class="nx">handlers</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">HandlerFunc</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">newRouter</span><span class="p">()</span> <span class="o">*</span><span class="nx">router</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">router</span><span class="p">{</span>
		<span class="nx">handlers</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">HandlerFunc</span><span class="p">),</span>
		<span class="nx">roots</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">node</span> <span class="p">),</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Only one * is allowed
</span><span class="c1">// 将 /test/v1/add -&gt; [test v1 add]
</span><span class="c1">// /test/*name/add -&gt; [test *name]
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">parsePattern</span><span class="p">(</span><span class="nx">pattern</span> <span class="kt">string</span> <span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="nx">vs</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="nx">pattern</span><span class="p">,</span><span class="s">&#34;/&#34;</span><span class="p">)</span>
	<span class="nx">parts</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span> <span class="p">,</span> <span class="nx">item</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">vs</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">item</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="nx">parts</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">parts</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;*&#39;</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">parts</span>
<span class="p">}</span>

<span class="c1">//
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">router</span><span class="p">)</span> <span class="nf">addRoute</span><span class="p">(</span><span class="nx">method</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">pattern</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">handler</span> <span class="nx">HandlerFunc</span> <span class="p">)</span> <span class="p">{</span>
	<span class="nx">parts</span> <span class="o">:=</span> <span class="nf">parsePattern</span><span class="p">(</span><span class="nx">pattern</span><span class="p">)</span>
	<span class="nx">key</span> <span class="o">:=</span> <span class="nx">method</span><span class="o">+</span><span class="s">&#34;-&#34;</span><span class="o">+</span><span class="nx">pattern</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">roots</span><span class="p">[</span><span class="nx">method</span><span class="p">]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">r</span><span class="p">.</span><span class="nx">roots</span><span class="p">[</span><span class="nx">method</span><span class="p">]</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">node</span><span class="p">{}</span>
	<span class="p">}</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">roots</span><span class="p">[</span><span class="nx">method</span><span class="p">].</span><span class="nf">insert</span><span class="p">(</span><span class="nx">pattern</span><span class="p">,</span><span class="nx">parts</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">handlers</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">handler</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">router</span><span class="p">)</span> <span class="nf">handle</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>

	<span class="nx">n</span><span class="p">,</span> <span class="nx">params</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">getRoute</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Method</span><span class="p">,</span><span class="nx">c</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="o">!=</span> <span class="kc">nil</span>  <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">Params</span> <span class="p">=</span> <span class="nx">params</span>
		<span class="nx">key</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Method</span> <span class="o">+</span> <span class="s">&#34;-&#34;</span> <span class="o">+</span> <span class="nx">n</span><span class="p">.</span><span class="nx">pattern</span>
		<span class="nx">r</span><span class="p">.</span><span class="nx">handlers</span><span class="p">[</span><span class="nx">key</span><span class="p">](</span><span class="nx">c</span><span class="p">)</span>
	<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusNotFound</span><span class="p">,</span><span class="s">&#34;404 not found : %s\n&#34;</span><span class="p">,</span><span class="nx">c</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">router</span><span class="p">)</span> <span class="nf">getRoute</span><span class="p">(</span><span class="nx">method</span> <span class="kt">string</span> <span class="p">,</span> <span class="nx">path</span> <span class="kt">string</span> <span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">node</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">searchParts</span> <span class="o">:=</span> <span class="nf">parsePattern</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span>
	<span class="nx">params</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span>
	<span class="nx">root</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">roots</span><span class="p">[</span><span class="nx">method</span><span class="p">]</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">root</span><span class="p">.</span><span class="nf">search</span><span class="p">(</span><span class="nx">searchParts</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">parts</span> <span class="o">:=</span> <span class="nf">parsePattern</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">pattern</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">part</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">parts</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">part</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;:&#39;</span> <span class="p">{</span>
				<span class="nx">params</span><span class="p">[</span><span class="nx">part</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span> <span class="p">=</span> <span class="nx">searchParts</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">part</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;*&#39;</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">part</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
				<span class="nx">params</span><span class="p">[</span><span class="nx">part</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">searchParts</span><span class="p">[</span><span class="nx">index</span><span class="p">:],</span> <span class="s">&#34;/&#34;</span><span class="p">)</span>
				<span class="k">break</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">params</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// 这里GET方法写在 router 里面
</span><span class="c1">// engine 是包含 router
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">router</span><span class="p">)</span> <span class="nf">GET</span><span class="p">(</span><span class="nx">pattern</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">handler</span> <span class="nx">HandlerFunc</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">r</span><span class="p">.</span><span class="nf">addRoute</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">MethodGet</span><span class="p">,</span><span class="nx">pattern</span><span class="p">,</span><span class="nx">handler</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">router</span><span class="p">)</span> <span class="nf">POST</span><span class="p">(</span><span class="nx">pattern</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">handler</span> <span class="nx">HandlerFunc</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">r</span><span class="p">.</span><span class="nf">addRoute</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">MethodPost</span><span class="p">,</span><span class="nx">pattern</span><span class="p">,</span><span class="nx">handler</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><h3 id="trie-树代码">trie 树代码</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">gee</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;strings&#34;</span>
<span class="p">)</span>

<span class="c1">// 采用 前缀树 方式来实现动态路由
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">node</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">pattern</span> <span class="kt">string</span> <span class="c1">//待匹配路由, 例如  /p/:lang , 是 req.URL.Path
</span><span class="c1"></span>	<span class="nx">part</span> <span class="kt">string</span> <span class="c1">// 路由中一部分, 例如 :lang, 是按照 / 分割的部分
</span><span class="c1"></span>	<span class="nx">children</span> <span class="p">[]</span><span class="o">*</span><span class="nx">node</span> <span class="c1">// 子节点, 例如 [ doc, tutorial, intro ]
</span><span class="c1"></span>	<span class="nx">isWild</span> <span class="kt">bool</span> <span class="c1">// 是否精确匹配, part含有: 或 * 时为true
</span><span class="c1"></span><span class="p">}</span>



<span class="c1">// 第一个匹配成功的节点, 用于插入 insert 方法
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span> <span class="p">)</span> <span class="nf">matchChild</span><span class="p">(</span><span class="nx">part</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">node</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">child</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">n</span><span class="p">.</span><span class="nx">children</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">child</span><span class="p">.</span><span class="nx">part</span> <span class="o">==</span> <span class="nx">part</span> <span class="o">||</span> <span class="nx">child</span><span class="p">.</span><span class="nx">isWild</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">child</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// 所有匹配成功的节点，用于查找 search 方法
</span><span class="c1">//  例如 /test/v1/add
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span><span class="p">)</span> <span class="nf">matchChildren</span><span class="p">(</span><span class="nx">part</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="o">*</span><span class="nx">node</span> <span class="p">{</span>
	<span class="nx">nodes</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">node</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="c1">// 查询方法就是从trie树中查询, 如果查到了添加到列表, 返回查询到的列表
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">child</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">n</span><span class="p">.</span><span class="nx">children</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">child</span><span class="p">.</span><span class="nx">part</span> <span class="o">==</span> <span class="nx">part</span> <span class="o">||</span> <span class="nx">child</span><span class="p">.</span><span class="nx">isWild</span> <span class="p">{</span>
			<span class="nx">nodes</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">nodes</span><span class="p">,</span> <span class="nx">child</span><span class="p">)</span>
			<span class="c1">// 这里加break是让查到的第一个就结束, 不希望路由匹配到多个结果
</span><span class="c1"></span>			<span class="c1">//break
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">nodes</span>
<span class="p">}</span>

<span class="c1">// 插入方法就是 判断 part路由是否已经存在路由节点中 如果是模糊匹配 直接返回
</span><span class="c1">//   if child.part == part || child.isWild {
</span><span class="c1">// 如果没有找到且是精确匹配, 那么就添加到子节点中
</span><span class="c1">//   n.children = append(n.children, child)
</span><span class="c1">//
</span><span class="c1">//  pattern 是完整路由url ,parts 是将 pattern 按照 / 拆分的 每一部分 , 然后height 从0 递归对 parts 进行查询或插入
</span><span class="c1">//
</span><span class="c1">//  这里是一个逆向看的, 可以先去查询 parsePattern 方法
</span><span class="c1">//  例如 /test/v1/add
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span><span class="p">)</span> <span class="nf">insert</span><span class="p">(</span><span class="nx">pattern</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">parts</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">height</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 在node中生成一条 test(node) -&gt; v2(node) -&gt; add(node) 一条trie链表 之后
</span><span class="c1"></span>	<span class="c1">// len(parts == height == 3 , 可以退出
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">parts</span><span class="p">)</span> <span class="o">==</span> <span class="nx">height</span> <span class="p">{</span>
		<span class="nx">n</span><span class="p">.</span><span class="nx">pattern</span> <span class="p">=</span> <span class="nx">pattern</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">//
</span><span class="c1"></span>	<span class="nx">part</span> <span class="o">:=</span> <span class="nx">parts</span><span class="p">[</span><span class="nx">height</span><span class="p">]</span>
	<span class="c1">// 首先取 test 从node中查询, 如果查到了 那么目前查到路由 : /test
</span><span class="c1"></span>	<span class="c1">// 那么继续递归insert, 取v1 去查询,
</span><span class="c1"></span>	<span class="c1">// 如果查到了说明路由存在, 如果没有查到 那么新建这个node,添加到当前node的children, 目前查到路由: /test/v1,
</span><span class="c1"></span>	<span class="c1">// 同样最后可以 在node中生成一条 test(node) -&gt; v2(node) -&gt; add(node) 一条trie链表
</span><span class="c1"></span>	<span class="nx">child</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nf">matchChild</span><span class="p">(</span><span class="nx">part</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">child</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">child</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">node</span><span class="p">{</span>
			<span class="nx">part</span><span class="p">:</span><span class="nx">part</span><span class="p">,</span>
			<span class="nx">isWild</span><span class="p">:</span><span class="nx">part</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;:&#39;</span> <span class="o">||</span> <span class="nx">part</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;*&#39;</span><span class="p">,</span>
		<span class="p">}</span>
		<span class="nx">n</span><span class="p">.</span><span class="nx">children</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">children</span><span class="p">,</span> <span class="nx">child</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">child</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="nx">pattern</span><span class="p">,</span> <span class="nx">parts</span><span class="p">,</span> <span class="nx">height</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 从node中查询节点是否存在, 如果存在就返回
</span><span class="c1">//  例如 /test/v1/add
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span><span class="p">)</span> <span class="nf">search</span><span class="p">(</span><span class="nx">parts</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">height</span> <span class="kt">int</span> <span class="p">)</span> <span class="o">*</span><span class="nx">node</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">parts</span><span class="p">)</span> <span class="o">==</span> <span class="nx">height</span> <span class="o">||</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">part</span><span class="p">,</span><span class="s">&#34;*&#34;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">pattern</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">n</span>
	<span class="p">}</span>
	<span class="nx">part</span> <span class="o">:=</span> <span class="nx">parts</span><span class="p">[</span><span class="nx">height</span><span class="p">]</span>
	<span class="c1">// 这里查询同样是 先查询 test, 如果找到trie树的第一个节点 children = [ test(node) ]
</span><span class="c1"></span>	<span class="c1">// 然后在出现v1, 根据trie结构, v1只能是在test(node) 这个节点的
</span><span class="c1"></span>	<span class="c1">// 这里需要for循环 为什么不直接取 children[0] 呢?
</span><span class="c1"></span>	<span class="c1">// 1. 有可能是因为v1 可能匹配到 /test/v1 也可能匹配到 /test/:version, 所以返回的是2个
</span><span class="c1"></span>	<span class="c1">// 2. 如果让每次matchChildren查询返回一定是唯一呢? 那如果先有路由1:&#34;/hello/geektutu&#34;, 在注册了路由2:&#34;/hello/*name&#34;, 当请求&#34;/hello/geektutu/a/b&#34;的时候就会无法匹配路由2
</span><span class="c1"></span>	<span class="nx">children</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nf">matchChildren</span><span class="p">(</span><span class="nx">part</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">child</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">children</span> <span class="p">{</span>
		<span class="c1">//log.Println(&#34;child:&#34;,child.pattern)
</span><span class="c1"></span>		<span class="nx">result</span> <span class="o">:=</span> <span class="nx">child</span><span class="p">.</span><span class="nf">search</span><span class="p">(</span><span class="nx">parts</span><span class="p">,</span> <span class="nx">height</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">result</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">result</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Gin学习 简单记录form数据获取源码解读</title>
			<link>https://www.ngirl.xyz/golang/gin%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95form%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</link>
			<pubDate>Wed, 13 Jan 2021 14:24:43 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/gin%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95form%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</guid>
			<description>http.request form 数据测试 func main() { e := gin.Default() e.Any(&amp;#34;/test&amp;#34;,func(c *gin.Context) { // 获取所有参数 	_ = c.Request.ParseForm() // log.Println(c.Request.Header[&amp;#34;Content-Type&amp;#34;]) 	// get form 参数, c.Request.URL.Query, err = url.ParseQuery 	log.Println(c.Request.URL.Query()) //log.Println(url.ParseQuery(c.Request.URL.RawQuery)) 	// post form 参数 	log.Println(c.Request.PostForm) // form 参数 	log.Println(c.Request.Form) }) e.Run(&amp;#34;localhost:8123&amp;#34;) }  请求日志
 # curl -XPOST &amp;quot;http://localhost:8123/test&amp;quot; -d &amp;quot;abc=123&amp;amp;q=123&amp;amp;ccc=123123&amp;quot; 2021/01/13 14:31:30 map[] 2021/01/13 14:31:30 map[abc:[123] ccc:[123123] q:[123]] 2021/01/13 14:31:30 map[abc:[123] ccc:[123123] q:[123]] [GIN] 2021/01/13 - 14:31:30 | 200 | 339.</description>
			<content type="html"><![CDATA[<h3 id="httprequest-form-数据测试">http.request form 数据测试</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">Default</span><span class="p">()</span>
	<span class="nx">e</span><span class="p">.</span><span class="nf">Any</span><span class="p">(</span><span class="s">&#34;/test&#34;</span><span class="p">,</span><span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// 获取所有参数
</span><span class="c1"></span>		<span class="nx">_</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nf">ParseForm</span><span class="p">()</span>
		<span class="c1">// log.Println(c.Request.Header[&#34;Content-Type&#34;])
</span><span class="c1"></span>		<span class="c1">// get form 参数, c.Request.URL.Query, err  = url.ParseQuery
</span><span class="c1"></span>		<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nf">Query</span><span class="p">())</span>
		<span class="c1">//log.Println(url.ParseQuery(c.Request.URL.RawQuery))
</span><span class="c1"></span>		<span class="c1">// post form 参数
</span><span class="c1"></span>		<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">PostForm</span><span class="p">)</span>
		<span class="c1">// form 参数
</span><span class="c1"></span>		<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">Form</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="nx">e</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="s">&#34;localhost:8123&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><blockquote>
<p>请求日志</p>
</blockquote>
<pre><code># curl -XPOST &quot;http://localhost:8123/test&quot; -d &quot;abc=123&amp;q=123&amp;ccc=123123&quot;
2021/01/13 14:31:30 map[]
2021/01/13 14:31:30 map[abc:[123] ccc:[123123] q:[123]]
2021/01/13 14:31:30 map[abc:[123] ccc:[123123] q:[123]]
[GIN] 2021/01/13 - 14:31:30 | 200 |     339.106µs |       127.0.0.1 | POST     &quot;/test&quot;

# curl &quot;http://localhost:8123/test?aaa=111&amp;bbbb=2222&quot;
2021/01/13 14:31:38 map[aaa:[111] bbbb:[2222]]
2021/01/13 14:31:38 map[]
2021/01/13 14:31:38 map[aaa:[111] bbbb:[2222]]
[GIN] 2021/01/13 - 14:31:38 | 200 |      73.852µs |       127.0.0.1 | GET      &quot;/test?aaa=111&amp;bbbb=2222&quot;

# curl -XPOST &quot;http://localhost:8123/test?aaa=111&amp;bbbb=2222&quot; -d &quot;abc=123&amp;q=123&amp;ccc=123123&quot;
2021/01/13 14:31:48 map[aaa:[111] bbbb:[2222]]
2021/01/13 14:31:48 map[abc:[123] ccc:[123123] q:[123]]
2021/01/13 14:31:48 map[aaa:[111] abc:[123] bbbb:[2222] ccc:[123123] q:[123]]
[GIN] 2021/01/13 - 14:31:48 | 200 |     119.833µs |       127.0.0.1 | POST     &quot;/test?aaa=111&amp;bbbb=2222&quot;

</code></pre><h3 id="看下parseform-的源码">看下ParseForm 的源码</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="nf">ParseForm</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">PostForm</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 以下方法 会调用 parsePostForm
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Method</span> <span class="o">==</span> <span class="s">&#34;POST&#34;</span> <span class="o">||</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Method</span> <span class="o">==</span> <span class="s">&#34;PUT&#34;</span> <span class="o">||</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Method</span> <span class="o">==</span> <span class="s">&#34;PATCH&#34;</span> <span class="p">{</span>
			<span class="nx">r</span><span class="p">.</span><span class="nx">PostForm</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">parsePostForm</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">PostForm</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">r</span><span class="p">.</span><span class="nx">PostForm</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">url</span><span class="p">.</span><span class="nx">Values</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Form</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 这里  PostForm 会复制到 Form, 所以 Form &gt;= PostForm
</span><span class="c1"></span>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">PostForm</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">r</span><span class="p">.</span><span class="nx">Form</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">url</span><span class="p">.</span><span class="nx">Values</span><span class="p">)</span>
			<span class="nf">copyValues</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Form</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">PostForm</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// 这里 get的参数是在r.URL里面的, 所以通过 ParseQuery 获取get参数
</span><span class="c1"></span>		<span class="kd">var</span> <span class="nx">newValues</span> <span class="nx">url</span><span class="p">.</span><span class="nx">Values</span>
		<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">URL</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="kd">var</span> <span class="nx">e</span> <span class="kt">error</span>
			<span class="nx">newValues</span><span class="p">,</span> <span class="nx">e</span> <span class="p">=</span> <span class="nx">url</span><span class="p">.</span><span class="nf">ParseQuery</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">RawQuery</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">err</span> <span class="p">=</span> <span class="nx">e</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">newValues</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">newValues</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">url</span><span class="p">.</span><span class="nx">Values</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// 最后也会添加 get参数到form, 所以 Form &gt;= url.Query()
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Form</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">r</span><span class="p">.</span><span class="nx">Form</span> <span class="p">=</span> <span class="nx">newValues</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nf">copyValues</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Form</span><span class="p">,</span> <span class="nx">newValues</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></div><h3 id="这里看下-parsepostform">这里看下 parsePostForm</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">parsePostForm</span><span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">(</span><span class="nx">vs</span> <span class="nx">url</span><span class="p">.</span><span class="nx">Values</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Body</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;missing form body&#34;</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">ct</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;Content-Type&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">ct</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">ct</span> <span class="p">=</span> <span class="s">&#34;application/octet-stream&#34;</span>
	<span class="p">}</span>
	<span class="nx">ct</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">mime</span><span class="p">.</span><span class="nf">ParseMediaType</span><span class="p">(</span><span class="nx">ct</span><span class="p">)</span>
	<span class="k">switch</span> <span class="p">{</span>
	<span class="c1">// 这里我们默认的header 就是 application/x-www-form-urlencoded
</span><span class="c1"></span>	<span class="c1">// 可以 log.Println(c.Request.Header[&#34;Content-Type&#34;]) 打印查看
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">ct</span> <span class="o">==</span> <span class="s">&#34;application/x-www-form-urlencoded&#34;</span><span class="p">:</span>
		<span class="kd">var</span> <span class="nx">reader</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Body</span>
		<span class="c1">// 首先初始化 maxFormSize = 2^63 -1
</span><span class="c1"></span>		<span class="nx">maxFormSize</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">63</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Body</span><span class="p">.(</span><span class="o">*</span><span class="nx">maxBytesReader</span><span class="p">);</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
			<span class="c1">// 设置 io.LimitedReader 的  N
</span><span class="c1"></span>			<span class="nx">maxFormSize</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">10</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">)</span> <span class="c1">// 10 MB is a lot of text.
</span><span class="c1"></span>			<span class="c1">// 返回了一个 带限制的 io.LimitedReader, 当然实现了 Reader interfacer
</span><span class="c1"></span>			<span class="nx">reader</span> <span class="p">=</span> <span class="nx">io</span><span class="p">.</span><span class="nf">LimitReader</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Body</span><span class="p">,</span> <span class="nx">maxFormSize</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// 这里会调用 io.LimitedReader 的Read 方法, 通过接口实现
</span><span class="c1"></span>		<span class="c1">// 直接读取post 的body即可
</span><span class="c1"></span>		<span class="nx">b</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadAll</span><span class="p">(</span><span class="nx">reader</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">e</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">err</span> <span class="p">=</span> <span class="nx">e</span>
			<span class="p">}</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nb">int64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span> <span class="p">&gt;</span> <span class="nx">maxFormSize</span> <span class="p">{</span>
			<span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;http: POST too large&#34;</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="c1">// 最终也是调用 url.ParseQuery
</span><span class="c1"></span>		<span class="c1">// 这里 string(b) = abc=123&amp;q=123&amp;ccc=123123
</span><span class="c1"></span>		<span class="nx">vs</span><span class="p">,</span> <span class="nx">e</span> <span class="p">=</span> <span class="nx">url</span><span class="p">.</span><span class="nf">ParseQuery</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">err</span> <span class="p">=</span> <span class="nx">e</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="nx">ct</span> <span class="o">==</span> <span class="s">&#34;multipart/form-data&#34;</span><span class="p">:</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>

</code></pre></div><h3 id="简单看下-iolimitedreader-的read-方法">简单看下 io.LimitedReader 的Read 方法</h3>
<blockquote>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">LimitedReader</span><span class="p">)</span> <span class="nf">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nx">N</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">EOF</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">int64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">))</span> <span class="p">&gt;</span> <span class="nx">l</span><span class="p">.</span><span class="nx">N</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="p">=</span> <span class="nx">p</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nx">l</span><span class="p">.</span><span class="nx">N</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">R</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">N</span> <span class="o">-=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
	<span class="k">return</span>
<span class="p">}</span>

</code></pre></div><h3 id="parsequery-分析">parseQuery 分析</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="kd">func</span> <span class="nf">parseQuery</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Values</span><span class="p">,</span> <span class="nx">query</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 这里的循环结束条件是 query == &#34;&#34;
</span><span class="c1"></span>	<span class="c1">// 那什么时候会空呢?
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">query</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">key</span> <span class="o">:=</span> <span class="nx">query</span>
		<span class="c1">// 这里取到第一个 &amp;或者; 的索引, 然后将 query 分成两半
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">IndexAny</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="s">&#34;&amp;;&#34;</span><span class="p">);</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// 这里会每次 截取后一半 赋值给query, 所以query一直在消耗 第一个&amp;前的数据
</span><span class="c1"></span>			<span class="nx">key</span><span class="p">,</span> <span class="nx">query</span> <span class="p">=</span> <span class="nx">key</span><span class="p">[:</span><span class="nx">i</span><span class="p">],</span> <span class="nx">key</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
		<span class="c1">// 如果 已经没有 &amp; 或者 ; 字符了, 说明只有最后一个字段了, 那么就直接置空 query, 然后读取完key 就可以结束循环了
</span><span class="c1"></span>		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">query</span> <span class="p">=</span> <span class="s">&#34;&#34;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">key</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">value</span> <span class="o">:=</span> <span class="s">&#34;&#34;</span>
		<span class="c1">// 取出 第一个 &amp; 前面的 参数 按照=分割, 从而得到 变量名 和变量值
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Index</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="s">&#34;=&#34;</span><span class="p">);</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="p">=</span> <span class="nx">key</span><span class="p">[:</span><span class="nx">i</span><span class="p">],</span> <span class="nx">key</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
		<span class="p">}</span>
		<span class="nx">key</span><span class="p">,</span> <span class="nx">err1</span> <span class="o">:=</span> <span class="nf">QueryUnescape</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err1</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">err</span> <span class="p">=</span> <span class="nx">err1</span>
			<span class="p">}</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">value</span><span class="p">,</span> <span class="nx">err1</span> <span class="p">=</span> <span class="nf">QueryUnescape</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err1</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">err</span> <span class="p">=</span> <span class="nx">err1</span>
			<span class="p">}</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="c1">// 最后将 post参数写成map结构 写到m (url.Value) 中
</span><span class="c1"></span>		<span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">],</span> <span class="nx">value</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Gin学习 Validator</title>
			<link>https://www.ngirl.xyz/golang/gin%E5%AD%A6%E4%B9%A0-validator/</link>
			<pubDate>Tue, 12 Jan 2021 10:17:46 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/gin%E5%AD%A6%E4%B9%A0-validator/</guid>
			<description>&lt;p&gt;记录一下Gin学习验证器和翻译器模块&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>记录一下Gin学习验证器和翻译器模块</p>
<ul>
<li>github地址: <a href="https://github.com/zhangzw001/learnGin/tree/gin-shouldbind">https://github.com/zhangzw001/learnGin/tree/gin-shouldbind</a></li>
<li>官方文档: <a href="https://godoc.org/github.com/go-playground/validator">https://godoc.org/github.com/go-playground/validator</a></li>
<li>官方示例: <a href="https://github.com/go-playground/validator/tree/v10.4.1/_examples">https://github.com/go-playground/validator/tree/v10.4.1/_examples</a></li>
<li>原文: <a href="https://github.com/xinliangnote/Go">https://github.com/xinliangnote/Go</a></li>
</ul>
<h3 id="功能演示介绍">功能演示介绍</h3>
<blockquote>
<p>首先这个模块是很方便校验接口的输入结构体参数是否符合规则,不用繁琐的自己写参数校验, 翻译器又可以支持不同语言的错误提示,而且可以自定义返回错误格式覆盖默认的格式</p>
</blockquote>
<pre><code>1. 调用localhost:8000/sn/create 执行验证器中间件
2. 调用localhost:8000/v1/product/add 执行验证器,签名等中间件
</code></pre><h3 id="部分相关目录结构">部分相关目录结构</h3>
<pre><code>.
├── config
│   └── env.go
├── controller
│   ├── api
│   │   └── v1.go
│   └── sign
│       └── sign.go
├── docs
│   ├── docs.go
│   ├── swagger.json
│   └── swagger.yaml
├── dto
│   └── api.go
├── go.mod
├── go.sum
├── logs
│   ├── gin-logger.log -&gt; gin-logger.log.20210112-000000.log
│   └── gin-logger.log.20210112-000000.log
├── main.go
├── middleware
│   ├── logger.go
│   ├── response.go
│   ├── sign.go
│   └── validator.go
├── public
│   ├── public.go
│   └── validator.go
└── routers
    └── router.go

</code></pre><h3 id="1-首先定义路由规则">1. 首先定义路由规则</h3>
<h4 id="routersroutergo">routers/router.go</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">routers</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
	<span class="nx">ginSwagger</span> <span class="s">&#34;github.com/swaggo/gin-swagger&#34;</span>
	<span class="s">&#34;github.com/swaggo/gin-swagger/swaggerFiles&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/controller/api&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/controller/sign&#34;</span>
	<span class="c1">// 这里需要导入自己项目的目录,否则swagger页面会报错
</span><span class="c1"></span>	<span class="nx">_</span> <span class="s">&#34;github.com/zhangzw001/learnGin/docs&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/middleware&#34;</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">InitRouter</span><span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Engine</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// swagger 文档
</span><span class="c1"></span>	<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/swagger/*any&#34;</span><span class="p">,</span><span class="nx">ginSwagger</span><span class="p">.</span><span class="nf">WrapHandler</span><span class="p">(</span><span class="nx">swaggerFiles</span><span class="p">.</span><span class="nx">Handler</span><span class="p">))</span>
	<span class="c1">// sign路由
</span><span class="c1"></span>	<span class="nx">Sign</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nf">Group</span><span class="p">(</span><span class="s">&#34;/sn&#34;</span><span class="p">)</span>
	<span class="nx">Sign</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">middleware</span><span class="p">.</span><span class="nf">TranslationMiddleware</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="nx">controllersign</span><span class="p">.</span><span class="nf">RegisterSign</span><span class="p">(</span><span class="nx">Sign</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// api v1版本路由
</span><span class="c1"></span>	<span class="nx">GroupV1</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nf">Group</span><span class="p">(</span><span class="s">&#34;/v1&#34;</span><span class="p">)</span>
	<span class="nx">GroupV1</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">middleware</span><span class="p">.</span><span class="nf">SignMiddleware</span><span class="p">(),</span><span class="nx">middleware</span><span class="p">.</span><span class="nf">TranslationMiddleware</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="nx">controllerapi</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">GroupV1</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="2-看下sign-controller">2. 看下sign controller</h3>
<h4 id="21-controllersignsigngo">2.1 controller/sign/sign.go</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">controllersign</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/dto&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/middleware&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/public&#34;</span>
	<span class="s">&#34;strconv&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Controller</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="nf">RegisterSign</span><span class="p">(</span><span class="nx">router</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">RouterGroup</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">sign</span> <span class="o">:=</span> <span class="nx">Controller</span><span class="p">{}</span>
	<span class="nx">router</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/create&#34;</span><span class="p">,</span> <span class="nx">sign</span><span class="p">.</span><span class="nx">Create</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Add godoc
</span><span class="c1">// @Summary sign接口
</span><span class="c1">// @Description sign接口
</span><span class="c1">// @Tags sign 创建接口
</span><span class="c1">// @ID /sn/create
</span><span class="c1">// @Accept  json
</span><span class="c1">// @Produce  json
</span><span class="c1">// @Param name query string true &#34;名称&#34;
</span><span class="c1">// @Param price query string true &#34;价格&#34;
</span><span class="c1">// @Success 200 {object} middleware.Response{data=dto.ApiOutput} &#34;success&#34;
</span><span class="c1">// @Router /sn/create [get]
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">sign</span> <span class="nx">Controller</span><span class="p">)</span> <span class="nf">Create</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">ts</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">FormatInt</span><span class="p">(</span><span class="nx">public</span><span class="p">.</span><span class="nf">GetTimeUnix</span><span class="p">(),</span> <span class="mi">10</span><span class="p">)</span>

	<span class="nx">params</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">dto</span><span class="p">.</span><span class="nx">ApiUpdateInput</span><span class="p">{}</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">params</span><span class="p">.</span><span class="nf">BindValueParam</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">middleware</span><span class="p">.</span><span class="nf">ResponseError</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="mi">10001</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">paramsSign</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">Form</span>
	<span class="nx">paramsSign</span><span class="p">[</span><span class="s">&#34;ts&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="nx">ts</span><span class="p">}</span>

	<span class="nx">data</span> <span class="o">:=</span> <span class="nx">dto</span><span class="p">.</span><span class="nx">ApiOutput</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span>  <span class="nx">params</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span>
		<span class="nx">Price</span><span class="p">:</span> <span class="nx">params</span><span class="p">.</span><span class="nx">Price</span><span class="p">,</span>
		<span class="nx">Ts</span><span class="p">:</span>    <span class="nx">ts</span><span class="p">,</span>
		<span class="nx">Sn</span><span class="p">:</span>    <span class="nx">public</span><span class="p">.</span><span class="nf">CreateSign</span><span class="p">(</span><span class="nx">paramsSign</span><span class="p">),</span>
	<span class="p">}</span>
	<span class="nx">middleware</span><span class="p">.</span><span class="nf">ResponseSuccess</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h4 id="22-数据传输-dtoapigo">2.2 数据传输 dto.api.go</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="err">#</span><span class="o">/</span><span class="nx">sn</span><span class="o">/</span><span class="nx">create</span> <span class="nx">的输入仅允许两个参数</span>
<span class="kd">type</span> <span class="nx">ApiUpdateInput</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// 这里validate 代表通过validator.v10验证自定义规则 test_tag,默认规则 required 表示必传字段
</span><span class="c1"></span>	<span class="nx">Name</span> <span class="kt">string</span>		<span class="s">`json:&#34;name&#34; form:&#34;name&#34; comment:&#34;名称&#34; example:&#34;abcdef&#34; validate:&#34;required,test_tag&#34;`</span>
    <span class="c1">// 这里仅验证最小值0
</span><span class="c1"></span>	<span class="nx">Price</span> <span class="kt">int</span>	<span class="s">`json:&#34;price&#34; form:&#34;price&#34; comment:&#34;价格&#34; example:&#34;10&#34; validate:&#34;required,min=0&#34;`</span>
<span class="p">}</span>

<span class="c1">// 绑定结构体
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">param</span> <span class="o">*</span><span class="nx">ApiUpdateInput</span><span class="p">)</span> <span class="nf">BindValueParam</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span>  <span class="p">{</span>
	<span class="k">return</span> <span class="nx">public</span><span class="p">.</span><span class="nf">DefaultGetValidParams</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="nx">param</span><span class="p">)</span>
<span class="p">}</span>

<span class="err">#</span> <span class="nx">另外output结构体</span><span class="p">,</span><span class="nx">这里不需要验证器</span>
<span class="kd">type</span> <span class="nx">ApiOutput</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span> <span class="kt">string</span>
	<span class="nx">Price</span> <span class="kt">int</span>
	<span class="nx">Ts</span> <span class="kt">string</span>
	<span class="nx">Sn</span> <span class="kt">string</span>
<span class="p">}</span>


<span class="kd">type</span> <span class="nx">ApiAddInput</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span> <span class="kt">string</span> <span class="s">`json:&#34;name&#34; form:&#34;name&#34; comment:&#34;名称&#34; example:&#34;abc&#34; validate:&#34;required,test_tag,max=24,min=6&#34;`</span>
	<span class="nx">Price</span> <span class="kt">int</span> <span class="s">`json:&#34;price&#34; form:&#34;price&#34; comment:&#34;价格&#34; example:&#34;abc&#34;  validate:&#34;required,min=0&#34;`</span>
	<span class="nx">Ts</span> <span class="kt">string</span> <span class="s">`json:&#34;ts&#34; form:&#34;ts&#34; comment:&#34;有效期&#34; example:&#34;&#34; validate:&#34;required,min=1&#34;`</span>
	<span class="nx">Sn</span> <span class="kt">string</span> <span class="s">`json:&#34;sn&#34; form:&#34;sn&#34; comment:&#34;签名&#34; example:&#34;&#34; validate:&#34;required,min=32,max=32&#34;`</span>
<span class="p">}</span>

<span class="c1">// 绑定结构体
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">param</span> <span class="o">*</span><span class="nx">ApiAddInput</span><span class="p">)</span> <span class="nf">BindValueParam</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span>  <span class="p">{</span>
	<span class="k">return</span> <span class="nx">public</span><span class="p">.</span><span class="nf">DefaultGetValidParams</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="nx">param</span><span class="p">)</span>
<span class="p">}</span>


</code></pre></div><h4 id="23-publicvalidatorgo-调用shouldbind-验证器-和翻译器">2.3 public/validator.go 调用shouldbind ,验证器 和翻译器</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">public</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
	<span class="nx">ut</span> <span class="s">&#34;github.com/go-playground/universal-translator&#34;</span>
	<span class="s">&#34;github.com/go-playground/validator/v10&#34;</span>
	<span class="s">&#34;github.com/pkg/errors&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/config&#34;</span>
	<span class="s">&#34;strings&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">DefaultGetValidParams</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">params</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">ShouldBind</span><span class="p">(</span><span class="nx">params</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="c1">// 获取验证器
</span><span class="c1"></span>	<span class="nx">valid</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">GetValidator</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="c1">// 获取翻译器
</span><span class="c1"></span>	<span class="nx">trans</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">GetTranslate</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="nx">err</span> <span class="p">=</span> <span class="nx">valid</span><span class="p">.</span><span class="nf">Struct</span><span class="p">(</span><span class="nx">params</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">errs</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="nx">validator</span><span class="p">.</span><span class="nx">ValidationErrors</span><span class="p">)</span>
		<span class="nx">sliceErrs</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{}</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span><span class="k">range</span> <span class="nx">errs</span> <span class="p">{</span>
			<span class="nx">sliceErrs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">sliceErrs</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nf">Translate</span><span class="p">(</span><span class="nx">trans</span><span class="p">))</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">sliceErrs</span><span class="p">,</span> <span class="s">&#34;,&#34;</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// 获取验证器
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GetValidator</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">validator</span><span class="p">.</span><span class="nx">Validate</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">ValidatorKey</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;未设置验证器&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">validate</span> <span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">val</span><span class="p">.(</span><span class="o">*</span><span class="nx">validator</span><span class="p">.</span><span class="nx">Validate</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;获取验证器失败&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">validate</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// 获取翻译器
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GetTranslate</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">ut</span><span class="p">.</span><span class="nx">Translator</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">trans</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">TranslatorKey</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;未设置翻译器&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">translator</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">trans</span><span class="p">.(</span><span class="nx">ut</span><span class="p">.</span><span class="nx">Translator</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;获取翻译器失败&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">translator</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

</code></pre></div><h3 id="3-中间件-middlewarevalidatorgo">3. 中间件 middleware/validator.go</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">middleware</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
	<span class="s">&#34;github.com/go-playground/locales/en&#34;</span>
	<span class="s">&#34;github.com/go-playground/locales/zh&#34;</span>
	<span class="nx">ut</span> <span class="s">&#34;github.com/go-playground/universal-translator&#34;</span>
	<span class="s">&#34;github.com/go-playground/validator/v10&#34;</span>
	<span class="nx">en_translations</span> <span class="s">&#34;github.com/go-playground/validator/v10/translations/en&#34;</span>
	<span class="nx">zh_translations</span> <span class="s">&#34;github.com/go-playground/validator/v10/translations/zh&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/config&#34;</span>
	<span class="s">&#34;reflect&#34;</span>
	<span class="s">&#34;regexp&#34;</span>
<span class="p">)</span>


<span class="c1">// 设置验证器+翻译器
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">TranslationMiddleware</span><span class="p">()</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">HandlerFunc</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// 创建验证器实例
</span><span class="c1"></span>		<span class="nx">val</span> <span class="o">:=</span> <span class="nx">validator</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

		<span class="c1">// 设置支持的语言
</span><span class="c1"></span>		<span class="nx">en</span> <span class="o">:=</span> <span class="nx">en</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
		<span class="nx">zh</span> <span class="o">:=</span> <span class="nx">zh</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
		<span class="c1">// 创建翻译器, 支持zh,en两种
</span><span class="c1"></span>		<span class="nx">uni</span> <span class="o">:=</span> <span class="nx">ut</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">zh</span><span class="p">,</span> <span class="nx">zh</span><span class="p">,</span><span class="nx">en</span><span class="p">)</span>
		<span class="c1">// 根据参数取翻译器实例
</span><span class="c1"></span>		<span class="nx">locale</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">DefaultQuery</span><span class="p">(</span><span class="s">&#34;locale&#34;</span><span class="p">,</span><span class="s">&#34;zh&#34;</span><span class="p">)</span>
		<span class="c1">// 获取默认的f.fallback
</span><span class="c1"></span>		<span class="nx">trans</span> <span class="p">,</span><span class="nx">_</span> <span class="o">:=</span> <span class="nx">uni</span><span class="p">.</span><span class="nf">GetTranslator</span><span class="p">(</span><span class="nx">locale</span><span class="p">)</span>

		<span class="c1">// 翻译器注册到验证器
</span><span class="c1"></span>		<span class="k">switch</span> <span class="nx">locale</span> <span class="p">{</span>
		<span class="k">case</span> <span class="s">&#34;en&#34;</span><span class="p">:</span>
			<span class="nx">_</span> <span class="p">=</span> <span class="nx">en_translations</span><span class="p">.</span><span class="nf">RegisterDefaultTranslations</span><span class="p">(</span><span class="nx">val</span><span class="p">,</span><span class="nx">trans</span><span class="p">)</span>
			<span class="nx">val</span><span class="p">.</span><span class="nf">RegisterTagNameFunc</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">fld</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">StructField</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">fld</span><span class="p">.</span><span class="nx">Tag</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;en_comment&#34;</span><span class="p">)</span>
			<span class="p">})</span>
			<span class="k">break</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="nx">_</span> <span class="p">=</span> <span class="nx">zh_translations</span><span class="p">.</span><span class="nf">RegisterDefaultTranslations</span><span class="p">(</span><span class="nx">val</span><span class="p">,</span><span class="nx">trans</span><span class="p">)</span>
			<span class="nx">val</span><span class="p">.</span><span class="nf">RegisterTagNameFunc</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">fld</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">StructField</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">fld</span><span class="p">.</span><span class="nx">Tag</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;comment&#34;</span><span class="p">)</span>
			<span class="p">})</span>

			<span class="c1">// 自定义的验证器
</span><span class="c1"></span>			<span class="nx">val</span><span class="p">.</span><span class="nf">RegisterValidation</span><span class="p">(</span><span class="s">&#34;test_tag&#34;</span><span class="p">,</span><span class="kd">func</span><span class="p">(</span><span class="nx">fl</span> <span class="nx">validator</span><span class="p">.</span><span class="nx">FieldLevel</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
				<span class="nx">matched</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MatchString</span><span class="p">(</span><span class="s">`^[_0-9a-zA-Z]{6,24}$`</span><span class="p">,</span><span class="nx">fl</span><span class="p">.</span><span class="nf">Field</span><span class="p">().</span><span class="nf">String</span><span class="p">())</span>
				<span class="k">return</span> <span class="nx">matched</span>
			<span class="p">})</span>

			<span class="c1">// 自定义的翻译器
</span><span class="c1"></span>			<span class="nx">val</span><span class="p">.</span><span class="nf">RegisterTranslation</span><span class="p">(</span><span class="s">&#34;test_tag&#34;</span><span class="p">,</span><span class="nx">trans</span><span class="p">,</span><span class="kd">func</span><span class="p">(</span><span class="nx">ut</span> <span class="nx">ut</span><span class="p">.</span><span class="nx">Translator</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">ut</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;test_tag&#34;</span><span class="p">,</span><span class="s">&#34;{0} 填写不正确,仅允许数字字母下划线,长度大于6小于24&#34;</span><span class="p">,</span><span class="kc">true</span>  <span class="p">)</span>
			<span class="p">},</span><span class="kd">func</span><span class="p">(</span><span class="nx">ut</span> <span class="nx">ut</span><span class="p">.</span><span class="nx">Translator</span><span class="p">,</span> <span class="nx">fe</span> <span class="nx">validator</span><span class="p">.</span><span class="nx">FieldError</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
				<span class="nx">t</span> <span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">ut</span><span class="p">.</span><span class="nf">T</span><span class="p">(</span><span class="s">&#34;test_tag&#34;</span><span class="p">,</span><span class="nx">fe</span><span class="p">.</span><span class="nf">Field</span><span class="p">())</span>
				<span class="k">return</span> <span class="nx">t</span>
			<span class="p">})</span>
			<span class="k">break</span>
		<span class="p">}</span>

		<span class="c1">// 设置翻译器和验证器
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">TranslatorKey</span><span class="p">,</span><span class="nx">trans</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">ValidatorKey</span><span class="p">,</span><span class="nx">val</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h3 id="4-中间件-middlewaresigngo">4. 中间件 middleware/sign.go</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">middleware</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
	<span class="s">&#34;github.com/pkg/errors&#34;</span>
	<span class="nx">config2</span> <span class="s">&#34;github.com/zhangzw001/learnGin/config&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/public&#34;</span>
	<span class="s">&#34;net/url&#34;</span>
	<span class="s">&#34;strconv&#34;</span>
<span class="p">)</span>



<span class="kd">func</span> <span class="nf">SignMiddleware</span><span class="p">()</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">HandlerFunc</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">method</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">Method</span>
		<span class="kd">var</span> <span class="nx">ts</span> <span class="kt">int64</span>
		<span class="kd">var</span> <span class="nx">sn</span> <span class="kt">string</span>
		<span class="kd">var</span> <span class="nx">req</span> <span class="nx">url</span><span class="p">.</span><span class="nx">Values</span>

		<span class="k">if</span> <span class="nx">method</span> <span class="o">==</span> <span class="s">&#34;GET&#34;</span> <span class="p">{</span>
			<span class="nx">req</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nf">Query</span><span class="p">()</span>
			<span class="nx">sn</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;sn&#34;</span><span class="p">)</span>
			<span class="nx">ts</span><span class="p">,</span> <span class="nx">_</span>  <span class="p">=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">ParseInt</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;ts&#34;</span><span class="p">),</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>

		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">method</span> <span class="o">==</span> <span class="s">&#34;POST&#34;</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nf">ParseForm</span><span class="p">()</span>
			<span class="nx">req</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">PostForm</span>
			<span class="nx">sn</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">PostForm</span><span class="p">(</span><span class="s">&#34;sn&#34;</span><span class="p">)</span>
			<span class="nx">ts</span><span class="p">,</span> <span class="nx">_</span>  <span class="p">=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">ParseInt</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">PostForm</span><span class="p">(</span><span class="s">&#34;ts&#34;</span><span class="p">),</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nf">ResponseError</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="mi">10000</span><span class="p">,</span><span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;Illegal requests&#34;</span><span class="p">))</span>
			<span class="k">return</span>
		<span class="p">}</span>

		<span class="nx">exp</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">ParseInt</span><span class="p">(</span><span class="nx">config2</span><span class="p">.</span><span class="nx">ApiExpiry</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>

		<span class="c1">// 验证过期时间
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">ts</span> <span class="p">&gt;</span> <span class="nx">public</span><span class="p">.</span><span class="nf">GetTimeUnix</span><span class="p">()</span> <span class="o">||</span> <span class="nx">public</span><span class="p">.</span><span class="nf">GetTimeUnix</span><span class="p">()</span> <span class="o">-</span> <span class="nx">ts</span> <span class="o">&gt;=</span> <span class="nx">exp</span> <span class="p">{</span>
			<span class="nf">ResponseError</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="mi">10001</span><span class="p">,</span><span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;Ts Error&#34;</span><span class="p">))</span>
			<span class="k">return</span>
		<span class="p">}</span>

		<span class="c1">// 验证签名
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">sn</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="o">||</span> <span class="nx">sn</span> <span class="o">!=</span> <span class="nx">public</span><span class="p">.</span><span class="nf">CreateSign</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span> <span class="p">{</span>
			<span class="nf">ResponseError</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="mi">10002</span><span class="p">,</span><span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;Sn Error&#34;</span><span class="p">))</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="c1">//
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h3 id="5-统一的返回参-middlewareresponsego">5. 统一的返回参 middleware/response.go</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">middleware</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;encoding/json&#34;</span>
	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">ResponseCode</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">SuccessCode</span> <span class="nx">ResponseCode</span> <span class="p">=</span> <span class="mi">200</span> <span class="o">+</span> <span class="kc">iota</span>
	<span class="nx">StatusCreated</span>
	<span class="nx">StatusAccepted</span>
	<span class="nx">InternalServerError</span> <span class="nx">ResponseCode</span> <span class="p">=</span> <span class="mi">500</span>
	<span class="nx">CustomizeCode</span>           <span class="p">=</span> <span class="mi">1000</span>
	<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Response</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Code</span> <span class="nx">ResponseCode</span> <span class="s">`json:&#34;code&#34;`</span>
	<span class="nx">Msg</span>  <span class="kt">string</span>       <span class="s">`json:&#34;msg&#34;`</span>
	<span class="nx">Data</span> <span class="kd">interface</span><span class="p">{}</span>  <span class="s">`json:&#34;data&#34;`</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">ResponseSuccess</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nx">resp</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Response</span><span class="p">{</span>
		<span class="nx">Code</span><span class="p">:</span> <span class="nx">SuccessCode</span><span class="p">,</span>
		<span class="nx">Msg</span><span class="p">:</span>  <span class="s">&#34;ok&#34;</span><span class="p">,</span>
		<span class="nx">Data</span><span class="p">:</span> <span class="nx">data</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="nx">resp</span><span class="p">)</span>
	<span class="nx">response</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="nx">resp</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;response&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">response</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">ResponseError</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">code</span> <span class="nx">ResponseCode</span><span class="p">,</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">resp</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Response</span><span class="p">{</span>
		<span class="nx">Code</span><span class="p">:</span> <span class="nx">code</span><span class="p">,</span>
		<span class="nx">Msg</span><span class="p">:</span>  <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">(),</span>
		<span class="nx">Data</span><span class="p">:</span> <span class="s">&#34;&#34;</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="nx">resp</span><span class="p">)</span>
	<span class="nx">response</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="nx">resp</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;response&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">response</span><span class="p">))</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">AbortWithError</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><h3 id="6-配置文件-configenvgo">6. 配置文件 config/env.go</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">config</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">PORT</span>      <span class="p">=</span> <span class="s">&#34;:8000&#34;</span>
	<span class="nx">AppName</span>   <span class="p">=</span> <span class="s">&#34;test&#34;</span>
	<span class="nx">AppSecret</span> <span class="p">=</span> <span class="s">&#34;test.123&#34;</span>
	<span class="nx">ApiExpiry</span> <span class="p">=</span> <span class="s">&#34;1200&#34;</span>

	<span class="nx">LogFilePath</span> <span class="p">=</span> <span class="s">&#34;logs&#34;</span>
	<span class="nx">LogFileName</span> <span class="p">=</span> <span class="s">&#34;gin-logger.log&#34;</span>

	<span class="nx">ValidatorKey</span>  <span class="p">=</span> <span class="s">&#34;ValidatorKey&#34;</span>
	<span class="nx">TranslatorKey</span> <span class="p">=</span> <span class="s">&#34;TranslatorKey&#34;</span>
<span class="p">)</span>
</code></pre></div><h3 id="maingo">main.go</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/config&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/routers&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

	<span class="nx">gin</span><span class="p">.</span><span class="nf">SetMode</span><span class="p">(</span><span class="nx">gin</span><span class="p">.</span><span class="nx">DebugMode</span><span class="p">)</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">Default</span><span class="p">()</span>
	<span class="nx">routers</span><span class="p">.</span><span class="nf">InitRouter</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
	<span class="nx">e</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">PORT</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Google资深工程师深度讲解Go语言 Elastic简单使用</title>
			<link>https://www.ngirl.xyz/golang/google%E8%B5%84%E6%B7%B1%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%B7%B1%E5%BA%A6%E8%AE%B2%E8%A7%A3go%E8%AF%AD%E8%A8%80-elastic%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</link>
			<pubDate>Wed, 06 Jan 2021 14:27:27 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/google%E8%B5%84%E6%B7%B1%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%B7%B1%E5%BA%A6%E8%AE%B2%E8%A7%A3go%E8%AF%AD%E8%A8%80-elastic%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</guid>
			<description></description>
			<content type="html"><![CDATA[<h3 id="elastic-检查查询">elastic 检查查询</h3>
<pre><code># 查询 女, 已购房 年龄小于22岁
http://172.16.76.220:9200/crawler/youyuan/_search?q=女  AND 已购房  AND Payload.Age:(&lt;22)
</code></pre>]]></content>
		</item>
		
		<item>
			<title>Google资深工程师深度讲解Go语言 单任务爬虫</title>
			<link>https://www.ngirl.xyz/golang/google%E8%B5%84%E6%B7%B1%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%B7%B1%E5%BA%A6%E8%AE%B2%E8%A7%A3go%E8%AF%AD%E8%A8%80-%E5%8D%95%E4%BB%BB%E5%8A%A1%E7%88%AC%E8%99%AB/</link>
			<pubDate>Mon, 21 Dec 2020 18:03:36 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/google%E8%B5%84%E6%B7%B1%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%B7%B1%E5%BA%A6%E8%AE%B2%E8%A7%A3go%E8%AF%AD%E8%A8%80-%E5%8D%95%E4%BB%BB%E5%8A%A1%E7%88%AC%E8%99%AB/</guid>
			<description>&lt;p&gt;由于教程的代码在zhenai.com更新之后无法访问,所以记录下代码改动&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>由于教程的代码在zhenai.com更新之后无法访问,所以记录下代码改动</p>
<h3 id="问题说明">问题说明</h3>
<p>这里在首页和城市列表页访问是没有问题的, curl请求也是正常, 但是当请求到用户信息的时候, 是需要UA 和cookie的
没有UA 会提示403, 没有cookie会提示 202</p>
<h3 id="fetchergo-代码">fetcher.go 代码</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">fetcher</span>

<span class="kn">import</span> <span class="p">(</span>
 <span class="s">&#34;bufio&#34;</span>
 <span class="s">&#34;fmt&#34;</span>
 <span class="s">&#34;golang.org/x/net/html/charset&#34;</span>
 <span class="s">&#34;golang.org/x/text/encoding&#34;</span>
 <span class="s">&#34;golang.org/x/text/encoding/unicode&#34;</span>
 <span class="s">&#34;golang.org/x/text/transform&#34;</span>
 <span class="s">&#34;io/ioutil&#34;</span>
 <span class="s">&#34;log&#34;</span>
 <span class="s">&#34;net/http&#34;</span>
 <span class="s">&#34;strings&#34;</span>
<span class="p">)</span>


<span class="kd">func</span> <span class="nf">Fetch</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
 <span class="nx">client</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">http</span><span class="p">.</span><span class="nx">Client</span><span class="p">{}</span>
 <span class="nx">newUrl</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Replace</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span> <span class="s">&#34;http://&#34;</span><span class="p">,</span><span class="s">&#34;https://&#34;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
 <span class="nx">request</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">NewRequest</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">MethodGet</span><span class="p">,</span> <span class="nx">newUrl</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
 <span class="p">}</span>
 <span class="c1">//添加header
</span><span class="c1"></span> <span class="nx">request</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Referer&#34;</span><span class="p">,</span><span class="s">&#34;http://www.zhenai.com/&#34;</span><span class="p">)</span>
 <span class="nx">request</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;User-Agent&#34;</span><span class="p">,</span><span class="s">&#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&#34;</span><span class="p">)</span>
 <span class="c1">//这里cookie只有1分钟有效期
</span><span class="c1"></span> <span class="nx">request</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;cookie&#34;</span><span class="p">,</span><span class="s">&#34;FSSBBIl1UgzbN7NO=53ZIxjnyRAeDyH5t9pg7cBA7QAYBxvaF7jmWYAZu2.CGt7mB9u9LeMhKl8ljte21zs7CWozraQ0E5VOTTi2KxSa; FSSBBIl1UgzbN7NP=5U5rnkYdGQG7qqqmCfWUuTapalzEu3wBuwQIl47nXp0HkSYoWXO9YSlekNkkwawdb3zC2rSWIE1_qIWRw3n3..NPhTqKwJXHroqsoGBqaeo_dgsIn64FK2YWZU6Y6L_l6d6tC7YBN8SMAPRcMqpmfS_9Jw.J8tXrIUZ6bUSeDufFFL1lNf8p4Om5i4P2teK4H1gnsMEldbBc9MLc1xhrJ7yLwLZhXr_mi2AhSHpshGFF7BkPzO_5ye_HaYME37Ukhc9MqOaqdytUs.ZebVaXEo7; Hm_lvt_2c8ad67df9e787ad29dbd54ee608f5d2=1608543698; Hm_lpvt_2c8ad67df9e787ad29dbd54ee608f5d2=1608544780; sid=d399176c-21e3-4e91-b550-fa8656de10e1; _exid=Fj3xNob61luAF5gXz5MAJq5CxrtoI86y%2Bqoc4YZ%2F64joUS0XSSIaALTyeW81WLbDLc0Pzw0kcM1r%2FGU1gm%2F2lA%3D%3D; ec=DH5wblNm-1608543720671-6a5cbb1e341df-781494537; _efmdata=HZvSyojNYRIMPbor%2FAzLk%2B5xwF4NLHTxU22OynbdfqEpXG7eNyAO1kHkZ%2FWDHgT7hGdqxoGwjueLMevvIv%2FF3upAu3SmFFc2zAJsHFMNjAc%3D&#34;</span><span class="p">)</span>

 <span class="nx">resp</span> <span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="nx">request</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
 <span class="p">}</span>
 <span class="k">defer</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
 <span class="k">if</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">StatusCode</span> <span class="o">!=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;wrong status code: %d&#34;</span><span class="p">,</span><span class="nx">resp</span><span class="p">.</span><span class="nx">StatusCode</span><span class="p">)</span>
 <span class="p">}</span>

 <span class="nx">bodyReader</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
 <span class="nx">e</span> <span class="o">:=</span> <span class="nf">determineEncoding</span><span class="p">(</span><span class="nx">bodyReader</span><span class="p">)</span>
 <span class="nx">uft8Reader</span> <span class="o">:=</span> <span class="nx">transform</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">bodyReader</span><span class="p">,</span><span class="nx">e</span><span class="p">.</span><span class="nf">NewDecoder</span><span class="p">())</span>
 <span class="k">return</span>  <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadAll</span><span class="p">(</span><span class="nx">uft8Reader</span><span class="p">)</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="nf">determineEncoding</span><span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">bufio</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">Encoding</span> <span class="p">{</span>
 <span class="nx">bytes</span> <span class="p">,</span><span class="nx">err</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Peek</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Fetcher error : %v&#34;</span><span class="p">,</span><span class="nx">err</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">unicode</span><span class="p">.</span><span class="nx">UTF8</span>
 <span class="p">}</span>

 <span class="nx">e</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">charset</span><span class="p">.</span><span class="nf">DetermineEncoding</span><span class="p">(</span><span class="nx">bytes</span><span class="p">,</span><span class="s">&#34;&#34;</span><span class="p">)</span>
 <span class="k">return</span> <span class="nx">e</span>
<span class="p">}</span>

</code></pre></div><h3 id="profile_testgo-测试一下">profile_test.go 测试一下</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">parser</span>

<span class="kn">import</span> <span class="p">(</span>
 <span class="s">&#34;learngo_crawler/fetcher&#34;</span>
 <span class="s">&#34;testing&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">TestParseProfile</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
 <span class="nx">contents</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fetcher</span><span class="p">.</span><span class="nf">Fetch</span><span class="p">(</span><span class="s">&#34;https://album.zhenai.com/u/1715998969&#34;</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
 <span class="p">}</span>
 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s\n&#34;</span><span class="p">,</span><span class="nx">contents</span><span class="p">)</span>
 <span class="nf">ParseProfile</span><span class="p">(</span><span class="nx">contents</span><span class="p">)</span>
<span class="p">}</span>


</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Google资深工程师深度讲解Go语言-广度优先算法学习-迷宫</title>
			<link>https://www.ngirl.xyz/golang/google%E8%B5%84%E6%B7%B1%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%B7%B1%E5%BA%A6%E8%AE%B2%E8%A7%A3go%E8%AF%AD%E8%A8%80-%E5%B9%BF%E5%BA%A6%E6%B7%B1%E5%BA%A6%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E8%BF%B7%E5%AE%AB/</link>
			<pubDate>Fri, 18 Dec 2020 18:00:44 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/google%E8%B5%84%E6%B7%B1%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%B7%B1%E5%BA%A6%E8%AE%B2%E8%A7%A3go%E8%AF%AD%E8%A8%80-%E5%B9%BF%E5%BA%A6%E6%B7%B1%E5%BA%A6%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E8%BF%B7%E5%AE%AB/</guid>
			<description>这里学习了Google吱声工程师深度讲解go语言-迷宫广度优先算法以记录
算法说明 图源: 图解迷宫算法（广度优先遍历)
首先看一张迷宫图, 左右黄色0 表示起始点, 0 表示可以行走, 1表示墙体 迷宫的广度优先算法的意思是, 可以通过0 发现四个方向的1, 然后在通过四个1 发现所有的2, 所有的2探索完 , 在探索3&amp;hellip; 以此类推&amp;hellip; 这里每个点都有三种状态:  未发现 已发现未探索 已探索  最终我们能探索到这样的结果图: 下面是详细代码 代码结构 ── maze ├── maze.go └── maze.in maze.in文件 6 5 0 1 0 0 0 0 0 0 1 0 0 1 0 1 0 1 1 1 0 0 0 1 0 0 1 0 1 0 0 0 maze.go package main import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;os&amp;#34; ) /* maze.</description>
			<content type="html"><![CDATA[<p>这里学习了Google吱声工程师深度讲解go语言-迷宫广度优先算法以记录</p>
<!-- more -->
<h3 id="算法说明">算法说明</h3>
<p>图源: <a href="https://www.pianshen.com/article/8849857777/">图解迷宫算法（广度优先遍历)</a></p>
<h4 id="首先看一张迷宫图-左右黄色0-表示起始点-0-表示可以行走-1表示墙体">首先看一张迷宫图, 左右黄色0 表示起始点, 0 表示可以行走, 1表示墙体</h4>
<p><img src="//zhangzw001.github.io/images/golang/maze-01.png" alt=""></p>
<p>迷宫的广度优先算法的意思是, 可以通过0 发现四个方向的1, 然后在通过四个1 发现所有的2, 所有的2探索完 , 在探索3&hellip;
<img src="//zhangzw001.github.io/images/golang/maze-02.png" alt=""></p>
<p>以此类推&hellip;
<img src="//zhangzw001.github.io/images/golang/maze-03.png" alt=""></p>
<h4 id="这里每个点都有三种状态">这里每个点都有三种状态:</h4>
<ul>
<li>未发现</li>
<li>已发现未探索</li>
<li>已探索</li>
</ul>
<p>最终我们能探索到这样的结果图:
<img src="//zhangzw001.github.io/images/golang/maze-04.png" alt=""></p>
<h3 id="下面是详细代码">下面是详细代码</h3>
<h4 id="代码结构">代码结构</h4>
<pre><code>── maze
   ├── maze.go
   └── maze.in
</code></pre><h4 id="mazein文件">maze.in文件</h4>
<pre><code>6 5
0 1 0 0 0
0 0 0 1 0
0 1 0 1 0
1 1 1 0 0
0 1 0 0 1
0 1 0 0 0
</code></pre><h4 id="mazego">maze.go</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
 <span class="s">&#34;fmt&#34;</span>
 <span class="s">&#34;log&#34;</span>
 <span class="s">&#34;os&#34;</span>
<span class="p">)</span>

<span class="cm">/*
</span><span class="cm">maze.in
</span><span class="cm">6 5
</span><span class="cm">0 1 0 0 0
</span><span class="cm">0 0 0 1 0
</span><span class="cm">0 1 0 1 0
</span><span class="cm">1 1 1 0 0
</span><span class="cm">0 1 0 0 1
</span><span class="cm">0 1 0 0 0
</span><span class="cm">
</span><span class="cm">- 未探索
</span><span class="cm">- 已发现未探索
</span><span class="cm">- 已探索
</span><span class="cm">
</span><span class="cm">- 广度优先算法 -&gt; 把所有的1全部探索完,再探索2
</span><span class="cm">*/</span>

<span class="kd">func</span> <span class="nf">readMaze</span><span class="p">(</span><span class="nx">filename</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
 <span class="nx">file</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
 <span class="p">}</span>
 <span class="k">defer</span> <span class="nx">file</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

 <span class="kd">var</span> <span class="nx">row</span><span class="p">,</span> <span class="nx">col</span> <span class="kt">int</span>
 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fscanf</span><span class="p">(</span><span class="nx">file</span><span class="p">,</span> <span class="s">&#34;%d %d&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">row</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">col</span><span class="p">)</span>
 <span class="nx">maze</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">row</span><span class="p">)</span>
 <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">maze</span> <span class="p">{</span>
  <span class="nx">maze</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">col</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">maze</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fscanf</span><span class="p">(</span><span class="nx">file</span><span class="p">,</span> <span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">maze</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">])</span>
  <span class="p">}</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="nx">maze</span>

<span class="p">}</span>

<span class="kd">type</span> <span class="nx">point</span> <span class="kd">struct</span> <span class="p">{</span>
 <span class="nx">i</span> <span class="kt">int</span>
 <span class="nx">j</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">dirs</span> <span class="p">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="nx">point</span><span class="p">{</span>
 <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="c1">//上
</span><span class="c1"></span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">},</span> <span class="c1">//左
</span><span class="c1"></span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>  <span class="c1">//下
</span><span class="c1"></span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>  <span class="c1">//右
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">//用值类型, 返回新的point
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">point</span><span class="p">)</span> <span class="nf">add</span><span class="p">(</span><span class="nx">po</span> <span class="nx">point</span><span class="p">)</span> <span class="nx">point</span> <span class="p">{</span>
 <span class="k">return</span> <span class="nx">point</span><span class="p">{</span><span class="nx">p</span><span class="p">.</span><span class="nx">i</span> <span class="o">+</span> <span class="nx">po</span><span class="p">.</span><span class="nx">i</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">j</span> <span class="o">+</span> <span class="nx">po</span><span class="p">.</span><span class="nx">j</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">point</span><span class="p">)</span> <span class="nf">notOver</span><span class="p">(</span><span class="nx">grid</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
 <span class="c1">//是否越界
</span><span class="c1"></span> <span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">p</span><span class="p">.</span><span class="nx">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">grid</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">false</span>
 <span class="p">}</span>
 <span class="c1">//if p.j &lt; 0 || p.j &gt;= len(grid[p.i]) {
</span><span class="c1"></span> <span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">j</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">p</span><span class="p">.</span><span class="nx">j</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">false</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">point</span><span class="p">)</span> <span class="nf">at</span><span class="p">(</span><span class="nx">grid</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>

 <span class="k">if</span> <span class="p">!</span><span class="nx">p</span><span class="p">.</span><span class="nf">notOver</span><span class="p">(</span><span class="nx">grid</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">false</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="nx">grid</span><span class="p">[</span><span class="nx">p</span><span class="p">.</span><span class="nx">i</span><span class="p">][</span><span class="nx">p</span><span class="p">.</span><span class="nx">j</span><span class="p">],</span> <span class="kc">true</span>

<span class="p">}</span>
<span class="kd">func</span> <span class="nf">walk</span><span class="p">(</span><span class="nx">maze</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">end</span> <span class="nx">point</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
 <span class="nx">steps</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">maze</span><span class="p">))</span>
 <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">steps</span> <span class="p">{</span>
  <span class="nx">steps</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">maze</span><span class="p">[</span><span class="nx">i</span><span class="p">]))</span>
 <span class="p">}</span>
 <span class="c1">//队列
</span><span class="c1"></span> <span class="nx">Q</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">point</span><span class="p">{</span><span class="nx">start</span><span class="p">}</span>

 <span class="c1">//开始探索
</span><span class="c1"></span> <span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">Q</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
  <span class="c1">// 探索头
</span><span class="c1"></span>  <span class="nx">cur</span> <span class="o">:=</span> <span class="nx">Q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="nx">Q</span> <span class="p">=</span> <span class="nx">Q</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

  <span class="c1">// 终端
</span><span class="c1"></span>  <span class="k">if</span> <span class="nx">cur</span> <span class="o">==</span> <span class="nx">end</span> <span class="p">{</span>
   <span class="k">break</span>
  <span class="p">}</span>

  <span class="c1">// 探索
</span><span class="c1"></span>  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">dir</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dirs</span> <span class="p">{</span>
   <span class="c1">//得到下一个点的坐标
</span><span class="c1"></span>   <span class="nx">next</span> <span class="o">:=</span> <span class="nx">cur</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">dir</span><span class="p">)</span>

   <span class="c1">// maze at next is 0
</span><span class="c1"></span>   <span class="c1">// and steps at next is 0
</span><span class="c1"></span>   <span class="c1">// and next != start
</span><span class="c1"></span>   <span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">next</span><span class="p">.</span><span class="nf">at</span><span class="p">(</span><span class="nx">maze</span><span class="p">)</span>
   <span class="c1">// 撞墙
</span><span class="c1"></span>   <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="o">||</span> <span class="nx">val</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
    <span class="k">continue</span>
   <span class="p">}</span>

   <span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">next</span><span class="p">.</span><span class="nf">at</span><span class="p">(</span><span class="nx">steps</span><span class="p">)</span>
   <span class="c1">// 不等于0 说明走过的
</span><span class="c1"></span>   <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="o">||</span> <span class="nx">val</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="k">continue</span>
   <span class="p">}</span>

   <span class="c1">// 原点
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">next</span> <span class="o">==</span> <span class="nx">start</span> <span class="p">{</span>
    <span class="k">continue</span>
   <span class="p">}</span>

   <span class="c1">//当前步骤数
</span><span class="c1"></span>   <span class="nx">curSteps</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">cur</span><span class="p">.</span><span class="nf">at</span><span class="p">(</span><span class="nx">steps</span><span class="p">)</span>
   <span class="nx">steps</span><span class="p">[</span><span class="nx">next</span><span class="p">.</span><span class="nx">i</span><span class="p">][</span><span class="nx">next</span><span class="p">.</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">curSteps</span> <span class="o">+</span> <span class="mi">1</span>

   <span class="nx">Q</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">Q</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span>
  <span class="p">}</span>
 <span class="p">}</span>

 <span class="k">return</span> <span class="nx">steps</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">walkLine</span><span class="p">(</span><span class="nx">steps</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">end</span> <span class="nx">point</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
 <span class="nx">newTable</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">steps</span><span class="p">))</span>
 <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">newTable</span> <span class="p">{</span>
  <span class="nx">newTable</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">steps</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
 <span class="p">}</span>

 <span class="nx">newTable</span><span class="p">[</span><span class="nx">end</span><span class="p">.</span><span class="nx">i</span><span class="p">][</span><span class="nx">end</span><span class="p">.</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">steps</span><span class="p">[</span><span class="nx">end</span><span class="p">.</span><span class="nx">i</span><span class="p">][</span><span class="nx">end</span><span class="p">.</span><span class="nx">j</span><span class="p">]</span>

 <span class="c1">//这里不需要队列, 因为只会找到一个值
</span><span class="c1"></span> <span class="nx">Q</span> <span class="o">:=</span> <span class="nx">end</span>
 <span class="c1">// 如果不是开头, 就继续找
</span><span class="c1"></span> <span class="k">for</span> <span class="nx">Q</span> <span class="o">!=</span> <span class="nx">start</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">dir</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dirs</span> <span class="p">{</span>
   <span class="c1">//得到下一个点的坐标
</span><span class="c1"></span>   <span class="nx">next</span> <span class="o">:=</span> <span class="nx">Q</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">dir</span><span class="p">)</span>
   <span class="c1">//是否越界
</span><span class="c1"></span>   <span class="k">if</span> <span class="p">!</span><span class="nx">next</span><span class="p">.</span><span class="nf">notOver</span><span class="p">(</span><span class="nx">steps</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">continue</span>
   <span class="p">}</span>
   <span class="c1">// 如果这个[坐标的值]=[当前坐标值]-1, 那就找到了,把这个坐标记录一下, 待会用这个坐标继续探索
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">steps</span><span class="p">[</span><span class="nx">next</span><span class="p">.</span><span class="nx">i</span><span class="p">][</span><span class="nx">next</span><span class="p">.</span><span class="nx">j</span><span class="p">]</span> <span class="o">==</span> <span class="nx">steps</span><span class="p">[</span><span class="nx">Q</span><span class="p">.</span><span class="nx">i</span><span class="p">][</span><span class="nx">Q</span><span class="p">.</span><span class="nx">j</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
    <span class="nx">newTable</span><span class="p">[</span><span class="nx">next</span><span class="p">.</span><span class="nx">i</span><span class="p">][</span><span class="nx">next</span><span class="p">.</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">steps</span><span class="p">[</span><span class="nx">next</span><span class="p">.</span><span class="nx">i</span><span class="p">][</span><span class="nx">next</span><span class="p">.</span><span class="nx">j</span><span class="p">]</span>
    <span class="nx">Q</span> <span class="p">=</span> <span class="nx">next</span>
   <span class="p">}</span>
  <span class="p">}</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="nx">newTable</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;&gt;&gt;&gt;&gt;&gt;&gt; 迷宫图如下:&#34;</span><span class="p">)</span>

 <span class="nx">maze</span> <span class="o">:=</span> <span class="nf">readMaze</span><span class="p">(</span><span class="s">&#34;maze/maze.in&#34;</span><span class="p">)</span>
 <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">row</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">maze</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">val</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">row</span> <span class="p">{</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%3d &#34;</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">()</span>
 <span class="p">}</span>

 <span class="nx">steps</span> <span class="o">:=</span> <span class="nf">walk</span><span class="p">(</span><span class="nx">maze</span><span class="p">,</span> <span class="nx">point</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="nx">point</span><span class="p">{</span><span class="nb">len</span><span class="p">(</span><span class="nx">maze</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">maze</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">})</span>
 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;&gt;&gt;&gt;&gt;&gt;&gt; 探索图如下:&#34;</span><span class="p">)</span>

 <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">row</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">steps</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">val</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">row</span> <span class="p">{</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%3d &#34;</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">()</span>
 <span class="p">}</span>
 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;&gt;&gt;&gt;&gt;&gt;&gt; 行走路线图如下:&#34;</span><span class="p">)</span>
 <span class="nx">newSteps</span> <span class="o">:=</span> <span class="nf">walkLine</span><span class="p">(</span><span class="nx">steps</span><span class="p">,</span> <span class="nx">point</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="nx">point</span><span class="p">{</span><span class="nb">len</span><span class="p">(</span><span class="nx">maze</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">maze</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">})</span>
 <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">row</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">newSteps</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">val</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">row</span> <span class="p">{</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%3d &#34;</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">()</span>
 <span class="p">}</span>
<span class="p">}</span>


</code></pre></div><h4 id="执行结果如下">执行结果如下:</h4>
<pre><code>&gt;&gt;&gt;&gt;&gt;&gt; 迷宫图如下:
  0   1   0   0   0
  0   0   0   1   0
  0   1   0   1   0
  1   1   1   0   0
  0   1   0   0   1
  0   1   0   0   0
&gt;&gt;&gt;&gt;&gt;&gt; 探索图如下:
  0   0   4   5   6
  1   2   3   0   7
  2   0   4   0   8
  0   0   0  10   9
  0   0  12  11   0
  0   0  13  12  13
&gt;&gt;&gt;&gt;&gt;&gt; 行走路线图如下:
  0   0   4   5   6
  1   2   3   0   7
  0   0   0   0   8
  0   0   0  10   9
  0   0   0  11   0
  0   0   0  12  13

</code></pre>]]></content>
		</item>
		
	</channel>
</rss>
