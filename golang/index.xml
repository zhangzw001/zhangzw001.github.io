<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Golangs on zhangzw</title>
		<link>https://www.ngirl.xyz/golang/</link>
		<description>Recent content in Golangs on zhangzw</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>zh-hans</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Mon, 07 Jun 2021 10:06:09 +0800</lastBuildDate>
		<atom:link href="https://www.ngirl.xyz/golang/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Go算法学习 动态规划 01背包基础</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%9201%E8%83%8C%E5%8C%85%E5%9F%BA%E7%A1%80/</link>
			<pubDate>Mon, 07 Jun 2021 10:06:09 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%9201%E8%83%8C%E5%8C%85%E5%9F%BA%E7%A1%80/</guid>
			<description>参考文档  carl 背包理论基础01背包 二维dp carl 背包理论基础01背包 一维dp  背包问题分类 01背包例子 题目说明: 有一堆物品, 背包的容量只有j,想要拿走最贵的东西,怎么装? weight := []int{1,3,4} //kg price := []int{15,20,30} //¥  01背包说明: 每个物品只能使用一次
 动态规划五部曲 1. 定义dp数组 这里我们定义一个dp[i][j]的数组 i代表 物品的下标,0,1,2&amp;hellip; j代表 背包的容量,1kg,3kg,4kg&amp;hellip; dp[i][j]代表 可选的i个物品中,容量为j的背包能装下最大为dp[i][j]的价值
 这里i个物品 是有两种状态, 选择 和不选择
 2. 确定推导公式 首先我们可以想到i个物品的dp[i][j] 是可以由 i-1个物品的情况下, 选择i转入背包 和不装入背包两种情况得到的 那不装入物品i的价值 = dp[i-1][j] 那装入了物品i的价值 = dp[i-1][j-weight[i]] + price[i], 显然装了东西, 背包容量肯定减少, 总价值肯定是增加 那我们dp[i][j] 应该选择哪种情况呢? 答案是选择更大价值的 dp[i][j] = max(dp[i-1][j] , dp[i-1][j-weight[i]] + price[i] ) 3.</description>
			<content type="html"><![CDATA[<h3 id="参考文档">参考文档</h3>
<ul>
<li><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.md">carl 背包理论基础01背包 二维dp</a></li>
<li><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.md">carl 背包理论基础01背包 一维dp</a></li>
</ul>
<h3 id="背包问题分类">背包问题分类</h3>
<p><img src="/assets/markdown-img-paste-20210607100754609.png" alt=""></p>
<h3 id="01背包例子">01背包例子</h3>
<h4 id="题目说明">题目说明:</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">有一堆物品</span><span class="p">,</span> <span class="nx">背包的容量只有j</span><span class="p">,</span><span class="nx">想要拿走最贵的东西</span><span class="p">,</span><span class="nx">怎么装</span><span class="err">?</span>
<span class="nx">weight</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">}</span>  <span class="c1">//kg
</span><span class="c1"></span><span class="nx">price</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">15</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">}</span>    <span class="c1">//¥
</span></code></pre></div><blockquote>
<p>01背包说明: 每个物品只能使用一次</p>
</blockquote>
<h3 id="动态规划五部曲">动态规划五部曲</h3>
<h4 id="1-定义dp数组">1. 定义dp数组</h4>
<p>这里我们定义一个dp[i][j]的数组
i代表 物品的下标,0,1,2&hellip;
j代表 背包的容量,1kg,3kg,4kg&hellip;
dp[i][j]代表 可选的i个物品中,容量为j的背包能装下最大为dp[i][j]的价值</p>
<blockquote>
<p>这里i个物品 是有两种状态, 选择 和不选择</p>
</blockquote>
<h4 id="2-确定推导公式">2. 确定推导公式</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">首先我们可以想到i个物品的dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="nx">是可以由</span> <span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="nx">个物品的情况下</span><span class="p">,</span> <span class="nx">选择i转入背包</span> <span class="nx">和不装入背包两种情况得到的</span>
<span class="nx">那不装入物品i的价值</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span>
<span class="nx">那装入了物品i的价值</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">+</span> <span class="nx">price</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">显然装了东西</span><span class="p">,</span> <span class="nx">背包容量肯定减少</span><span class="p">,</span> <span class="nx">总价值肯定是增加</span>
<span class="nx">那我们dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="nx">应该选择哪种情况呢</span><span class="err">?</span>
<span class="nx">答案是选择更大价值的</span>
<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">,</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">+</span> <span class="nx">price</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">)</span>
</code></pre></div><h4 id="3-初始化">3. 初始化</h4>
<ul>
<li>dp[0][0]</li>
</ul>
<pre><code>现在有i=0 这一个物品可以选择,j=0 说明背包大小是0
那我们只能不选择 重量为weight[0]的物品, 因为装不下嘛
那么什么也没装, 我们的dp[0][0] = 0
</code></pre><ul>
<li>dp[i][0]</li>
</ul>
<pre><code>这种情况, 背包容量都是0, 所以dp[i][0] = 0
</code></pre><ul>
<li>dp[0][j]</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">对于这种情况</span><span class="p">,</span><span class="nx">我们要判断背包容量j</span> <span class="nx">是否大于等于</span> <span class="nx">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">只要大于就装入背包</span>
<span class="k">for</span> <span class="nx">j</span><span class="o">:=</span> <span class="nx">bagWeight</span> <span class="p">;</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="nx">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">;</span> <span class="nx">j</span><span class="o">--</span> <span class="p">{</span>
    <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="nx">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">+</span> <span class="nx">price</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div><h4 id="4-遍历的顺序">4. 遍历的顺序</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">从3</span><span class="p">.</span><span class="nx">初始化</span> <span class="nx">步骤我们可以看到</span><span class="p">,</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span><span class="nx">的遍历是倒序的</span><span class="p">,</span> <span class="nx">为啥需要倒序呢</span><span class="err">?</span>

<span class="nx">首先我们看下如果正序会怎么样</span><span class="p">:</span>
<span class="k">for</span> <span class="nx">j</span><span class="o">:=</span> <span class="nx">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">bagWeight</span> <span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="nx">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">+</span> <span class="nx">price</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span>
<span class="c1">//weight := []int{1,3,4}  //kg
</span><span class="c1">//price := []int{15,20,30}    //¥
</span><span class="c1"></span>
<span class="nx">这里weight</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">bagWeight</span> <span class="p">=</span><span class="mi">4</span>
<span class="nx">当j</span><span class="p">=</span><span class="mi">1</span><span class="nx">时</span>      <span class="p">,</span>  <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">15</span> <span class="p">=</span> <span class="mi">15</span>
<span class="nx">当j</span><span class="p">=</span><span class="mi">2</span><span class="nx">时</span>      <span class="p">,</span>  <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">15</span> <span class="p">=</span><span class="mi">30</span> <span class="c1">// 显然这里price[0]被取了两次
</span><span class="c1"></span>

<span class="nx">我们再来看下倒序的过程</span><span class="p">:</span>
<span class="k">for</span> <span class="nx">j</span><span class="o">:=</span> <span class="nx">bagWeight</span> <span class="p">;</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="nx">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">;</span> <span class="nx">j</span><span class="o">--</span> <span class="p">{</span>
    <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="nx">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">+</span> <span class="nx">price</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span>

<span class="nx">j</span><span class="p">=</span><span class="mi">4</span>       <span class="p">,</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="mi">15</span> <span class="p">=</span> <span class="mi">15</span>
<span class="nx">j</span><span class="p">=</span><span class="mi">3</span>       <span class="p">,</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">15</span> <span class="p">=</span> <span class="mi">15</span>
<span class="nx">j</span><span class="p">=</span><span class="mi">2</span>       <span class="p">,</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">15</span> <span class="p">=</span> <span class="mi">15</span>
<span class="nx">j</span><span class="p">=</span><span class="mi">1</span>       <span class="p">,</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">15</span> <span class="p">=</span> <span class="mi">15</span>

<span class="nx">因为我们的推导公式遍历的顺序</span> <span class="nx">同样倒序遍历j会更方便</span>
</code></pre></div><h4 id="5-自己手工写一下结果是否正确">5. 自己手工写一下结果是否正确</h4>
<p><img src="/assets/markdown-img-paste-20210607112304945.png" alt=""></p>
<h3 id="show-me-the-code">show me the code</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">test_2_wei_bag_problem</span><span class="p">(</span><span class="nx">weight</span><span class="p">,</span> <span class="nx">price</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">target</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c1">// 定义dp数组
</span><span class="c1"></span>	<span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">weight</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dp</span> <span class="p">{</span>
		<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">target</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 初始化
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">weight</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="nx">target</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="nx">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="nx">j</span><span class="o">--</span> <span class="p">{</span>
		<span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="nx">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="nx">price</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="c1">// 推导公式
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">weight</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// 正序, j从0 开始
</span><span class="c1"></span>		<span class="c1">//[0 15 15 15 15]
</span><span class="c1"></span>		<span class="c1">//[0 15 15 20 35]
</span><span class="c1"></span>		<span class="c1">//[0 15 15 20 35]
</span><span class="c1"></span>		<span class="c1">//for  j := 0;j&lt;= target ; j++ {
</span><span class="c1"></span>		<span class="c1">//	if j &lt; weight[i] {
</span><span class="c1"></span>		<span class="c1">//		// 因为只有这一种情况, 没办法拿到dp[i-1][j-weight[i]]
</span><span class="c1"></span>		<span class="c1">//		dp[i][j] = dp[i-1][j]
</span><span class="c1"></span>		<span class="c1">//	}else {
</span><span class="c1"></span>		<span class="c1">//		dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+price[i])
</span><span class="c1"></span>		<span class="c1">//	}
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">//}
</span><span class="c1"></span>		<span class="c1">// 正序, 舍弃无用的遍历
</span><span class="c1"></span>		<span class="c1">//[0 15 15 15 15]
</span><span class="c1"></span>		<span class="c1">//[0 0  0  20 35]
</span><span class="c1"></span>		<span class="c1">//[0 0  0  0  35]
</span><span class="c1"></span>		<span class="k">for</span>  <span class="nx">j</span> <span class="o">:=</span> <span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span><span class="nx">j</span><span class="o">&lt;=</span> <span class="nx">target</span> <span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="o">+</span><span class="nx">price</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="p">}</span>
		<span class="c1">// 倒序
</span><span class="c1"></span>		<span class="c1">//[0 15 15 15 15]
</span><span class="c1"></span>		<span class="c1">//[0 0  0  20 35]
</span><span class="c1"></span>		<span class="c1">//[0 0  0  0  35]
</span><span class="c1"></span>		<span class="c1">//for j := target; j &gt;= weight[i]; j-- {
</span><span class="c1"></span>		<span class="c1">//	dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+price[i])
</span><span class="c1"></span>		<span class="c1">//}
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span> <span class="p">;</span><span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">dp</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">weight</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">target</span><span class="p">]</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">weight</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">}</span>
	<span class="nx">price</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">15</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">}</span>
	<span class="nf">bag01</span><span class="p">(</span><span class="nx">weight</span><span class="p">,</span><span class="nx">price</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><h3 id="dp数组优化">dp数组优化</h3>
<pre><code>//[0 15 15 15 15]
//[0 0  0  20 35]
//[0 0  0  0  35]
</code></pre><p>推导公式:  <code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+price[i])</code>
这里我们发现i 主要是用来保留了状态,  我们可以将i层的覆盖到i-1层, 因此状态压缩后的推导公式:
<code>dp[j] = max(dp[j], dp[j-weight[i]]+price[i])</code></p>
<h3 id="动态规划五部曲-1">动态规划五部曲</h3>
<h4 id="1-dp数组定义">1. dp数组定义</h4>
<p>dp[j] 表示背包容量为j,装的物品最大价值为dp[j]</p>
<h4 id="2-dp推导公式">2. dp推导公式</h4>
<p><code>dp[j] = max(dp[j], dp[j-weight[i]]+price[i])</code></p>
<h4 id="3-初始化-1">3. 初始化</h4>
<p>dp[0] 背包容量为0的话, 装的物品最大价值当然也是0</p>
<h4 id="4-遍历的顺序-1">4. 遍历的顺序</h4>
<p>推导遍历的i顺序 当然是从0&lt;=i &lt;len(weight)
那么推导的j顺序呢?</p>
<p>首先我们看一下正序:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span> <span class="p">;</span><span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">weight</span><span class="p">)</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="c1">// 这里必须倒序
</span><span class="c1"></span>    <span class="c1">//for j:= target; j &gt;= weight[i] ; j-- {
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">j</span><span class="o">:=</span> <span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">target</span> <span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
        <span class="c1">// 递推公式
</span><span class="c1"></span>        <span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="o">+</span><span class="nx">price</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">dp</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 结果
</span><span class="c1"></span><span class="p">[</span><span class="mi">0</span> <span class="mi">15</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">15</span> <span class="mi">30</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">15</span> <span class="mi">30</span> <span class="mi">45</span> <span class="mi">0</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">15</span> <span class="mi">30</span> <span class="mi">45</span> <span class="mi">60</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">15</span> <span class="mi">30</span> <span class="mi">45</span> <span class="mi">60</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">15</span> <span class="mi">30</span> <span class="mi">45</span> <span class="mi">60</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">15</span> <span class="mi">30</span> <span class="mi">45</span> <span class="mi">60</span><span class="p">]</span>
</code></pre></div><p>在j的循环内部对price[i]进行了多次累加</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">当i</span><span class="p">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">j</span><span class="p">=</span><span class="nx">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">]=</span><span class="mi">1</span><span class="p">;</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]=</span><span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="nx">price</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">15</span><span class="p">)</span> <span class="p">=</span> <span class="mi">15</span>
<span class="nx">当i</span><span class="p">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">j</span><span class="p">=</span><span class="nx">j</span><span class="o">++</span><span class="p">=</span><span class="mi">2</span><span class="p">;</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">]=</span><span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="nx">price</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">15</span><span class="o">+</span><span class="mi">15</span><span class="p">)</span> <span class="p">=</span> <span class="mi">30</span>
<span class="nx">当i</span><span class="p">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">j</span><span class="p">=</span><span class="nx">j</span><span class="o">++</span><span class="p">=</span><span class="mi">3</span><span class="p">;</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">3</span><span class="p">]=</span><span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">3</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="nx">price</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">30</span><span class="o">+</span><span class="mi">15</span><span class="p">)</span> <span class="p">=</span> <span class="mi">45</span>
<span class="nx">当i</span><span class="p">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">j</span><span class="p">=</span><span class="nx">j</span><span class="o">++</span><span class="p">=</span><span class="mi">4</span><span class="p">;</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">4</span><span class="p">]=</span><span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">4</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="nx">price</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">45</span><span class="o">+</span><span class="mi">15</span><span class="p">)</span> <span class="p">=</span> <span class="mi">60</span>
</code></pre></div><p>显然这不符合我们的预期, 单个物品只能选取一次</p>
<p>因此这里我们应该使用倒序的方式</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span> <span class="p">;</span><span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">weight</span><span class="p">)</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="c1">// 这里必须倒序
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">j</span><span class="o">:=</span> <span class="nx">target</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">;</span> <span class="nx">j</span><span class="o">--</span> <span class="p">{</span>
        <span class="c1">// 递推公式
</span><span class="c1"></span>        <span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="o">+</span><span class="nx">price</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">dp</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//结果
</span><span class="c1"></span><span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">15</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">15</span> <span class="mi">15</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">15</span> <span class="mi">15</span> <span class="mi">15</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">15</span> <span class="mi">15</span> <span class="mi">15</span> <span class="mi">15</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">15</span> <span class="mi">15</span> <span class="mi">15</span> <span class="mi">35</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">15</span> <span class="mi">15</span> <span class="mi">20</span> <span class="mi">35</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">15</span> <span class="mi">15</span> <span class="mi">20</span> <span class="mi">35</span><span class="p">]</span>
</code></pre></div><h4 id="5-举例推导dp数组">5. 举例推导dp数组</h4>
<p>上面的结果就包含了举例:</p>
<pre><code>i=0, dp=[0 15 15 15 15]
i=1, dp=[0 15 15 20 35]
i=2, dp=[0 15 15 20 35]
</code></pre><h3 id="show-me-the-code-1">show me the code</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">test_1_wei_bag_problem</span><span class="p">(</span><span class="nx">weight</span><span class="p">,</span> <span class="nx">price</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">target</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c1">// 定义 and 初始化
</span><span class="c1"></span>	<span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nx">target</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="c1">// 递推顺序
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span> <span class="p">;</span><span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">weight</span><span class="p">)</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// 这里必须倒序
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">j</span><span class="o">:=</span> <span class="nx">target</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">;</span> <span class="nx">j</span><span class="o">--</span> <span class="p">{</span>
			<span class="c1">// 递推公式
</span><span class="c1"></span>			<span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="o">+</span><span class="nx">price</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="p">}</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">dp</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">target</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">weight</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">}</span>
	<span class="nx">price</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">15</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">test_1_wei_bag_problem</span><span class="p">(</span><span class="nx">weight</span><span class="p">,</span><span class="nx">price</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go算法学习 动态规划 分割等和子集</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</link>
			<pubDate>Thu, 27 May 2021 18:36:38 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</guid>
			<description>dp 一维数组模板  例一
    \ 重量 价值     物品0 1 15   物品1 3 20   物品2 4 30    for i:=0;i&amp;lt; 物品重量列表长度;i++ { for j:= 背包容量;j &amp;gt;= i物品的重量;j-- { dp[j] = max(dp[j], dp[j- 物品i的重量] + 物品i的价值) } } 物品重量: weight := []int{1,3,4} 物品价值: value := []int{15,20,30} for i:=0;i&amp;lt; len(weight);i++ { for j:= target ;j &amp;gt;= weight[i];j-- { dp[j] = max(dp[j], dp[j- weight[i]] + value[i]) } } # 背包问题简单测试 func bag01() { weight := []int{1, 3, 4} value := []int{15, 20, 30} target := 10 dp := make([]int,target+1) for i := 0; i &amp;lt; len(weight); i++ { for j := target; j &amp;gt;= weight[i]; j-- { dp[j] = max(dp[j], dp[j-weight[i]]+value[i]) } } fmt.</description>
			<content type="html"><![CDATA[<h3 id="dp-一维数组模板">dp 一维数组模板</h3>
<blockquote>
<p>例一</p>
</blockquote>
<table>
<thead>
<tr>
<th>\</th>
<th>重量</th>
<th>价值</th>
</tr>
</thead>
<tbody>
<tr>
<td>物品0</td>
<td>1</td>
<td>15</td>
</tr>
<tr>
<td>物品1</td>
<td>3</td>
<td>20</td>
</tr>
<tr>
<td>物品2</td>
<td>4</td>
<td>30</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span> <span class="nx">物品重量列表长度</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">j</span><span class="o">:=</span> <span class="nx">背包容量</span><span class="p">;</span><span class="nx">j</span> <span class="o">&gt;=</span> <span class="nx">i物品的重量</span><span class="p">;</span><span class="nx">j</span><span class="o">--</span> <span class="p">{</span>
        <span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span> <span class="nx">物品i的重量</span><span class="p">]</span> <span class="o">+</span> <span class="nx">物品i的价值</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">物品重量</span><span class="p">:</span>   <span class="nx">weight</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">}</span>
<span class="nx">物品价值</span><span class="p">:</span>   <span class="nx">value</span>  <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">15</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">}</span>

<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">weight</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">j</span><span class="o">:=</span> <span class="nx">target</span> <span class="p">;</span><span class="nx">j</span> <span class="o">&gt;=</span> <span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span><span class="nx">j</span><span class="o">--</span> <span class="p">{</span>
        <span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span> <span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">+</span> <span class="nx">value</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="err">#</span> <span class="nx">背包问题简单测试</span>
<span class="kd">func</span> <span class="nf">bag01</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">weight</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
	<span class="nx">value</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">}</span>
	<span class="nx">target</span> <span class="o">:=</span> <span class="mi">10</span>
	<span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nx">target</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">weight</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="nx">target</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span> <span class="nx">j</span><span class="o">--</span> <span class="p">{</span>
			<span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="o">+</span><span class="nx">value</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">dp</span><span class="p">)</span>    <span class="c1">//[0 15 15 20 35 45 45 50 65 65 65]
</span><span class="c1"></span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>  <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>

</code></pre></div><h3 id="show-me-the-code">show me the code</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="c1">//https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.md
</span><span class="c1">//416. 分割等和子集
</span><span class="c1">//题目链接：https://leetcode-cn.com/problems/partition-equal-subset-sum/
</span><span class="c1">//
</span><span class="c1">//题目难易：中等
</span><span class="c1">//
</span><span class="c1">//给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
</span><span class="c1">//
</span><span class="c1">//注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200
</span><span class="c1">//
</span><span class="c1">//示例 1: 输入: [1, 5, 11, 5] 输出: true 解释: 数组可以分割成 [1, 5, 5] 和 [11].   示例 2: 输入: [1, 2, 3, 5] 输出: false 解释: 数组不能分割成两个元素和相等的子集.
</span><span class="c1"></span>
<span class="c1">// 1. 暴力回溯法
</span><span class="c1">// 1,5,11,5
</span><span class="c1">// 找到所有和=22, 取一半 = 11
</span><span class="c1">// 先取第一个数字: 1,1+5,1+11,1+5|1+5+11,1+5+5|1+11+5  存在==11
</span><span class="c1">// 先取第二个数字: 5+11,5+5
</span><span class="c1">// 先取第三个数字: 11+5
</span><span class="c1">// 先取第四个数字: 5
</span><span class="c1">// 回溯遍历可以得到结果, 但是会超时
</span><span class="c1">// 时间复杂度: O(n*n!) ?
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">canPartition</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">sum</span> <span class="o">+=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">sum</span><span class="o">%</span><span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="c1">// 回溯三部曲
</span><span class="c1"></span>	<span class="c1">// 1. 传参:
</span><span class="c1"></span>	<span class="c1">// 2. 终止条件
</span><span class="c1"></span>	<span class="c1">// 3. 单次循环
</span><span class="c1"></span>	<span class="nx">part</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="kc">false</span>
	<span class="kd">var</span> <span class="nx">dfs</span> <span class="kd">func</span><span class="p">(</span><span class="nx">index</span> <span class="kt">int</span><span class="p">)</span>
	<span class="nx">dfs</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">index</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// 终止条件
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">part</span> <span class="p">&gt;</span> <span class="nx">sum</span><span class="o">/</span><span class="mi">2</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">part</span> <span class="o">==</span> <span class="nx">sum</span><span class="o">/</span><span class="mi">2</span> <span class="p">{</span>
			<span class="nx">result</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="c1">// 单次循环,每次取值进行累加
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">index</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">part</span> <span class="o">+=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
			<span class="c1">// 递归
</span><span class="c1"></span>			<span class="nf">dfs</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
			<span class="c1">// 回溯
</span><span class="c1"></span>			<span class="nx">part</span> <span class="o">-=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="c1">// 01背包问题, 元素只能使用一次
</span><span class="c1">// 本次是要求找出 元素和 等于总和/2
</span><span class="c1">// 1. dp数组的定义
</span><span class="c1">// dp[value] 表示 容量为value的背包,所背的物品价值为dp[value]
</span><span class="c1">// 在这里
</span><span class="c1">// dp[value] 表示 容量为value的背包,所存储的最大的值 dp[value]
</span><span class="c1">// 2. dp数组的推导公式
</span><span class="c1">// dp[value] = max(dp[value], dp[value-nums[j]]+nums[j]
</span><span class="c1">// 3. dp数组初始化
</span><span class="c1">// dp[0] = 0
</span><span class="c1">// 4. dp数组的顺序
</span><span class="c1">// 在动态规划：关于01背包问题，你该了解这些！（滚动数组）中就已经说明：如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒叙遍历！
</span><span class="c1">// 5. 举例数组
</span><span class="c1">// dp[value]的数值一定小于等于value, 肯定不能超过最大容量
</span><span class="c1">// 如果dp[value]== value,说明子集合刚好可以凑成总和i, 这里我们的i上限 其实等于 sum/2
</span><span class="c1">// 例如 输入[1,5,11,5], sum/2 = 11
</span><span class="c1">// dp[value] = 0,1,1,1,1,5,6,6,6,6,10,11
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">canPartition2</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">sum</span> <span class="o">+=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">sum</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span>  <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="c1">// max方法
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">max</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
	<span class="nx">max</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
		<span class="k">return</span> <span class="nx">b</span>
	<span class="p">}</span>

	<span class="nx">target</span> <span class="o">:=</span> <span class="nx">sum</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
	<span class="c1">// 1. 定义dp数组
</span><span class="c1"></span>	<span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">target</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="c1">// 3. 初始化
</span><span class="c1"></span>	<span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="c1">// 4. dp数组的顺序
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// 每一个元素一定是不可重复放入，所以从大到小遍历
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">value</span> <span class="o">:=</span> <span class="nx">target</span><span class="p">;</span> <span class="nx">value</span> <span class="o">&gt;=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span> <span class="nx">value</span><span class="o">--</span> <span class="p">{</span>
			<span class="nx">dp</span><span class="p">[</span><span class="nx">value</span><span class="p">]</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">value</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">value</span><span class="o">-</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="o">+</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 等于target 说明整合凑成
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">target</span><span class="p">]</span> <span class="o">==</span> <span class="nx">target</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>



<span class="c1">// 优化版本, 不需要计算值
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">canPartition3</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">sum</span> <span class="o">+=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">sum</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span>  <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="nx">target</span> <span class="o">:=</span> <span class="nx">sum</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
	<span class="c1">// 1. 定义dp数组
</span><span class="c1"></span>	<span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">bool</span><span class="p">,</span> <span class="nx">target</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="c1">// 3. 初始化
</span><span class="c1"></span>	<span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="c1">// 4. dp数组的顺序
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// 每一个元素一定是不可重复放入，所以从大到小遍历
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">value</span> <span class="o">:=</span> <span class="nx">target</span><span class="p">;</span> <span class="nx">value</span> <span class="o">&gt;=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span> <span class="nx">value</span><span class="o">--</span> <span class="p">{</span>
			<span class="nx">dp</span><span class="p">[</span><span class="nx">value</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">value</span><span class="p">]</span><span class="o">||</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">value</span><span class="o">-</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span>
		<span class="p">}</span>
		<span class="c1">// 一旦等于target
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">target</span><span class="p">]</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">true</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>




<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">canPartition</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">5</span><span class="p">}))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">canPartition</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">}))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">canPartition</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">}))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">canPartition</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mi">97</span><span class="p">}))</span>
<span class="p">}</span>


</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go算法学习 动态规划 整数拆分</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/</link>
			<pubDate>Thu, 27 May 2021 11:07:46 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/</guid>
			<description>show me the code package main //https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0343.%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86.md //343. 整数拆分 //题目链接：https://leetcode-cn.com/problems/integer-break/ // //给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 // //示例 1: 输入: 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1。 // //示例 2: 输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 说明: 你可以假设 n 不小于 2 且不大于 58。  // dp[i] 代表 i这个数 拆分得到最大的乘积 // 看看示例 // dp[0],dp[1] 不用考虑, 题目是n大于等于2 // dp[2] = 1 * 1 = 1 只有一个结果  // 1.</description>
			<content type="html"><![CDATA[<h3 id="show-me-the-code">show me the code</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="c1">//https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0343.%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86.md
</span><span class="c1">//343. 整数拆分
</span><span class="c1">//题目链接：https://leetcode-cn.com/problems/integer-break/
</span><span class="c1">//
</span><span class="c1">//给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。
</span><span class="c1">//
</span><span class="c1">//示例 1: 输入: 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1。
</span><span class="c1">//
</span><span class="c1">//示例 2: 输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 说明: 你可以假设 n 不小于 2 且不大于 58。
</span><span class="c1"></span>


<span class="c1">// dp[i] 代表 i这个数 拆分得到最大的乘积
</span><span class="c1">// 看看示例
</span><span class="c1">// dp[0],dp[1] 不用考虑, 题目是n大于等于2
</span><span class="c1">// dp[2] = 1 * 1  = 1 只有一个结果
</span><span class="c1"></span>
<span class="c1">// 1.dp[3] 可以如下拆分
</span><span class="c1">// 	1.1 (3-1) * 1 = 2
</span><span class="c1">// 	1.2 dp[3-1] * 1 = 1	 =&gt; 局部最优: 1 * 1 * 1 = 1
</span><span class="c1">//  这里的dp[3-1] 其实就是我们在对2拆分获取最大乘积
</span><span class="c1">//  1.3 (3-2) * 2 = 2
</span><span class="c1">//  不存在dp[3-2]了
</span><span class="c1">//  所以 dp[3] = 2
</span><span class="c1"></span>
<span class="c1">// 2. dp[4] 可以如下拆分
</span><span class="c1">// 	2.1 (4-1) * 1 = 3
</span><span class="c1">//  2.2 dp[4-1] * 1 = 2	=&gt; 局部最优: 1 * 2 * 1 = 2
</span><span class="c1">//  2.3 (4-2) * 2 = 4
</span><span class="c1">//  2.4 dp[4-2] * 2 = 2 =&gt; 局部最优: 1 * 1 * 2 = 2
</span><span class="c1">//  2.5 (4-3) * 3 = 3
</span><span class="c1">//  所以dp[4] = 4
</span><span class="c1"></span>
<span class="c1">// 3. dp[5] 可以拆分
</span><span class="c1">//  3.1 (5-1) * 1 = 4
</span><span class="c1">//  3.2 dp[5-1] * 1 = 4	=&gt; 局部最优: 2 * 2 * 1 = 4
</span><span class="c1">//  3.3 (5-2) * 2 = 6
</span><span class="c1">//  3.4 dp[5-2] * 2 = 4 =&gt; 局部最优: 1 * 2 * 2 = 4
</span><span class="c1">//  3.5 (5-3) * 3 = 6
</span><span class="c1">//  3.6 dp[5-3] * 3 = 3 =&gt; 局部最优: 1 * 1 * 3 = 3
</span><span class="c1">//  3.7 (5-4) * 4 = 4
</span><span class="c1">//  所以dp[5] = 6
</span><span class="c1"></span>
<span class="c1">// 因此dp[i] 可以得到如下
</span><span class="c1">// 	1. (i-j) * j  拆成两个数字
</span><span class="c1">//  2. dp[i-j] * j ,dp[i-j] 代表i-j可以得到的最大乘积
</span><span class="c1">// 所以dp[i] = max(dp[i], dp[i-j] * j , (i-j)*j)
</span><span class="c1"></span>
<span class="c1">// 1. dp[i]数组定义: i这个正整数可以拆分的最大乘积
</span><span class="c1">// 2. dp数组初始化: dp[2] = 1
</span><span class="c1">// 3. dp推导公式: dp[i] = max(dp[i], dp[i-j] * j , (i-j)*j)
</span><span class="c1">// 4. 顺序: 同样从前往后
</span><span class="c1">// 5. 举例: dp[i] = 0,0,1,2,4,6,9,12,18,27,36
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">integerBreak</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c1">// 1.定义dp数组
</span><span class="c1"></span>	<span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="c1">// 3. 初始化
</span><span class="c1"></span>	<span class="nx">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="c1">// 4. 遍历顺序
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="c1">// 2. dp推导公式
</span><span class="c1"></span>			<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="nx">j</span><span class="p">]</span><span class="o">*</span><span class="nx">j</span><span class="p">,</span> <span class="p">(</span><span class="nx">i</span><span class="o">-</span><span class="nx">j</span><span class="p">)</span><span class="o">*</span><span class="nx">j</span><span class="p">))</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">integerBreak</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="p">}</span>


</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go算法学习 动态规划 不同路径2</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%842/</link>
			<pubDate>Wed, 26 May 2021 18:01:37 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%842/</guid>
			<description>show me the code package main import &amp;#34;fmt&amp;#34; //https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0063.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II.md //63. 不同路径 II //题目链接：https://leetcode-cn.com/problems/unique-paths-ii/ // //一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 // //机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 // //现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？  // 同样根据我们 &amp;lt;&amp;lt; 62. 不同路径&amp;gt;&amp;gt; 的分析可以指定 // dp[i][j] 代表的是 (i,j) 坐标到达的所有路径数 // 显然(i,j) 如果是路障, 那么dp[i][j] = 0 是肯定的, 因为无法到达哈  // 那我们先来举例演示一下 // obstacleGrid = [[0,0,0,0],[0,1,0,1],[1,0,0,0],[0,0,0,0]] // [0,0,0,0] // [0,1,0,1] // [1,0,0,0] // [0,0,0,0] // 我们的dp数组同样初始化为: // 二维数组如下: //[1 1 1 1] //[1 0 0 0] //[0 0 0 0] //[0 0 0 0] // 根据有障碍的数组, 按照dp[i][j] = dp[i][j-1] + dp[i-1][j] 来计算可以得到如下: //[1 1 1 1] //[1 0 1 0] //[0 0 1 1] //[0 0 1 2]  // 动态规划五部曲 // 1.</description>
			<content type="html"><![CDATA[<h3 id="show-me-the-code">show me the code</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="c1">//https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0063.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II.md
</span><span class="c1">//63. 不同路径 II
</span><span class="c1">//题目链接：https://leetcode-cn.com/problems/unique-paths-ii/
</span><span class="c1">//
</span><span class="c1">//一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
</span><span class="c1">//
</span><span class="c1">//机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
</span><span class="c1">//
</span><span class="c1">//现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
</span><span class="c1"></span>
<span class="c1">// 同样根据我们 &lt;&lt; 62. 不同路径&gt;&gt; 的分析可以指定
</span><span class="c1">// dp[i][j] 代表的是 (i,j) 坐标到达的所有路径数
</span><span class="c1">// 显然(i,j) 如果是路障, 那么dp[i][j] = 0 是肯定的, 因为无法到达哈
</span><span class="c1"></span>
<span class="c1">// 那我们先来举例演示一下
</span><span class="c1">// obstacleGrid = [[0,0,0,0],[0,1,0,1],[1,0,0,0],[0,0,0,0]]
</span><span class="c1">// [0,0,0,0]
</span><span class="c1">// [0,1,0,1]
</span><span class="c1">// [1,0,0,0]
</span><span class="c1">// [0,0,0,0]
</span><span class="c1">// 我们的dp数组同样初始化为:
</span><span class="c1">// 二维数组如下:
</span><span class="c1">//[1 1 1 1]
</span><span class="c1">//[1 0 0 0]
</span><span class="c1">//[0 0 0 0]
</span><span class="c1">//[0 0 0 0]
</span><span class="c1">// 根据有障碍的数组, 按照dp[i][j] = dp[i][j-1] + dp[i-1][j] 来计算可以得到如下:
</span><span class="c1">//[1 1 1 1]
</span><span class="c1">//[1 0 1 0]
</span><span class="c1">//[0 0 1 1]
</span><span class="c1">//[0 0 1 2]
</span><span class="c1"></span>
<span class="c1">// 动态规划五部曲
</span><span class="c1">// 1. dp数组定义和含义 : dp[i][j] 同样代表该位置(i,j) 所有路线总和
</span><span class="c1">// 2. dp的推导过程: 同样是 dp[i][j] = dp[i][j-1] +  dp[i-1][j]
</span><span class="c1">// 3. dp数组初始化:
</span><span class="c1">//    3.1 同样是第一行或第一列都初始化为1
</span><span class="c1">//    3.2 但是如果该行有障碍物, 后面的都将是0, 因为不可能到达
</span><span class="c1">// 4. 顺序
</span><span class="c1">// 5. 举例dp数组
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">uniquePathsWithObstacles</span><span class="p">(</span><span class="nx">obstacleGrid</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">,</span><span class="nx">n</span><span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">obstacleGrid</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="nx">obstacleGrid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="c1">// 定义一个dp数组
</span><span class="c1"></span>	<span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span><span class="nx">m</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span><span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dp</span> <span class="p">{</span>
		<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nx">n</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 初始化
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">m</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// 如果是障碍物, 后面的就都是0, 不用循环了
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">obstacleGrid</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]=</span><span class="mi">1</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">n</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">obstacleGrid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">i</span><span class="p">]=</span><span class="mi">1</span>
	<span class="p">}</span>
	<span class="c1">// dp数组推导过程
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">m</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span><span class="o">:=</span><span class="mi">1</span><span class="p">;</span><span class="nx">j</span><span class="p">&lt;</span><span class="nx">n</span><span class="p">;</span><span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="c1">// 如果obstacleGrid[i][j]这个点是障碍物, 那么我们的dp[i][j]保持为0
</span><span class="c1"></span>            <span class="k">if</span> <span class="nx">obstacleGrid</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span> <span class="p">{</span>
				<span class="c1">// 否则我们需要计算当前点可以到达的路径数
</span><span class="c1"></span>				<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span><span class="o">+</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// debug遍历dp
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span><span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dp</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span><span class="p">,</span><span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%.2v,&#34;</span><span class="p">,</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">])</span>
		<span class="p">}</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">m</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">obstacleGrid</span> <span class="o">:=</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">{{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">},{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">},{</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">},{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">}}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">uniquePathsWithObstacles</span><span class="p">(</span><span class="nx">obstacleGrid</span><span class="p">))</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go算法学习 动态规划 不同路径</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</link>
			<pubDate>Wed, 26 May 2021 17:17:21 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</guid>
			<description>show me the code package main import &amp;#34;fmt&amp;#34; //https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.md //62.不同路径 //题目链接：https://leetcode-cn.com/problems/unique-paths/ // //一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 // //机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 // //问总共有多少条不同的路径？ //输入：m = 3, n = 7 输出：28 // //示例 2： 输入：m = 2, n = 3 输出：3 解释： 从左上角开始，总共有 3 条路径可以到达右下角。 // //向右 -&amp;gt; 向右 -&amp;gt; 向下 //向右 -&amp;gt; 向下 -&amp;gt; 向右 //向下 -&amp;gt; 向右 -&amp;gt; 向右 //示例 3： 输入：m = 7, n = 3 输出：28 // //示例 4： 输入：m = 3, n = 3 输出：6 提示： // //1 &amp;lt;= m, n &amp;lt;= 100 //题目数据保证答案小于等于 2 * 10^9  // 动态规划五部曲 // 1.</description>
			<content type="html"><![CDATA[<h3 id="show-me-the-code">show me the code</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="c1">//https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.md
</span><span class="c1">//62.不同路径
</span><span class="c1">//题目链接：https://leetcode-cn.com/problems/unique-paths/
</span><span class="c1">//
</span><span class="c1">//一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
</span><span class="c1">//
</span><span class="c1">//机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
</span><span class="c1">//
</span><span class="c1">//问总共有多少条不同的路径？
</span><span class="c1">//输入：m = 3, n = 7 输出：28
</span><span class="c1">//
</span><span class="c1">//示例 2： 输入：m = 2, n = 3 输出：3 解释： 从左上角开始，总共有 3 条路径可以到达右下角。
</span><span class="c1">//
</span><span class="c1">//向右 -&gt; 向右 -&gt; 向下
</span><span class="c1">//向右 -&gt; 向下 -&gt; 向右
</span><span class="c1">//向下 -&gt; 向右 -&gt; 向右
</span><span class="c1">//示例 3： 输入：m = 7, n = 3 输出：28
</span><span class="c1">//
</span><span class="c1">//示例 4： 输入：m = 3, n = 3 输出：6   提示：
</span><span class="c1">//
</span><span class="c1">//1 &lt;= m, n &lt;= 100
</span><span class="c1">//题目数据保证答案小于等于 2 * 10^9
</span><span class="c1"></span>

<span class="c1">// 动态规划五部曲
</span><span class="c1">// 1. dp数组定义 dp[i][j]
</span><span class="c1">//  从左上角(0,0) 出发到达(i,j) 所有的不同路径: dp[i][j]
</span><span class="c1">// 2. dp推导公式
</span><span class="c1">//  显然  dp[i][j] 有两种情况可以到达
</span><span class="c1">//   1. dp[i][j-1] 向右走一步
</span><span class="c1">//   2. dp[i-1][j] 向下走一步
</span><span class="c1">//  dp[i][j] = dp[i][j-1] +  dp[i-1][j]
</span><span class="c1">// 3. dp数组初始化
</span><span class="c1">//  dp[0][0] = 1
</span><span class="c1">//  dp[0][1] = 1
</span><span class="c1">//  dp[1][0] = 1
</span><span class="c1">//  是这样吗? 错误哈!
</span><span class="c1">//  应该初始化第一排和第一列
</span><span class="c1">//  dp[0][0] = 1
</span><span class="c1">//  dp[0][i] = 1
</span><span class="c1">//  dp[i][0] = 1
</span><span class="c1">// 4. 顺序
</span><span class="c1">// 5. dp数组举例
</span><span class="c1">//  dp[0][0] = 1
</span><span class="c1">//  dp[0][1] = 1
</span><span class="c1">//  dp[1][0] = 1
</span><span class="c1">//  dp[1][1] = dp[0][1] + dp[1][0] = 2
</span><span class="c1">//  dp[1][2] = dp[1][1] + dp[0][2] = 3
</span><span class="c1">//
</span><span class="c1">//  01,01,01,01,01,01,01,
</span><span class="c1">//  01,02,03,04,05,06,07,
</span><span class="c1">//  01,03,06,10,15,21,28,
</span><span class="c1"></span>

<span class="kd">func</span> <span class="nf">uniquePaths</span><span class="p">(</span><span class="nx">m</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c1">// 定义dp数组
</span><span class="c1"></span>	<span class="c1">// 这里的m代表m行, n代表n列
</span><span class="c1"></span>	<span class="c1">// m =3, n = 7
</span><span class="c1"></span>	<span class="c1">// 二维数组如下:
</span><span class="c1"></span>	<span class="c1">//[0 0 0 0 0 0 0]
</span><span class="c1"></span>	<span class="c1">//[0 0 0 0 0 0 0]
</span><span class="c1"></span>	<span class="c1">//[0 0 0 0 0 0 0]
</span><span class="c1"></span>	<span class="c1">// 首先定义dp的行
</span><span class="c1"></span>	<span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span><span class="nx">m</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span><span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dp</span> <span class="p">{</span>
		<span class="c1">// 然后定义每个元素的长度, 也就是二维数组的宽
</span><span class="c1"></span>		<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nx">n</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 初始化dp, 初始化为如下:
</span><span class="c1"></span>	<span class="c1">// 二维数组如下:
</span><span class="c1"></span>	<span class="c1">//[1 1 1 1 1 1 1]
</span><span class="c1"></span>	<span class="c1">//[1 0 0 0 0 0 0]
</span><span class="c1"></span>	<span class="c1">//[1 0 0 0 0 0 0]
</span><span class="c1"></span>	<span class="c1">// 一开始初始化有问题, 只初始化了三个值
</span><span class="c1"></span>	<span class="c1">//dp[1][0] = 1
</span><span class="c1"></span>	<span class="c1">//dp[0][1] = 1
</span><span class="c1"></span>	<span class="c1">// 纠正后如下, 应该初始化第一排和第一列
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">m</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">n</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="p">}</span>
	<span class="c1">// 这里是dp推导过程
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span> <span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">m</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span><span class="o">:=</span><span class="mi">1</span><span class="p">;</span><span class="nx">j</span><span class="p">&lt;</span><span class="nx">n</span><span class="p">;</span><span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 遍历dp来debug哪里出现问题, 比如我开始初始化有问题, 通过dp打印就能发现
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span><span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dp</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span><span class="p">,</span><span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%.2v,&#34;</span><span class="p">,</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">])</span>
		<span class="p">}</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">m</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">uniquePaths</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">))</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go算法学习 二叉树 迭代统一遍历写法</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E4%BA%8C%E5%8F%89%E6%A0%91-%E8%BF%AD%E4%BB%A3%E7%BB%9F%E4%B8%80%E9%81%8D%E5%8E%86%E5%86%99%E6%B3%95/</link>
			<pubDate>Tue, 27 Apr 2021 11:21:41 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E4%BA%8C%E5%8F%89%E6%A0%91-%E8%BF%AD%E4%BB%A3%E7%BB%9F%E4%B8%80%E9%81%8D%E5%8E%86%E5%86%99%E6%B3%95/</guid>
			<description>说明 首先二叉树有三种遍历,针对根节点遍历顺序分别是 前序,中序, 后续
 前序: 中 左 右 中序: 左 中 右 后续: 左 右 中  遍历的写法分为两种:
 递归 迭代  二叉树结构体 type TreeNode struct { Val int Left *TreeNode Right *TreeNode } 1. 递归  递归比较简单, 代码如下:
  1.1 前序遍历 (中 左 右)  func preorderTraversal(root *TreeNode) []int { var result []int var Traversal func( *TreeNode) Traversal = func(node *TreeNode) { if node == nil { return } result = append(result, node.</description>
			<content type="html"><![CDATA[<h3 id="说明">说明</h3>
<p>首先二叉树有三种遍历,针对根节点遍历顺序分别是 前序,中序, 后续</p>
<ul>
<li>前序: 中 左 右</li>
<li>中序: 左 中 右</li>
<li>后续: 左 右 中</li>
</ul>
<p>遍历的写法分为两种:</p>
<ul>
<li>递归</li>
<li>迭代</li>
</ul>
<h3 id="二叉树结构体">二叉树结构体</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">TreeNode</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Val</span>   <span class="kt">int</span>
	<span class="nx">Left</span>  <span class="o">*</span><span class="nx">TreeNode</span>
	<span class="nx">Right</span> <span class="o">*</span><span class="nx">TreeNode</span>
<span class="p">}</span>

</code></pre></div><h3 id="1-递归">1. 递归</h3>
<blockquote>
<p>递归比较简单, 代码如下:</p>
</blockquote>
<ul>
<li>1.1 前序遍历 (中 左 右)</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">preorderTraversal</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">result</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="kd">var</span> <span class="nx">Traversal</span> <span class="kd">func</span><span class="p">(</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span>
	<span class="nx">Traversal</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">node</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">node</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span> <span class="c1">//1 中
</span><span class="c1"></span>		<span class="nf">Traversal</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>              <span class="c1">//2 左
</span><span class="c1"></span>		<span class="nf">Traversal</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>             <span class="c1">//3 右
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="nf">Traversal</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</code></pre></div><p><strong>根据1.1 前序遍历 很容易能写出中序遍历 和后序遍历</strong></p>
<hr>
<h3 id="2-迭代法">2. 迭代法</h3>
<blockquote>
<p>首先这里使用一般的迭代方法</p>
</blockquote>
<ul>
<li>2.1 前序遍历 (中 左 右)</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">preorderTraversal</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">result</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">result</span>
	<span class="p">}</span>
	<span class="nx">stack</span> <span class="o">:=</span> <span class="p">[]</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">{</span><span class="nx">root</span><span class="p">}</span>
    <span class="c1">// 迭代循环
</span><span class="c1"></span>	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="c1">// 处理当前节点
</span><span class="c1"></span>		<span class="nx">node</span> <span class="o">:=</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1">// 访问的节点就是 结果集的节点
</span><span class="c1"></span>		<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
        <span class="c1">// 先将右节点 入栈
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
		<span class="p">}</span>
        <span class="c1">// 再将左节点 入栈
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</code></pre></div><blockquote>
<p>前序遍历比较简单, 因为前序遍历的节点 就是结果集的节点, 如果是中序遍历呢?</p>
<p>由于中序遍历需要找的最左边的节点, 所以每次访问的节点并不是结果集的节点, 那应该怎么弄呢?</p>
</blockquote>
<ul>
<li>2.1 中序遍历 (左 中 右)</li>
</ul>
<blockquote>
<p>由于每次访问的节点并不是要处理的节点, 访问到左边最后一个节点才开始处理
因此需要将每次遇到的右节点保存到堆栈中</p>
</blockquote>
<blockquote>
<ol>
<li>
<p>第一步先找到最左边的节点,并且将访问的节点都存到堆栈中</p>
</li>
<li>
<p>当发现一家到最左边的节点(==nil) 时, 就需要从堆栈中取出最后一个节点(最左边的节点) ,遍历该节点, 并处理他的右节点</p>
</li>
<li>
<p>然后就拿着右节点 继续遍历 1 2步骤</p>
</li>
</ol>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">inorderTraversal</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">result</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">stack</span> <span class="p">[]</span><span class="o">*</span><span class="nx">TreeNode</span>
	<span class="nx">node</span> <span class="o">:=</span> <span class="nx">root</span>
	<span class="k">for</span> <span class="nx">node</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">node</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span>
			<span class="nx">node</span> <span class="p">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// 已经是最左边的节点了, 就可以推出栈元素了
</span><span class="c1"></span>			<span class="c1">// 栈最后一个元素, 就是左节点
</span><span class="c1"></span>			<span class="nx">node</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="c1">// 添加左节点的
</span><span class="c1"></span>			<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
			<span class="c1">// 再去遍历右节点
</span><span class="c1"></span>			<span class="nx">node</span> <span class="p">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>2.1 后序遍历 (左 右 中)</li>
</ul>
<blockquote>
<p>对比前序遍历 中 左 右 -&gt; 稍作修改为: 中 右 左, 然后倒序输出</p>
<ol>
<li>
<p>把根节点加入堆栈 , 弹出</p>
</li>
<li>
<p>每次判断先判断右边是否nil,然后判断左边是否nil, 把 右左 顺序加入堆栈, 左右顺序弹出</p>
</li>
</ol>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">postorderTraversal</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">result</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">result</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">stack</span> <span class="p">[]</span><span class="o">*</span><span class="nx">TreeNode</span>
	<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">root</span><span class="p">)</span>
	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">cur</span> <span class="o">:=</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">j</span><span class="p">;</span> <span class="p">{</span>
		<span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">result</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">result</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">i</span><span class="o">++</span>
		<span class="nx">j</span><span class="o">--</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</code></pre></div><hr>
<p>经过以上比较,我们发现<strong>递归写法比较统一,迭代写法很不统一,是否有统一的迭代写法呢?</strong></p>
<blockquote>
<p>参考文档</p>
</blockquote>
<ul>
<li><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/bang-ni-dui-er-cha-shu-bu-zai-mi-mang-che-di-chi-t/">来自leetcode 代码随想录 分享</a></li>
</ul>
<h3 id="3-迭代法-统一写法版本">3. 迭代法 统一写法版本</h3>
<ul>
<li>3.1 先序遍历 ( 中 左 右)</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 统一写法  先序遍历 ( 中 左 右)
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">preorderTraversal</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">result</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="nx">stack</span> <span class="o">:=</span> <span class="p">[]</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">{</span><span class="nx">root</span><span class="p">}</span>
	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// 先取一个节点来处理
</span><span class="c1"></span>		<span class="nx">node</span> <span class="o">:=</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="c1">// 判断是否用nil标记了
</span><span class="c1"></span>
		<span class="k">if</span> <span class="nx">node</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// 不是标记节点, 就处理该节点
</span><span class="c1"></span>			<span class="c1">// 怎么处理呢? 就是按照顺序加入到队列中
</span><span class="c1"></span>			<span class="c1">// 右节点入栈
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="c1">// 左节点入栈
</span><span class="c1"></span>
			<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="c1">// 中节点入栈
</span><span class="c1"></span>			<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span>
			<span class="c1">// 中节点以及处理,所以标记
</span><span class="c1"></span>			<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>

		<span class="p">}</span><span class="k">else</span> <span class="p">{</span><span class="c1">// 如果遇到nil,就弹出并加入结果集
</span><span class="c1"></span>			<span class="nx">node</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>3.2 中序遍历(左 中 右)</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 迭代的统一写法 , 中序遍历(左 中 右)
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">inorderTraversal11</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">result</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="nx">stack</span> <span class="o">:=</span>  <span class="p">[]</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">{</span><span class="nx">root</span><span class="p">}</span>
	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// 首先从队列取出一个接地
</span><span class="c1"></span>		<span class="nx">inorder</span> <span class="o">:=</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="c1">// 判断是否为 nil , 不是空说明没有处理过, 因为处理过的节点 紧跟着都加了 nil 标记
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">inorder</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// 如果右边不是 nil, 就加入到队列
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">inorder</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">inorder</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="c1">// 中间节点加入队列
</span><span class="c1"></span>			<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">inorder</span><span class="p">)</span>
			<span class="c1">// 中节点访问过，但是还没有处理，加入空节点做为标记。
</span><span class="c1"></span>			<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span><span class="kc">nil</span> <span class="p">)</span>
			<span class="c1">// 如果左边不是 nil, 就加入到队列
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">inorder</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">inorder</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span> <span class="c1">// 空节点, 说明 nil前面的节点是处理过的, 直接添加到 result即可
</span><span class="c1"></span>			<span class="nx">inorder</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="c1">// 结果集
</span><span class="c1"></span>			<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">inorder</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>

<span class="p">}</span>
</code></pre></div><ul>
<li>3.3 后序遍历( 左 右 中)</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 统一写法 后序遍历( 左 右 中)
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">postorderTraversal</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">result</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="nx">stack</span> <span class="o">:=</span> <span class="p">[]</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">{</span><span class="nx">root</span><span class="p">}</span>
	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">node</span> <span class="o">:=</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="k">if</span> <span class="nx">node</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// 中节点, nil用于标记
</span><span class="c1"></span>			<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">node</span><span class="p">,</span><span class="kc">nil</span> <span class="p">)</span>
			<span class="c1">// 右节点
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="c1">// 左节点
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span><span class="c1">// 遇到标记节点
</span><span class="c1"></span>			<span class="c1">// 在取一次, 标记节点前面的节点就是需要加入结果集的内容
</span><span class="c1"></span>			<span class="nx">node</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>

<span class="p">}</span>
</code></pre></div><hr>
<blockquote>
<p>参考文档</p>
</blockquote>
<ul>
<li><a href="https://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html">Morris Traversal方法遍历二叉树</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/101321696">神级遍历——morris</a></li>
</ul>
<h3 id="4-morris-遍历-o1空间复杂度">4. morris 遍历 (O(1)空间复杂度)</h3>
<ul>
<li>4.1 先序遍历</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// morris 前序遍历写法
</span><span class="c1">// 规则: (规则的目的主要是能找到回溯的路径)
</span><span class="c1">// 1. curr 无左孩子, 那么输出curr 并且右移 (curr = curr.right)
</span><span class="c1">// 2. curr 有左孩子, 那么记录左孩子的最右节点 mostright (所以这里是循环找)
</span><span class="c1">//   2.1 如果mostright.right == nil(找到最右节点), 那么就让他指向curr 并且curr 左移, mostright.right = curr (这就是回溯的路线),curr = curr.left
</span><span class="c1">//   2.2 如果mostright.right == curr(说明已经遍历过),那么就让他指向nil并且curr 右移,mostright.right = nil (还原二叉树),curr = curr.right
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">preorderTraversalMorris</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">curr</span> <span class="o">:=</span> <span class="nx">root</span>
	<span class="k">for</span> <span class="nx">curr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 1. 无左孩子
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Left</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">curr</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
			<span class="nx">curr</span> <span class="p">=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Right</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span>	<span class="c1">// 2. 有左孩子
</span><span class="c1"></span>			<span class="c1">// 先记录一个mostRight
</span><span class="c1"></span>			<span class="nx">mostRight</span> <span class="o">:=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Left</span>
			<span class="c1">// 一直循环找 curr.Left 的最右节点
</span><span class="c1"></span>			<span class="k">for</span> <span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="nx">curr</span> <span class="p">{</span>
				<span class="nx">mostRight</span> <span class="p">=</span> <span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span>
			<span class="p">}</span>
			<span class="c1">// 2.1 如果找到了
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">curr</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>		
				<span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="p">=</span> <span class="nx">curr</span>
				<span class="nx">curr</span> <span class="p">=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Left</span>
			<span class="p">}</span>
			<span class="c1">// 2.2 如果遍历过
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="o">==</span> <span class="nx">curr</span> <span class="p">{</span>
				<span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="p">=</span> <span class="kc">nil</span>
				<span class="nx">curr</span> <span class="p">=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Right</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div><ul>
<li>4.2 中序遍历</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// morris中序遍历
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">inorderTraversalMorris</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">curr</span> <span class="o">:=</span> <span class="nx">root</span>
	<span class="k">for</span> <span class="nx">curr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 1. 无左孩子
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Left</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">curr</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
			<span class="nx">curr</span> <span class="p">=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Right</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span>	<span class="c1">// 2. 有左孩子
</span><span class="c1"></span>			<span class="c1">// 先记录一个mostRight
</span><span class="c1"></span>			<span class="nx">mostRight</span> <span class="o">:=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Left</span>
			<span class="c1">// 一直循环找 curr.Left 的最右节点
</span><span class="c1"></span>			<span class="k">for</span> <span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="nx">curr</span> <span class="p">{</span>
				<span class="nx">mostRight</span> <span class="p">=</span> <span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span>
			<span class="p">}</span>
			<span class="c1">// 2.1 如果找到了
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="p">=</span> <span class="nx">curr</span>
				<span class="nx">curr</span> <span class="p">=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Left</span>
			<span class="p">}</span>
			<span class="c1">// 2.2 如果遍历过
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="o">==</span> <span class="nx">curr</span> <span class="p">{</span>
				<span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="p">=</span> <span class="kc">nil</span>
				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">curr</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span> <span class="c1">// 和前序遍历的区别, 在这里输出是因为已经遍历过左子树
</span><span class="c1"></span>				<span class="nx">curr</span> <span class="p">=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Right</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go算法学习 回溯 分割回文串</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%9B%9E%E6%BA%AF-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/</link>
			<pubDate>Fri, 23 Apr 2021 09:27:50 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%9B%9E%E6%BA%AF-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/</guid>
			<description>说明  纯暴力搜索, 通常可以抽象为N叉树, 树的深度就是递归的深度
  组合问题(不强调顺序) 1234 =&amp;gt; 12,13,14,23,24,34 切割问题(分割回文串) aab =&amp;gt; [a,a,b],[aa,b] 子集问题 排列问题(强调顺序) 1234 =&amp;gt; 12,13,14,21,23,24&amp;hellip; 棋盘问题(N皇后,数独)  回溯算法模板 func backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归  回溯，撤销处理结果 } } 参考文献  力扣题目: 77.组合 力扣题目: 39.组合总和 力扣题目: 131.分割回文串 代码随想录视频 回溯算法-理论（对应力扣题目：77.组合） 代码随想录视频 回溯算法-组合（对应力扣题目：77.组合） 代码随想录视频 回溯算法-组合剪枝（对应力扣题目：77.组合） 代码随想录视频 回溯算法-分割回文串（对应力扣题目：131.分割回文串） 代码随想录图文 回溯算法：分割回文串  例一 77. 组合 //77. 组合 //给定两个整数 n 和 k，返回 1 .</description>
			<content type="html"><![CDATA[<h3 id="说明">说明</h3>
<blockquote>
<p>纯暴力搜索, 通常可以抽象为N叉树, 树的深度就是递归的深度</p>
</blockquote>
<ul>
<li>组合问题(不强调顺序)   1234 =&gt;  12,13,14,23,24,34</li>
<li>切割问题(分割回文串)   aab  =&gt;  [a,a,b],[aa,b]</li>
<li>子集问题</li>
<li>排列问题(强调顺序)     1234 =&gt; 12,13,14,21,23,24&hellip;</li>
<li>棋盘问题(N皇后,数独)</li>
</ul>
<h3 id="回溯算法模板">回溯算法模板</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">backtracking</span><span class="p">(</span><span class="nx">参数</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">终止条件</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">存放结果</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="nx">选择</span><span class="err">：</span><span class="nx">本层集合中元素</span><span class="err">（</span><span class="nx">树中节点孩子的数量就是集合的大小</span><span class="err">）</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">处理节点</span><span class="p">;</span>
        <span class="nf">backtracking</span><span class="p">(</span><span class="nx">路径</span><span class="err">，</span><span class="nx">选择列表</span><span class="p">);</span> <span class="c1">// 递归
</span><span class="c1"></span>        <span class="nx">回溯</span><span class="err">，</span><span class="nx">撤销处理结果</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h3 id="参考文献">参考文献</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/combinations/">力扣题目: 77.组合</a></li>
<li><a href="https://leetcode-cn.com/problems/combination-sum/">力扣题目: 39.组合总和</a></li>
<li><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">力扣题目: 131.分割回文串</a></li>
<li><a href="https://www.bilibili.com/video/BV1cy4y167mM">代码随想录视频 回溯算法-理论（对应力扣题目：77.组合）</a></li>
<li><a href="https://www.bilibili.com/video/BV1ti4y1L7cv">代码随想录视频 回溯算法-组合（对应力扣题目：77.组合）</a></li>
<li><a href="https://www.bilibili.com/video/BV1wi4y157er/?spm_id_from=autoNext">代码随想录视频 回溯算法-组合剪枝（对应力扣题目：77.组合）</a></li>
<li><a href="https://www.bilibili.com/video/BV1c54y1e7k6">代码随想录视频 回溯算法-分割回文串（对应力扣题目：131.分割回文串）</a></li>
<li><a href="https://mp.weixin.qq.com/s/Pb1epUTbU8fHIht-g_MS5Q">代码随想录图文 回溯算法：分割回文串</a></li>
</ul>
<h3 id="例一-77-组合">例一 77. 组合</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">//77. 组合
</span><span class="c1">//给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。
</span><span class="c1">//
</span><span class="c1">//示例:
</span><span class="c1">//
</span><span class="c1">//输入: n = 4, k = 2
</span><span class="c1">//输出:
</span><span class="c1">//[
</span><span class="c1">//  [2,4],
</span><span class="c1">//  [3,4],
</span><span class="c1">//  [2,3],
</span><span class="c1">//  [1,2],
</span><span class="c1">//  [1,3],
</span><span class="c1">//  [1,4],
</span><span class="c1">//]
</span><span class="c1">//https://leetcode-cn.com/problems/combinations/
</span><span class="c1">// bilibili视频: https://www.bilibili.com/video/BV1ti4y1L7cv/?spm_id_from=autoNext
</span><span class="c1"></span>
<span class="c1">// 思路
</span><span class="c1">// 首先根据回溯算法的模板,这里n代表的就是横向的循环, k影响递归的深度
</span><span class="c1">// n = 4, k = 2
</span><span class="c1">//
</span><span class="c1">// 	  1       2     3   4
</span><span class="c1">//  2 3 4     3 4   4
</span><span class="c1">// 12|13|14 23|24   34
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">combine</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="nx">path</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>

	<span class="c1">// 1. 递归参数和返回值
</span><span class="c1"></span>	<span class="c1">// 2. 递归的终止条件
</span><span class="c1"></span>	<span class="c1">// 3. 单词递归的逻辑
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">backtracking</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
	<span class="nx">backtracking</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">startIndex</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">{</span>
		<span class="c1">// 递归的终止条件
</span><span class="c1"></span>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span> <span class="o">==</span> <span class="nx">k</span> <span class="p">{</span>
			<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nb">append</span><span class="p">([]</span><span class="kt">int</span><span class="p">{},</span><span class="nx">path</span><span class="o">...</span><span class="p">))</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span> <span class="nx">startIndex</span><span class="p">;</span><span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span> <span class="p">;</span><span class="nx">i</span> <span class="o">++</span> <span class="p">{</span>
			<span class="c1">// 寻找组合
</span><span class="c1"></span>			<span class="nx">path</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
			<span class="nf">backtracking</span><span class="p">(</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
			<span class="c1">// 回溯过程
</span><span class="c1"></span>			<span class="nx">path</span> <span class="p">=</span> <span class="nx">path</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">backtracking</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>


</code></pre></div><h3 id="例二-39组合总和">例二: 39.组合总和</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// 思路
</span><span class="c1">//  candidates = [2,3,5], target = 8,
</span><span class="c1">//    		  2     		  3	    	 5
</span><span class="c1">//   	2	  3 	5       3   5 		 5
</span><span class="c1">// 	  235     35    5       35  
</span><span class="c1">// 235 35 5  35 5   
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">combinationSum</span><span class="p">(</span><span class="nx">candidates</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">target</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="nx">path</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="nx">pathInt</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="kd">var</span> <span class="nx">backTracking</span> <span class="kd">func</span><span class="p">(</span><span class="nx">startIndex</span> <span class="kt">int</span><span class="p">)</span>
	<span class="c1">// 递归三部曲
</span><span class="c1"></span>	<span class="c1">// 1. 递归参数, 这里需要开始位置
</span><span class="c1"></span>	<span class="c1">// 2. 终止条件, path的结果和等于target, 或者大于
</span><span class="c1"></span>	<span class="c1">// 3. 单次递归逻辑, 往path里添加结果 , 只要小于target
</span><span class="c1"></span>	<span class="nx">backTracking</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">startIndex</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">pathInt</span> <span class="o">==</span> <span class="nx">target</span> <span class="p">{</span>
			<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nb">append</span><span class="p">([]</span><span class="kt">int</span><span class="p">{},</span><span class="nx">path</span><span class="o">...</span><span class="p">))</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="c1">// 超过target也需要返回, 但是不用保存数据
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">pathInt</span> <span class="p">&gt;</span> <span class="nx">target</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
        <span class="c1">// 可以遍历同一个数字, 但不使用startIndex 前面的值, 应该组合是不可重复的
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span> <span class="nx">startIndex</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">candidates</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>

			<span class="k">if</span> <span class="nx">pathInt</span> <span class="p">&lt;</span> <span class="nx">target</span> <span class="p">{</span>
				<span class="nx">pathInt</span> <span class="o">+=</span> <span class="nx">candidates</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
				<span class="nx">path</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">candidates</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">)</span>
			<span class="p">}</span>
			<span class="c1">// 可以无限使用同一个
</span><span class="c1"></span>			<span class="nf">backTracking</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
			<span class="c1">// 回溯
</span><span class="c1"></span>			<span class="nx">path</span> <span class="p">=</span> <span class="nx">path</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">pathInt</span> <span class="o">-=</span> <span class="nx">candidates</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">backTracking</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>


</code></pre></div><h3 id="例三-131分割回文串">例三: 131.分割回文串</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="c1">// 简单思路
</span><span class="c1">// 切割方式, 按照树的方式:
</span><span class="c1">// 横向→循环,  纵向↓递归
</span><span class="c1">//            		aab
</span><span class="c1">//      a/      	|aa   	\aab 		//第一次切割分成三个节点, a后切割,aa后切割,aab后切割 ,对应代码的 i=0,1,2,其中分割后的结果append到path切片中
</span><span class="c1">//    a/   \b    	|b    	(aab|)		//第二次切割分成四个节点, a|a|,(a|ab|),(aa|b|),(aab|)  带括号的已经是叶子节点,该情况结束,本次递归可以返回
</span><span class="c1">//   b|    (a|ab|) (aa|b|)				//第三次切割分成四个节点, (a|a|b|),(a|ab|),(aa|b|),(aab|)
</span><span class="c1">//  (a|a|b|)
</span><span class="c1">// 以上所有方案为四种切割方式: (a|a|b|) (a|ab|) (aa|b|) (aab|)
</span><span class="c1">// 代码部分需要注意, 在切割a|a|b| 之后需要回溯,想要回溯到 a|ab|,需将path中 a|a|b|的 后面(a|b|)删除, 当path=a,则可以继续切割出 (a|ab|)节点, 后续回溯同样
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">partition</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">result</span> <span class="p">[][]</span><span class="kt">string</span>
	<span class="c1">// 判断是否回文
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">isPalindrome</span> <span class="kd">func</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span>
	<span class="nx">isPalindrome</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">true</span>
		<span class="p">}</span>
		<span class="nx">head</span><span class="p">,</span> <span class="nx">tail</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
		<span class="k">for</span> <span class="nx">head</span> <span class="p">&lt;</span> <span class="nx">tail</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">s</span><span class="p">[</span><span class="nx">head</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">tail</span><span class="p">]</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">false</span>
			<span class="p">}</span>
			<span class="nx">head</span><span class="o">++</span>
			<span class="nx">tail</span><span class="o">--</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">backtracking</span> <span class="kd">func</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">startIndex</span> <span class="kt">int</span><span class="p">)</span>
	<span class="c1">//startIndex 就是切割的位置
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">path</span> <span class="p">[]</span><span class="kt">string</span>
	<span class="nx">backtracking</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">startIndex</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">startIndex</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// 为什么要这样添加, 是因为path这个函数外slice 会最终被修改,导致最后append是相同的数据
</span><span class="c1"></span>			<span class="c1">//var newPath []string
</span><span class="c1"></span>			<span class="c1">//newPath = append(newPath,path...)
</span><span class="c1"></span>			<span class="c1">//result = append(result, newPath)
</span><span class="c1"></span>			<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nb">append</span><span class="p">([]</span><span class="nb">string</span><span class="p">(</span><span class="kc">nil</span><span class="p">),</span> <span class="nx">path</span><span class="o">...</span><span class="p">))</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">startIndex</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="c1">// 假如这里startIndex = 0 , 切割到第一个a后面
</span><span class="c1"></span>			<span class="c1">// i=1 [startIndex:i+1] = [0:1] = a 是回文
</span><span class="c1"></span>			<span class="c1">// i=2 [startIndex:i+1] = [1:2] = a 是回文
</span><span class="c1"></span>			<span class="c1">// i=3 [startIndex:i+1] = [2:3] = b 是回文
</span><span class="c1"></span>			<span class="c1">//fmt.Println(s[startIndex:i+1])
</span><span class="c1"></span>			<span class="k">if</span> <span class="nf">isPalindrome</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">startIndex</span> <span class="p">:</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
				<span class="nx">path</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">s</span><span class="p">[</span><span class="nx">startIndex</span><span class="p">:</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
				<span class="c1">//fmt.Println(&#34;backtracking前&#34;,startIndex,s[startIndex:i+1],path)
</span><span class="c1"></span>
				<span class="c1">// 寻找 i =1 的切割点
</span><span class="c1"></span>				<span class="nf">backtracking</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

				<span class="c1">// 回溯  重要!!!
</span><span class="c1"></span>				<span class="c1">// 每次 backtracking 函数执行返回的时候就是 startIndex == len(s)的时候, 也就是结果path已经添加到result中了
</span><span class="c1"></span>				<span class="c1">// 由于在isPalindrome 中, 所以前面path append了几次, backtracking函数退出的时候这里就会删除几次
</span><span class="c1"></span>				<span class="c1">// 因为是回溯, 当然是要每次删除一个尾部内容
</span><span class="c1"></span>				<span class="nx">path</span> <span class="p">=</span> <span class="nx">path</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
				<span class="c1">//fmt.Println(&#34;backtracking后&#34;,startIndex,s[startIndex:i+1],path)
</span><span class="c1"></span>			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">backtracking</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">partition</span><span class="p">(</span><span class="s">&#34;aab&#34;</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">partition</span><span class="p">(</span><span class="s">&#34;cdadad&#34;</span><span class="p">))</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go算法学习 辗转相除法</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95/</link>
			<pubDate>Fri, 16 Apr 2021 15:56:59 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95/</guid>
			<description></description>
			<content type="html"><![CDATA[<p>原文: <a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653189913&amp;idx=1&amp;sn=8667ba0170aef9b6c34713ce8cea60a8&amp;chksm=8c9905c3bbee8cd56d079bb0a436a46a18eb43061bc9390483f6cca692760f01cb575241ffff&amp;scene=21#wechat_redirect">程序员小灰 辗转相除法 更相减损术</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="c1">// 求最大公约数, 两个数都能整除的最大整数
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">MaxMin</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">a</span>
<span class="p">}</span>

<span class="c1">// 1. 暴力 O(min(a,b))
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">getGreatestCommonDivisor</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">max</span><span class="p">,</span> <span class="nx">min</span> <span class="o">:=</span> <span class="nf">MaxMin</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">max</span><span class="o">%</span><span class="nx">min</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">min</span>
	<span class="p">}</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="nx">min</span>
	<span class="k">for</span> <span class="nx">a</span><span class="o">%</span><span class="nx">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">b</span><span class="o">%</span><span class="nx">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">i</span><span class="o">--</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">i</span>
<span class="p">}</span>

<span class="c1">// 2. 辗转相除法 O(log(max(a,b)))
</span><span class="c1">// 两个数的最大公约数 = 大数对小数取余结果 和小数 的最大公约数
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">getGreatestCommonDivisor2</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nf">MaxMin</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
	<span class="c1">//取余
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">m</span><span class="o">%</span><span class="nx">n</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">m</span><span class="p">,</span> <span class="nx">n</span> <span class="p">=</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">m</span><span class="o">%</span><span class="nx">n</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">n</span>
<span class="p">}</span>

<span class="c1">// 3. 更相减损术(出自算术九章) O(max(a,b))
</span><span class="c1">// 两个数的最大公约数 = 大数减小数结果 和小数的最大公约数
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">getGreatestCommonDivisor3</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nf">MaxMin</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">m</span><span class="o">!=</span><span class="nx">n</span>  <span class="p">{</span>
		<span class="nx">m</span><span class="p">,</span> <span class="nx">n</span> <span class="p">=</span> <span class="nf">MaxMin</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">m</span><span class="o">-</span><span class="nx">n</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">n</span>
<span class="p">}</span>

<span class="c1">// 4. 更相减损术+移位操作
</span><span class="c1">// gcb(a,b)代表 a,b的最大公约数
</span><span class="c1">// 4.1 a,b都是偶数: 	gcb(a,b) = 2 * gcb(a/2,b/2)	= 2 * gcb(a&gt;&gt;1,b&gt;&gt;1)
</span><span class="c1">// 4.2 a,b是奇偶: 	gcb(a,b) = gcb(a,b/2)		= gcb(a,b&gt;&gt;1)
</span><span class="c1">// 4.3 a,b是偶奇: 	gcb(a,b) = 2 * gcb(a/2,b)	= gcb(a&gt;&gt;1,b)
</span><span class="c1">// 4.4 a,b都是奇数: 	gcb(a,b) = gcb((a-b)/2,b)	= gcb((a-b)&gt;&gt;1,b)  因为a-b必然是偶数
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">getGreatestCommonDivisor4</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nf">MaxMin</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">gcb</span> <span class="kd">func</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
	<span class="nx">gcb</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">m</span> <span class="o">==</span> <span class="nx">n</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">n</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">m</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// 偶 偶
</span><span class="c1"></span>				<span class="k">return</span> <span class="nf">gcb</span><span class="p">(</span><span class="nx">m</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">,</span><span class="nx">n</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">m</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// 奇 偶
</span><span class="c1"></span>				<span class="k">return</span> <span class="nf">gcb</span><span class="p">(</span><span class="nf">MaxMin</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span><span class="nx">n</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">))</span>
			<span class="p">}</span><span class="k">else</span> <span class="k">if</span> <span class="nx">m</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>	<span class="c1">// 偶 奇
</span><span class="c1"></span>				<span class="k">return</span> <span class="nf">gcb</span><span class="p">(</span><span class="nf">MaxMin</span><span class="p">(</span><span class="nx">m</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">,</span><span class="nx">n</span><span class="p">))</span>
			<span class="p">}</span><span class="k">else</span> <span class="p">{</span>	<span class="c1">// 奇 奇
</span><span class="c1"></span>				<span class="k">return</span> <span class="nf">gcb</span><span class="p">(</span><span class="nf">MaxMin</span><span class="p">((</span><span class="nx">m</span><span class="o">-</span><span class="nx">n</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">,</span><span class="nx">n</span><span class="p">))</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">n</span> <span class="p">=</span> <span class="nf">gcb</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span><span class="nx">n</span> <span class="p">)</span>
	<span class="k">return</span> <span class="nx">n</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">getGreatestCommonDivisor</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">768</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">getGreatestCommonDivisor2</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">768</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">getGreatestCommonDivisor3</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">248</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">getGreatestCommonDivisor4</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">248</span><span class="p">))</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go算法学习 最小栈的实现</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%9C%80%E5%B0%8F%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
			<pubDate>Fri, 16 Apr 2021 10:09:37 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%9C%80%E5%B0%8F%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
			<description></description>
			<content type="html"><![CDATA[<p>原文: <a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653190073&amp;idx=1&amp;sn=c20c002127e2ce3fe0c71a00aee70806&amp;chksm=8c990563bbee8c75521c54ea8eb44b009ad07266b1e5fbf22926baf9a7b7302c7e4f7657dbb8&amp;scene=21#wechat_redirect">程序员小灰 最小栈的实现</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>


<span class="c1">//题目：实现一个栈，带有出栈（pop），入栈（push），取最小元素（getMin）三个方法。要保证这三个方法的时间复杂度都是O（1）。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">stack</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">V</span> <span class="p">[]</span><span class="kt">int</span>	<span class="c1">// 栈存储
</span><span class="c1"></span>	<span class="nx">Min</span> <span class="p">[]</span><span class="kt">int</span>	<span class="c1">//栈最小值下标存储
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// 入栈
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">stack</span><span class="p">)</span> <span class="nf">Pop</span><span class="p">(</span><span class="nx">a</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 入栈
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nx">V</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
	<span class="c1">// 判断min是否为空
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">Min</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 如果比最小栈 栈顶值小, 就入栈
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">a</span> <span class="p">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">[</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">Min</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 出栈
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">stack</span><span class="p">)</span> <span class="nf">Push</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c1">// 出栈
</span><span class="c1"></span>	<span class="nx">a1</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="c1">// 如果出栈的下标等于最小栈栈顶的值,就删除最小栈栈顶
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">Min</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="c1">// 在删除栈顶
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nx">V</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

	<span class="k">return</span> <span class="nx">a1</span>
<span class="p">}</span>

<span class="c1">//新建堆
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewStack</span><span class="p">(</span><span class="nx">l</span> <span class="o">...</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">stack</span><span class="p">{</span>
	<span class="nx">stack1</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">stack</span><span class="p">{}</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">l</span> <span class="p">{</span>
		<span class="nx">stack1</span><span class="p">.</span><span class="nf">Pop</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">stack1</span>
<span class="p">}</span>

<span class="c1">// 查询最小值
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">stack</span><span class="p">)</span> <span class="nf">GetMin</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">min</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">Min</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="k">return</span> <span class="nx">min</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">stack1</span> <span class="o">:=</span> <span class="nf">NewStack</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">14</span><span class="p">}</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">stack1</span><span class="p">.</span><span class="nf">Pop</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">stack1</span><span class="p">)</span>
	<span class="nx">stack1</span><span class="p">.</span><span class="nf">Pop</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">stack1</span><span class="p">)</span>
	<span class="nx">stack1</span><span class="p">.</span><span class="nf">Pop</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">stack1</span><span class="p">)</span>
	<span class="nx">stack1</span><span class="p">.</span><span class="nf">Push</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">stack1</span><span class="p">)</span>

<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go算法学习 找出缺失的整数</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%89%BE%E5%87%BA%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B4%E6%95%B0/</link>
			<pubDate>Thu, 15 Apr 2021 18:09:46 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%89%BE%E5%87%BA%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B4%E6%95%B0/</guid>
			<description>原文: 程序员小灰 找出缺失的整数
实现代码 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;math/rand&amp;#34; &amp;#34;time&amp;#34; ) var ( a []int b []int c []int l = 100 r = rand.New(rand.NewSource(time.Now().UnixNano())) ) func init() { // 1~10 随机数 	tmp := r.Intn(l-1)+1 // 在生成一个不等于tmp的随机数 	var tmp2 int for tmp2 == 0 || tmp2 == tmp { tmp2 = r.Intn(l-1)+1 } fmt.Println(tmp,tmp2) for i:=1 ;i &amp;lt;=l;i++ { if i == tmp { b = append(b, i) continue } a = append(a, i) b = append(b, i) b = append(b, i) } for i:=1 ;i &amp;lt;=l;i++ { if i == tmp ||i == tmp2 { c = append(c,i) continue } c = append(c,i) c = append(c,i) } //fmt.</description>
			<content type="html"><![CDATA[<p>原文: <a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653189951&amp;idx=1&amp;sn=0181c95484b67d108672235b14e5ebbb&amp;chksm=8c9905e5bbee8cf3362ccc4c7e091caa18b5783183ce4475b6f011c09c1cb03847ea4cb5220c&amp;scene=21#wechat_redirect">程序员小灰 找出缺失的整数</a></p>
<h3 id="实现代码">实现代码</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;math/rand&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">a</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="nx">b</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="nx">c</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="nx">l</span> <span class="p">=</span> <span class="mi">100</span>
	<span class="nx">r</span> <span class="p">=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nf">NewSource</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UnixNano</span><span class="p">()))</span>

<span class="p">)</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 1~10 随机数
</span><span class="c1"></span>	<span class="nx">tmp</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="nx">l</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
	<span class="c1">// 在生成一个不等于tmp的随机数
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">tmp2</span> <span class="kt">int</span>
	<span class="k">for</span> <span class="nx">tmp2</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">tmp2</span> <span class="o">==</span> <span class="nx">tmp</span> <span class="p">{</span>
		<span class="nx">tmp2</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="nx">l</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
	<span class="p">}</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">tmp</span><span class="p">,</span><span class="nx">tmp2</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">1</span> <span class="p">;</span><span class="nx">i</span> <span class="o">&lt;=</span><span class="nx">l</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="nx">tmp</span> <span class="p">{</span>
			<span class="nx">b</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">a</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
		<span class="nx">b</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
		<span class="nx">b</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>

	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">1</span> <span class="p">;</span><span class="nx">i</span> <span class="o">&lt;=</span><span class="nx">l</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="nx">tmp</span> <span class="o">||</span><span class="nx">i</span> <span class="o">==</span> <span class="nx">tmp2</span>  <span class="p">{</span>
			<span class="nx">c</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">c</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span>
		<span class="nx">c</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">//fmt.Println(&#34;&gt;&gt;&gt; 有序数组&#34;)
</span><span class="c1"></span>	<span class="c1">//fmt.Println(a)
</span><span class="c1"></span>	<span class="c1">//fmt.Println(b)
</span><span class="c1"></span>	<span class="c1">//fmt.Println(c)
</span><span class="c1"></span>	<span class="nf">random</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
	<span class="nf">random</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
	<span class="nf">random</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
	<span class="c1">//fmt.Println(&#34;&gt;&gt;&gt; 无序数组&#34;)
</span><span class="c1"></span>	<span class="c1">//fmt.Println(a)
</span><span class="c1"></span>	<span class="c1">//fmt.Println(b)
</span><span class="c1"></span>	<span class="c1">//fmt.Println(c)
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// 随机打乱字符串算法
</span><span class="c1">//Fisher-Yates随机置乱算法
</span><span class="c1">//也称高纳德置乱算法
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">random</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)&gt;</span><span class="mi">0</span> <span class="p">{</span>
		<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>
		<span class="nx">tmp</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
		<span class="nx">nums</span><span class="p">[</span><span class="nx">tmp</span><span class="p">]</span> <span class="p">,</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">tmp</span><span class="p">]</span>
		<span class="c1">//对前n-1进行替换
</span><span class="c1"></span>		<span class="nx">nums</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[:</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">//题目：一个无序数组里有99个不重复正整数，范围从1到100，唯独缺少一个整数。如何找出这个缺失的整数？
</span><span class="c1"></span><span class="kd">func</span>  <span class="nf">findInt1</span><span class="p">(</span><span class="nx">a</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">)</span> <span class="kt">int</span>  <span class="p">{</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span> <span class="mi">0</span> <span class="p">;</span><span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">l</span><span class="o">-</span><span class="mi">1</span> <span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">sum</span><span class="o">+=</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="nx">l</span><span class="p">)</span><span class="o">*</span><span class="nx">l</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="nx">sum</span>
<span class="p">}</span>

<span class="c1">//题目扩展：一个无序数组里有若干个正整数，范围从1到100，其中99个整数都出现了偶数次，
</span><span class="c1">//只有一个整数出现了奇数次（比如1,1,2,2,3,3,4,5,5），如何找到这个出现奇数次的整数？
</span><span class="c1">// 思路: 所有的数做 异或
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">findInt2</span><span class="p">(</span><span class="nx">a</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">rst</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span> <span class="mi">1</span> <span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
		<span class="nx">rst</span> <span class="p">^=</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">rst</span>
<span class="p">}</span>

<span class="c1">//题目第二次扩展：一个无序数组里有若干个正整数，范围从1到100，其中98个整数都出现了偶数次，
</span><span class="c1">//只有两个整数出现了奇数次（比如1,1,2,2,3,4,5,5），如何找到这个出现奇数次的整数？
</span><span class="c1">// 思路:
</span><span class="c1">// 1. 先对所有数异或, 异或的结果就是两个奇数的异或结果, 这个数二进制位必定有一位是1
</span><span class="c1">// 2. 按异或结果其中一个1的位置, 将无序数组分成两个数组
</span><span class="c1">//
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">findInt3</span><span class="p">(</span><span class="nx">a</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">a1</span> <span class="o">:=</span> <span class="nf">findInt2</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
	<span class="c1">//fmt.Println(a1)
</span><span class="c1"></span>	<span class="nx">m</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">a1</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">a1</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
		<span class="nx">m</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="c1">//fmt.Println(m)
</span><span class="c1"></span>	<span class="nx">odd</span><span class="p">,</span><span class="nx">even</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// 说明该位 是1
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="nx">m</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
			<span class="nx">odd</span> <span class="p">^=</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
			<span class="nx">even</span> <span class="p">^=</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">odd</span><span class="p">,</span><span class="nx">even</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">findInt1</span><span class="p">(</span><span class="nx">a</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">findInt2</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">findInt3</span><span class="p">(</span><span class="nx">c</span><span class="p">))</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go学习 Goroutine泄露</title>
			<link>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-goroutine%E6%B3%84%E9%9C%B2/</link>
			<pubDate>Thu, 25 Feb 2021 10:43:52 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-goroutine%E6%B3%84%E9%9C%B2/</guid>
			<description>&lt;p&gt;goroutine 泄露常见说明&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>goroutine 泄露常见说明</p>
<blockquote>
<p>参考文档</p>
</blockquote>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/74090074">Go 笔记之如何防止 goroutine 泄露</a></li>
<li><a href="https://juejin.cn/post/6844903901410361358">Go 笔记之如何防止 goroutine 泄露（二）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/68921032">Go 译文之如何构建并发 Pipeline</a></li>
</ul>
<h3 id="泄露情况分类">泄露情况分类</h3>
<ul>
<li>
<ol>
<li>死循环导致goroutine 无法退出</li>
</ol>
</li>
<li>
<ol start="2">
<li>channel泄露</li>
</ol>
<ul>
<li>发送无接收</li>
<li>接收无发送</li>
<li>nil channel 发送和接收都会阻塞, 通过select方式, nil channel不会被select</li>
</ul>
</li>
<li>
<ol start="3">
<li>传统同步机制</li>
</ol>
<ul>
<li>sync.Mutex 使用未释放, 建议Lock 后执行defer  Unlock</li>
<li>sync.WaitGroup 设置的任务数错误导致一直 wait阻塞, 建议每次wg.Add(1)</li>
</ul>
</li>
</ul>
<h3 id="简单实例">简单实例</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="kd">func</span> <span class="nf">Test4</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
	<span class="nx">count</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">())</span>
	<span class="nx">timeout</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">{</span>
            <span class="k">select</span> <span class="p">{</span>
        	<span class="k">case</span> <span class="nx">c</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}:</span>
        		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
        	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
        		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;停止写入 ... &#34;</span><span class="p">)</span>
        		<span class="k">return</span>
        	<span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}()</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">c</span><span class="p">:</span>
			<span class="nx">count</span><span class="o">++</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">timeout</span><span class="p">:</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;timeout ... &#34;</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="mi">50</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">count</span> <span class="p">&gt;</span> <span class="mi">3</span> <span class="p">{</span>
				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;已经写入三次, 准备停止...&#34;</span><span class="p">)</span>
				<span class="nf">cancel</span><span class="p">()</span>
				<span class="k">return</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div><h3 id="自动化测试泄露">自动化测试泄露</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">TestTest4</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">//defer goleak.VerifyNone(t)
</span><span class="c1"></span>	<span class="k">defer</span> <span class="nx">leaktest</span><span class="p">.</span><span class="nf">Check</span><span class="p">(</span><span class="nx">t</span><span class="p">)()</span>
	<span class="nf">Test4</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><h3 id="通过-runtimenumgoroutine-函数计数">通过 runtime.NumGoroutine() 函数计数</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;runtime.NumGoroutine : &#34;</span><span class="p">,</span><span class="nx">runtime</span><span class="p">.</span><span class="nf">NumGoroutine</span><span class="p">())</span>
			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="mi">500</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">test1</span><span class="p">.</span><span class="nf">Test3</span><span class="p">()</span>
	<span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go源码学习 Sort包Search方法</title>
			<link>https://www.ngirl.xyz/golang/go%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-sort%E5%8C%85search%E6%96%B9%E6%B3%95/</link>
			<pubDate>Mon, 25 Jan 2021 14:54:22 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-sort%E5%8C%85search%E6%96%B9%E6%B3%95/</guid>
			<description>&lt;p&gt;Sort包Search方法的实践说明&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>Sort包Search方法的实践说明</p>
<h3 id="首先查看示例">首先查看示例</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;sort&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">data</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span>
	<span class="nx">sort</span><span class="p">.</span><span class="nf">Ints</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
	<span class="c1">// Search 会查询已排序数列 满足条件的最小索引
</span><span class="c1"></span>	<span class="nx">i</span> <span class="o">:=</span> <span class="nx">sort</span><span class="p">.</span><span class="nf">Search</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">),</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;当前查询的index: %v, 查询的结果data[%v]: %v&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="c1">// 因为该列表已经排序, 满足二分条件(即左边全部小于右边)
</span><span class="c1"></span>		<span class="c1">// 当满足条件的时候, 向前查询
</span><span class="c1"></span>		<span class="c1">// 只要满足条件, 前面就可能还有更小的满足条件的值
</span><span class="c1"></span>		<span class="k">return</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">23</span>
	<span class="p">})</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;最终的结果为&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="c1">// 1
</span><span class="c1"></span><span class="p">}</span>

</code></pre></div><h3 id="sort的search源码">sort的Search源码</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Search</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c1">// Define f(-1) == false and f(n) == true.
</span><span class="c1"></span>	<span class="c1">// Invariant: f(i-1) == false, f(j) == true.
</span><span class="c1"></span>	<span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">n</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">j</span> <span class="p">{</span>
		<span class="c1">// 这里左移 实现二分 h = (i+j) / 2
</span><span class="c1"></span>		<span class="nx">h</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">uint</span><span class="p">(</span><span class="nx">i</span><span class="o">+</span><span class="nx">j</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// avoid overflow when computing h
</span><span class="c1"></span>		<span class="c1">// i ≤ h &lt; j
</span><span class="c1"></span>		<span class="c1">// 如果f(h) 为false, 那么就执行 i = h + 1 , 查看 中间位置的下一个值, 向后查询
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nf">f</span><span class="p">(</span><span class="nx">h</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">i</span> <span class="p">=</span> <span class="nx">h</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// preserves f(i-1) == false
</span><span class="c1"></span>		<span class="c1">// 否则f(h) 为true , 那么执行 j = h , 查询的区间由 (i,n) 变成 (i,h) , 向前查询
</span><span class="c1"></span>		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">j</span> <span class="p">=</span> <span class="nx">h</span> <span class="c1">// preserves f(j) == true
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// i == j, f(i-1) == false, and f(j) (= f(i)) == true  =&gt;  answer is i.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">i</span>
<span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go学习 并发的实现原理</title>
			<link>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-%E5%B9%B6%E5%8F%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
			<pubDate>Thu, 14 Jan 2021 17:49:48 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-%E5%B9%B6%E5%8F%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
			<description>&lt;p&gt;go&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>go</p>
<ul>
<li><a href="https://studygolang.com/articles/22390?fr=sidebar">【深度知识】GO语言的goroutine并发原理和调度机制</a></li>
</ul>
<h3 id="go并发的模型">go并发的模型</h3>
<ul>
<li>多线程共享内存</li>
<li>CSP(communicating sequential processes)   - 以通信的方式来共享内存</li>
</ul>
<h3 id="go的csp并发模型是通过goroutine和channel来实现的">Go的CSP并发模型，是通过goroutine和channel来实现的。</h3>
<ul>
<li>goroutine 是Go语言中并发的执行单位。有点抽象，其实就是和传统概念上的&quot;线程“类似，可以理解为&quot;线程“。</li>
<li>channel是Go语言中各个并发结构体(goroutine)之前的通信机制。 通俗的讲，就是各个goroutine之间通信的&quot;管道“，有点类似于Linux中的管道。</li>
</ul>
<h3 id="go线程实现模型mpg">Go线程实现模型MPG</h3>
<ul>
<li>M指的是Machine，一个M直接关联了一个内核线程。由操作系统管理。</li>
<li>P指的是&quot;processor&quot;，代表了M所需的上下文环境，也是处理用户级代码逻辑的处理器。它负责衔接M和G的调度上下文，将等待执行的G与M对接。</li>
<li>G指的是Goroutine，其实本质上也是一种轻量级的线程。包括了调用栈，重要的调度信息，例如channel等。</li>
</ul>
<p><img src="/assets/markdown-img-paste-20210114180539724.png" alt=""></p>
<h3 id="goroutine-小结">Goroutine 小结</h3>
<h4 id="优点">优点：</h4>
<ul>
<li>
<p>1、开销小
POSIX的thread API虽然能够提供丰富的API，例如配置自己的CPU亲和性，申请资源等等，线程在得到了很多与进程相同的控制权的同时，开销也非常的大，在Goroutine中则不需这些额外的开销，所以一个Golang的程序中可以支持10w级别的Goroutine。
每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少（goroutine：2KB ，线程：8MB）</p>
</li>
<li>
<p>2、调度性能好
在Golang的程序中，操作系统级别的线程调度，通常不会做出合适的调度决策。例如在GC时，内存必须要达到一个一致的状态。在Goroutine机制里，Golang可以控制Goroutine的调度，从而在一个合适的时间进行GC。
在应用层模拟的线程，它避免了上下文切换的额外耗费，兼顾了多线程的优点。简化了高并发程序的复杂度。</p>
</li>
</ul>
<h4 id="缺点">缺点：</h4>
<p>协程调度机制无法实现公平调度。</p>]]></content>
		</item>
		
		<item>
			<title>Gee学习-路由trie测试编写</title>
			<link>https://www.ngirl.xyz/golang/gee%E5%AD%A6%E4%B9%A0-%E8%B7%AF%E7%94%B1trie%E6%B5%8B%E8%AF%95%E7%BC%96%E5%86%99/</link>
			<pubDate>Thu, 14 Jan 2021 11:32:54 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/gee%E5%AD%A6%E4%B9%A0-%E8%B7%AF%E7%94%B1trie%E6%B5%8B%E8%AF%95%E7%BC%96%E5%86%99/</guid>
			<description>github地址: github.com/zhangzw001/learnGee
 路由分析测试 package gee import ( &amp;#34;reflect&amp;#34; &amp;#34;testing&amp;#34; ) func TestParsePattern(t *testing.T) { tests := []struct { patterns string parts []string ok bool }{ {&amp;#34;/test/v1/add&amp;#34;, []string{&amp;#34;test&amp;#34;, &amp;#34;v1&amp;#34;, &amp;#34;add&amp;#34;},true }, {&amp;#34;/test/*name/add&amp;#34;, []string{&amp;#34;test&amp;#34;, &amp;#34;*name&amp;#34;},true}, {&amp;#34;/test/:name&amp;#34;, []string{&amp;#34;test&amp;#34;, &amp;#34;:name&amp;#34;},true }, {&amp;#34;/test/:name/abc&amp;#34;, []string{&amp;#34;test&amp;#34;, &amp;#34;:name&amp;#34;, &amp;#34;abc&amp;#34;},true}, {&amp;#34;/test/v1/add&amp;#34;, []string{&amp;#34;testv1&amp;#34;, &amp;#34;add&amp;#34;},false }, {&amp;#34;/test/*name/add&amp;#34;, []string{&amp;#34;test&amp;#34;, &amp;#34;*name&amp;#34;,&amp;#34;add&amp;#34;},false}, {&amp;#34;/test/:name&amp;#34;, []string{&amp;#34;test&amp;#34;, &amp;#34;:&amp;#34;,&amp;#34;name&amp;#34;},false }, {&amp;#34;/test/:name/abc&amp;#34;, []string{&amp;#34;test&amp;#34;, &amp;#34;:name&amp;#34;},false}, } m := make(map[string][]string) for _, test := range tests { m[test.patterns] = test.parts p := parsePattern(test.</description>
			<content type="html"><![CDATA[<p>github地址: <a href="github.com/zhangzw001/learnGee">github.com/zhangzw001/learnGee</a></p>
<hr>
<h3 id="路由分析测试">路由分析测试</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">gee</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;reflect&#34;</span>
	<span class="s">&#34;testing&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">TestParsePattern</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">tests</span> <span class="o">:=</span> <span class="p">[]</span><span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">patterns</span> <span class="kt">string</span>
		<span class="nx">parts</span>    <span class="p">[]</span><span class="kt">string</span>
		<span class="nx">ok</span> <span class="kt">bool</span>
	<span class="p">}{</span>
		<span class="p">{</span><span class="s">&#34;/test/v1/add&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="s">&#34;v1&#34;</span><span class="p">,</span> <span class="s">&#34;add&#34;</span><span class="p">},</span><span class="kc">true</span> <span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;/test/*name/add&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="s">&#34;*name&#34;</span><span class="p">},</span><span class="kc">true</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;/test/:name&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="s">&#34;:name&#34;</span><span class="p">},</span><span class="kc">true</span> <span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;/test/:name/abc&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="s">&#34;:name&#34;</span><span class="p">,</span> <span class="s">&#34;abc&#34;</span><span class="p">},</span><span class="kc">true</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;/test/v1/add&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;testv1&#34;</span><span class="p">,</span> <span class="s">&#34;add&#34;</span><span class="p">},</span><span class="kc">false</span> <span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;/test/*name/add&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="s">&#34;*name&#34;</span><span class="p">,</span><span class="s">&#34;add&#34;</span><span class="p">},</span><span class="kc">false</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;/test/:name&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="s">&#34;:&#34;</span><span class="p">,</span><span class="s">&#34;name&#34;</span><span class="p">},</span><span class="kc">false</span> <span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;/test/:name/abc&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="s">&#34;:name&#34;</span><span class="p">},</span><span class="kc">false</span><span class="p">},</span>
	<span class="p">}</span>

	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">test</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tests</span> <span class="p">{</span>
		<span class="nx">m</span><span class="p">[</span><span class="nx">test</span><span class="p">.</span><span class="nx">patterns</span><span class="p">]</span> <span class="p">=</span> <span class="nx">test</span><span class="p">.</span><span class="nx">parts</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nf">parsePattern</span><span class="p">(</span><span class="nx">test</span><span class="p">.</span><span class="nx">patterns</span><span class="p">)</span>

		<span class="k">if</span> <span class="nx">test</span><span class="p">.</span><span class="nx">ok</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">DeepEqual</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">m</span><span class="p">[</span><span class="nx">test</span><span class="p">.</span><span class="nx">patterns</span><span class="p">])</span> <span class="p">{</span>
				<span class="nx">t</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;expect %v, but actual %v\n&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">[</span><span class="nx">test</span><span class="p">.</span><span class="nx">patterns</span><span class="p">],</span> <span class="nx">p</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">DeepEqual</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">m</span><span class="p">[</span><span class="nx">test</span><span class="p">.</span><span class="nx">patterns</span><span class="p">])</span> <span class="p">{</span>
				<span class="nx">t</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;not expect %v, but actual %v\n&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">[</span><span class="nx">test</span><span class="p">.</span><span class="nx">patterns</span><span class="p">],</span> <span class="nx">p</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>


	<span class="p">}</span>

<span class="p">}</span>


<span class="kd">func</span> <span class="nf">Testrouter_GET</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">tests</span> <span class="o">:=</span> <span class="p">[]</span><span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">method</span>  <span class="kt">string</span>
		<span class="nx">pattern</span> <span class="kt">string</span>
		<span class="nx">parts</span>   <span class="p">[]</span><span class="kt">string</span>
		<span class="nx">ok</span>      <span class="kt">bool</span>
	<span class="p">}{</span>
		<span class="p">{</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="s">&#34;/test1/v1/add&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;/test1/v1/add&#34;</span><span class="p">},</span> <span class="kc">true</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="s">&#34;/test2/*name&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;/test2/name1&#34;</span><span class="p">,</span> <span class="s">&#34;/test2/name1/name2&#34;</span><span class="p">},</span> <span class="kc">true</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="s">&#34;/test3/:file/add&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;/test3/file123/add&#34;</span><span class="p">,</span> <span class="s">&#34;/test3/file_!@#$/add&#34;</span><span class="p">,</span> <span class="s">&#34;/test3/123431/add&#34;</span><span class="p">},</span> <span class="kc">true</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="s">&#34;/test4/:file/add&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;/test4/file123&#34;</span><span class="p">,</span> <span class="s">&#34;/test3/file_!@#$/add123&#34;</span><span class="p">,</span> <span class="s">&#34;/test3/123431/123_@#&#34;</span><span class="p">},</span> <span class="kc">false</span><span class="p">},</span>
		<span class="c1">// 这两条 应该怎么走呢?
</span><span class="c1"></span>		<span class="p">{</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="s">&#34;/hello/*name&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;/hello/geektutu/a/b&#34;</span><span class="p">,</span><span class="s">&#34;hello/geektutu&#34;</span><span class="p">},</span> <span class="kc">true</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="s">&#34;/hello/geektutu&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;hello/geektutu&#34;</span><span class="p">},</span> <span class="kc">true</span><span class="p">},</span>

	<span class="p">}</span>

	<span class="nx">r</span> <span class="o">:=</span> <span class="nf">newRouter</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">test</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tests</span> <span class="p">{</span>
		<span class="nx">r</span><span class="p">.</span><span class="nf">addRoute</span><span class="p">(</span><span class="nx">test</span><span class="p">.</span><span class="nx">method</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">pattern</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">test</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tests</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">part</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">test</span><span class="p">.</span><span class="nx">parts</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">test</span><span class="p">.</span><span class="nx">ok</span> <span class="p">{</span>
				<span class="nx">node</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">getRoute</span><span class="p">(</span><span class="nx">test</span><span class="p">.</span><span class="nx">method</span><span class="p">,</span> <span class="nx">part</span><span class="p">)</span>
				<span class="k">if</span> <span class="nx">node</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nx">t</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;url Path %s, expected : %s, but actual : %s\n&#34;</span><span class="p">,</span> <span class="nx">part</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">pattern</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">)</span>
					<span class="k">continue</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">pattern</span> <span class="o">!=</span> <span class="nx">test</span><span class="p">.</span><span class="nx">pattern</span> <span class="o">&amp;&amp;</span> <span class="nx">test</span><span class="p">.</span><span class="nx">ok</span> <span class="p">{</span>
					<span class="nx">t</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;url Path %s, expected : %s, but actual : %s\n&#34;</span><span class="p">,</span> <span class="nx">part</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">pattern</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">pattern</span><span class="p">)</span>
				<span class="p">}</span>
			<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
				<span class="nx">node</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">getRoute</span><span class="p">(</span><span class="nx">test</span><span class="p">.</span><span class="nx">method</span><span class="p">,</span> <span class="nx">part</span><span class="p">)</span>
				<span class="k">if</span> <span class="nx">node</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="k">continue</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">pattern</span> <span class="o">==</span> <span class="nx">test</span><span class="p">.</span><span class="nx">pattern</span> <span class="p">{</span>
					<span class="nx">t</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;url Path %s, not expected : %s, but actual : %s\n&#34;</span><span class="p">,</span> <span class="nx">part</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">pattern</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">pattern</span><span class="p">)</span>
				<span class="p">}</span>
			<span class="p">}</span>

		<span class="p">}</span>
	<span class="p">}</span>

<span class="p">}</span>

</code></pre></div><h3 id="路由代码">路由代码</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">gee</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;net/http&#34;</span>
	<span class="s">&#34;strings&#34;</span>
<span class="p">)</span>

<span class="c1">// 这里包装router
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">router</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">roots</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">node</span>
	<span class="nx">handlers</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">HandlerFunc</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">newRouter</span><span class="p">()</span> <span class="o">*</span><span class="nx">router</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">router</span><span class="p">{</span>
		<span class="nx">handlers</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">HandlerFunc</span><span class="p">),</span>
		<span class="nx">roots</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">node</span> <span class="p">),</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Only one * is allowed
</span><span class="c1">// 将 /test/v1/add -&gt; [test v1 add]
</span><span class="c1">// /test/*name/add -&gt; [test *name]
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">parsePattern</span><span class="p">(</span><span class="nx">pattern</span> <span class="kt">string</span> <span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="nx">vs</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="nx">pattern</span><span class="p">,</span><span class="s">&#34;/&#34;</span><span class="p">)</span>
	<span class="nx">parts</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span> <span class="p">,</span> <span class="nx">item</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">vs</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">item</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="nx">parts</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">parts</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;*&#39;</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">parts</span>
<span class="p">}</span>

<span class="c1">//
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">router</span><span class="p">)</span> <span class="nf">addRoute</span><span class="p">(</span><span class="nx">method</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">pattern</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">handler</span> <span class="nx">HandlerFunc</span> <span class="p">)</span> <span class="p">{</span>
	<span class="nx">parts</span> <span class="o">:=</span> <span class="nf">parsePattern</span><span class="p">(</span><span class="nx">pattern</span><span class="p">)</span>
	<span class="nx">key</span> <span class="o">:=</span> <span class="nx">method</span><span class="o">+</span><span class="s">&#34;-&#34;</span><span class="o">+</span><span class="nx">pattern</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">roots</span><span class="p">[</span><span class="nx">method</span><span class="p">]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">r</span><span class="p">.</span><span class="nx">roots</span><span class="p">[</span><span class="nx">method</span><span class="p">]</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">node</span><span class="p">{}</span>
	<span class="p">}</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">roots</span><span class="p">[</span><span class="nx">method</span><span class="p">].</span><span class="nf">insert</span><span class="p">(</span><span class="nx">pattern</span><span class="p">,</span><span class="nx">parts</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">handlers</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">handler</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">router</span><span class="p">)</span> <span class="nf">handle</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>

	<span class="nx">n</span><span class="p">,</span> <span class="nx">params</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">getRoute</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Method</span><span class="p">,</span><span class="nx">c</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="o">!=</span> <span class="kc">nil</span>  <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">Params</span> <span class="p">=</span> <span class="nx">params</span>
		<span class="nx">key</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Method</span> <span class="o">+</span> <span class="s">&#34;-&#34;</span> <span class="o">+</span> <span class="nx">n</span><span class="p">.</span><span class="nx">pattern</span>
		<span class="nx">r</span><span class="p">.</span><span class="nx">handlers</span><span class="p">[</span><span class="nx">key</span><span class="p">](</span><span class="nx">c</span><span class="p">)</span>
	<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusNotFound</span><span class="p">,</span><span class="s">&#34;404 not found : %s\n&#34;</span><span class="p">,</span><span class="nx">c</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">router</span><span class="p">)</span> <span class="nf">getRoute</span><span class="p">(</span><span class="nx">method</span> <span class="kt">string</span> <span class="p">,</span> <span class="nx">path</span> <span class="kt">string</span> <span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">node</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">searchParts</span> <span class="o">:=</span> <span class="nf">parsePattern</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span>
	<span class="nx">params</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span>
	<span class="nx">root</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">roots</span><span class="p">[</span><span class="nx">method</span><span class="p">]</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">root</span><span class="p">.</span><span class="nf">search</span><span class="p">(</span><span class="nx">searchParts</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">parts</span> <span class="o">:=</span> <span class="nf">parsePattern</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">pattern</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">part</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">parts</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">part</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;:&#39;</span> <span class="p">{</span>
				<span class="nx">params</span><span class="p">[</span><span class="nx">part</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span> <span class="p">=</span> <span class="nx">searchParts</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">part</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;*&#39;</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">part</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
				<span class="nx">params</span><span class="p">[</span><span class="nx">part</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">searchParts</span><span class="p">[</span><span class="nx">index</span><span class="p">:],</span> <span class="s">&#34;/&#34;</span><span class="p">)</span>
				<span class="k">break</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">params</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// 这里GET方法写在 router 里面
</span><span class="c1">// engine 是包含 router
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">router</span><span class="p">)</span> <span class="nf">GET</span><span class="p">(</span><span class="nx">pattern</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">handler</span> <span class="nx">HandlerFunc</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">r</span><span class="p">.</span><span class="nf">addRoute</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">MethodGet</span><span class="p">,</span><span class="nx">pattern</span><span class="p">,</span><span class="nx">handler</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">router</span><span class="p">)</span> <span class="nf">POST</span><span class="p">(</span><span class="nx">pattern</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">handler</span> <span class="nx">HandlerFunc</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">r</span><span class="p">.</span><span class="nf">addRoute</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">MethodPost</span><span class="p">,</span><span class="nx">pattern</span><span class="p">,</span><span class="nx">handler</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><h3 id="trie-树代码">trie 树代码</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">gee</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;strings&#34;</span>
<span class="p">)</span>

<span class="c1">// 采用 前缀树 方式来实现动态路由
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">node</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">pattern</span> <span class="kt">string</span> <span class="c1">//待匹配路由, 例如  /p/:lang , 是 req.URL.Path
</span><span class="c1"></span>	<span class="nx">part</span> <span class="kt">string</span> <span class="c1">// 路由中一部分, 例如 :lang, 是按照 / 分割的部分
</span><span class="c1"></span>	<span class="nx">children</span> <span class="p">[]</span><span class="o">*</span><span class="nx">node</span> <span class="c1">// 子节点, 例如 [ doc, tutorial, intro ]
</span><span class="c1"></span>	<span class="nx">isWild</span> <span class="kt">bool</span> <span class="c1">// 是否精确匹配, part含有: 或 * 时为true
</span><span class="c1"></span><span class="p">}</span>



<span class="c1">// 第一个匹配成功的节点, 用于插入 insert 方法
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span> <span class="p">)</span> <span class="nf">matchChild</span><span class="p">(</span><span class="nx">part</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">node</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">child</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">n</span><span class="p">.</span><span class="nx">children</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">child</span><span class="p">.</span><span class="nx">part</span> <span class="o">==</span> <span class="nx">part</span> <span class="o">||</span> <span class="nx">child</span><span class="p">.</span><span class="nx">isWild</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">child</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// 所有匹配成功的节点，用于查找 search 方法
</span><span class="c1">//  例如 /test/v1/add
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span><span class="p">)</span> <span class="nf">matchChildren</span><span class="p">(</span><span class="nx">part</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="o">*</span><span class="nx">node</span> <span class="p">{</span>
	<span class="nx">nodes</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">node</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="c1">// 查询方法就是从trie树中查询, 如果查到了添加到列表, 返回查询到的列表
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">child</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">n</span><span class="p">.</span><span class="nx">children</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">child</span><span class="p">.</span><span class="nx">part</span> <span class="o">==</span> <span class="nx">part</span> <span class="o">||</span> <span class="nx">child</span><span class="p">.</span><span class="nx">isWild</span> <span class="p">{</span>
			<span class="nx">nodes</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">nodes</span><span class="p">,</span> <span class="nx">child</span><span class="p">)</span>
			<span class="c1">// 这里加break是让查到的第一个就结束, 不希望路由匹配到多个结果
</span><span class="c1"></span>			<span class="c1">//break
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">nodes</span>
<span class="p">}</span>

<span class="c1">// 插入方法就是 判断 part路由是否已经存在路由节点中 如果是模糊匹配 直接返回
</span><span class="c1">//   if child.part == part || child.isWild {
</span><span class="c1">// 如果没有找到且是精确匹配, 那么就添加到子节点中
</span><span class="c1">//   n.children = append(n.children, child)
</span><span class="c1">//
</span><span class="c1">//  pattern 是完整路由url ,parts 是将 pattern 按照 / 拆分的 每一部分 , 然后height 从0 递归对 parts 进行查询或插入
</span><span class="c1">//
</span><span class="c1">//  这里是一个逆向看的, 可以先去查询 parsePattern 方法
</span><span class="c1">//  例如 /test/v1/add
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span><span class="p">)</span> <span class="nf">insert</span><span class="p">(</span><span class="nx">pattern</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">parts</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">height</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 在node中生成一条 test(node) -&gt; v2(node) -&gt; add(node) 一条trie链表 之后
</span><span class="c1"></span>	<span class="c1">// len(parts == height == 3 , 可以退出
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">parts</span><span class="p">)</span> <span class="o">==</span> <span class="nx">height</span> <span class="p">{</span>
		<span class="nx">n</span><span class="p">.</span><span class="nx">pattern</span> <span class="p">=</span> <span class="nx">pattern</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">//
</span><span class="c1"></span>	<span class="nx">part</span> <span class="o">:=</span> <span class="nx">parts</span><span class="p">[</span><span class="nx">height</span><span class="p">]</span>
	<span class="c1">// 首先取 test 从node中查询, 如果查到了 那么目前查到路由 : /test
</span><span class="c1"></span>	<span class="c1">// 那么继续递归insert, 取v1 去查询,
</span><span class="c1"></span>	<span class="c1">// 如果查到了说明路由存在, 如果没有查到 那么新建这个node,添加到当前node的children, 目前查到路由: /test/v1,
</span><span class="c1"></span>	<span class="c1">// 同样最后可以 在node中生成一条 test(node) -&gt; v2(node) -&gt; add(node) 一条trie链表
</span><span class="c1"></span>	<span class="nx">child</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nf">matchChild</span><span class="p">(</span><span class="nx">part</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">child</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">child</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">node</span><span class="p">{</span>
			<span class="nx">part</span><span class="p">:</span><span class="nx">part</span><span class="p">,</span>
			<span class="nx">isWild</span><span class="p">:</span><span class="nx">part</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;:&#39;</span> <span class="o">||</span> <span class="nx">part</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;*&#39;</span><span class="p">,</span>
		<span class="p">}</span>
		<span class="nx">n</span><span class="p">.</span><span class="nx">children</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">children</span><span class="p">,</span> <span class="nx">child</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">child</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="nx">pattern</span><span class="p">,</span> <span class="nx">parts</span><span class="p">,</span> <span class="nx">height</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 从node中查询节点是否存在, 如果存在就返回
</span><span class="c1">//  例如 /test/v1/add
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span><span class="p">)</span> <span class="nf">search</span><span class="p">(</span><span class="nx">parts</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">height</span> <span class="kt">int</span> <span class="p">)</span> <span class="o">*</span><span class="nx">node</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">parts</span><span class="p">)</span> <span class="o">==</span> <span class="nx">height</span> <span class="o">||</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">part</span><span class="p">,</span><span class="s">&#34;*&#34;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">pattern</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">n</span>
	<span class="p">}</span>
	<span class="nx">part</span> <span class="o">:=</span> <span class="nx">parts</span><span class="p">[</span><span class="nx">height</span><span class="p">]</span>
	<span class="c1">// 这里查询同样是 先查询 test, 如果找到trie树的第一个节点 children = [ test(node) ]
</span><span class="c1"></span>	<span class="c1">// 然后在出现v1, 根据trie结构, v1只能是在test(node) 这个节点的
</span><span class="c1"></span>	<span class="c1">// 这里需要for循环 为什么不直接取 children[0] 呢?
</span><span class="c1"></span>	<span class="c1">// 1. 有可能是因为v1 可能匹配到 /test/v1 也可能匹配到 /test/:version, 所以返回的是2个
</span><span class="c1"></span>	<span class="c1">// 2. 如果让每次matchChildren查询返回一定是唯一呢? 那如果先有路由1:&#34;/hello/geektutu&#34;, 在注册了路由2:&#34;/hello/*name&#34;, 当请求&#34;/hello/geektutu/a/b&#34;的时候就会无法匹配路由2
</span><span class="c1"></span>	<span class="nx">children</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nf">matchChildren</span><span class="p">(</span><span class="nx">part</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">child</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">children</span> <span class="p">{</span>
		<span class="c1">//log.Println(&#34;child:&#34;,child.pattern)
</span><span class="c1"></span>		<span class="nx">result</span> <span class="o">:=</span> <span class="nx">child</span><span class="p">.</span><span class="nf">search</span><span class="p">(</span><span class="nx">parts</span><span class="p">,</span> <span class="nx">height</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">result</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">result</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Gin学习 简单记录form数据获取源码解读</title>
			<link>https://www.ngirl.xyz/golang/gin%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95form%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</link>
			<pubDate>Wed, 13 Jan 2021 14:24:43 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/gin%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95form%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</guid>
			<description>http.request form 数据测试 func main() { e := gin.Default() e.Any(&amp;#34;/test&amp;#34;,func(c *gin.Context) { // 获取所有参数 	_ = c.Request.ParseForm() // log.Println(c.Request.Header[&amp;#34;Content-Type&amp;#34;]) 	// get form 参数, c.Request.URL.Query, err = url.ParseQuery 	log.Println(c.Request.URL.Query()) //log.Println(url.ParseQuery(c.Request.URL.RawQuery)) 	// post form 参数 	log.Println(c.Request.PostForm) // form 参数 	log.Println(c.Request.Form) }) e.Run(&amp;#34;localhost:8123&amp;#34;) }  请求日志
 # curl -XPOST &amp;quot;http://localhost:8123/test&amp;quot; -d &amp;quot;abc=123&amp;amp;q=123&amp;amp;ccc=123123&amp;quot; 2021/01/13 14:31:30 map[] 2021/01/13 14:31:30 map[abc:[123] ccc:[123123] q:[123]] 2021/01/13 14:31:30 map[abc:[123] ccc:[123123] q:[123]] [GIN] 2021/01/13 - 14:31:30 | 200 | 339.</description>
			<content type="html"><![CDATA[<h3 id="httprequest-form-数据测试">http.request form 数据测试</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">Default</span><span class="p">()</span>
	<span class="nx">e</span><span class="p">.</span><span class="nf">Any</span><span class="p">(</span><span class="s">&#34;/test&#34;</span><span class="p">,</span><span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// 获取所有参数
</span><span class="c1"></span>		<span class="nx">_</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nf">ParseForm</span><span class="p">()</span>
		<span class="c1">// log.Println(c.Request.Header[&#34;Content-Type&#34;])
</span><span class="c1"></span>		<span class="c1">// get form 参数, c.Request.URL.Query, err  = url.ParseQuery
</span><span class="c1"></span>		<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nf">Query</span><span class="p">())</span>
		<span class="c1">//log.Println(url.ParseQuery(c.Request.URL.RawQuery))
</span><span class="c1"></span>		<span class="c1">// post form 参数
</span><span class="c1"></span>		<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">PostForm</span><span class="p">)</span>
		<span class="c1">// form 参数
</span><span class="c1"></span>		<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">Form</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="nx">e</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="s">&#34;localhost:8123&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><blockquote>
<p>请求日志</p>
</blockquote>
<pre><code># curl -XPOST &quot;http://localhost:8123/test&quot; -d &quot;abc=123&amp;q=123&amp;ccc=123123&quot;
2021/01/13 14:31:30 map[]
2021/01/13 14:31:30 map[abc:[123] ccc:[123123] q:[123]]
2021/01/13 14:31:30 map[abc:[123] ccc:[123123] q:[123]]
[GIN] 2021/01/13 - 14:31:30 | 200 |     339.106µs |       127.0.0.1 | POST     &quot;/test&quot;

# curl &quot;http://localhost:8123/test?aaa=111&amp;bbbb=2222&quot;
2021/01/13 14:31:38 map[aaa:[111] bbbb:[2222]]
2021/01/13 14:31:38 map[]
2021/01/13 14:31:38 map[aaa:[111] bbbb:[2222]]
[GIN] 2021/01/13 - 14:31:38 | 200 |      73.852µs |       127.0.0.1 | GET      &quot;/test?aaa=111&amp;bbbb=2222&quot;

# curl -XPOST &quot;http://localhost:8123/test?aaa=111&amp;bbbb=2222&quot; -d &quot;abc=123&amp;q=123&amp;ccc=123123&quot;
2021/01/13 14:31:48 map[aaa:[111] bbbb:[2222]]
2021/01/13 14:31:48 map[abc:[123] ccc:[123123] q:[123]]
2021/01/13 14:31:48 map[aaa:[111] abc:[123] bbbb:[2222] ccc:[123123] q:[123]]
[GIN] 2021/01/13 - 14:31:48 | 200 |     119.833µs |       127.0.0.1 | POST     &quot;/test?aaa=111&amp;bbbb=2222&quot;

</code></pre><h3 id="看下parseform-的源码">看下ParseForm 的源码</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="nf">ParseForm</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">PostForm</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 以下方法 会调用 parsePostForm
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Method</span> <span class="o">==</span> <span class="s">&#34;POST&#34;</span> <span class="o">||</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Method</span> <span class="o">==</span> <span class="s">&#34;PUT&#34;</span> <span class="o">||</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Method</span> <span class="o">==</span> <span class="s">&#34;PATCH&#34;</span> <span class="p">{</span>
			<span class="nx">r</span><span class="p">.</span><span class="nx">PostForm</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">parsePostForm</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">PostForm</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">r</span><span class="p">.</span><span class="nx">PostForm</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">url</span><span class="p">.</span><span class="nx">Values</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Form</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 这里  PostForm 会复制到 Form, 所以 Form &gt;= PostForm
</span><span class="c1"></span>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">PostForm</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">r</span><span class="p">.</span><span class="nx">Form</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">url</span><span class="p">.</span><span class="nx">Values</span><span class="p">)</span>
			<span class="nf">copyValues</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Form</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">PostForm</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// 这里 get的参数是在r.URL里面的, 所以通过 ParseQuery 获取get参数
</span><span class="c1"></span>		<span class="kd">var</span> <span class="nx">newValues</span> <span class="nx">url</span><span class="p">.</span><span class="nx">Values</span>
		<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">URL</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="kd">var</span> <span class="nx">e</span> <span class="kt">error</span>
			<span class="nx">newValues</span><span class="p">,</span> <span class="nx">e</span> <span class="p">=</span> <span class="nx">url</span><span class="p">.</span><span class="nf">ParseQuery</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">RawQuery</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">err</span> <span class="p">=</span> <span class="nx">e</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">newValues</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">newValues</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">url</span><span class="p">.</span><span class="nx">Values</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// 最后也会添加 get参数到form, 所以 Form &gt;= url.Query()
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Form</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">r</span><span class="p">.</span><span class="nx">Form</span> <span class="p">=</span> <span class="nx">newValues</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nf">copyValues</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Form</span><span class="p">,</span> <span class="nx">newValues</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></div><h3 id="这里看下-parsepostform">这里看下 parsePostForm</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">parsePostForm</span><span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">(</span><span class="nx">vs</span> <span class="nx">url</span><span class="p">.</span><span class="nx">Values</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Body</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;missing form body&#34;</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">ct</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;Content-Type&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">ct</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">ct</span> <span class="p">=</span> <span class="s">&#34;application/octet-stream&#34;</span>
	<span class="p">}</span>
	<span class="nx">ct</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">mime</span><span class="p">.</span><span class="nf">ParseMediaType</span><span class="p">(</span><span class="nx">ct</span><span class="p">)</span>
	<span class="k">switch</span> <span class="p">{</span>
	<span class="c1">// 这里我们默认的header 就是 application/x-www-form-urlencoded
</span><span class="c1"></span>	<span class="c1">// 可以 log.Println(c.Request.Header[&#34;Content-Type&#34;]) 打印查看
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">ct</span> <span class="o">==</span> <span class="s">&#34;application/x-www-form-urlencoded&#34;</span><span class="p">:</span>
		<span class="kd">var</span> <span class="nx">reader</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Body</span>
		<span class="c1">// 首先初始化 maxFormSize = 2^63 -1
</span><span class="c1"></span>		<span class="nx">maxFormSize</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">63</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Body</span><span class="p">.(</span><span class="o">*</span><span class="nx">maxBytesReader</span><span class="p">);</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
			<span class="c1">// 设置 io.LimitedReader 的  N
</span><span class="c1"></span>			<span class="nx">maxFormSize</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">10</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">)</span> <span class="c1">// 10 MB is a lot of text.
</span><span class="c1"></span>			<span class="c1">// 返回了一个 带限制的 io.LimitedReader, 当然实现了 Reader interfacer
</span><span class="c1"></span>			<span class="nx">reader</span> <span class="p">=</span> <span class="nx">io</span><span class="p">.</span><span class="nf">LimitReader</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Body</span><span class="p">,</span> <span class="nx">maxFormSize</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// 这里会调用 io.LimitedReader 的Read 方法, 通过接口实现
</span><span class="c1"></span>		<span class="c1">// 直接读取post 的body即可
</span><span class="c1"></span>		<span class="nx">b</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadAll</span><span class="p">(</span><span class="nx">reader</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">e</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">err</span> <span class="p">=</span> <span class="nx">e</span>
			<span class="p">}</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nb">int64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span> <span class="p">&gt;</span> <span class="nx">maxFormSize</span> <span class="p">{</span>
			<span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;http: POST too large&#34;</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="c1">// 最终也是调用 url.ParseQuery
</span><span class="c1"></span>		<span class="c1">// 这里 string(b) = abc=123&amp;q=123&amp;ccc=123123
</span><span class="c1"></span>		<span class="nx">vs</span><span class="p">,</span> <span class="nx">e</span> <span class="p">=</span> <span class="nx">url</span><span class="p">.</span><span class="nf">ParseQuery</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">err</span> <span class="p">=</span> <span class="nx">e</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="nx">ct</span> <span class="o">==</span> <span class="s">&#34;multipart/form-data&#34;</span><span class="p">:</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>

</code></pre></div><h3 id="简单看下-iolimitedreader-的read-方法">简单看下 io.LimitedReader 的Read 方法</h3>
<blockquote>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">LimitedReader</span><span class="p">)</span> <span class="nf">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nx">N</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">EOF</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">int64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">))</span> <span class="p">&gt;</span> <span class="nx">l</span><span class="p">.</span><span class="nx">N</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="p">=</span> <span class="nx">p</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nx">l</span><span class="p">.</span><span class="nx">N</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">R</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">N</span> <span class="o">-=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
	<span class="k">return</span>
<span class="p">}</span>

</code></pre></div><h3 id="parsequery-分析">parseQuery 分析</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="kd">func</span> <span class="nf">parseQuery</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Values</span><span class="p">,</span> <span class="nx">query</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 这里的循环结束条件是 query == &#34;&#34;
</span><span class="c1"></span>	<span class="c1">// 那什么时候会空呢?
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">query</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">key</span> <span class="o">:=</span> <span class="nx">query</span>
		<span class="c1">// 这里取到第一个 &amp;或者; 的索引, 然后将 query 分成两半
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">IndexAny</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="s">&#34;&amp;;&#34;</span><span class="p">);</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// 这里会每次 截取后一半 赋值给query, 所以query一直在消耗 第一个&amp;前的数据
</span><span class="c1"></span>			<span class="nx">key</span><span class="p">,</span> <span class="nx">query</span> <span class="p">=</span> <span class="nx">key</span><span class="p">[:</span><span class="nx">i</span><span class="p">],</span> <span class="nx">key</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
		<span class="c1">// 如果 已经没有 &amp; 或者 ; 字符了, 说明只有最后一个字段了, 那么就直接置空 query, 然后读取完key 就可以结束循环了
</span><span class="c1"></span>		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">query</span> <span class="p">=</span> <span class="s">&#34;&#34;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">key</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">value</span> <span class="o">:=</span> <span class="s">&#34;&#34;</span>
		<span class="c1">// 取出 第一个 &amp; 前面的 参数 按照=分割, 从而得到 变量名 和变量值
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Index</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="s">&#34;=&#34;</span><span class="p">);</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="p">=</span> <span class="nx">key</span><span class="p">[:</span><span class="nx">i</span><span class="p">],</span> <span class="nx">key</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
		<span class="p">}</span>
		<span class="nx">key</span><span class="p">,</span> <span class="nx">err1</span> <span class="o">:=</span> <span class="nf">QueryUnescape</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err1</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">err</span> <span class="p">=</span> <span class="nx">err1</span>
			<span class="p">}</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">value</span><span class="p">,</span> <span class="nx">err1</span> <span class="p">=</span> <span class="nf">QueryUnescape</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err1</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">err</span> <span class="p">=</span> <span class="nx">err1</span>
			<span class="p">}</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="c1">// 最后将 post参数写成map结构 写到m (url.Value) 中
</span><span class="c1"></span>		<span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">],</span> <span class="nx">value</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Gin学习 Validator</title>
			<link>https://www.ngirl.xyz/golang/gin%E5%AD%A6%E4%B9%A0-validator/</link>
			<pubDate>Tue, 12 Jan 2021 10:17:46 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/gin%E5%AD%A6%E4%B9%A0-validator/</guid>
			<description>&lt;p&gt;记录一下Gin学习验证器和翻译器模块&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>记录一下Gin学习验证器和翻译器模块</p>
<ul>
<li>github地址: <a href="https://github.com/zhangzw001/learnGin/tree/gin-shouldbind">https://github.com/zhangzw001/learnGin/tree/gin-shouldbind</a></li>
<li>官方文档: <a href="https://godoc.org/github.com/go-playground/validator">https://godoc.org/github.com/go-playground/validator</a></li>
<li>官方示例: <a href="https://github.com/go-playground/validator/tree/v10.4.1/_examples">https://github.com/go-playground/validator/tree/v10.4.1/_examples</a></li>
<li>原文: <a href="https://github.com/xinliangnote/Go">https://github.com/xinliangnote/Go</a></li>
</ul>
<h3 id="功能演示介绍">功能演示介绍</h3>
<blockquote>
<p>首先这个模块是很方便校验接口的输入结构体参数是否符合规则,不用繁琐的自己写参数校验, 翻译器又可以支持不同语言的错误提示,而且可以自定义返回错误格式覆盖默认的格式</p>
</blockquote>
<pre><code>1. 调用localhost:8000/sn/create 执行验证器中间件
2. 调用localhost:8000/v1/product/add 执行验证器,签名等中间件
</code></pre><h3 id="部分相关目录结构">部分相关目录结构</h3>
<pre><code>.
├── config
│   └── env.go
├── controller
│   ├── api
│   │   └── v1.go
│   └── sign
│       └── sign.go
├── docs
│   ├── docs.go
│   ├── swagger.json
│   └── swagger.yaml
├── dto
│   └── api.go
├── go.mod
├── go.sum
├── logs
│   ├── gin-logger.log -&gt; gin-logger.log.20210112-000000.log
│   └── gin-logger.log.20210112-000000.log
├── main.go
├── middleware
│   ├── logger.go
│   ├── response.go
│   ├── sign.go
│   └── validator.go
├── public
│   ├── public.go
│   └── validator.go
└── routers
    └── router.go

</code></pre><h3 id="1-首先定义路由规则">1. 首先定义路由规则</h3>
<h4 id="routersroutergo">routers/router.go</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">routers</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
	<span class="nx">ginSwagger</span> <span class="s">&#34;github.com/swaggo/gin-swagger&#34;</span>
	<span class="s">&#34;github.com/swaggo/gin-swagger/swaggerFiles&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/controller/api&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/controller/sign&#34;</span>
	<span class="c1">// 这里需要导入自己项目的目录,否则swagger页面会报错
</span><span class="c1"></span>	<span class="nx">_</span> <span class="s">&#34;github.com/zhangzw001/learnGin/docs&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/middleware&#34;</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">InitRouter</span><span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Engine</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// swagger 文档
</span><span class="c1"></span>	<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/swagger/*any&#34;</span><span class="p">,</span><span class="nx">ginSwagger</span><span class="p">.</span><span class="nf">WrapHandler</span><span class="p">(</span><span class="nx">swaggerFiles</span><span class="p">.</span><span class="nx">Handler</span><span class="p">))</span>
	<span class="c1">// sign路由
</span><span class="c1"></span>	<span class="nx">Sign</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nf">Group</span><span class="p">(</span><span class="s">&#34;/sn&#34;</span><span class="p">)</span>
	<span class="nx">Sign</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">middleware</span><span class="p">.</span><span class="nf">TranslationMiddleware</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="nx">controllersign</span><span class="p">.</span><span class="nf">RegisterSign</span><span class="p">(</span><span class="nx">Sign</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// api v1版本路由
</span><span class="c1"></span>	<span class="nx">GroupV1</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nf">Group</span><span class="p">(</span><span class="s">&#34;/v1&#34;</span><span class="p">)</span>
	<span class="nx">GroupV1</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">middleware</span><span class="p">.</span><span class="nf">SignMiddleware</span><span class="p">(),</span><span class="nx">middleware</span><span class="p">.</span><span class="nf">TranslationMiddleware</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="nx">controllerapi</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">GroupV1</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="2-看下sign-controller">2. 看下sign controller</h3>
<h4 id="21-controllersignsigngo">2.1 controller/sign/sign.go</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">controllersign</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/dto&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/middleware&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/public&#34;</span>
	<span class="s">&#34;strconv&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Controller</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="nf">RegisterSign</span><span class="p">(</span><span class="nx">router</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">RouterGroup</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">sign</span> <span class="o">:=</span> <span class="nx">Controller</span><span class="p">{}</span>
	<span class="nx">router</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/create&#34;</span><span class="p">,</span> <span class="nx">sign</span><span class="p">.</span><span class="nx">Create</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Add godoc
</span><span class="c1">// @Summary sign接口
</span><span class="c1">// @Description sign接口
</span><span class="c1">// @Tags sign 创建接口
</span><span class="c1">// @ID /sn/create
</span><span class="c1">// @Accept  json
</span><span class="c1">// @Produce  json
</span><span class="c1">// @Param name query string true &#34;名称&#34;
</span><span class="c1">// @Param price query string true &#34;价格&#34;
</span><span class="c1">// @Success 200 {object} middleware.Response{data=dto.ApiOutput} &#34;success&#34;
</span><span class="c1">// @Router /sn/create [get]
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">sign</span> <span class="nx">Controller</span><span class="p">)</span> <span class="nf">Create</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">ts</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">FormatInt</span><span class="p">(</span><span class="nx">public</span><span class="p">.</span><span class="nf">GetTimeUnix</span><span class="p">(),</span> <span class="mi">10</span><span class="p">)</span>

	<span class="nx">params</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">dto</span><span class="p">.</span><span class="nx">ApiUpdateInput</span><span class="p">{}</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">params</span><span class="p">.</span><span class="nf">BindValueParam</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">middleware</span><span class="p">.</span><span class="nf">ResponseError</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="mi">10001</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">paramsSign</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">Form</span>
	<span class="nx">paramsSign</span><span class="p">[</span><span class="s">&#34;ts&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="nx">ts</span><span class="p">}</span>

	<span class="nx">data</span> <span class="o">:=</span> <span class="nx">dto</span><span class="p">.</span><span class="nx">ApiOutput</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span>  <span class="nx">params</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span>
		<span class="nx">Price</span><span class="p">:</span> <span class="nx">params</span><span class="p">.</span><span class="nx">Price</span><span class="p">,</span>
		<span class="nx">Ts</span><span class="p">:</span>    <span class="nx">ts</span><span class="p">,</span>
		<span class="nx">Sn</span><span class="p">:</span>    <span class="nx">public</span><span class="p">.</span><span class="nf">CreateSign</span><span class="p">(</span><span class="nx">paramsSign</span><span class="p">),</span>
	<span class="p">}</span>
	<span class="nx">middleware</span><span class="p">.</span><span class="nf">ResponseSuccess</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h4 id="22-数据传输-dtoapigo">2.2 数据传输 dto.api.go</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="err">#</span><span class="o">/</span><span class="nx">sn</span><span class="o">/</span><span class="nx">create</span> <span class="nx">的输入仅允许两个参数</span>
<span class="kd">type</span> <span class="nx">ApiUpdateInput</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// 这里validate 代表通过validator.v10验证自定义规则 test_tag,默认规则 required 表示必传字段
</span><span class="c1"></span>	<span class="nx">Name</span> <span class="kt">string</span>		<span class="s">`json:&#34;name&#34; form:&#34;name&#34; comment:&#34;名称&#34; example:&#34;abcdef&#34; validate:&#34;required,test_tag&#34;`</span>
    <span class="c1">// 这里仅验证最小值0
</span><span class="c1"></span>	<span class="nx">Price</span> <span class="kt">int</span>	<span class="s">`json:&#34;price&#34; form:&#34;price&#34; comment:&#34;价格&#34; example:&#34;10&#34; validate:&#34;required,min=0&#34;`</span>
<span class="p">}</span>

<span class="c1">// 绑定结构体
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">param</span> <span class="o">*</span><span class="nx">ApiUpdateInput</span><span class="p">)</span> <span class="nf">BindValueParam</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span>  <span class="p">{</span>
	<span class="k">return</span> <span class="nx">public</span><span class="p">.</span><span class="nf">DefaultGetValidParams</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="nx">param</span><span class="p">)</span>
<span class="p">}</span>

<span class="err">#</span> <span class="nx">另外output结构体</span><span class="p">,</span><span class="nx">这里不需要验证器</span>
<span class="kd">type</span> <span class="nx">ApiOutput</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span> <span class="kt">string</span>
	<span class="nx">Price</span> <span class="kt">int</span>
	<span class="nx">Ts</span> <span class="kt">string</span>
	<span class="nx">Sn</span> <span class="kt">string</span>
<span class="p">}</span>


<span class="kd">type</span> <span class="nx">ApiAddInput</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span> <span class="kt">string</span> <span class="s">`json:&#34;name&#34; form:&#34;name&#34; comment:&#34;名称&#34; example:&#34;abc&#34; validate:&#34;required,test_tag,max=24,min=6&#34;`</span>
	<span class="nx">Price</span> <span class="kt">int</span> <span class="s">`json:&#34;price&#34; form:&#34;price&#34; comment:&#34;价格&#34; example:&#34;abc&#34;  validate:&#34;required,min=0&#34;`</span>
	<span class="nx">Ts</span> <span class="kt">string</span> <span class="s">`json:&#34;ts&#34; form:&#34;ts&#34; comment:&#34;有效期&#34; example:&#34;&#34; validate:&#34;required,min=1&#34;`</span>
	<span class="nx">Sn</span> <span class="kt">string</span> <span class="s">`json:&#34;sn&#34; form:&#34;sn&#34; comment:&#34;签名&#34; example:&#34;&#34; validate:&#34;required,min=32,max=32&#34;`</span>
<span class="p">}</span>

<span class="c1">// 绑定结构体
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">param</span> <span class="o">*</span><span class="nx">ApiAddInput</span><span class="p">)</span> <span class="nf">BindValueParam</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span>  <span class="p">{</span>
	<span class="k">return</span> <span class="nx">public</span><span class="p">.</span><span class="nf">DefaultGetValidParams</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="nx">param</span><span class="p">)</span>
<span class="p">}</span>


</code></pre></div><h4 id="23-publicvalidatorgo-调用shouldbind-验证器-和翻译器">2.3 public/validator.go 调用shouldbind ,验证器 和翻译器</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">public</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
	<span class="nx">ut</span> <span class="s">&#34;github.com/go-playground/universal-translator&#34;</span>
	<span class="s">&#34;github.com/go-playground/validator/v10&#34;</span>
	<span class="s">&#34;github.com/pkg/errors&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/config&#34;</span>
	<span class="s">&#34;strings&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">DefaultGetValidParams</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">params</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">ShouldBind</span><span class="p">(</span><span class="nx">params</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="c1">// 获取验证器
</span><span class="c1"></span>	<span class="nx">valid</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">GetValidator</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="c1">// 获取翻译器
</span><span class="c1"></span>	<span class="nx">trans</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">GetTranslate</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="nx">err</span> <span class="p">=</span> <span class="nx">valid</span><span class="p">.</span><span class="nf">Struct</span><span class="p">(</span><span class="nx">params</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">errs</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="nx">validator</span><span class="p">.</span><span class="nx">ValidationErrors</span><span class="p">)</span>
		<span class="nx">sliceErrs</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{}</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span><span class="k">range</span> <span class="nx">errs</span> <span class="p">{</span>
			<span class="nx">sliceErrs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">sliceErrs</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nf">Translate</span><span class="p">(</span><span class="nx">trans</span><span class="p">))</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">sliceErrs</span><span class="p">,</span> <span class="s">&#34;,&#34;</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// 获取验证器
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GetValidator</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">validator</span><span class="p">.</span><span class="nx">Validate</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">ValidatorKey</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;未设置验证器&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">validate</span> <span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">val</span><span class="p">.(</span><span class="o">*</span><span class="nx">validator</span><span class="p">.</span><span class="nx">Validate</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;获取验证器失败&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">validate</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// 获取翻译器
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GetTranslate</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">ut</span><span class="p">.</span><span class="nx">Translator</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">trans</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">TranslatorKey</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;未设置翻译器&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">translator</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">trans</span><span class="p">.(</span><span class="nx">ut</span><span class="p">.</span><span class="nx">Translator</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;获取翻译器失败&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">translator</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

</code></pre></div><h3 id="3-中间件-middlewarevalidatorgo">3. 中间件 middleware/validator.go</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">middleware</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
	<span class="s">&#34;github.com/go-playground/locales/en&#34;</span>
	<span class="s">&#34;github.com/go-playground/locales/zh&#34;</span>
	<span class="nx">ut</span> <span class="s">&#34;github.com/go-playground/universal-translator&#34;</span>
	<span class="s">&#34;github.com/go-playground/validator/v10&#34;</span>
	<span class="nx">en_translations</span> <span class="s">&#34;github.com/go-playground/validator/v10/translations/en&#34;</span>
	<span class="nx">zh_translations</span> <span class="s">&#34;github.com/go-playground/validator/v10/translations/zh&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/config&#34;</span>
	<span class="s">&#34;reflect&#34;</span>
	<span class="s">&#34;regexp&#34;</span>
<span class="p">)</span>


<span class="c1">// 设置验证器+翻译器
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">TranslationMiddleware</span><span class="p">()</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">HandlerFunc</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// 创建验证器实例
</span><span class="c1"></span>		<span class="nx">val</span> <span class="o">:=</span> <span class="nx">validator</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

		<span class="c1">// 设置支持的语言
</span><span class="c1"></span>		<span class="nx">en</span> <span class="o">:=</span> <span class="nx">en</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
		<span class="nx">zh</span> <span class="o">:=</span> <span class="nx">zh</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
		<span class="c1">// 创建翻译器, 支持zh,en两种
</span><span class="c1"></span>		<span class="nx">uni</span> <span class="o">:=</span> <span class="nx">ut</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">zh</span><span class="p">,</span> <span class="nx">zh</span><span class="p">,</span><span class="nx">en</span><span class="p">)</span>
		<span class="c1">// 根据参数取翻译器实例
</span><span class="c1"></span>		<span class="nx">locale</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">DefaultQuery</span><span class="p">(</span><span class="s">&#34;locale&#34;</span><span class="p">,</span><span class="s">&#34;zh&#34;</span><span class="p">)</span>
		<span class="c1">// 获取默认的f.fallback
</span><span class="c1"></span>		<span class="nx">trans</span> <span class="p">,</span><span class="nx">_</span> <span class="o">:=</span> <span class="nx">uni</span><span class="p">.</span><span class="nf">GetTranslator</span><span class="p">(</span><span class="nx">locale</span><span class="p">)</span>

		<span class="c1">// 翻译器注册到验证器
</span><span class="c1"></span>		<span class="k">switch</span> <span class="nx">locale</span> <span class="p">{</span>
		<span class="k">case</span> <span class="s">&#34;en&#34;</span><span class="p">:</span>
			<span class="nx">_</span> <span class="p">=</span> <span class="nx">en_translations</span><span class="p">.</span><span class="nf">RegisterDefaultTranslations</span><span class="p">(</span><span class="nx">val</span><span class="p">,</span><span class="nx">trans</span><span class="p">)</span>
			<span class="nx">val</span><span class="p">.</span><span class="nf">RegisterTagNameFunc</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">fld</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">StructField</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">fld</span><span class="p">.</span><span class="nx">Tag</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;en_comment&#34;</span><span class="p">)</span>
			<span class="p">})</span>
			<span class="k">break</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="nx">_</span> <span class="p">=</span> <span class="nx">zh_translations</span><span class="p">.</span><span class="nf">RegisterDefaultTranslations</span><span class="p">(</span><span class="nx">val</span><span class="p">,</span><span class="nx">trans</span><span class="p">)</span>
			<span class="nx">val</span><span class="p">.</span><span class="nf">RegisterTagNameFunc</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">fld</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">StructField</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">fld</span><span class="p">.</span><span class="nx">Tag</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;comment&#34;</span><span class="p">)</span>
			<span class="p">})</span>

			<span class="c1">// 自定义的验证器
</span><span class="c1"></span>			<span class="nx">val</span><span class="p">.</span><span class="nf">RegisterValidation</span><span class="p">(</span><span class="s">&#34;test_tag&#34;</span><span class="p">,</span><span class="kd">func</span><span class="p">(</span><span class="nx">fl</span> <span class="nx">validator</span><span class="p">.</span><span class="nx">FieldLevel</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
				<span class="nx">matched</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MatchString</span><span class="p">(</span><span class="s">`^[_0-9a-zA-Z]{6,24}$`</span><span class="p">,</span><span class="nx">fl</span><span class="p">.</span><span class="nf">Field</span><span class="p">().</span><span class="nf">String</span><span class="p">())</span>
				<span class="k">return</span> <span class="nx">matched</span>
			<span class="p">})</span>

			<span class="c1">// 自定义的翻译器
</span><span class="c1"></span>			<span class="nx">val</span><span class="p">.</span><span class="nf">RegisterTranslation</span><span class="p">(</span><span class="s">&#34;test_tag&#34;</span><span class="p">,</span><span class="nx">trans</span><span class="p">,</span><span class="kd">func</span><span class="p">(</span><span class="nx">ut</span> <span class="nx">ut</span><span class="p">.</span><span class="nx">Translator</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">ut</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;test_tag&#34;</span><span class="p">,</span><span class="s">&#34;{0} 填写不正确,仅允许数字字母下划线,长度大于6小于24&#34;</span><span class="p">,</span><span class="kc">true</span>  <span class="p">)</span>
			<span class="p">},</span><span class="kd">func</span><span class="p">(</span><span class="nx">ut</span> <span class="nx">ut</span><span class="p">.</span><span class="nx">Translator</span><span class="p">,</span> <span class="nx">fe</span> <span class="nx">validator</span><span class="p">.</span><span class="nx">FieldError</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
				<span class="nx">t</span> <span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">ut</span><span class="p">.</span><span class="nf">T</span><span class="p">(</span><span class="s">&#34;test_tag&#34;</span><span class="p">,</span><span class="nx">fe</span><span class="p">.</span><span class="nf">Field</span><span class="p">())</span>
				<span class="k">return</span> <span class="nx">t</span>
			<span class="p">})</span>
			<span class="k">break</span>
		<span class="p">}</span>

		<span class="c1">// 设置翻译器和验证器
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">TranslatorKey</span><span class="p">,</span><span class="nx">trans</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">ValidatorKey</span><span class="p">,</span><span class="nx">val</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h3 id="4-中间件-middlewaresigngo">4. 中间件 middleware/sign.go</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">middleware</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
	<span class="s">&#34;github.com/pkg/errors&#34;</span>
	<span class="nx">config2</span> <span class="s">&#34;github.com/zhangzw001/learnGin/config&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/public&#34;</span>
	<span class="s">&#34;net/url&#34;</span>
	<span class="s">&#34;strconv&#34;</span>
<span class="p">)</span>



<span class="kd">func</span> <span class="nf">SignMiddleware</span><span class="p">()</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">HandlerFunc</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">method</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">Method</span>
		<span class="kd">var</span> <span class="nx">ts</span> <span class="kt">int64</span>
		<span class="kd">var</span> <span class="nx">sn</span> <span class="kt">string</span>
		<span class="kd">var</span> <span class="nx">req</span> <span class="nx">url</span><span class="p">.</span><span class="nx">Values</span>

		<span class="k">if</span> <span class="nx">method</span> <span class="o">==</span> <span class="s">&#34;GET&#34;</span> <span class="p">{</span>
			<span class="nx">req</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nf">Query</span><span class="p">()</span>
			<span class="nx">sn</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;sn&#34;</span><span class="p">)</span>
			<span class="nx">ts</span><span class="p">,</span> <span class="nx">_</span>  <span class="p">=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">ParseInt</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;ts&#34;</span><span class="p">),</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>

		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">method</span> <span class="o">==</span> <span class="s">&#34;POST&#34;</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nf">ParseForm</span><span class="p">()</span>
			<span class="nx">req</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">PostForm</span>
			<span class="nx">sn</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">PostForm</span><span class="p">(</span><span class="s">&#34;sn&#34;</span><span class="p">)</span>
			<span class="nx">ts</span><span class="p">,</span> <span class="nx">_</span>  <span class="p">=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">ParseInt</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">PostForm</span><span class="p">(</span><span class="s">&#34;ts&#34;</span><span class="p">),</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nf">ResponseError</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="mi">10000</span><span class="p">,</span><span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;Illegal requests&#34;</span><span class="p">))</span>
			<span class="k">return</span>
		<span class="p">}</span>

		<span class="nx">exp</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">ParseInt</span><span class="p">(</span><span class="nx">config2</span><span class="p">.</span><span class="nx">ApiExpiry</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>

		<span class="c1">// 验证过期时间
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">ts</span> <span class="p">&gt;</span> <span class="nx">public</span><span class="p">.</span><span class="nf">GetTimeUnix</span><span class="p">()</span> <span class="o">||</span> <span class="nx">public</span><span class="p">.</span><span class="nf">GetTimeUnix</span><span class="p">()</span> <span class="o">-</span> <span class="nx">ts</span> <span class="o">&gt;=</span> <span class="nx">exp</span> <span class="p">{</span>
			<span class="nf">ResponseError</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="mi">10001</span><span class="p">,</span><span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;Ts Error&#34;</span><span class="p">))</span>
			<span class="k">return</span>
		<span class="p">}</span>

		<span class="c1">// 验证签名
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">sn</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="o">||</span> <span class="nx">sn</span> <span class="o">!=</span> <span class="nx">public</span><span class="p">.</span><span class="nf">CreateSign</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span> <span class="p">{</span>
			<span class="nf">ResponseError</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="mi">10002</span><span class="p">,</span><span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;Sn Error&#34;</span><span class="p">))</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="c1">//
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h3 id="5-统一的返回参-middlewareresponsego">5. 统一的返回参 middleware/response.go</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">middleware</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;encoding/json&#34;</span>
	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">ResponseCode</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">SuccessCode</span> <span class="nx">ResponseCode</span> <span class="p">=</span> <span class="mi">200</span> <span class="o">+</span> <span class="kc">iota</span>
	<span class="nx">StatusCreated</span>
	<span class="nx">StatusAccepted</span>
	<span class="nx">InternalServerError</span> <span class="nx">ResponseCode</span> <span class="p">=</span> <span class="mi">500</span>
	<span class="nx">CustomizeCode</span>           <span class="p">=</span> <span class="mi">1000</span>
	<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Response</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Code</span> <span class="nx">ResponseCode</span> <span class="s">`json:&#34;code&#34;`</span>
	<span class="nx">Msg</span>  <span class="kt">string</span>       <span class="s">`json:&#34;msg&#34;`</span>
	<span class="nx">Data</span> <span class="kd">interface</span><span class="p">{}</span>  <span class="s">`json:&#34;data&#34;`</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">ResponseSuccess</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nx">resp</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Response</span><span class="p">{</span>
		<span class="nx">Code</span><span class="p">:</span> <span class="nx">SuccessCode</span><span class="p">,</span>
		<span class="nx">Msg</span><span class="p">:</span>  <span class="s">&#34;ok&#34;</span><span class="p">,</span>
		<span class="nx">Data</span><span class="p">:</span> <span class="nx">data</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="nx">resp</span><span class="p">)</span>
	<span class="nx">response</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="nx">resp</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;response&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">response</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">ResponseError</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">code</span> <span class="nx">ResponseCode</span><span class="p">,</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">resp</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Response</span><span class="p">{</span>
		<span class="nx">Code</span><span class="p">:</span> <span class="nx">code</span><span class="p">,</span>
		<span class="nx">Msg</span><span class="p">:</span>  <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">(),</span>
		<span class="nx">Data</span><span class="p">:</span> <span class="s">&#34;&#34;</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="nx">resp</span><span class="p">)</span>
	<span class="nx">response</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="nx">resp</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;response&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">response</span><span class="p">))</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">AbortWithError</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><h3 id="6-配置文件-configenvgo">6. 配置文件 config/env.go</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">config</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">PORT</span>      <span class="p">=</span> <span class="s">&#34;:8000&#34;</span>
	<span class="nx">AppName</span>   <span class="p">=</span> <span class="s">&#34;test&#34;</span>
	<span class="nx">AppSecret</span> <span class="p">=</span> <span class="s">&#34;test.123&#34;</span>
	<span class="nx">ApiExpiry</span> <span class="p">=</span> <span class="s">&#34;1200&#34;</span>

	<span class="nx">LogFilePath</span> <span class="p">=</span> <span class="s">&#34;logs&#34;</span>
	<span class="nx">LogFileName</span> <span class="p">=</span> <span class="s">&#34;gin-logger.log&#34;</span>

	<span class="nx">ValidatorKey</span>  <span class="p">=</span> <span class="s">&#34;ValidatorKey&#34;</span>
	<span class="nx">TranslatorKey</span> <span class="p">=</span> <span class="s">&#34;TranslatorKey&#34;</span>
<span class="p">)</span>
</code></pre></div><h3 id="maingo">main.go</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/config&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/routers&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

	<span class="nx">gin</span><span class="p">.</span><span class="nf">SetMode</span><span class="p">(</span><span class="nx">gin</span><span class="p">.</span><span class="nx">DebugMode</span><span class="p">)</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">Default</span><span class="p">()</span>
	<span class="nx">routers</span><span class="p">.</span><span class="nf">InitRouter</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
	<span class="nx">e</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">PORT</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Google资深工程师深度讲解Go语言 Elastic简单使用</title>
			<link>https://www.ngirl.xyz/golang/google%E8%B5%84%E6%B7%B1%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%B7%B1%E5%BA%A6%E8%AE%B2%E8%A7%A3go%E8%AF%AD%E8%A8%80-elastic%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</link>
			<pubDate>Wed, 06 Jan 2021 14:27:27 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/google%E8%B5%84%E6%B7%B1%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%B7%B1%E5%BA%A6%E8%AE%B2%E8%A7%A3go%E8%AF%AD%E8%A8%80-elastic%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</guid>
			<description></description>
			<content type="html"><![CDATA[<h3 id="elastic-检查查询">elastic 检查查询</h3>
<pre><code># 查询 女, 已购房 年龄小于22岁
http://172.16.76.220:9200/crawler/youyuan/_search?q=女  AND 已购房  AND Payload.Age:(&lt;22)
</code></pre>]]></content>
		</item>
		
		<item>
			<title>Google资深工程师深度讲解Go语言 单任务爬虫</title>
			<link>https://www.ngirl.xyz/golang/google%E8%B5%84%E6%B7%B1%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%B7%B1%E5%BA%A6%E8%AE%B2%E8%A7%A3go%E8%AF%AD%E8%A8%80-%E5%8D%95%E4%BB%BB%E5%8A%A1%E7%88%AC%E8%99%AB/</link>
			<pubDate>Mon, 21 Dec 2020 18:03:36 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/google%E8%B5%84%E6%B7%B1%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%B7%B1%E5%BA%A6%E8%AE%B2%E8%A7%A3go%E8%AF%AD%E8%A8%80-%E5%8D%95%E4%BB%BB%E5%8A%A1%E7%88%AC%E8%99%AB/</guid>
			<description>&lt;p&gt;由于教程的代码在zhenai.com更新之后无法访问,所以记录下代码改动&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>由于教程的代码在zhenai.com更新之后无法访问,所以记录下代码改动</p>
<h3 id="问题说明">问题说明</h3>
<p>这里在首页和城市列表页访问是没有问题的, curl请求也是正常, 但是当请求到用户信息的时候, 是需要UA 和cookie的
没有UA 会提示403, 没有cookie会提示 202</p>
<h3 id="fetchergo-代码">fetcher.go 代码</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">fetcher</span>

<span class="kn">import</span> <span class="p">(</span>
 <span class="s">&#34;bufio&#34;</span>
 <span class="s">&#34;fmt&#34;</span>
 <span class="s">&#34;golang.org/x/net/html/charset&#34;</span>
 <span class="s">&#34;golang.org/x/text/encoding&#34;</span>
 <span class="s">&#34;golang.org/x/text/encoding/unicode&#34;</span>
 <span class="s">&#34;golang.org/x/text/transform&#34;</span>
 <span class="s">&#34;io/ioutil&#34;</span>
 <span class="s">&#34;log&#34;</span>
 <span class="s">&#34;net/http&#34;</span>
 <span class="s">&#34;strings&#34;</span>
<span class="p">)</span>


<span class="kd">func</span> <span class="nf">Fetch</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
 <span class="nx">client</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">http</span><span class="p">.</span><span class="nx">Client</span><span class="p">{}</span>
 <span class="nx">newUrl</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Replace</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span> <span class="s">&#34;http://&#34;</span><span class="p">,</span><span class="s">&#34;https://&#34;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
 <span class="nx">request</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">NewRequest</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">MethodGet</span><span class="p">,</span> <span class="nx">newUrl</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
 <span class="p">}</span>
 <span class="c1">//添加header
</span><span class="c1"></span> <span class="nx">request</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Referer&#34;</span><span class="p">,</span><span class="s">&#34;http://www.zhenai.com/&#34;</span><span class="p">)</span>
 <span class="nx">request</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;User-Agent&#34;</span><span class="p">,</span><span class="s">&#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&#34;</span><span class="p">)</span>
 <span class="c1">//这里cookie只有1分钟有效期
</span><span class="c1"></span> <span class="nx">request</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;cookie&#34;</span><span class="p">,</span><span class="s">&#34;FSSBBIl1UgzbN7NO=53ZIxjnyRAeDyH5t9pg7cBA7QAYBxvaF7jmWYAZu2.CGt7mB9u9LeMhKl8ljte21zs7CWozraQ0E5VOTTi2KxSa; FSSBBIl1UgzbN7NP=5U5rnkYdGQG7qqqmCfWUuTapalzEu3wBuwQIl47nXp0HkSYoWXO9YSlekNkkwawdb3zC2rSWIE1_qIWRw3n3..NPhTqKwJXHroqsoGBqaeo_dgsIn64FK2YWZU6Y6L_l6d6tC7YBN8SMAPRcMqpmfS_9Jw.J8tXrIUZ6bUSeDufFFL1lNf8p4Om5i4P2teK4H1gnsMEldbBc9MLc1xhrJ7yLwLZhXr_mi2AhSHpshGFF7BkPzO_5ye_HaYME37Ukhc9MqOaqdytUs.ZebVaXEo7; Hm_lvt_2c8ad67df9e787ad29dbd54ee608f5d2=1608543698; Hm_lpvt_2c8ad67df9e787ad29dbd54ee608f5d2=1608544780; sid=d399176c-21e3-4e91-b550-fa8656de10e1; _exid=Fj3xNob61luAF5gXz5MAJq5CxrtoI86y%2Bqoc4YZ%2F64joUS0XSSIaALTyeW81WLbDLc0Pzw0kcM1r%2FGU1gm%2F2lA%3D%3D; ec=DH5wblNm-1608543720671-6a5cbb1e341df-781494537; _efmdata=HZvSyojNYRIMPbor%2FAzLk%2B5xwF4NLHTxU22OynbdfqEpXG7eNyAO1kHkZ%2FWDHgT7hGdqxoGwjueLMevvIv%2FF3upAu3SmFFc2zAJsHFMNjAc%3D&#34;</span><span class="p">)</span>

 <span class="nx">resp</span> <span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="nx">request</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
 <span class="p">}</span>
 <span class="k">defer</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
 <span class="k">if</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">StatusCode</span> <span class="o">!=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;wrong status code: %d&#34;</span><span class="p">,</span><span class="nx">resp</span><span class="p">.</span><span class="nx">StatusCode</span><span class="p">)</span>
 <span class="p">}</span>

 <span class="nx">bodyReader</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
 <span class="nx">e</span> <span class="o">:=</span> <span class="nf">determineEncoding</span><span class="p">(</span><span class="nx">bodyReader</span><span class="p">)</span>
 <span class="nx">uft8Reader</span> <span class="o">:=</span> <span class="nx">transform</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">bodyReader</span><span class="p">,</span><span class="nx">e</span><span class="p">.</span><span class="nf">NewDecoder</span><span class="p">())</span>
 <span class="k">return</span>  <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadAll</span><span class="p">(</span><span class="nx">uft8Reader</span><span class="p">)</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="nf">determineEncoding</span><span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">bufio</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">Encoding</span> <span class="p">{</span>
 <span class="nx">bytes</span> <span class="p">,</span><span class="nx">err</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Peek</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Fetcher error : %v&#34;</span><span class="p">,</span><span class="nx">err</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">unicode</span><span class="p">.</span><span class="nx">UTF8</span>
 <span class="p">}</span>

 <span class="nx">e</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">charset</span><span class="p">.</span><span class="nf">DetermineEncoding</span><span class="p">(</span><span class="nx">bytes</span><span class="p">,</span><span class="s">&#34;&#34;</span><span class="p">)</span>
 <span class="k">return</span> <span class="nx">e</span>
<span class="p">}</span>

</code></pre></div><h3 id="profile_testgo-测试一下">profile_test.go 测试一下</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">parser</span>

<span class="kn">import</span> <span class="p">(</span>
 <span class="s">&#34;learngo_crawler/fetcher&#34;</span>
 <span class="s">&#34;testing&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">TestParseProfile</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
 <span class="nx">contents</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fetcher</span><span class="p">.</span><span class="nf">Fetch</span><span class="p">(</span><span class="s">&#34;https://album.zhenai.com/u/1715998969&#34;</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
 <span class="p">}</span>
 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s\n&#34;</span><span class="p">,</span><span class="nx">contents</span><span class="p">)</span>
 <span class="nf">ParseProfile</span><span class="p">(</span><span class="nx">contents</span><span class="p">)</span>
<span class="p">}</span>


</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Google资深工程师深度讲解Go语言-广度优先算法学习-迷宫</title>
			<link>https://www.ngirl.xyz/golang/google%E8%B5%84%E6%B7%B1%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%B7%B1%E5%BA%A6%E8%AE%B2%E8%A7%A3go%E8%AF%AD%E8%A8%80-%E5%B9%BF%E5%BA%A6%E6%B7%B1%E5%BA%A6%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E8%BF%B7%E5%AE%AB/</link>
			<pubDate>Fri, 18 Dec 2020 18:00:44 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/google%E8%B5%84%E6%B7%B1%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%B7%B1%E5%BA%A6%E8%AE%B2%E8%A7%A3go%E8%AF%AD%E8%A8%80-%E5%B9%BF%E5%BA%A6%E6%B7%B1%E5%BA%A6%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E8%BF%B7%E5%AE%AB/</guid>
			<description>这里学习了Google吱声工程师深度讲解go语言-迷宫广度优先算法以记录
算法说明 图源: 图解迷宫算法（广度优先遍历)
首先看一张迷宫图, 左右黄色0 表示起始点, 0 表示可以行走, 1表示墙体 迷宫的广度优先算法的意思是, 可以通过0 发现四个方向的1, 然后在通过四个1 发现所有的2, 所有的2探索完 , 在探索3&amp;hellip; 以此类推&amp;hellip; 这里每个点都有三种状态:  未发现 已发现未探索 已探索  最终我们能探索到这样的结果图: 下面是详细代码 代码结构 ── maze ├── maze.go └── maze.in maze.in文件 6 5 0 1 0 0 0 0 0 0 1 0 0 1 0 1 0 1 1 1 0 0 0 1 0 0 1 0 1 0 0 0 maze.go package main import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;os&amp;#34; ) /* maze.</description>
			<content type="html"><![CDATA[<p>这里学习了Google吱声工程师深度讲解go语言-迷宫广度优先算法以记录</p>
<!-- more -->
<h3 id="算法说明">算法说明</h3>
<p>图源: <a href="https://www.pianshen.com/article/8849857777/">图解迷宫算法（广度优先遍历)</a></p>
<h4 id="首先看一张迷宫图-左右黄色0-表示起始点-0-表示可以行走-1表示墙体">首先看一张迷宫图, 左右黄色0 表示起始点, 0 表示可以行走, 1表示墙体</h4>
<p><img src="//zhangzw001.github.io/images/golang/maze-01.png" alt=""></p>
<p>迷宫的广度优先算法的意思是, 可以通过0 发现四个方向的1, 然后在通过四个1 发现所有的2, 所有的2探索完 , 在探索3&hellip;
<img src="//zhangzw001.github.io/images/golang/maze-02.png" alt=""></p>
<p>以此类推&hellip;
<img src="//zhangzw001.github.io/images/golang/maze-03.png" alt=""></p>
<h4 id="这里每个点都有三种状态">这里每个点都有三种状态:</h4>
<ul>
<li>未发现</li>
<li>已发现未探索</li>
<li>已探索</li>
</ul>
<p>最终我们能探索到这样的结果图:
<img src="//zhangzw001.github.io/images/golang/maze-04.png" alt=""></p>
<h3 id="下面是详细代码">下面是详细代码</h3>
<h4 id="代码结构">代码结构</h4>
<pre><code>── maze
   ├── maze.go
   └── maze.in
</code></pre><h4 id="mazein文件">maze.in文件</h4>
<pre><code>6 5
0 1 0 0 0
0 0 0 1 0
0 1 0 1 0
1 1 1 0 0
0 1 0 0 1
0 1 0 0 0
</code></pre><h4 id="mazego">maze.go</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
 <span class="s">&#34;fmt&#34;</span>
 <span class="s">&#34;log&#34;</span>
 <span class="s">&#34;os&#34;</span>
<span class="p">)</span>

<span class="cm">/*
</span><span class="cm">maze.in
</span><span class="cm">6 5
</span><span class="cm">0 1 0 0 0
</span><span class="cm">0 0 0 1 0
</span><span class="cm">0 1 0 1 0
</span><span class="cm">1 1 1 0 0
</span><span class="cm">0 1 0 0 1
</span><span class="cm">0 1 0 0 0
</span><span class="cm">
</span><span class="cm">- 未探索
</span><span class="cm">- 已发现未探索
</span><span class="cm">- 已探索
</span><span class="cm">
</span><span class="cm">- 广度优先算法 -&gt; 把所有的1全部探索完,再探索2
</span><span class="cm">*/</span>

<span class="kd">func</span> <span class="nf">readMaze</span><span class="p">(</span><span class="nx">filename</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
 <span class="nx">file</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
 <span class="p">}</span>
 <span class="k">defer</span> <span class="nx">file</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

 <span class="kd">var</span> <span class="nx">row</span><span class="p">,</span> <span class="nx">col</span> <span class="kt">int</span>
 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fscanf</span><span class="p">(</span><span class="nx">file</span><span class="p">,</span> <span class="s">&#34;%d %d&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">row</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">col</span><span class="p">)</span>
 <span class="nx">maze</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">row</span><span class="p">)</span>
 <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">maze</span> <span class="p">{</span>
  <span class="nx">maze</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">col</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">maze</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fscanf</span><span class="p">(</span><span class="nx">file</span><span class="p">,</span> <span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">maze</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">])</span>
  <span class="p">}</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="nx">maze</span>

<span class="p">}</span>

<span class="kd">type</span> <span class="nx">point</span> <span class="kd">struct</span> <span class="p">{</span>
 <span class="nx">i</span> <span class="kt">int</span>
 <span class="nx">j</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">dirs</span> <span class="p">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="nx">point</span><span class="p">{</span>
 <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="c1">//上
</span><span class="c1"></span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">},</span> <span class="c1">//左
</span><span class="c1"></span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>  <span class="c1">//下
</span><span class="c1"></span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>  <span class="c1">//右
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">//用值类型, 返回新的point
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">point</span><span class="p">)</span> <span class="nf">add</span><span class="p">(</span><span class="nx">po</span> <span class="nx">point</span><span class="p">)</span> <span class="nx">point</span> <span class="p">{</span>
 <span class="k">return</span> <span class="nx">point</span><span class="p">{</span><span class="nx">p</span><span class="p">.</span><span class="nx">i</span> <span class="o">+</span> <span class="nx">po</span><span class="p">.</span><span class="nx">i</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">j</span> <span class="o">+</span> <span class="nx">po</span><span class="p">.</span><span class="nx">j</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">point</span><span class="p">)</span> <span class="nf">notOver</span><span class="p">(</span><span class="nx">grid</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
 <span class="c1">//是否越界
</span><span class="c1"></span> <span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">p</span><span class="p">.</span><span class="nx">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">grid</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">false</span>
 <span class="p">}</span>
 <span class="c1">//if p.j &lt; 0 || p.j &gt;= len(grid[p.i]) {
</span><span class="c1"></span> <span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">j</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">p</span><span class="p">.</span><span class="nx">j</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">false</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">point</span><span class="p">)</span> <span class="nf">at</span><span class="p">(</span><span class="nx">grid</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>

 <span class="k">if</span> <span class="p">!</span><span class="nx">p</span><span class="p">.</span><span class="nf">notOver</span><span class="p">(</span><span class="nx">grid</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">false</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="nx">grid</span><span class="p">[</span><span class="nx">p</span><span class="p">.</span><span class="nx">i</span><span class="p">][</span><span class="nx">p</span><span class="p">.</span><span class="nx">j</span><span class="p">],</span> <span class="kc">true</span>

<span class="p">}</span>
<span class="kd">func</span> <span class="nf">walk</span><span class="p">(</span><span class="nx">maze</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">end</span> <span class="nx">point</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
 <span class="nx">steps</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">maze</span><span class="p">))</span>
 <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">steps</span> <span class="p">{</span>
  <span class="nx">steps</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">maze</span><span class="p">[</span><span class="nx">i</span><span class="p">]))</span>
 <span class="p">}</span>
 <span class="c1">//队列
</span><span class="c1"></span> <span class="nx">Q</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">point</span><span class="p">{</span><span class="nx">start</span><span class="p">}</span>

 <span class="c1">//开始探索
</span><span class="c1"></span> <span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">Q</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
  <span class="c1">// 探索头
</span><span class="c1"></span>  <span class="nx">cur</span> <span class="o">:=</span> <span class="nx">Q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="nx">Q</span> <span class="p">=</span> <span class="nx">Q</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

  <span class="c1">// 终端
</span><span class="c1"></span>  <span class="k">if</span> <span class="nx">cur</span> <span class="o">==</span> <span class="nx">end</span> <span class="p">{</span>
   <span class="k">break</span>
  <span class="p">}</span>

  <span class="c1">// 探索
</span><span class="c1"></span>  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">dir</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dirs</span> <span class="p">{</span>
   <span class="c1">//得到下一个点的坐标
</span><span class="c1"></span>   <span class="nx">next</span> <span class="o">:=</span> <span class="nx">cur</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">dir</span><span class="p">)</span>

   <span class="c1">// maze at next is 0
</span><span class="c1"></span>   <span class="c1">// and steps at next is 0
</span><span class="c1"></span>   <span class="c1">// and next != start
</span><span class="c1"></span>   <span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">next</span><span class="p">.</span><span class="nf">at</span><span class="p">(</span><span class="nx">maze</span><span class="p">)</span>
   <span class="c1">// 撞墙
</span><span class="c1"></span>   <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="o">||</span> <span class="nx">val</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
    <span class="k">continue</span>
   <span class="p">}</span>

   <span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">next</span><span class="p">.</span><span class="nf">at</span><span class="p">(</span><span class="nx">steps</span><span class="p">)</span>
   <span class="c1">// 不等于0 说明走过的
</span><span class="c1"></span>   <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="o">||</span> <span class="nx">val</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="k">continue</span>
   <span class="p">}</span>

   <span class="c1">// 原点
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">next</span> <span class="o">==</span> <span class="nx">start</span> <span class="p">{</span>
    <span class="k">continue</span>
   <span class="p">}</span>

   <span class="c1">//当前步骤数
</span><span class="c1"></span>   <span class="nx">curSteps</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">cur</span><span class="p">.</span><span class="nf">at</span><span class="p">(</span><span class="nx">steps</span><span class="p">)</span>
   <span class="nx">steps</span><span class="p">[</span><span class="nx">next</span><span class="p">.</span><span class="nx">i</span><span class="p">][</span><span class="nx">next</span><span class="p">.</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">curSteps</span> <span class="o">+</span> <span class="mi">1</span>

   <span class="nx">Q</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">Q</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span>
  <span class="p">}</span>
 <span class="p">}</span>

 <span class="k">return</span> <span class="nx">steps</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">walkLine</span><span class="p">(</span><span class="nx">steps</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">end</span> <span class="nx">point</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
 <span class="nx">newTable</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">steps</span><span class="p">))</span>
 <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">newTable</span> <span class="p">{</span>
  <span class="nx">newTable</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">steps</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
 <span class="p">}</span>

 <span class="nx">newTable</span><span class="p">[</span><span class="nx">end</span><span class="p">.</span><span class="nx">i</span><span class="p">][</span><span class="nx">end</span><span class="p">.</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">steps</span><span class="p">[</span><span class="nx">end</span><span class="p">.</span><span class="nx">i</span><span class="p">][</span><span class="nx">end</span><span class="p">.</span><span class="nx">j</span><span class="p">]</span>

 <span class="c1">//这里不需要队列, 因为只会找到一个值
</span><span class="c1"></span> <span class="nx">Q</span> <span class="o">:=</span> <span class="nx">end</span>
 <span class="c1">// 如果不是开头, 就继续找
</span><span class="c1"></span> <span class="k">for</span> <span class="nx">Q</span> <span class="o">!=</span> <span class="nx">start</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">dir</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dirs</span> <span class="p">{</span>
   <span class="c1">//得到下一个点的坐标
</span><span class="c1"></span>   <span class="nx">next</span> <span class="o">:=</span> <span class="nx">Q</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">dir</span><span class="p">)</span>
   <span class="c1">//是否越界
</span><span class="c1"></span>   <span class="k">if</span> <span class="p">!</span><span class="nx">next</span><span class="p">.</span><span class="nf">notOver</span><span class="p">(</span><span class="nx">steps</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">continue</span>
   <span class="p">}</span>
   <span class="c1">// 如果这个[坐标的值]=[当前坐标值]-1, 那就找到了,把这个坐标记录一下, 待会用这个坐标继续探索
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">steps</span><span class="p">[</span><span class="nx">next</span><span class="p">.</span><span class="nx">i</span><span class="p">][</span><span class="nx">next</span><span class="p">.</span><span class="nx">j</span><span class="p">]</span> <span class="o">==</span> <span class="nx">steps</span><span class="p">[</span><span class="nx">Q</span><span class="p">.</span><span class="nx">i</span><span class="p">][</span><span class="nx">Q</span><span class="p">.</span><span class="nx">j</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
    <span class="nx">newTable</span><span class="p">[</span><span class="nx">next</span><span class="p">.</span><span class="nx">i</span><span class="p">][</span><span class="nx">next</span><span class="p">.</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">steps</span><span class="p">[</span><span class="nx">next</span><span class="p">.</span><span class="nx">i</span><span class="p">][</span><span class="nx">next</span><span class="p">.</span><span class="nx">j</span><span class="p">]</span>
    <span class="nx">Q</span> <span class="p">=</span> <span class="nx">next</span>
   <span class="p">}</span>
  <span class="p">}</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="nx">newTable</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;&gt;&gt;&gt;&gt;&gt;&gt; 迷宫图如下:&#34;</span><span class="p">)</span>

 <span class="nx">maze</span> <span class="o">:=</span> <span class="nf">readMaze</span><span class="p">(</span><span class="s">&#34;maze/maze.in&#34;</span><span class="p">)</span>
 <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">row</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">maze</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">val</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">row</span> <span class="p">{</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%3d &#34;</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">()</span>
 <span class="p">}</span>

 <span class="nx">steps</span> <span class="o">:=</span> <span class="nf">walk</span><span class="p">(</span><span class="nx">maze</span><span class="p">,</span> <span class="nx">point</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="nx">point</span><span class="p">{</span><span class="nb">len</span><span class="p">(</span><span class="nx">maze</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">maze</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">})</span>
 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;&gt;&gt;&gt;&gt;&gt;&gt; 探索图如下:&#34;</span><span class="p">)</span>

 <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">row</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">steps</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">val</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">row</span> <span class="p">{</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%3d &#34;</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">()</span>
 <span class="p">}</span>
 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;&gt;&gt;&gt;&gt;&gt;&gt; 行走路线图如下:&#34;</span><span class="p">)</span>
 <span class="nx">newSteps</span> <span class="o">:=</span> <span class="nf">walkLine</span><span class="p">(</span><span class="nx">steps</span><span class="p">,</span> <span class="nx">point</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="nx">point</span><span class="p">{</span><span class="nb">len</span><span class="p">(</span><span class="nx">maze</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">maze</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">})</span>
 <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">row</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">newSteps</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">val</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">row</span> <span class="p">{</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%3d &#34;</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">()</span>
 <span class="p">}</span>
<span class="p">}</span>


</code></pre></div><h4 id="执行结果如下">执行结果如下:</h4>
<pre><code>&gt;&gt;&gt;&gt;&gt;&gt; 迷宫图如下:
  0   1   0   0   0
  0   0   0   1   0
  0   1   0   1   0
  1   1   1   0   0
  0   1   0   0   1
  0   1   0   0   0
&gt;&gt;&gt;&gt;&gt;&gt; 探索图如下:
  0   0   4   5   6
  1   2   3   0   7
  2   0   4   0   8
  0   0   0  10   9
  0   0  12  11   0
  0   0  13  12  13
&gt;&gt;&gt;&gt;&gt;&gt; 行走路线图如下:
  0   0   4   5   6
  1   2   3   0   7
  0   0   0   0   8
  0   0   0  10   9
  0   0   0  11   0
  0   0   0  12  13

</code></pre>]]></content>
		</item>
		
	</channel>
</rss>
