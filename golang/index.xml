<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Golangs on zhangzw</title>
		<link>https://www.ngirl.xyz/golang/</link>
		<description>Recent content in Golangs on zhangzw</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>zh-hans</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Thu, 17 Mar 2022 14:16:09 +0800</lastBuildDate>
		<atom:link href="https://www.ngirl.xyz/golang/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Go学习 6.824 lab2 raft2B</title>
			<link>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-6.824-lab2-raft2b/</link>
			<pubDate>Thu, 17 Mar 2022 14:16:09 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-6.824-lab2-raft2b/</guid>
			<description>文档  Raft-Extended 论文翻译 MIT 6.824 Lab2 实验翻译  简单记录 </description>
			<content type="html"><![CDATA[<h3 id="文档">文档</h3>
<ul>
<li><a href="https://blog.csdn.net/Hedon954/article/details/119186225">Raft-Extended 论文翻译</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/248686289">MIT 6.824 Lab2 实验翻译</a></li>
</ul>
<h3 id="简单记录">简单记录</h3>
<pre><code></code></pre>]]></content>
		</item>
		
		<item>
			<title>Go学习 6.824 lab2 raft2A</title>
			<link>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-6.824-lab2-raft2a/</link>
			<pubDate>Mon, 07 Mar 2022 17:58:09 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-6.824-lab2-raft2a/</guid>
			<description>文档  Raft-Extended 论文翻译 MIT 6.824 Lab2 实验翻译  实现 Raft Leader选举和心跳检测 首先对Raft-Extended的相关几点做个说明 1. raft集群在 ticker 超时 后进行选举, 节点未收到心跳检测就会发起选举 2. 选举的节点会存在几种状态切换 follower -&amp;gt; candidate : 开始选举的时候 candidate -&amp;gt; leader : 选举成功的时候 candidate -&amp;gt; follower : 选举失败的时候 leader -&amp;gt; follower : 旧的过期节点 对于 candidate -&amp;gt; candidate的情况, 这里是被分解成 candidate -&amp;gt; follower -&amp;gt; candidate 3. raft节点会在延迟不同的时间后 在切换成 candidate, 防止多节点同时切换 4. raft节点在成为 candidate 后, 会并发向每个节点发一次 RequestVote 来进行投票, 然后等到有半数同意就成为leader 并启动goroutine 进行持续心跳检测(AppendEntries RPC), 如果没有人同意那么就没人成为leader会等到下次超时发起新的选举 在成为leader之前, raft节点同样可能收到别的 旧leader发来的AppendEntries RPC, 所以在 AppendEntries RPC 方法里面,我们需要如下判断: i) 如果收到的任期号小于当前任期号, 那么直接拒绝忽略 ii) 如果收到的任期号大于等于那就做如下修改: 把自己的状态改为 follower, 记录候选人id, 领导人id , 修改自己的当前任期号 和已提交任期号 代码部分 raft结构体中的Log type Raft struct { .</description>
			<content type="html"><![CDATA[<h3 id="文档">文档</h3>
<ul>
<li><a href="https://blog.csdn.net/Hedon954/article/details/119186225">Raft-Extended 论文翻译</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/248686289">MIT 6.824 Lab2 实验翻译</a></li>
</ul>
<h3 id="实现-raft-leader选举和心跳检测">实现 Raft Leader选举和心跳检测</h3>
<h4 id="首先对raft-extended的相关几点做个说明">首先对Raft-Extended的相关几点做个说明</h4>
<pre><code>1. raft集群在 ticker 超时 后进行选举, 节点未收到心跳检测就会发起选举
2. 选举的节点会存在几种状态切换
    follower  -&gt; candidate : 开始选举的时候
    candidate -&gt; leader    : 选举成功的时候
    candidate -&gt; follower  : 选举失败的时候
    leader    -&gt; follower  : 旧的过期节点
    对于 candidate -&gt; candidate的情况, 这里是被分解成 candidate -&gt; follower -&gt; candidate
3. raft节点会在延迟不同的时间后 在切换成 candidate, 防止多节点同时切换
4. raft节点在成为 candidate 后, 会并发向每个节点发一次 RequestVote 来进行投票, 然后等到有半数同意就成为leader 并启动goroutine 进行持续心跳检测(AppendEntries RPC), 如果没有人同意那么就没人成为leader会等到下次超时发起新的选举
    在成为leader之前, raft节点同样可能收到别的 旧leader发来的AppendEntries RPC, 所以在 AppendEntries RPC 方法里面,我们需要如下判断:
    i) 如果收到的任期号小于当前任期号, 那么直接拒绝忽略
    ii) 如果收到的任期号大于等于那就做如下修改:
       把自己的状态改为 follower, 记录候选人id, 领导人id , 修改自己的当前任期号 和已提交任期号

</code></pre><h3 id="代码部分">代码部分</h3>
<h4 id="raft结构体中的log">raft结构体中的Log</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Raft</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="nx">log</span> <span class="o">*</span><span class="nx">Log</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">Log</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">mu</span>	 <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
	<span class="nx">leaderID</span>   <span class="kt">int</span>	   <span class="c1">// leaderID, 表示当前集群已经选举完成
</span><span class="c1"></span>	<span class="nx">votedFor</span>   <span class="kt">int</span>	   <span class="c1">// 当前获得选票的候选人id, -1表示没有人获得选票, 用于一个节点值会给一个候选人投票
</span><span class="c1"></span>	<span class="nx">role</span>       <span class="kt">int</span>	   <span class="c1">// 节点处在什么角色, follower,candidate,leader
</span><span class="c1"></span>	<span class="nx">currTerm</span>   <span class="kt">int</span>	   <span class="c1">// 当前任期号
</span><span class="c1"></span>	<span class="nx">eleRelay</span>   <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="c1">// 选举定时器
</span><span class="c1"></span>	<span class="nx">ticker</span>     <span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Ticker</span>
	<span class="nx">isElect</span>    <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">r</span>	   <span class="p">=</span> <span class="nf">newRand</span><span class="p">()</span>
	<span class="nx">newDalyFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">vari</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">i</span><span class="o">+</span><span class="nx">r</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="nx">vari</span><span class="p">))</span>
	<span class="p">}</span>
<span class="p">)</span>
</code></pre></div><h4 id="make-方法">make 方法</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="kd">func</span> <span class="nf">Make</span><span class="p">(</span><span class="nx">peers</span> <span class="p">[]</span><span class="o">*</span><span class="nx">labrpc</span><span class="p">.</span><span class="nx">ClientEnd</span><span class="p">,</span> <span class="nx">me</span> <span class="kt">int</span><span class="p">,</span>
	<span class="nx">persister</span> <span class="o">*</span><span class="nx">Persister</span><span class="p">,</span> <span class="nx">applyCh</span> <span class="kd">chan</span> <span class="nx">ApplyMsg</span><span class="p">)</span> <span class="o">*</span><span class="nx">Raft</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="c1">// Your initialization code here (2A, 2B, 2C).
</span><span class="c1"></span>	<span class="nx">rf</span><span class="p">.</span><span class="nx">log</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Log</span><span class="p">{</span>
		<span class="nx">ticker</span><span class="p">:</span>   <span class="nx">time</span><span class="p">.</span><span class="nf">NewTicker</span><span class="p">(</span><span class="nf">newDalyFunc</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="p">)),</span>
		<span class="nx">isElect</span><span class="p">:</span>  <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}),</span>
		<span class="nx">eleRelay</span><span class="p">:</span> <span class="nf">newDalyFunc</span><span class="p">(</span><span class="mi">150</span><span class="p">,</span> <span class="mi">150</span><span class="p">),</span>
		<span class="nx">votedFor</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="c1">// 选举的随机时间
</span><span class="c1"></span>	<span class="k">go</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">Election</span><span class="p">()</span>

	<span class="o">...</span>
<span class="p">}</span>
</code></pre></div><h4 id="选举主进程-election">选举主进程 Election</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">rf</span> <span class="o">*</span><span class="nx">Raft</span><span class="p">)</span> <span class="nf">Election</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="c1">// 收到选举的请求
</span><span class="c1"></span>		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">isElect</span><span class="p">:</span>
			<span class="c1">// 开始选举
</span><span class="c1"></span>			<span class="k">go</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">startElect</span><span class="p">()</span>
		<span class="c1">// 定时器超时, 没有收到心跳检测
</span><span class="c1"></span>		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">ticker</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
			<span class="c1">// 需要选举
</span><span class="c1"></span>			<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">isElect</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
			<span class="p">}()</span>
		<span class="k">default</span><span class="p">:</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="选举方法">选举方法</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">rf</span> <span class="o">*</span><span class="nx">Raft</span><span class="p">)</span> <span class="nf">startElect</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 发送投票 并提交
</span><span class="c1"></span>	<span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">ticker</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
	<span class="c1">// 并且设置所有 votedFor 都为-1
</span><span class="c1"></span>	<span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nf">convRole</span><span class="p">(</span><span class="nx">follower</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">currTerm</span><span class="p">)</span>
	<span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">leaderID</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
	<span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">eleRelay</span> <span class="p">=</span> <span class="nf">newDalyFunc</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
	<span class="nx">currTerm</span> <span class="o">:=</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">currTerm</span>
	<span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="c1">// 发送投票 并提交
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">role</span> <span class="o">==</span> <span class="nx">follower</span> <span class="p">{</span>
		<span class="c1">// 新的任期号
</span><span class="c1"></span>		<span class="nx">nextTerm</span> <span class="o">:=</span> <span class="nx">currTerm</span> <span class="o">+</span> <span class="mi">1</span>
		<span class="c1">// 进行随机的延迟
</span><span class="c1"></span>		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">eleRelay</span><span class="p">)</span>

		<span class="c1">// 多节点可能同时想要成为 candidate, leaderID如果不等于-1, 可能已经完成了选举, 选举随机时间慢的节点就不用在去选举了
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">leaderID</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
			<span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
			<span class="c1">// 成为候选人
</span><span class="c1"></span>			<span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nf">convRole</span><span class="p">(</span><span class="nx">candidate</span><span class="p">,</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">me</span><span class="p">,</span> <span class="nx">nextTerm</span><span class="p">)</span>
			<span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

			<span class="kd">var</span> <span class="nx">agrees</span> <span class="kt">int32</span> <span class="p">=</span> <span class="mi">1</span>
			<span class="nx">wg</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>

			<span class="k">for</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">peers</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">me</span> <span class="o">==</span> <span class="nx">id</span> <span class="p">{</span>
					<span class="k">continue</span>
				<span class="p">}</span>
				<span class="c1">// 并发发送
</span><span class="c1"></span>				<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
				<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
					<span class="nx">args</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">RequestVoteArgs</span><span class="p">{</span><span class="nx">Xterm</span><span class="p">:</span> <span class="nx">nextTerm</span><span class="p">,</span> <span class="nx">CandidateId</span><span class="p">:</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">me</span><span class="p">,</span> <span class="nx">LastLogTerm</span><span class="p">:</span> <span class="nx">currTerm</span><span class="p">}</span>
					<span class="nx">reply</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">RequestVoteReply</span><span class="p">{}</span>
					<span class="c1">// rpc请求投票, 同时告知其他人 自己是候选人
</span><span class="c1"></span>					<span class="k">if</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">sendRequestVote</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">reply</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
						<span class="c1">// 如果节点当前任期号小于其他节点,那么自己不配成为候选人
</span><span class="c1"></span>						<span class="k">if</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Term</span> <span class="p">&gt;</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">currTerm</span> <span class="p">{</span>
							<span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
							<span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nf">convRole</span><span class="p">(</span><span class="nx">follower</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Term</span><span class="p">)</span>
							<span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
							<span class="k">return</span>
						<span class="p">}</span>
						<span class="c1">// 如果是赞成票
</span><span class="c1"></span>						<span class="k">if</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Ok</span> <span class="p">{</span>
							<span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">agrees</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
							<span class="k">if</span> <span class="nx">agrees</span> <span class="p">&gt;</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">rf</span><span class="p">.</span><span class="nx">peers</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">role</span> <span class="o">==</span> <span class="nx">candidate</span> <span class="p">{</span>
								<span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
								<span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nf">convRole</span><span class="p">(</span><span class="nx">leader</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
								<span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
								<span class="c1">// 心跳
</span><span class="c1"></span>								<span class="k">go</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">HeartBeat</span><span class="p">()</span>
							<span class="p">}</span>
						<span class="p">}</span>
					<span class="p">}</span>
				<span class="p">}(</span><span class="nx">id</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="c1">// 可能没有选出来leader
</span><span class="c1"></span>			<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
				<span class="k">if</span> <span class="nx">agrees</span> <span class="o">&lt;=</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">rf</span><span class="p">.</span><span class="nx">peers</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
					<span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
					<span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nf">convRole</span><span class="p">(</span><span class="nx">follower</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">currTerm</span><span class="p">)</span>
					<span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
					<span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">ticker</span><span class="p">.</span><span class="nf">Reset</span><span class="p">(</span><span class="nf">newDalyFunc</span><span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
				<span class="p">}</span>
			<span class="p">}()</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div><ul>
<li>设置状态</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Log</span><span class="p">)</span> <span class="nf">setRole</span><span class="p">(</span><span class="nx">role</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">role</span> <span class="p">=</span> <span class="nx">role</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Log</span><span class="p">)</span> <span class="nf">setVotedFor</span><span class="p">(</span><span class="nx">votedFor</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">votedFor</span> <span class="p">=</span> <span class="nx">votedFor</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Log</span><span class="p">)</span> <span class="nf">setCurrTerm</span><span class="p">(</span><span class="nx">xterm</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">currTerm</span> <span class="p">=</span> <span class="nx">xterm</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Log</span><span class="p">)</span> <span class="nf">convRole</span><span class="p">(</span><span class="nx">role</span><span class="p">,</span> <span class="nx">votedFor</span><span class="p">,</span> <span class="nx">xterm</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="nx">role</span> <span class="p">{</span>
	<span class="c1">// 1. candidate -&gt; follower : 候选人没有获得半数的投票
</span><span class="c1"></span>	<span class="c1">// 2. leader -&gt; follower : 过期的leader,或者xterm高于currTerm
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">follower</span><span class="p">:</span>
		<span class="nx">l</span><span class="p">.</span><span class="nf">setRole</span><span class="p">(</span><span class="nx">follower</span><span class="p">)</span>
		<span class="nx">l</span><span class="p">.</span><span class="nf">setVotedFor</span><span class="p">(</span><span class="nx">votedFor</span><span class="p">)</span>
		<span class="nx">l</span><span class="p">.</span><span class="nf">setCurrTerm</span><span class="p">(</span><span class="nx">xterm</span><span class="p">)</span>
	<span class="c1">// 1. follower -&gt; candidate : 集群没有leader,或者没收到心跳检测
</span><span class="c1"></span>	<span class="c1">// 2. candidate -&gt; candidate : 没有选出leader(比如集群数量少于半数)
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">candidate</span><span class="p">:</span>
		<span class="c1">// candidate 需要
</span><span class="c1"></span>		<span class="nx">l</span><span class="p">.</span><span class="nf">setRole</span><span class="p">(</span><span class="nx">candidate</span><span class="p">)</span>
		<span class="nx">l</span><span class="p">.</span><span class="nf">setVotedFor</span><span class="p">(</span><span class="nx">votedFor</span><span class="p">)</span>
		<span class="nx">l</span><span class="p">.</span><span class="nf">setCurrTerm</span><span class="p">(</span><span class="nx">xterm</span><span class="p">)</span>
	<span class="c1">// 1. candidate -&gt; leader : 得到过半选票
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">leader</span><span class="p">:</span>
		<span class="c1">// leader只需要修改第一个角色即可
</span><span class="c1"></span>		<span class="nx">l</span><span class="p">.</span><span class="nf">setRole</span><span class="p">(</span><span class="nx">leader</span><span class="p">)</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34; 不支持的角色&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>投票的rpc方法 RequestVote</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">rf</span> <span class="o">*</span><span class="nx">Raft</span><span class="p">)</span> <span class="nf">sendRequestVote</span><span class="p">(</span><span class="nx">server</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">args</span> <span class="o">*</span><span class="nx">RequestVoteArgs</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">RequestVoteReply</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">ok</span> <span class="o">:=</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">peers</span><span class="p">[</span><span class="nx">server</span><span class="p">].</span><span class="nf">Call</span><span class="p">(</span><span class="s">&#34;Raft.RequestVote&#34;</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">reply</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">ok</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rf</span> <span class="o">*</span><span class="nx">Raft</span><span class="p">)</span> <span class="nf">RequestVote</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">RequestVoteArgs</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">RequestVoteReply</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Your code here (2A, 2B).
</span><span class="c1"></span>	<span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="c1">// 当前rf.me是有可能成为 candidate, 并且同样可能收到投票rpc
</span><span class="c1"></span>	<span class="nx">reply</span><span class="p">.</span><span class="nx">Term</span> <span class="p">=</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">currTerm</span>

	<span class="c1">// 你当前任期号比我的还小, 你发什么rpc?
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">args</span><span class="p">.</span><span class="nx">LastLogTerm</span> <span class="p">&lt;</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">currTerm</span> <span class="p">{</span>
		<span class="nx">reply</span><span class="p">.</span><span class="nx">Ok</span> <span class="p">=</span> <span class="kc">false</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// 以前是leader, 下线了, 重新连上来的时候, 集群中最新的 LastLogTerm 已经比自己的大了
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">args</span><span class="p">.</span><span class="nx">LastLogTerm</span> <span class="p">&gt;</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">currTerm</span> <span class="p">{</span>
		<span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nf">convRole</span><span class="p">(</span><span class="nx">follower</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">args</span><span class="p">.</span><span class="nx">LastLogTerm</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 等于的情况本身是要判断追加日志长度是否 大于等于,所以这里先直接改为 follower, 否则多个 candidate 拥有相同的 LastLogTerm 就都保持 candidate 角色了, 我们要求只让一个成为 candidate
</span><span class="c1"></span>	<span class="c1">// 这里暂时还没有 appendEntries 长度, 之后在添加
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">args</span><span class="p">.</span><span class="nx">LastLogTerm</span> <span class="o">==</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">currTerm</span> <span class="p">{</span>
		<span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nf">convRole</span><span class="p">(</span><span class="nx">follower</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">args</span><span class="p">.</span><span class="nx">LastLogTerm</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 只有没有 候选人id的才有资格投票
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">votedFor</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
		<span class="nx">reply</span><span class="p">.</span><span class="nx">Ok</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">votedFor</span> <span class="p">=</span> <span class="nx">args</span><span class="p">.</span><span class="nx">CandidateId</span>
	<span class="p">}</span>

	<span class="k">return</span>
<span class="p">}</span>
</code></pre></div><h4 id="leader节点的心跳检测-heartbeat">leader节点的心跳检测 HeartBeat</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">rf</span> <span class="o">*</span><span class="nx">Raft</span><span class="p">)</span> <span class="nf">HeartBeat</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="c1">// 期间有可能 从leader 变成 follower
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">role</span> <span class="o">!=</span> <span class="nx">leader</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">peers</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">id</span> <span class="o">==</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">me</span> <span class="p">{</span>
				<span class="c1">// leader 重置心跳超时定时器, follower 是由心跳检测的rpc重置
</span><span class="c1"></span>				<span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">ticker</span><span class="p">.</span><span class="nf">Reset</span><span class="p">(</span><span class="nf">newDalyFunc</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="c1">// 成功了就会重置超时时钟
</span><span class="c1"></span>			<span class="c1">// 失败了就不管, 等超时时钟触发即可开始选举
</span><span class="c1"></span>			<span class="k">go</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">heartBeat</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nf">newDalyFunc</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rf</span> <span class="o">*</span><span class="nx">Raft</span><span class="p">)</span> <span class="nf">heartBeat</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">id</span> <span class="o">==</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">me</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">arg</span> <span class="o">:=</span> <span class="nx">RequestVoteArgs</span><span class="p">{</span><span class="nx">Xterm</span><span class="p">:</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">currTerm</span><span class="p">,</span> <span class="nx">CandidateId</span><span class="p">:</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">me</span><span class="p">}</span>
	<span class="nx">reply</span> <span class="o">:=</span> <span class="nx">RequestVoteReply</span><span class="p">{}</span>
	<span class="k">if</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">sendAppendEntries</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">reply</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="c1">// 如果 节点返回的任期号更大, 说明我是个 过期的旧leader -&gt; follower
</span><span class="c1"></span>		<span class="c1">// 如果我是个旧的leader,那集群目前很有可能已经有leader了, 那么我的 votedFor和leaderID也是需要更新, 那我应该在哪更新呢?
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Term</span> <span class="p">&gt;</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">currTerm</span> <span class="p">{</span>
			<span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
			<span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nf">convRole</span><span class="p">(</span><span class="nx">follower</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Term</span><span class="p">)</span>
			<span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">leaderID</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
			<span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>心跳检测的rpc AppendEntries</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">rf</span> <span class="o">*</span><span class="nx">Raft</span><span class="p">)</span> <span class="nf">sendAppendEntries</span><span class="p">(</span><span class="nx">server</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">args</span> <span class="o">*</span><span class="nx">RequestVoteArgs</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">RequestVoteReply</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">ok</span> <span class="o">:=</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">peers</span><span class="p">[</span><span class="nx">server</span><span class="p">].</span><span class="nf">Call</span><span class="p">(</span><span class="s">&#34;Raft.AppendEntries&#34;</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">reply</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">ok</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rf</span> <span class="o">*</span><span class="nx">Raft</span><span class="p">)</span> <span class="nf">AppendEntries</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">RequestVoteArgs</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">RequestVoteReply</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Your code here (2A, 2B).
</span><span class="c1"></span>	<span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="nx">reply</span><span class="p">.</span><span class="nx">Term</span> <span class="p">=</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">currTerm</span>
	<span class="c1">// 这里 rf.me 有可能刚好是 candidate 状态, 并且刚好收到了另外的 自称为leader的节点发送的 rpc
</span><span class="c1"></span>	<span class="c1">// 这个心跳或者追加日志的任期号肯定不能小于当前任期号,
</span><span class="c1"></span>	<span class="c1">// 等于的情况是持续的心跳检测, 大于的情况是刚成为leader第一次的append日志
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">args</span><span class="p">.</span><span class="nx">Xterm</span> <span class="p">&lt;</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">currTerm</span> <span class="p">{</span>
		<span class="nx">reply</span><span class="p">.</span><span class="nx">Ok</span> <span class="p">=</span> <span class="kc">false</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// 以下就是大于等于的情况
</span><span class="c1"></span>	<span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">ticker</span><span class="p">.</span><span class="nf">Reset</span><span class="p">(</span><span class="nf">newDalyFunc</span><span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
	<span class="c1">// 这里就要设置为 follower , 因为自己有可能在 candidate 状态
</span><span class="c1"></span>	<span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nf">convRole</span><span class="p">(</span><span class="nx">follower</span><span class="p">,</span> <span class="nx">args</span><span class="p">.</span><span class="nx">CandidateId</span><span class="p">,</span> <span class="nx">args</span><span class="p">.</span><span class="nx">Xterm</span><span class="p">)</span>
	<span class="nx">rf</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">leaderID</span> <span class="p">=</span> <span class="nx">args</span><span class="p">.</span><span class="nx">CandidateId</span>
	<span class="nx">reply</span><span class="p">.</span><span class="nx">Ok</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="k">return</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>遇到的几个问题</li>
</ul>
<pre><code>1. 在哪个时间点将 follower 切换成 candidate ?
答: 首先让 follower 延迟随机时间 , 然后需要先判断当前集群是否 已经选举出了leader, 在没有leader的的情况下让当前节点成为 candidate.  当延迟更久的 follower 发现当前集群已经选举出了leader, 所以直接放弃选举了
2. 当节点数量越多时,就会出现更多的分票的情况,导致选举不成功
答: 这个问题是我 投票条件漏写了 args.LastLogTerm == rf.log.currTerm 等于的情况, 导致出现了多个 candidate, 从而出现了各个 candidate都给自己投票
3. 为什么用ticker来超时, 还不适用time.Now来按时间分割任期号的有效期呢
答: time.Now依赖各个节点时钟是否一致, 可能导致一些不可预料的错误
</code></pre>]]></content>
		</item>
		
		<item>
			<title>Go学习 6.824-lab1-MapReduce实验</title>
			<link>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-6.824-lab1-mapreduce/</link>
			<pubDate>Fri, 04 Mar 2022 13:55:22 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-6.824-lab1-mapreduce/</guid>
			<description>相关知识点了解 课程翻译内容  mit6.824课程 中文翻译 文字版 mit6.824课程 2021 lab1-MapReduce实验翻译   阅读以上内容之后, 对MapReduce概念上 和lab1实验的内容有了大概的了解了
 代码逻辑 简单的流程分析 通过lab1实验内容的了解, 我们知道 我们需要实现的内容是 src/mr/目录的三个文件coordinator.go, rpc.go, worker.go coordinator.go 主要是服务端, 实现任务调度功能(master) worker.go 主要是客户端, 实现任务执行功能(node) rpc.go 主要是rpc端, 实现一些rpc数据传输的结构体 晚上代码的编写之后,我们可以首先测试wc.go的功能 cd 6.824/src/main # 在当前目录生成wc.so文件(之后测试rtiming.go, crash.go同样) go build -race -buildmode=plugin ../mrapps/wc.go # 启动服务端 go run -race mrcoordinator.go pg-*.txt # 启动客户端 go run -race mrworker.go wc.so # 完整之后, 客户端和服务端都会退出, 当前目录生成如下文件: # 其中 mr-X-Y.txt 是map 函数生成的中间文件 NMap * NReduce个 # 其中 mr-out-Y.</description>
			<content type="html"><![CDATA[<h3 id="相关知识点了解">相关知识点了解</h3>
<h4 id="课程翻译内容">课程翻译内容</h4>
<ul>
<li><a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-824/lecture-01-introduction">mit6.824课程 中文翻译 文字版</a></li>
<li><a href="https://blog.csdn.net/hh1986170901/article/details/120262227">mit6.824课程 2021 lab1-MapReduce实验翻译</a></li>
</ul>
<blockquote>
<p>阅读以上内容之后, 对MapReduce概念上 和lab1实验的内容有了大概的了解了</p>
</blockquote>
<h3 id="代码逻辑">代码逻辑</h3>
<h4 id="简单的流程分析">简单的流程分析</h4>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">通过lab1实验内容的了解, 我们知道
我们需要实现的内容是 src/mr/目录的三个文件coordinator.go, rpc.go, worker.go
  coordinator.go 主要是服务端, 实现任务调度功能<span class="o">(</span>master<span class="o">)</span>
  worker.go      主要是客户端, 实现任务执行功能<span class="o">(</span>node<span class="o">)</span>
  rpc.go         主要是rpc端, 实现一些rpc数据传输的结构体

晚上代码的编写之后,我们可以首先测试wc.go的功能
<span class="nb">cd</span> 6.824/src/main
<span class="c1"># 在当前目录生成wc.so文件(之后测试rtiming.go, crash.go同样)</span>
go build -race -buildmode<span class="o">=</span>plugin ../mrapps/wc.go
<span class="c1"># 启动服务端</span>
go run -race mrcoordinator.go pg-*.txt
<span class="c1"># 启动客户端</span>
go run -race mrworker.go wc.so
<span class="c1"># 完整之后, 客户端和服务端都会退出, 当前目录生成如下文件:</span>
<span class="c1"># 其中 mr-X-Y.txt 是map 函数生成的中间文件 NMap * NReduce个</span>
<span class="c1"># 其中 mr-out-Y.txt 是reduce 函数生成最终文件 NReduce个</span>
mr-0-0.txt   mr-0-8.txt   mr-1-6.txt   mr-2-4.txt   mr-3-2.txt   mr-4-0.txt   mr-4-8.txt   mr-5-6.txt   mr-6-4.txt   mr-7-2.txt   
mr-0-1.txt   mr-0-9.txt   mr-1-7.txt   mr-2-5.txt   mr-3-3.txt   mr-4-1.txt   mr-4-9.txt   mr-5-7.txt   mr-6-5.txt   mr-7-3.txt    
mr-0-2.txt   mr-1-0.txt   mr-1-8.txt   mr-2-6.txt   mr-3-4.txt   mr-4-2.txt   mr-5-0.txt   mr-5-8.txt   mr-6-6.txt   mr-7-4.txt   
mr-0-3.txt   mr-1-1.txt   mr-1-9.txt   mr-2-7.txt   mr-3-5.txt   mr-4-3.txt   mr-5-1.txt   mr-5-9.txt   mr-6-7.txt   mr-7-5.txt   
mr-0-4.txt   mr-1-2.txt   mr-2-0.txt   mr-2-8.txt   mr-3-6.txt   mr-4-4.txt   mr-5-2.txt   mr-6-0.txt   mr-6-8.txt   mr-7-6.txt   
mr-0-5.txt   mr-1-3.txt   mr-2-1.txt   mr-2-9.txt   mr-3-7.txt   mr-4-5.txt   mr-5-3.txt   mr-6-1.txt   mr-6-9.txt   mr-7-7.txt   
mr-0-6.txt   mr-1-4.txt   mr-2-2.txt   mr-3-0.txt   mr-3-8.txt   mr-4-6.txt   mr-5-4.txt   mr-6-2.txt   mr-7-0.txt   mr-7-8.txt   
mr-0-7.txt   mr-1-5.txt   mr-2-3.txt   mr-3-1.txt   mr-3-9.txt   mr-4-7.txt   mr-5-5.txt   mr-6-3.txt   mr-7-1.txt   mr-7-9.txt   
mr-out-0.txt mr-out-1.txt mr-out-2.txt mr-out-3.txt mr-out-4.txt mr-out-5.txt mr-out-6.txt mr-out-7.txt mr-out-8.txt mr-out-9.txt

<span class="c1"># 之后我们就可以进行全部功能测试</span>
bash test-mr.sh
<span class="c1"># 结果如下</span>
*** Starting wc test.
2022/03/04 14:52:03 rpc.Register: method <span class="s2">&#34;Done&#34;</span> has <span class="m">1</span> input parameters<span class="p">;</span> needs exactly three
--- wc test: PASS
*** Starting indexer test.
2022/03/04 14:52:27 rpc.Register: method <span class="s2">&#34;Done&#34;</span> has <span class="m">1</span> input parameters<span class="p">;</span> needs exactly three
--- indexer test: PASS
*** Starting map parallelism test.
2022/03/04 14:52:37 rpc.Register: method <span class="s2">&#34;Done&#34;</span> has <span class="m">1</span> input parameters<span class="p">;</span> needs exactly three
--- map parallelism test: PASS
*** Starting reduce parallelism test.
2022/03/04 14:52:47 rpc.Register: method <span class="s2">&#34;Done&#34;</span> has <span class="m">1</span> input parameters<span class="p">;</span> needs exactly three
--- reduce parallelism test: PASS
*** Starting job count test.
2022/03/04 14:53:00 rpc.Register: method <span class="s2">&#34;Done&#34;</span> has <span class="m">1</span> input parameters<span class="p">;</span> needs exactly three
2022/03/04 14:53:22 dialing:dial-http unix /var/tmp/824-mr-501: unexpected EOF
2022/03/04 14:53:22 dialing:dial unix /var/tmp/824-mr-501: connect: connection refused
--- job count test: PASS
*** Starting early <span class="nb">exit</span> test.
2022/03/04 14:53:22 rpc.Register: method <span class="s2">&#34;Done&#34;</span> has <span class="m">1</span> input parameters<span class="p">;</span> needs exactly three
--- early <span class="nb">exit</span> test: PASS
*** Starting crash test.
2022/03/04 14:53:32 rpc.Register: method <span class="s2">&#34;Done&#34;</span> has <span class="m">1</span> input parameters<span class="p">;</span> needs exactly three
2022/03/04 14:54:13 dialing:dial unix /var/tmp/824-mr-501: connect: connection refused
2022/03/04 14:54:13 dialing:dial unix /var/tmp/824-mr-501: connect: connection refused
2022/03/04 14:54:13 dialing:dial unix /var/tmp/824-mr-501: connect: connection refused
--- crash test: PASS
*** PASSED ALL TESTS
</code></pre></div><h4 id="代码分析">代码分析</h4>
<pre><code>我们先从worker的角度看一下
1. worker 是包括了map和reduce的, 这里我们先完成map的所有工作之后, 在继续完成reduce
2. map worker需要通过rpc的方式调用master, master告知worker一个token或者告知一个错误, 没有token了,或者没有任务了,
    2.1 运气很好, 我拿到了token如果,那么worker就可以工作了
        2.1.1 工作的很好,一切顺利, 我完成了文件的读取,并且通过json编码写入到了临时文件,最后mapf执行的也没有问题, 没有crash,我把临时文件重命名为中间文件(mapworker的输出),最后一步rpc通知master,我完成了工作, perfect!!! (master默默的在本子上记录一笔,worker0记录✔️!)
        2.1.2 工作的不顺利, 各种问题,导致最终并没有通知master (master很没有耐心,在10秒钟以后, 给worker0 记录了×!)
    2.2 糟糕, 我失业了...我只能游手好闲一段时间...
    2.3 不管是工作完成, 还是失业, 接下来都要继续去找工作-&gt; 回到2
3. 我们必须要有一个wait程序, 等待map worker全部完成, wait通过rpc调用master 询问所有的工作都完成了吗?
    3.1 rpc调用发现map的所有任务都完成了, 那就终止wait等待
    3.2 rpc调用发现map的任务还有未完成
    3.3 注意, 这个wait循环的rpc调用需要很简单, 不能存在较多的计算
4. reduce worker 同样类似步骤2
...

从master的角度看一下
1. master首先需要如下几个rpc服务
    1.1 GetMapWorker(...) error 分配map worker
    1.2 GetReduceWorker(...) error 分配reduce worker
    1.3 SetMapDoneOne(...) error 设置某个map worker完成
    1.4 SetReduceDoneOne(...) error 设置某个reduce worker完成
    1.5 GetMapFinish(...) error 查看所有的map 是否都完成
    1.6 GetReduceFinish(...) error 查看所有的reduce 是否都完成
2. 我们首先需要一个分配worker的队列
3. 我们需要定义worker, 记录id,timeout 和step, step是记录在map步骤还是reduce步骤
4. 我们需要一个后台循环程序,检测是否完成了step1, 然后完成后,在检测是否完成了step2,最后 Done()掉master服务,Done的逻辑是改lab的逻辑,显然我们不希望真是服务端mster宕机
5. 我们还需要一个后台循环程序,检测是否有step1的超时,然后在检测是否有step2的超时
6. 我们需要设置锁来支持分布式
7. 针对mapf可能会crash的情况, 这里是通过timeout来解决, 当worker crash了, 则会达到10秒的超时时间,此时我们将该token继续放到队列中,并且清理worker, 当然如果真实执行了这么久,也直接忽略了
8. 服务端master收到了GetMapWorker或者GetReduceWorker的rpc请求之后, 会查询队列是否有token可以提供,返回客户端node成功或失败
9. 服务端master收到了SetMapDoneOne 或者SetReduceDoneOne 的rpc请求, 会将对应的token id的worker设置为完成状态
10. 服务端master收到了GetMapFinish 或者GetReduceFinish 的rpc请求, 会将对应finish字段返回
</code></pre><h3 id="服务端的代码">服务端的代码</h3>
<blockquote>
<p>coordinator.go</p>
</blockquote>
<h4 id="队列">队列</h4>
<ul>
<li>queues结构体</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">queues</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">ids</span> <span class="p">[]</span><span class="kt">int</span>      <span class="c1">// 存储token
</span><span class="c1"></span>	<span class="nx">mu</span>  <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>对应的出入队列</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">q</span> <span class="o">*</span><span class="nx">queues</span><span class="p">)</span> <span class="nf">Pop</span><span class="p">()</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">q</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">ids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;queue is null&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="nx">q</span><span class="p">.</span><span class="nx">ids</span> <span class="p">=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">ids</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
	<span class="k">return</span> <span class="nx">i</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">q</span> <span class="o">*</span><span class="nx">queues</span><span class="p">)</span> <span class="nf">Push</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">q</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
        <span class="k">defer</span> <span class="nx">q</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="nx">q</span><span class="p">.</span><span class="nx">ids</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">ids</span><span class="p">,</span> <span class="nx">id</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h4 id="每个工作记录">每个工作记录</h4>
<ul>
<li>job和jobs结构体</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
	<span class="nx">step0</span> <span class="p">=</span> <span class="kc">iota</span>
	<span class="nx">step1</span>
	<span class="nx">step2</span>
<span class="p">)</span>
<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">defaultTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="p">=</span> <span class="mi">10</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">job</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">id</span>      <span class="kt">int</span>              <span class="c1">// 这是一个任务id
</span><span class="c1"></span>	<span class="nx">timeout</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span> <span class="c1">// 超时时间
</span><span class="c1"></span>	<span class="nx">step</span>    <span class="kt">int</span>              <span class="c1">// 记录到第几步, step1: map完成, step2: reduce完成
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">jobs</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">tokens</span>    <span class="o">*</span><span class="nx">queues</span>       <span class="c1">// tokens 队列,实现分配给worker并发
</span><span class="c1"></span>	<span class="nx">workers</span>   <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="o">*</span><span class="nx">job</span>  <span class="c1">// 记录worker的状态,每个worker对应一个job
</span><span class="c1"></span>	<span class="nx">maxThread</span> <span class="kt">int</span>           <span class="c1">// 用于记录当前jobs的最大并发数
</span><span class="c1"></span>	<span class="nx">mu</span>        <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span> <span class="c1">// 锁
</span><span class="c1"></span>	<span class="nx">finish</span>    <span class="kt">bool</span>          <span class="c1">// 记录jobs是否全部完成
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><ul>
<li>客户端获取token的相关操作</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// 从队列获取token
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">j</span> <span class="o">*</span><span class="nx">jobs</span><span class="p">)</span> <span class="nf">getToken</span><span class="p">()</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">j</span><span class="p">.</span><span class="nx">tokens</span><span class="p">.</span><span class="nf">Pop</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// 记录jobs当前有哪些work在运行
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">j</span> <span class="o">*</span><span class="nx">jobs</span><span class="p">)</span> <span class="nf">addJob</span><span class="p">(</span><span class="nx">token</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">j</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">jobN</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">job</span><span class="p">{</span>
		<span class="nx">id</span><span class="p">:</span>      <span class="nx">token</span><span class="p">,</span>
		<span class="nx">timeout</span><span class="p">:</span> <span class="nx">time</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="nx">defaultTimeout</span><span class="p">),</span>
	<span class="p">}</span>
	<span class="nx">j</span><span class="p">.</span><span class="nx">workers</span><span class="p">[</span><span class="nx">token</span><span class="p">]</span> <span class="p">=</span> <span class="nx">jobN</span>
	<span class="nx">j</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>客户端worker完成后的状态设置</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 设置worker完成
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">j</span> <span class="o">*</span><span class="nx">jobs</span><span class="p">)</span> <span class="nf">SetDoneOne</span><span class="p">(</span><span class="nx">arg</span> <span class="o">*</span><span class="nx">InWorker</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">j</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="c1">// arg.Step 可能是step1 也可能是step2
</span><span class="c1"></span>	<span class="c1">// 防止是step2 被改成了step1, 并发下是有可能的
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">arg</span><span class="p">.</span><span class="nx">Step</span> <span class="p">&gt;</span> <span class="nx">j</span><span class="p">.</span><span class="nx">workers</span><span class="p">[</span><span class="nx">arg</span><span class="p">.</span><span class="nx">Token</span><span class="p">].</span><span class="nx">step</span> <span class="p">{</span>
		<span class="nx">j</span><span class="p">.</span><span class="nx">workers</span><span class="p">[</span><span class="nx">arg</span><span class="p">.</span><span class="nx">Token</span><span class="p">].</span><span class="nx">step</span> <span class="p">=</span> <span class="nx">arg</span><span class="p">.</span><span class="nx">Step</span>
	<span class="p">}</span>
	<span class="c1">//log.Printf(&#34;[server] &gt;&gt;&gt; SetDoneOne step: %v\n&#34;, arg.Step)
</span><span class="c1"></span>	<span class="nx">j</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><blockquote>
<p>其他方法稍后慢慢说明</p>
<p>接着我们看下 Coordinator</p>
</blockquote>
<h4 id="rpc注册的结构体">rpc注册的结构体</h4>
<blockquote>
<p>我们对Map 和Reduce使用同样的jobs, 这样后续可以直接调用jobs的方法</p>
</blockquote>
<ul>
<li>Coordinator</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Coordinator</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">mu</span>       <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>
	<span class="nx">mapFiles</span> <span class="p">[]</span><span class="kt">string</span> <span class="c1">// 用于存储map中需要读取的文件列表
</span><span class="c1"></span>	<span class="nx">M</span>        <span class="o">*</span><span class="nx">jobs</span>
	<span class="nx">R</span>        <span class="o">*</span><span class="nx">jobs</span>
<span class="p">}</span>
</code></pre></div><h4 id="客户端获取worker的rpc方法">客户端获取worker的rpc方法</h4>
<ul>
<li>GetMapWorker rpc</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// GetMapWorker rpc接口
</span><span class="c1">// arg *InWorker 不需要输入参数
</span><span class="c1">// reply *OutWorker 输出参数
</span><span class="c1">// 	Token: 每个token对应一个任务,对应一个文件
</span><span class="c1">// 	Filename: mapf 需要处理的文件名
</span><span class="c1">//	NReduce: 这是reducef的并发数, 同样在mapf中也需要, 因为mapf会生成 NMap*NReduce 个中间临时文件
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Coordinator</span><span class="p">)</span> <span class="nf">GetMapWorker</span><span class="p">(</span><span class="nx">arg</span> <span class="o">*</span><span class="nx">InWorker</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">OutWorker</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="c1">// 直接从队列获取token
</span><span class="c1"></span>	<span class="nx">token</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">M</span><span class="p">.</span><span class="nf">getToken</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="c1">// 通过token索引获取文件名
</span><span class="c1"></span>	<span class="nx">filename</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">getMapFile</span><span class="p">(</span><span class="nx">token</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="c1">// 当前jobs记录下token对应的job
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">M</span><span class="p">.</span><span class="nf">addJob</span><span class="p">(</span><span class="nx">token</span><span class="p">)</span>
	<span class="c1">// 写入rpc的返回值中
</span><span class="c1"></span>	<span class="nx">reply</span><span class="p">.</span><span class="nx">Token</span> <span class="p">=</span> <span class="nx">token</span>
	<span class="nx">reply</span><span class="p">.</span><span class="nx">Filename</span> <span class="p">=</span> <span class="nx">filename</span>
	<span class="c1">// 这里要注意是nReduce
</span><span class="c1"></span>	<span class="nx">reply</span><span class="p">.</span><span class="nx">NReduce</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">R</span><span class="p">.</span><span class="nx">maxThread</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>getMapFile 仅map worker需要</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Coordinator</span><span class="p">)</span> <span class="nf">getMapFile</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">mapFiles</span><span class="p">[</span><span class="nx">id</span><span class="p">],</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>GetReduceWorker rpc</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Coordinator</span><span class="p">)</span> <span class="nf">GetReduceWorker</span><span class="p">(</span><span class="nx">arg</span> <span class="o">*</span><span class="nx">InWorker</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">OutWorker</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">token</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">R</span><span class="p">.</span><span class="nf">getToken</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">R</span><span class="p">.</span><span class="nf">addJob</span><span class="p">(</span><span class="nx">token</span><span class="p">)</span>
	<span class="nx">reply</span><span class="p">.</span><span class="nx">Token</span> <span class="p">=</span> <span class="nx">token</span>
	<span class="nx">reply</span><span class="p">.</span><span class="nx">NReduce</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">R</span><span class="p">.</span><span class="nx">maxThread</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><h4 id="客户端完成任务后的rpc方法">客户端完成任务后的rpc方法</h4>
<ul>
<li>这里实际上直接调用了上面的 jobs.SetDoneOne 方法</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// SetMapDoneOne rpc是对 jobs.SetDoneOne的封装
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Coordinator</span><span class="p">)</span> <span class="nf">SetMapDoneOne</span><span class="p">(</span><span class="nx">arg</span> <span class="o">*</span><span class="nx">InWorker</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">OutWorker</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">M</span><span class="p">.</span><span class="nf">SetDoneOne</span><span class="p">(</span><span class="nx">arg</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Coordinator</span><span class="p">)</span> <span class="nf">SetReduceDoneOne</span><span class="p">(</span><span class="nx">arg</span> <span class="o">*</span><span class="nx">InWorker</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">OutWorker</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">R</span><span class="p">.</span><span class="nf">SetDoneOne</span><span class="p">(</span><span class="nx">arg</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h4 id="客户端wait中检测的是否全部完成的rpc方法">客户端wait中检测的是否全部完成的rpc方法</h4>
<ul>
<li>GetMapFinish 和 GetReduceFinish 的rpc</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Coordinator</span><span class="p">)</span> <span class="nf">GetMapFinish</span><span class="p">(</span><span class="nx">arg</span> <span class="o">*</span><span class="nx">InWorker</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">OutWorker</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">M</span><span class="p">.</span><span class="nf">getFinish</span><span class="p">()</span> <span class="o">==</span> <span class="kc">true</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;map running &#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Coordinator</span><span class="p">)</span> <span class="nf">GetReduceFinish</span><span class="p">(</span><span class="nx">arg</span> <span class="o">*</span><span class="nx">InWorker</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">OutWorker</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">R</span><span class="p">.</span><span class="nf">getFinish</span><span class="p">()</span> <span class="o">==</span> <span class="kc">true</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;reduce running &#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>实际的返回finish 字段</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">j</span> <span class="o">*</span><span class="nx">jobs</span><span class="p">)</span> <span class="nf">getFinish</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">j</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">j</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">j</span><span class="p">.</span><span class="nx">finish</span>
<span class="p">}</span>
</code></pre></div><blockquote>
<p>以上与客户端交互的rpc方法都介绍完了</p>
</blockquote>
<h4 id="服务端的初始化代码">服务端的初始化代码</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">MakeCoordinator</span><span class="p">(</span><span class="nx">files</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">nReduce</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Coordinator</span> <span class="p">{</span>
	<span class="c1">// mapf的tokens的数量是和文件数保持一致的
</span><span class="c1"></span>	<span class="nx">numMap</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">files</span><span class="p">)</span>
	<span class="nx">map1</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">jobs</span><span class="p">{</span>
		<span class="nx">mu</span><span class="p">:</span>        <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span><span class="p">{},</span>
		<span class="nx">maxThread</span><span class="p">:</span> <span class="nx">numMap</span><span class="p">,</span>
		<span class="nx">workers</span><span class="p">:</span>   <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="o">*</span><span class="nx">job</span><span class="p">,</span> <span class="nx">numMap</span><span class="p">),</span>
		<span class="nx">tokens</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">queues</span><span class="p">{</span>
			<span class="nx">mu</span><span class="p">:</span>  <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span><span class="p">{},</span>
			<span class="nx">ids</span><span class="p">:</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">numMap</span><span class="p">),</span>
		<span class="p">},</span>
	<span class="p">}</span>
        <span class="c1">// 设置workers这个map的key 和队列
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">numMap</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">map1</span><span class="p">.</span><span class="nx">workers</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="nx">map1</span><span class="p">.</span><span class="nx">tokens</span><span class="p">.</span><span class="nx">ids</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">i</span>
	<span class="p">}</span>
	<span class="c1">// reducef的数量是和nReduce一致
</span><span class="c1"></span>	<span class="nx">reduce1</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">jobs</span><span class="p">{</span>
		<span class="nx">mu</span><span class="p">:</span>        <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span><span class="p">{},</span>
		<span class="nx">maxThread</span><span class="p">:</span> <span class="nx">nReduce</span><span class="p">,</span>
		<span class="nx">workers</span><span class="p">:</span>   <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="o">*</span><span class="nx">job</span><span class="p">,</span> <span class="nx">nReduce</span><span class="p">),</span>
		<span class="nx">tokens</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">queues</span><span class="p">{</span>
			<span class="nx">mu</span><span class="p">:</span>  <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span><span class="p">{},</span>
			<span class="nx">ids</span><span class="p">:</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">nReduce</span><span class="p">),</span>
		<span class="p">},</span>
	<span class="p">}</span>
        <span class="c1">// 设置workers这个map的key 和队列
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">nReduce</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">reduce1</span><span class="p">.</span><span class="nx">workers</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="nx">reduce1</span><span class="p">.</span><span class="nx">tokens</span><span class="p">.</span><span class="nx">ids</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">i</span>
	<span class="p">}</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Coordinator</span><span class="p">{</span>
		<span class="nx">mu</span><span class="p">:</span>       <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span><span class="p">{},</span>
		<span class="nx">mapFiles</span><span class="p">:</span> <span class="nx">files</span><span class="p">,</span>
		<span class="nx">M</span><span class="p">:</span>        <span class="nx">map1</span><span class="p">,</span>
		<span class="nx">R</span><span class="p">:</span>        <span class="nx">reduce1</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">server</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">c</span>
<span class="p">}</span>

</code></pre></div><h4 id="服务端的后台循环脚本">服务端的后台循环脚本</h4>
<blockquote>
<p>这里我是放在了Done()的方法里面</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Coordinator</span><span class="p">)</span> <span class="nf">Done</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="kc">false</span>
	<span class="c1">// 后台检测是否完成了所有的任务
</span><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
                <span class="c1">// 实际调用jobs.Finish
</span><span class="c1"></span>                <span class="c1">// 这等价于 for ;!c.M.Finish(&amp;InWorker{Step: step1}) ; {}
</span><span class="c1"></span>                <span class="c1">// 只要有一次Finish返回为true,就会退出循环
</span><span class="c1"></span>		<span class="k">for</span> <span class="p">!</span><span class="nx">c</span><span class="p">.</span><span class="nx">M</span><span class="p">.</span><span class="nf">Finish</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">InWorker</span><span class="p">{</span><span class="nx">Step</span><span class="p">:</span> <span class="nx">step1</span><span class="p">})</span> <span class="p">{</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="p">!</span><span class="nx">c</span><span class="p">.</span><span class="nx">R</span><span class="p">.</span><span class="nf">Finish</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">InWorker</span><span class="p">{</span><span class="nx">Step</span><span class="p">:</span> <span class="nx">step2</span><span class="p">})</span> <span class="p">{</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="c1">// 如果 mapf jobs没有全部完成
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">!</span><span class="nx">c</span><span class="p">.</span><span class="nx">M</span><span class="p">.</span><span class="nf">getFinish</span><span class="p">()</span> <span class="p">{</span>
                <span class="c1">// 那就需要查看是否有超时
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">M</span><span class="p">.</span><span class="nf">GetTimeoutJob</span><span class="p">(</span><span class="nx">step1</span><span class="p">)</span>
		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">!</span><span class="nx">c</span><span class="p">.</span><span class="nx">R</span><span class="p">.</span><span class="nf">getFinish</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">R</span><span class="p">.</span><span class="nf">GetTimeoutJob</span><span class="p">(</span><span class="nx">step2</span><span class="p">)</span>
		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">ret</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>jobs.Finish的方法会设置finish字段</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 检测jobs是不是已经全部完成
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">j</span> <span class="o">*</span><span class="nx">jobs</span><span class="p">)</span> <span class="nf">Finish</span><span class="p">(</span><span class="nx">arg</span> <span class="o">*</span><span class="nx">InWorker</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="nx">j</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">j</span><span class="p">.</span><span class="nx">workers</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">j</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
                <span class="c1">// 如果传入的arg.Step(step1) &gt; v.step(step0),那么就说明worker还未完成
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">arg</span><span class="p">.</span><span class="nx">Step</span> <span class="p">&gt;</span> <span class="nx">v</span><span class="p">.</span><span class="nx">step</span> <span class="p">{</span>
			<span class="nx">j</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">j</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
        <span class="c1">// 在这之前需要释放读锁, 否则setFinish中无法拿到写锁
</span><span class="c1"></span>	<span class="nx">j</span><span class="p">.</span><span class="nf">setFinish</span><span class="p">()</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">j</span> <span class="o">*</span><span class="nx">jobs</span><span class="p">)</span> <span class="nf">setFinish</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">j</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">j</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="nx">j</span><span class="p">.</span><span class="nx">finish</span> <span class="p">=</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>GetTimeoutJob的方法</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 查看是否有超时job
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">j</span> <span class="o">*</span><span class="nx">jobs</span><span class="p">)</span> <span class="nf">GetTimeoutJob</span><span class="p">(</span><span class="nx">step</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">j</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">w</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">j</span><span class="p">.</span><span class="nx">workers</span> <span class="p">{</span>
		<span class="c1">// 必须是add过的job
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">w</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// 如果是已经完成的任务, 不需要验证是否过期
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">w</span><span class="p">.</span><span class="nx">step</span> <span class="o">==</span> <span class="nx">step</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">w</span><span class="p">.</span><span class="nx">timeout</span><span class="p">:</span>
				<span class="c1">// 再看一眼是否完成了
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">w</span><span class="p">.</span><span class="nx">step</span> <span class="o">==</span> <span class="nx">step</span> <span class="p">{</span>
					<span class="k">continue</span>
				<span class="p">}</span>
				<span class="nx">id</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.</span><span class="nx">id</span>
				<span class="c1">// 这里必须先释放读锁, 因为后面的push和removejob都需要获取 写锁,
</span><span class="c1"></span>				<span class="c1">// 写锁和其他锁都是互斥的, 读锁只与读锁兼容
</span><span class="c1"></span>				<span class="nx">j</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
				<span class="nx">j</span><span class="p">.</span><span class="nx">tokens</span><span class="p">.</span><span class="nf">Push</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
				<span class="nx">j</span><span class="p">.</span><span class="nf">removeJob</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
				<span class="c1">// push和removejob 执行完之后还需要在 开启读锁
</span><span class="c1"></span>				<span class="nx">j</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
			<span class="k">default</span><span class="p">:</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 最后需要是否读锁
</span><span class="c1"></span>	<span class="nx">j</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>

<span class="p">}</span>
</code></pre></div><ul>
<li>jobs.removeJob</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 超时的job需要剔除
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">j</span> <span class="o">*</span><span class="nx">jobs</span><span class="p">)</span> <span class="nf">removeJob</span><span class="p">(</span><span class="nx">token</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">j</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">j</span><span class="p">.</span><span class="nx">workers</span><span class="p">[</span><span class="nx">token</span><span class="p">]</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">j</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">j</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>

	<span class="nx">j</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">j</span><span class="p">.</span><span class="nx">workers</span><span class="p">[</span><span class="nx">token</span><span class="p">]</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="c1">// j.finish = false
</span><span class="c1"></span>	<span class="nx">j</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><h4 id="rpc的数据传输的结构体">rpc的数据传输的结构体</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">InWorker</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Token</span> <span class="kt">int</span>
	<span class="nx">Step</span> <span class="kt">int</span>
	<span class="nx">Filename</span> <span class="kt">string</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">OutWorker</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Token</span> <span class="kt">int</span>
	<span class="nx">Filename</span> <span class="kt">string</span>
	<span class="nx">NReduce</span> <span class="kt">int</span>
<span class="p">}</span>
</code></pre></div><blockquote>
<p>以上除了课程默认的 rpc的server没介绍, 其他的所有服务端的程序都介绍完了</p>
</blockquote>
<h3 id="客户端的代码">客户端的代码</h3>
<blockquote>
<p>worker.go</p>
</blockquote>
<h4 id="首先我们直接看下worker方法">首先我们直接看下worker方法</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Worker</span><span class="p">(</span><span class="nx">mapf</span> <span class="kd">func</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="nx">KeyValue</span><span class="p">,</span>
	<span class="nx">reducef</span> <span class="kd">func</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">//###################### map ###########################################
</span><span class="c1"></span>	<span class="nx">replyMap</span> <span class="o">:=</span> <span class="nx">OutWorker</span><span class="p">{}</span>
        <span class="c1">// 获取token的协程
</span><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">n</span> <span class="o">:=</span> <span class="mi">1</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="k">select</span> <span class="p">{</span>
                        <span class="c1">// wait方法中,如果检测到master已经完成了所有的任务,则直接break
</span><span class="c1"></span>			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">step1Done</span><span class="p">:</span>
				<span class="k">break</span>
			<span class="k">default</span><span class="p">:</span>
                                <span class="c1">// rpc调用GetMapWorker 方法, 得到replyMap
</span><span class="c1"></span>				<span class="k">if</span> <span class="nf">call</span><span class="p">(</span><span class="s">&#34;Coordinator.GetMapWorker&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">InWorker</span><span class="p">{},</span> <span class="o">&amp;</span><span class="nx">replyMap</span><span class="p">)</span> <span class="p">{</span>
                                        <span class="c1">// 这里我们并不需要goroutine的方式执行, 因为实际场景和测试脚本是通过多进程运行的, 而不需要我们go去多线程了
</span><span class="c1"></span>                                        <span class="c1">// 实际场景也同样是在多个服务器上运行的客户端
</span><span class="c1"></span>					<span class="nf">mapWorker</span><span class="p">(</span><span class="nx">mapf</span><span class="p">,</span> <span class="nx">replyMap</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="c1">// 100ms 200ms 400ms 800ms 800ms
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="mi">8</span> <span class="p">{</span>
					<span class="nx">n</span>  <span class="o">*=</span> <span class="mi">2</span>
				<span class="p">}</span>
				<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="mi">100</span><span class="p">)</span> <span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="c1">// 等待 mapf执行完毕
</span><span class="c1"></span>	<span class="nf">wait</span><span class="p">(</span><span class="s">&#34;Coordinator.GetMapFinish&#34;</span><span class="p">,</span> <span class="nx">step1</span><span class="p">,</span> <span class="nx">step1Done</span><span class="p">)</span>
	<span class="c1">//###################### reduce ###########################################
</span><span class="c1"></span>	<span class="nx">replyReduce</span> <span class="o">:=</span> <span class="nx">OutWorker</span><span class="p">{}</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
                <span class="nx">n</span> <span class="o">:=</span> <span class="mi">1</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">step2Done</span><span class="p">:</span>
				<span class="k">break</span>
			<span class="k">default</span><span class="p">:</span>
				<span class="k">if</span> <span class="nf">call</span><span class="p">(</span><span class="s">&#34;Coordinator.GetReduceWorker&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">InWorker</span><span class="p">{},</span> <span class="o">&amp;</span><span class="nx">replyReduce</span><span class="p">)</span> <span class="p">{</span>
					<span class="nf">reduceWorker</span><span class="p">(</span><span class="nx">reducef</span><span class="p">,</span> <span class="nx">replyReduce</span><span class="p">)</span>
				<span class="p">}</span>
                                <span class="k">if</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="mi">8</span> <span class="p">{</span>
                                        <span class="nx">n</span>  <span class="o">*=</span> <span class="mi">2</span>
                                <span class="p">}</span>
                                <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="mi">100</span><span class="p">)</span> <span class="p">)</span>			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="nf">wait</span><span class="p">(</span><span class="s">&#34;Coordinator.GetReduceFinish&#34;</span><span class="p">,</span> <span class="nx">step2</span><span class="p">,</span> <span class="nx">step2Done</span><span class="p">)</span>
	<span class="c1">// uncomment to send the Example RPC to the coordinator.
</span><span class="c1"></span>	<span class="c1">//CallExample()
</span><span class="c1"></span>
<span class="p">}</span>
</code></pre></div><h4 id="先看下默认的数据类型-keyvalue">先看下默认的数据类型 KeyValue</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">KeyValue</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Key</span>   <span class="kt">string</span>
	<span class="nx">Value</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre></div><h4 id="一个从示例代码copy的快排">一个从示例代码copy的快排</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// for sorting by key.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ByKey</span> <span class="p">[]</span><span class="nx">KeyValue</span>

<span class="c1">// for sorting by key.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="nx">ByKey</span><span class="p">)</span> <span class="nf">Len</span><span class="p">()</span> <span class="kt">int</span>           <span class="p">{</span> <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="nx">ByKey</span><span class="p">)</span> <span class="nf">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span>      <span class="p">{</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">a</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">a</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="nx">ByKey</span><span class="p">)</span> <span class="nf">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Key</span> <span class="p">&lt;</span> <span class="nx">a</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">Key</span> <span class="p">}</span>

</code></pre></div><h4 id="继续看下mapworker">继续看下mapWorker</h4>
<blockquote>
<p>部分可以从示例copy</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mapWorker</span><span class="p">(</span><span class="nx">mapf</span> <span class="kd">func</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="nx">KeyValue</span><span class="p">,</span> <span class="nx">in</span> <span class="nx">OutWorker</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 定义中间
</span><span class="c1"></span>	<span class="nx">intermediate</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">KeyValue</span><span class="p">{}</span>
	<span class="nx">file</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">in</span><span class="p">.</span><span class="nx">Filename</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">//log.Printf(&#34;%s read err : %v\n&#34;, filename, err)
</span><span class="c1"></span>		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">content</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadAll</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">//log.Printf(&#34;cannot read %v&#34;, filename)
</span><span class="c1"></span>		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">file</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="nx">kva</span> <span class="o">:=</span> <span class="nf">mapf</span><span class="p">(</span><span class="nx">in</span><span class="p">.</span><span class="nx">Filename</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">content</span><span class="p">))</span>
	<span class="nx">intermediate</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">intermediate</span><span class="p">,</span> <span class="nx">kva</span><span class="o">...</span><span class="p">)</span>
        <span class="c1">// 以上几乎都来自于mrsequential.go
</span><span class="c1"></span>
        <span class="c1">// 这里新建中间文件, 每个map worker可能写入到NReduce个文件中
</span><span class="c1"></span>	<span class="nx">files</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">os</span><span class="p">.</span><span class="nx">File</span><span class="p">,</span> <span class="nx">in</span><span class="p">.</span><span class="nx">NReduce</span><span class="p">)</span>
	<span class="nx">encs</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">json</span><span class="p">.</span><span class="nx">Encoder</span><span class="p">,</span> <span class="nx">in</span><span class="p">.</span><span class="nx">NReduce</span><span class="p">)</span>
	<span class="c1">// 这个mapf函数内不变
</span><span class="c1"></span>	<span class="nx">mapId</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">in</span><span class="p">.</span><span class="nx">Token</span><span class="p">)</span>
	<span class="c1">// 生成临时文件
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">in</span><span class="p">.</span><span class="nx">NReduce</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">files</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">TempFile</span><span class="p">(</span><span class="s">&#34;.&#34;</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;mr-map-tmp-%s-*&#34;</span><span class="p">,</span> <span class="nx">mapId</span><span class="p">))</span>
		<span class="nx">encs</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">NewEncoder</span><span class="p">(</span><span class="nx">files</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
	<span class="p">}</span>
	<span class="c1">// 写入临时文件
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">intermediate</span> <span class="p">{</span>
		<span class="nx">nr</span> <span class="o">:=</span> <span class="nf">ihash</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">Key</span><span class="p">)</span> <span class="o">%</span> <span class="nx">in</span><span class="p">.</span><span class="nx">NReduce</span>
		<span class="nx">_</span> <span class="p">=</span> <span class="nx">encs</span><span class="p">[</span><span class="nx">nr</span><span class="p">].</span><span class="nf">Encode</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
        <span class="c1">// 把零食文件重命名
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">files</span> <span class="p">{</span>
		<span class="nx">fName</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;mr-%s-%s.txt&#34;</span><span class="p">,</span> <span class="nx">mapId</span><span class="p">,</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
		<span class="k">if</span> <span class="nx">f</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">files</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="nx">encs</span><span class="p">))</span>
		<span class="p">}</span>
		<span class="nx">os</span><span class="p">.</span><span class="nf">Rename</span><span class="p">(</span><span class="nx">filepath</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nf">Name</span><span class="p">()),</span> <span class="nx">fName</span><span class="p">)</span>
		<span class="nx">files</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nf">Close</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">inWorker</span> <span class="o">:=</span> <span class="nx">InWorker</span><span class="p">{</span>
		<span class="nx">Filename</span><span class="p">:</span> <span class="nx">in</span><span class="p">.</span><span class="nx">Filename</span><span class="p">,</span>
		<span class="nx">Step</span><span class="p">:</span>     <span class="nx">step1</span><span class="p">,</span>
		<span class="nx">Token</span><span class="p">:</span>    <span class="nx">in</span><span class="p">.</span><span class="nx">Token</span><span class="p">,</span>
	<span class="p">}</span>
        <span class="c1">// 调用rpc方法
</span><span class="c1"></span>	<span class="nf">call</span><span class="p">(</span><span class="s">&#34;Coordinator.SetMapDoneOne&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">inWorker</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">OutWorker</span><span class="p">{})</span>
<span class="p">}</span>
</code></pre></div><h4 id="再来看下">再来看下</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="kd">func</span> <span class="nf">reduceWorker</span><span class="p">(</span><span class="nx">reducef</span> <span class="kd">func</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">in</span> <span class="nx">OutWorker</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 这个reducef函数内不变, 比如当前reduce worker的token是0
</span><span class="c1"></span>        <span class="c1">// 那么后续我会把所有mr-X-0.txt的文件的数据聚合
</span><span class="c1"></span>	<span class="nx">reduceId</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">in</span><span class="p">.</span><span class="nx">Token</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">kvs</span> <span class="p">[]</span><span class="nx">KeyValue</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">in</span><span class="p">.</span><span class="nx">NReduce</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">mapId</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
		<span class="nx">fName</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;mr-%s-%s.txt&#34;</span><span class="p">,</span> <span class="nx">mapId</span><span class="p">,</span> <span class="nx">reduceId</span><span class="p">)</span>
		<span class="nx">file</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">fName</span><span class="p">)</span>
                <span class="c1">// 这里同样通过json读取
</span><span class="c1"></span>		<span class="nx">dec</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">NewDecoder</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="kd">var</span> <span class="nx">kv</span> <span class="nx">KeyValue</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">dec</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">kv</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="nx">kvs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">kvs</span><span class="p">,</span> <span class="nx">kv</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">_</span> <span class="p">=</span> <span class="nx">file</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="c1">// 排序
</span><span class="c1"></span>	<span class="nx">sort</span><span class="p">.</span><span class="nf">Sort</span><span class="p">(</span><span class="nf">ByKey</span><span class="p">(</span><span class="nx">kvs</span><span class="p">))</span>
	<span class="c1">// 写入到 mr-out-Y.txt文件中
</span><span class="c1"></span>        <span class="c1">// 同样是通过临时文件的方式, 而不是create
</span><span class="c1"></span>	<span class="nx">oFile</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">TempFile</span><span class="p">(</span><span class="s">&#34;.&#34;</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;mr-reduce-tmp-%s-*&#34;</span><span class="p">,</span> <span class="nx">reduceId</span><span class="p">))</span>
	<span class="c1">//oFile, err := os.Create(fmt.Sprintf(&#34;mr-out-%s.txt&#34;, reduceId))
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;[reduceWorker] os.Create error : %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">kvs</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">j</span> <span class="o">:=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span>
		<span class="c1">// 因为是有序的, 所以我们期望找到相同的key一次性处理
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">kvs</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">kvs</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">Key</span> <span class="o">==</span> <span class="nx">kvs</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Key</span> <span class="p">{</span>
			<span class="nx">j</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="nx">values</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{}</span>
		<span class="c1">// 把所有相同的key的value聚合, 这里value都是字符串&#34;1&#34;
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">k</span> <span class="p">&lt;</span> <span class="nx">j</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">values</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">values</span><span class="p">,</span> <span class="nx">kvs</span><span class="p">[</span><span class="nx">k</span><span class="p">].</span><span class="nx">Value</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// reducef 直接结算values的长度即可
</span><span class="c1"></span>		<span class="nx">output</span> <span class="o">:=</span> <span class="nf">reducef</span><span class="p">(</span><span class="nx">kvs</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Key</span><span class="p">,</span> <span class="nx">values</span><span class="p">)</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">oFile</span><span class="p">,</span> <span class="s">&#34;%v %v\n&#34;</span><span class="p">,</span> <span class="nx">kvs</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Key</span><span class="p">,</span> <span class="nx">output</span><span class="p">)</span>
		<span class="nx">i</span> <span class="p">=</span> <span class="nx">j</span>
	<span class="p">}</span>
	<span class="nx">os</span><span class="p">.</span><span class="nf">Rename</span><span class="p">(</span><span class="nx">oFile</span><span class="p">.</span><span class="nf">Name</span><span class="p">(),</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;mr-out-%s.txt&#34;</span><span class="p">,</span> <span class="nx">reduceId</span><span class="p">))</span>
	<span class="nx">oFile</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="c1">// 通知coordinator 完成reduce
</span><span class="c1"></span>	<span class="nx">inWorker</span> <span class="o">:=</span> <span class="nx">InWorker</span><span class="p">{</span>
		<span class="nx">Step</span><span class="p">:</span>  <span class="nx">step2</span><span class="p">,</span>
		<span class="nx">Token</span><span class="p">:</span> <span class="nx">in</span><span class="p">.</span><span class="nx">Token</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nf">call</span><span class="p">(</span><span class="s">&#34;Coordinator.SetReduceDoneOne&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">inWorker</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">OutWorker</span><span class="p">{})</span>

<span class="p">}</span>

</code></pre></div><h4 id="最后一个wait方法">最后一个wait方法</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">wait</span><span class="p">(</span><span class="nx">rpcname</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">step</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">stepDone</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
		<span class="k">if</span> <span class="nf">call</span><span class="p">(</span><span class="nx">rpcname</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">InWorker</span><span class="p">{</span><span class="nx">Step</span><span class="p">:</span> <span class="nx">step</span><span class="p">},</span> <span class="o">&amp;</span><span class="nx">OutWorker</span><span class="p">{})</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">stepDone</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
<span class="p">}</span>
</code></pre></div><blockquote>
<p>以上worker.go的代码也都介绍完了</p>
</blockquote>
<h3 id="总结">总结</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="mf">1.</span> <span class="nx">需要注意一些锁的问题</span><span class="p">,</span><span class="nx">在正确的位置释放锁</span> <span class="p">,</span> <span class="nx">否则可能导致死锁</span>
<span class="mf">2.</span> <span class="nx">通过队列来分配任务是比较好用的一种方式</span>
<span class="mf">3.</span> <span class="nx">对于写文件通过临时文件是比较好的方式</span><span class="p">,</span> <span class="nx">防止crash的任务但是创建了mr</span><span class="o">-</span><span class="nx">out</span><span class="p">,</span><span class="nx">同时ioutil</span><span class="p">.</span><span class="nx">TempFile的dir是必须存在的</span><span class="p">,</span> <span class="nx">如果不存在会报错</span><span class="p">,</span> <span class="nx">由于我这里忽略了错误</span><span class="p">,</span><span class="nx">导致一开始有点问题</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go学习 令牌桶</title>
			<link>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-%E4%BB%A4%E7%89%8C%E6%A1%B6/</link>
			<pubDate>Fri, 10 Dec 2021 15:32:16 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-%E4%BB%A4%E7%89%8C%E6%A1%B6/</guid>
			<description>首先看个简单例子 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;github.com/gin-gonic/gin&amp;#34; &amp;#34;golang.org/x/time/rate&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;time&amp;#34; &amp;#34;errors&amp;#34; &amp;#34;io/ioutil&amp;#34; ) var ( limit = rate.NewLimiter(rate.Limit(1), 2) ) func limitMiddleware() func(*gin.Context) { return func(ctx *gin.Context) { if !limit.Allow() { ctx.String(http.StatusServiceUnavailable, &amp;#34;服务器忙...&amp;#34;) ctx.Abort() return } ctx.Next() } } func GetOnce(addr string) ([]byte,error) { resp, err := http.Get(&amp;#34;http://&amp;#34;+addr) if err != nil { return nil, err } defer resp.Body.Close() b,err := ioutil.ReadAll(resp.Body) if err != nil { return nil, err } if resp.</description>
			<content type="html"><![CDATA[<h2 id="首先看个简单例子">首先看个简单例子</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
	<span class="s">&#34;golang.org/x/time/rate&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
	<span class="s">&#34;time&#34;</span>
        <span class="s">&#34;errors&#34;</span>
        <span class="s">&#34;io/ioutil&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">limit</span> <span class="p">=</span> <span class="nx">rate</span><span class="p">.</span><span class="nf">NewLimiter</span><span class="p">(</span><span class="nx">rate</span><span class="p">.</span><span class="nf">Limit</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">limitMiddleware</span><span class="p">()</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">limit</span><span class="p">.</span><span class="nf">Allow</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">ctx</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusServiceUnavailable</span><span class="p">,</span> <span class="s">&#34;服务器忙...&#34;</span><span class="p">)</span>
			<span class="nx">ctx</span><span class="p">.</span><span class="nf">Abort</span><span class="p">()</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">ctx</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">GetOnce</span><span class="p">(</span><span class="nx">addr</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span><span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;http://&#34;</span><span class="o">+</span><span class="nx">addr</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
        <span class="nx">b</span><span class="p">,</span><span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadAll</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">StatusCode</span> <span class="o">!=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span> <span class="p">,</span><span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span><span class="p">,</span><span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">clientGin</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span> <span class="p">,</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">b</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">GetOnce</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;#%v: %v\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="mi">200</span><span class="p">)</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;#%v: %v\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">Default</span><span class="p">()</span>
	<span class="nx">r</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nf">limitMiddleware</span><span class="p">())</span>
	<span class="nx">r</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/limit&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;ok&#34;</span><span class="p">)</span>
	<span class="p">})</span>
	<span class="k">go</span> <span class="nf">clientGin</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="s">&#34;localhost:8080/limit&#34;</span><span class="p">)</span>
	<span class="nx">r</span><span class="p">.</span><span class="nf">Run</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// 执行结果
</span><span class="c1"></span><span class="p">[</span><span class="nx">GIN</span><span class="o">-</span><span class="nx">debug</span><span class="p">]</span> <span class="nx">GET</span>    <span class="o">/</span><span class="nx">limit</span>                    <span class="o">--</span><span class="p">&gt;</span> <span class="nx">main</span><span class="p">.</span><span class="nx">main</span><span class="p">.</span><span class="nf">func1</span> <span class="p">(</span><span class="mi">4</span> <span class="nx">handlers</span><span class="p">)</span>
<span class="p">[</span><span class="nx">GIN</span><span class="o">-</span><span class="nx">debug</span><span class="p">]</span> <span class="nx">Environment</span> <span class="nx">variable</span> <span class="nx">PORT</span> <span class="nx">is</span> <span class="nx">undefined</span><span class="p">.</span> <span class="nx">Using</span> <span class="nx">port</span> <span class="p">:</span><span class="mi">8080</span> <span class="nx">by</span> <span class="k">default</span>
<span class="p">[</span><span class="nx">GIN</span><span class="o">-</span><span class="nx">debug</span><span class="p">]</span> <span class="nx">Listening</span> <span class="nx">and</span> <span class="nx">serving</span> <span class="nx">HTTP</span> <span class="nx">on</span> <span class="p">:</span><span class="mi">8080</span>
<span class="p">[</span><span class="nx">GIN</span><span class="p">]</span> <span class="mi">2021</span><span class="o">/</span><span class="mi">12</span><span class="o">/</span><span class="mi">10</span> <span class="o">-</span> <span class="mi">15</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">23</span> <span class="p">|</span> <span class="mi">200</span> <span class="p">|</span>      <span class="mf">90.569</span><span class="nx">µs</span> <span class="p">|</span>             <span class="p">::</span><span class="mi">1</span> <span class="p">|</span> <span class="nx">GET</span>      <span class="s">&#34;/limit&#34;</span>
<span class="err">#</span><span class="mi">0</span><span class="p">:</span> <span class="nx">ok</span>
<span class="p">[</span><span class="nx">GIN</span><span class="p">]</span> <span class="mi">2021</span><span class="o">/</span><span class="mi">12</span><span class="o">/</span><span class="mi">10</span> <span class="o">-</span> <span class="mi">15</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">23</span> <span class="p">|</span> <span class="mi">200</span> <span class="p">|</span>      <span class="mf">12.282</span><span class="nx">µs</span> <span class="p">|</span>             <span class="p">::</span><span class="mi">1</span> <span class="p">|</span> <span class="nx">GET</span>      <span class="s">&#34;/limit&#34;</span>
<span class="err">#</span><span class="mi">1</span><span class="p">:</span> <span class="nx">ok</span>
<span class="p">[</span><span class="nx">GIN</span><span class="p">]</span> <span class="mi">2021</span><span class="o">/</span><span class="mi">12</span><span class="o">/</span><span class="mi">10</span> <span class="o">-</span> <span class="mi">15</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">23</span> <span class="p">|</span> <span class="mi">503</span> <span class="p">|</span>      <span class="mf">14.045</span><span class="nx">µs</span> <span class="p">|</span>             <span class="p">::</span><span class="mi">1</span> <span class="p">|</span> <span class="nx">GET</span>      <span class="s">&#34;/limit&#34;</span>
<span class="err">#</span><span class="mi">2</span><span class="p">:</span> <span class="nx">服务器忙</span><span class="o">...</span>
<span class="p">[</span><span class="nx">GIN</span><span class="p">]</span> <span class="mi">2021</span><span class="o">/</span><span class="mi">12</span><span class="o">/</span><span class="mi">10</span> <span class="o">-</span> <span class="mi">15</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">23</span> <span class="p">|</span> <span class="mi">503</span> <span class="p">|</span>       <span class="mf">6.766</span><span class="nx">µs</span> <span class="p">|</span>             <span class="p">::</span><span class="mi">1</span> <span class="p">|</span> <span class="nx">GET</span>      <span class="s">&#34;/limit&#34;</span>
<span class="err">#</span><span class="mi">3</span><span class="p">:</span> <span class="nx">服务器忙</span><span class="o">...</span>
<span class="p">[</span><span class="nx">GIN</span><span class="p">]</span> <span class="mi">2021</span><span class="o">/</span><span class="mi">12</span><span class="o">/</span><span class="mi">10</span> <span class="o">-</span> <span class="mi">15</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">23</span> <span class="p">|</span> <span class="mi">503</span> <span class="p">|</span>        <span class="mf">5.36</span><span class="nx">µs</span> <span class="p">|</span>             <span class="p">::</span><span class="mi">1</span> <span class="p">|</span> <span class="nx">GET</span>      <span class="s">&#34;/limit&#34;</span>
<span class="err">#</span><span class="mi">4</span><span class="p">:</span> <span class="nx">服务器忙</span><span class="o">...</span>
<span class="p">[</span><span class="nx">GIN</span><span class="p">]</span> <span class="mi">2021</span><span class="o">/</span><span class="mi">12</span><span class="o">/</span><span class="mi">10</span> <span class="o">-</span> <span class="mi">15</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">23</span> <span class="p">|</span> <span class="mi">503</span> <span class="p">|</span>       <span class="mf">44.56</span><span class="nx">µs</span> <span class="p">|</span>             <span class="p">::</span><span class="mi">1</span> <span class="p">|</span> <span class="nx">GET</span>      <span class="s">&#34;/limit&#34;</span>
<span class="err">#</span><span class="mi">5</span><span class="p">:</span> <span class="nx">服务器忙</span><span class="o">...</span>
<span class="p">[</span><span class="nx">GIN</span><span class="p">]</span> <span class="mi">2021</span><span class="o">/</span><span class="mi">12</span><span class="o">/</span><span class="mi">10</span> <span class="o">-</span> <span class="mi">15</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">23</span> <span class="p">|</span> <span class="mi">503</span> <span class="p">|</span>      <span class="mf">11.402</span><span class="nx">µs</span> <span class="p">|</span>             <span class="p">::</span><span class="mi">1</span> <span class="p">|</span> <span class="nx">GET</span>      <span class="s">&#34;/limit&#34;</span>
<span class="err">#</span><span class="mi">6</span><span class="p">:</span> <span class="nx">服务器忙</span><span class="o">...</span>
<span class="p">[</span><span class="nx">GIN</span><span class="p">]</span> <span class="mi">2021</span><span class="o">/</span><span class="mi">12</span><span class="o">/</span><span class="mi">10</span> <span class="o">-</span> <span class="mi">15</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">24</span> <span class="p">|</span> <span class="mi">200</span> <span class="p">|</span>      <span class="mf">21.299</span><span class="nx">µs</span> <span class="p">|</span>             <span class="p">::</span><span class="mi">1</span> <span class="p">|</span> <span class="nx">GET</span>      <span class="s">&#34;/limit&#34;</span>
<span class="err">#</span><span class="mi">7</span><span class="p">:</span> <span class="nx">ok</span>
</code></pre></div><blockquote>
<p>以上就是 go官方提供的令牌桶的实现, 简单好用</p>
<p>接下来我们详细看下源码实现</p>
</blockquote>
<h2 id="limiter">Limiter</h2>
<blockquote>
<p>我们从上面例子中的初始化函数入手</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// limit 字段表示qps, burst 表示桶的大小
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewLimiter</span><span class="p">(</span><span class="nx">r</span> <span class="nx">Limit</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Limiter</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Limiter</span><span class="p">{</span>
		<span class="nx">limit</span><span class="p">:</span> <span class="nx">r</span><span class="p">,</span>
		<span class="nx">burst</span><span class="p">:</span> <span class="nx">b</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="limiter-struct">Limiter struct</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Limiter</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">mu</span>     <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>      <span class="c1">// 锁
</span><span class="c1"></span>	<span class="nx">limit</span>  <span class="nx">Limit</span>           <span class="c1">// qps
</span><span class="c1"></span>	<span class="nx">burst</span>  <span class="kt">int</span>             <span class="c1">// 桶的容量
</span><span class="c1"></span>	<span class="nx">tokens</span> <span class="kt">float64</span>         <span class="c1">// 剩余的tokens数
</span><span class="c1"></span>	<span class="nx">last</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>         <span class="c1">// 最近发放token的时间
</span><span class="c1"></span>	<span class="nx">lastEvent</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>    <span class="c1">// 最近限流的时间
</span><span class="c1"></span><span class="p">}</span>

</code></pre></div><h2 id="allow-函数">Allow() 函数</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 对AllowN 包装, 获取一个token
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">lim</span> <span class="o">*</span><span class="nx">Limiter</span><span class="p">)</span> <span class="nf">Allow</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">lim</span><span class="p">.</span><span class="nf">AllowN</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// 对reserveN 包装, 延迟时间是0
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">lim</span> <span class="o">*</span><span class="nx">Limiter</span><span class="p">)</span> <span class="nf">AllowN</span><span class="p">(</span><span class="nx">now</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">lim</span><span class="p">.</span><span class="nf">reserveN</span><span class="p">(</span><span class="nx">now</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">).</span><span class="nx">ok</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">lim</span> <span class="o">*</span><span class="nx">Limiter</span><span class="p">)</span> <span class="nf">reserveN</span><span class="p">(</span><span class="nx">now</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">maxFutureReserve</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="nx">Reservation</span> <span class="p">{</span>
        <span class="c1">// 限流器的字段修改前要加锁的
</span><span class="c1"></span>	<span class="nx">lim</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">lim</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
        <span class="c1">// Inf 是 math.MaxFloat64
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">lim</span><span class="p">.</span><span class="nx">limit</span> <span class="o">==</span> <span class="nx">Inf</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">Reservation</span><span class="p">{</span>
                        <span class="c1">// 这里ok字段直接返回true
</span><span class="c1"></span>			<span class="nx">ok</span><span class="p">:</span>        <span class="kc">true</span><span class="p">,</span>
			<span class="nx">lim</span><span class="p">:</span>       <span class="nx">lim</span><span class="p">,</span>
			<span class="nx">tokens</span><span class="p">:</span>    <span class="nx">n</span><span class="p">,</span>
			<span class="nx">timeToAct</span><span class="p">:</span> <span class="nx">now</span><span class="p">,</span>
		<span class="p">}</span>
        <span class="c1">// 如果这里 qps设置为0
</span><span class="c1"></span>	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">lim</span><span class="p">.</span><span class="nx">limit</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">ok</span> <span class="kt">bool</span>
                <span class="c1">// 判断桶里面是否有存货
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">lim</span><span class="p">.</span><span class="nx">burst</span> <span class="o">&gt;=</span> <span class="nx">n</span> <span class="p">{</span>
                        <span class="c1">// 有存货直接设置为true
</span><span class="c1"></span>			<span class="nx">ok</span> <span class="p">=</span> <span class="kc">true</span>
                        <span class="c1">// 并且减少存货
</span><span class="c1"></span>			<span class="nx">lim</span><span class="p">.</span><span class="nx">burst</span> <span class="o">-=</span> <span class="nx">n</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">Reservation</span><span class="p">{</span>
			<span class="nx">ok</span><span class="p">:</span>        <span class="nx">ok</span><span class="p">,</span>
			<span class="nx">lim</span><span class="p">:</span>       <span class="nx">lim</span><span class="p">,</span>
			<span class="nx">tokens</span><span class="p">:</span>    <span class="nx">lim</span><span class="p">.</span><span class="nx">burst</span><span class="p">,</span>
			<span class="nx">timeToAct</span><span class="p">:</span> <span class="nx">now</span><span class="p">,</span>
		<span class="p">}</span>
	<span class="p">}</span>
        <span class="c1">// 如果 0 &lt; qps &lt; math.MaxFloat64 ,
</span><span class="c1"></span>        <span class="c1">// 那么就计算当前时间now距离last时间内 , 我们一共可以有多少个令牌发放, tokens最大只能是burst
</span><span class="c1"></span>        <span class="c1">// 详细见 &#34;说明1&#34;
</span><span class="c1"></span>	<span class="nx">now</span><span class="p">,</span> <span class="nx">last</span><span class="p">,</span> <span class="nx">tokens</span> <span class="o">:=</span> <span class="nx">lim</span><span class="p">.</span><span class="nf">advance</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span>

	<span class="c1">// 减去本次要发的令牌数
</span><span class="c1"></span>	<span class="nx">tokens</span> <span class="o">-=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>

	<span class="c1">// 计算要等待的时间
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">waitDuration</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
        <span class="c1">// 如果没有足够的token可以发放
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">tokens</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="c1">// 计算大概要多久才能有足够的token发放
</span><span class="c1"></span>                <span class="c1">// (-tokens)/qps 秒
</span><span class="c1"></span>		<span class="nx">waitDuration</span> <span class="p">=</span> <span class="nx">lim</span><span class="p">.</span><span class="nx">limit</span><span class="p">.</span><span class="nf">durationFromTokens</span><span class="p">(</span><span class="o">-</span><span class="nx">tokens</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 桶的容量 要大于n 并且 等待的时间 小于等于 maxFutureReserve(这里是0)
</span><span class="c1"></span>        <span class="c1">// 在这里的情况, 如果要ok=true的话 就必须burst大于等于n, 而且tokens也要大于等于n,这样waitDuration才大于等于0呢
</span><span class="c1"></span>        <span class="c1">// 当然其他函数调用 reserveN 时 maxFutureReserve 可能不通
</span><span class="c1"></span>	<span class="nx">ok</span> <span class="o">:=</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="nx">lim</span><span class="p">.</span><span class="nx">burst</span> <span class="o">&amp;&amp;</span> <span class="nx">waitDuration</span> <span class="o">&lt;=</span> <span class="nx">maxFutureReserve</span>

	<span class="c1">// Prepare reservation
</span><span class="c1"></span>	<span class="nx">r</span> <span class="o">:=</span> <span class="nx">Reservation</span><span class="p">{</span>
		<span class="nx">ok</span><span class="p">:</span>    <span class="nx">ok</span><span class="p">,</span>
		<span class="nx">lim</span><span class="p">:</span>   <span class="nx">lim</span><span class="p">,</span>
		<span class="nx">limit</span><span class="p">:</span> <span class="nx">lim</span><span class="p">.</span><span class="nx">limit</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">r</span><span class="p">.</span><span class="nx">tokens</span> <span class="p">=</span> <span class="nx">n</span>
                <span class="c1">// 在maxFutureReserve 非0的时候, waitDuration 也可能非0, 所以可能要延迟
</span><span class="c1"></span>		<span class="nx">r</span><span class="p">.</span><span class="nx">timeToAct</span> <span class="p">=</span> <span class="nx">now</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">waitDuration</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 更新状态
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">lim</span><span class="p">.</span><span class="nx">last</span> <span class="p">=</span> <span class="nx">now</span>
		<span class="nx">lim</span><span class="p">.</span><span class="nx">tokens</span> <span class="p">=</span> <span class="nx">tokens</span>
		<span class="nx">lim</span><span class="p">.</span><span class="nx">lastEvent</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">timeToAct</span>
        <span class="c1">// 没拿到token, 还是还原数据
</span><span class="c1"></span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">lim</span><span class="p">.</span><span class="nx">last</span> <span class="p">=</span> <span class="nx">last</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>

</code></pre></div><blockquote>
<p>看完我们发现,  令牌桶的设计就是一个 tokens 来计数, 通过 now时间last的时间差 , qps, burst 来计算和调整新的tokens 数</p>
<p>接着我们看一下另外一个函数, Wait()</p>
</blockquote>
<h2 id="wait-函数">Wait() 函数</h2>
<blockquote>
<p>Wait 顾名思义是会阻塞一直等待获得到token, 而Allow() 则直接返回 bool</p>
<p>Wait 还可以传入一个 ctx参数, 可以设置超时时间 或者结束时间</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 包装WaitN
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">lim</span> <span class="o">*</span><span class="nx">Limiter</span><span class="p">)</span> <span class="nf">Wait</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 同样获取1个token
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">lim</span><span class="p">.</span><span class="nf">WaitN</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">lim</span> <span class="o">*</span><span class="nx">Limiter</span><span class="p">)</span> <span class="nf">WaitN</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 同样需要锁
</span><span class="c1"></span>	<span class="nx">lim</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
        <span class="c1">// 读取桶大小和qps
</span><span class="c1"></span>	<span class="nx">burst</span> <span class="o">:=</span> <span class="nx">lim</span><span class="p">.</span><span class="nx">burst</span>
	<span class="nx">limit</span> <span class="o">:=</span> <span class="nx">lim</span><span class="p">.</span><span class="nx">limit</span>
	<span class="nx">lim</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="nx">burst</span> <span class="o">&amp;&amp;</span> <span class="nx">limit</span> <span class="o">!=</span> <span class="nx">Inf</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;rate: Wait(n=%d) exceeds limiter&#39;s burst %d&#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">burst</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 查看ctx是否已经结束
</span><span class="c1"></span>	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
		<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Err</span><span class="p">()</span>
	<span class="k">default</span><span class="p">:</span>
	<span class="p">}</span>
	<span class="c1">// Determine wait limit
</span><span class="c1"></span>	<span class="nx">now</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
        <span class="c1">// InfDuration = 1&lt;&lt;63-1
</span><span class="c1"></span>	<span class="nx">waitLimit</span> <span class="o">:=</span> <span class="nx">InfDuration</span>
        <span class="c1">// deadline 就是 ctx设置的
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">deadline</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Deadline</span><span class="p">();</span> <span class="nx">ok</span> <span class="p">{</span>
                <span class="c1">// waitLimit 表示ctx 结束时间
</span><span class="c1"></span>		<span class="nx">waitLimit</span> <span class="p">=</span> <span class="nx">deadline</span><span class="p">.</span><span class="nf">Sub</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 这里调用reserveN 和Allow()不同的是, 延迟时间参数waitLimit
</span><span class="c1"></span>        <span class="c1">// waitLimit 既然表示ctx cancel() 的最后时间, 那么意思是 waitDuration 只要小于等于 结束时间 就有可能 r.ok == true
</span><span class="c1"></span>	<span class="nx">r</span> <span class="o">:=</span> <span class="nx">lim</span><span class="p">.</span><span class="nf">reserveN</span><span class="p">(</span><span class="nx">now</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">waitLimit</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">r</span><span class="p">.</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;rate: Wait(n=%d) would exceed context deadline&#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 这里是把 r.timeToAct - now, r.timeToAct 我们知道在reserveN 函数内部被更新了
</span><span class="c1"></span>	<span class="nx">delay</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">DelayFrom</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">delay</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
        <span class="c1">// 新建一个定时器
</span><span class="c1"></span>	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="nx">delay</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
	<span class="k">select</span> <span class="p">{</span>
        <span class="c1">// 延迟
</span><span class="c1"></span>	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">t</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
		<span class="c1">// We can proceed.
</span><span class="c1"></span>		<span class="k">return</span> <span class="kc">nil</span>
        <span class="c1">// 也有可能ctx 被设置结束了
</span><span class="c1"></span>	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
                <span class="c1">// Reservation 是包含了 limiter的
</span><span class="c1"></span>                <span class="c1">// 通过Reservation对令牌桶的数据进行还原, 详细见 &#34;说明2&#34;
</span><span class="c1"></span>		<span class="nx">r</span><span class="p">.</span><span class="nf">Cancel</span><span class="p">()</span>
		<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Err</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><hr>
<h2 id="详细说明">详细说明</h2>
<h3 id="说明1">说明1</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">lim</span> <span class="o">*</span><span class="nx">Limiter</span><span class="p">)</span> <span class="nf">advance</span><span class="p">(</span><span class="nx">now</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="p">(</span><span class="nx">newNow</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="nx">newLast</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="nx">newTokens</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 最近发放token的时间
</span><span class="c1"></span>	<span class="nx">last</span> <span class="o">:=</span> <span class="nx">lim</span><span class="p">.</span><span class="nx">last</span>
        <span class="c1">// 如果 now &lt; last
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">now</span><span class="p">.</span><span class="nf">Before</span><span class="p">(</span><span class="nx">last</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">last</span> <span class="p">=</span> <span class="nx">now</span>
	<span class="p">}</span>
        <span class="c1">// 到这里 now 肯定是 &gt;= last
</span><span class="c1"></span>	<span class="c1">// now - last &gt;= 0
</span><span class="c1"></span>	<span class="nx">elapsed</span> <span class="o">:=</span> <span class="nx">now</span><span class="p">.</span><span class="nf">Sub</span><span class="p">(</span><span class="nx">last</span><span class="p">)</span>
        <span class="c1">// 获得这段时间中 可以有几个令牌
</span><span class="c1"></span>	<span class="nx">delta</span> <span class="o">:=</span> <span class="nx">lim</span><span class="p">.</span><span class="nx">limit</span><span class="p">.</span><span class="nf">tokensFromDuration</span><span class="p">(</span><span class="nx">elapsed</span><span class="p">)</span>
        <span class="c1">// 获得最新可以发放的总令牌数
</span><span class="c1"></span>	<span class="nx">tokens</span> <span class="o">:=</span> <span class="nx">lim</span><span class="p">.</span><span class="nx">tokens</span> <span class="o">+</span> <span class="nx">delta</span>
        <span class="c1">// 如果超过了桶的容量, 那没办法, 最大是桶的容量
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">burst</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">lim</span><span class="p">.</span><span class="nx">burst</span><span class="p">);</span> <span class="nx">tokens</span> <span class="p">&gt;</span> <span class="nx">burst</span> <span class="p">{</span>
		<span class="nx">tokens</span> <span class="p">=</span> <span class="nx">burst</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">now</span><span class="p">,</span> <span class="nx">last</span><span class="p">,</span> <span class="nx">tokens</span>
<span class="p">}</span>

<span class="c1">// 比如qps=5, 表示1秒可以有5个token
</span><span class="c1">// 那假如 now-last 差是1s
</span><span class="c1">// 那么说明1s我没有发放token了, 那我应该要发放 5个token
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">limit</span> <span class="nx">Limit</span><span class="p">)</span> <span class="nf">tokensFromDuration</span><span class="p">(</span><span class="nx">d</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">limit</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">d</span><span class="p">.</span><span class="nf">Seconds</span><span class="p">()</span> <span class="o">*</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">limit</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3 id="说明2">说明2</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Reservation</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">ok</span>        <span class="kt">bool</span>         <span class="c1">// 是否拿到了token
</span><span class="c1"></span>	<span class="nx">lim</span>       <span class="o">*</span><span class="nx">Limiter</span>     <span class="c1">// 令牌桶地址
</span><span class="c1"></span>	<span class="nx">tokens</span>    <span class="kt">int</span>          <span class="c1">// 令牌桶剩余的token数
</span><span class="c1"></span>	<span class="nx">timeToAct</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>    <span class="c1">// 发放令牌的时间(可能是未来时间)
</span><span class="c1"></span>	<span class="nx">limit</span> <span class="nx">Limit</span>            <span class="c1">// qps
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Reservation</span><span class="p">)</span> <span class="nf">Cancel</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">r</span><span class="p">.</span><span class="nf">CancelAt</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Reservation</span><span class="p">)</span> <span class="nf">CancelAt</span><span class="p">(</span><span class="nx">now</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">r</span><span class="p">.</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
        <span class="c1">// 上锁
</span><span class="c1"></span>	<span class="nx">r</span><span class="p">.</span><span class="nx">lim</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">r</span><span class="p">.</span><span class="nx">lim</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
        <span class="c1">// 这种情况 都不用处理直接返回
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">lim</span><span class="p">.</span><span class="nx">limit</span> <span class="o">==</span> <span class="nx">Inf</span> <span class="o">||</span> <span class="nx">r</span><span class="p">.</span><span class="nx">tokens</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">r</span><span class="p">.</span><span class="nx">timeToAct</span><span class="p">.</span><span class="nf">Before</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// calculate tokens to restore
</span><span class="c1"></span>	<span class="c1">// The duration between lim.lastEvent and r.timeToAct tells us how many tokens were reserved
</span><span class="c1"></span>	<span class="c1">// after r was obtained. These tokens should not be restored.
</span><span class="c1"></span>	<span class="nx">restoreTokens</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">tokens</span><span class="p">)</span> <span class="o">-</span> <span class="nx">r</span><span class="p">.</span><span class="nx">limit</span><span class="p">.</span><span class="nf">tokensFromDuration</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">lim</span><span class="p">.</span><span class="nx">lastEvent</span><span class="p">.</span><span class="nf">Sub</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">timeToAct</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">restoreTokens</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// advance time to now
</span><span class="c1"></span>	<span class="nx">now</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">tokens</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">lim</span><span class="p">.</span><span class="nf">advance</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span>
	<span class="c1">// calculate new number of tokens
</span><span class="c1"></span>	<span class="nx">tokens</span> <span class="o">+=</span> <span class="nx">restoreTokens</span>
	<span class="k">if</span> <span class="nx">burst</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">lim</span><span class="p">.</span><span class="nx">burst</span><span class="p">);</span> <span class="nx">tokens</span> <span class="p">&gt;</span> <span class="nx">burst</span> <span class="p">{</span>
		<span class="nx">tokens</span> <span class="p">=</span> <span class="nx">burst</span>
	<span class="p">}</span>
	<span class="c1">// update state
</span><span class="c1"></span>	<span class="nx">r</span><span class="p">.</span><span class="nx">lim</span><span class="p">.</span><span class="nx">last</span> <span class="p">=</span> <span class="nx">now</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">lim</span><span class="p">.</span><span class="nx">tokens</span> <span class="p">=</span> <span class="nx">tokens</span>
	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">timeToAct</span> <span class="o">==</span> <span class="nx">r</span><span class="p">.</span><span class="nx">lim</span><span class="p">.</span><span class="nx">lastEvent</span> <span class="p">{</span>
		<span class="nx">prevEvent</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">timeToAct</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">limit</span><span class="p">.</span><span class="nf">durationFromTokens</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="o">-</span><span class="nx">r</span><span class="p">.</span><span class="nx">tokens</span><span class="p">)))</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">prevEvent</span><span class="p">.</span><span class="nf">Before</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">r</span><span class="p">.</span><span class="nx">lim</span><span class="p">.</span><span class="nx">lastEvent</span> <span class="p">=</span> <span class="nx">prevEvent</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><p>1</p>
]]></content>
		</item>
		
		<item>
			<title>Go学习 Map源码分析</title>
			<link>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-map%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
			<pubDate>Mon, 22 Nov 2021 13:59:53 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-map%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
			<description>在看map之前,我们从一个简单的代码开始 1 package main 2 func main() { 3	a := make(map[int]int,209) 4	a[1] = 1 5	print(a[1]) 6 }  以上代码我们看下编译的map相关调用  go tool compile -S map源码分析.go|egrep &amp;quot;map源码分析.*CALL.*map&amp;quot; 0x0051 00081 (map源码分析.go:3)	CALL	runtime.makemap(SB)	// 显然第3行是初始化 0x0079 00121 (map源码分析.go:4)	CALL	runtime.mapassign_fast64(SB) //第4行是写入 0x00a8 00168 (map源码分析.go:5)	CALL	runtime.mapaccess1_fast64(SB) //第5行是读取 首先看下相关结构体hmap type hmap struct { // Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go. 	// Make sure this stays in sync with the compiler&amp;#39;s definition.</description>
			<content type="html"><![CDATA[<h3 id="在看map之前我们从一个简单的代码开始">在看map之前,我们从一个简单的代码开始</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="mi">1</span> <span class="kn">package</span> <span class="nx">main</span>
<span class="mi">2</span> <span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="mi">3</span>	<span class="nx">a</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span><span class="mi">209</span><span class="p">)</span>
<span class="mi">4</span>	<span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
<span class="mi">5</span>	<span class="nb">print</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="mi">6</span> <span class="p">}</span>
</code></pre></div><ul>
<li>以上代码我们看下编译的map相关调用</li>
</ul>
<pre><code>go tool compile -S map源码分析.go|egrep &quot;map源码分析.*CALL.*map&quot;
	0x0051 00081 (map源码分析.go:3)	CALL	runtime.makemap(SB)	      // 显然第3行是初始化
	0x0079 00121 (map源码分析.go:4)	CALL	runtime.mapassign_fast64(SB)  //第4行是写入
	0x00a8 00168 (map源码分析.go:5)	CALL	runtime.mapaccess1_fast64(SB) //第5行是读取
</code></pre><h3 id="首先看下相关结构体hmap">首先看下相关结构体hmap</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">hmap</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.
</span><span class="c1"></span>	<span class="c1">// Make sure this stays in sync with the compiler&#39;s definition.
</span><span class="c1"></span>	<span class="nx">count</span>      <span class="kt">int</span>            <span class="c1">// # 已经在使用的键值对总数, len(map)的值
</span><span class="c1"></span>	<span class="nx">flags</span>      <span class="kt">uint8</span>          <span class="c1">// 标志位
</span><span class="c1"></span>	<span class="nx">B</span>          <span class="kt">uint8</span>          <span class="c1">// 装载因子, 2^B = 桶的大小
</span><span class="c1"></span>	<span class="nx">noverflow</span>  <span class="kt">uint16</span>         <span class="c1">// overflow 的 bucket 近似数
</span><span class="c1"></span>	<span class="nx">hash0</span>      <span class="kt">uint32</span>         <span class="c1">// 哈希因子
</span><span class="c1"></span>	<span class="nx">buckets</span>    <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 桶的大小 , may be nil if count==0.
</span><span class="c1"></span>	<span class="nx">oldbuckets</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 通常是nil, 如果在扩容,就是旧的桶
</span><span class="c1"></span>	<span class="nx">nevacuate</span>  <span class="kt">uintptr</span>        <span class="c1">// 指示扩容进度，小于此地址的 buckets 迁移完成
</span><span class="c1"></span>	<span class="nx">extra</span>      <span class="o">*</span><span class="nx">mapextra</span>      <span class="c1">// 溢出桶
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">mapextra</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">overflow</span>     <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span>
	<span class="nx">oldoverflow</span>  <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span>
	<span class="nx">nextOverflow</span> <span class="o">*</span><span class="nx">bmap</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">bmap</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">tophash</span> <span class="p">[</span><span class="nx">bucketCnt</span><span class="p">]</span><span class="kt">uint8</span>  <span class="c1">// hash值的高8位
</span><span class="c1"></span>	<span class="c1">//在src/cmd/compile/internal/gc/reflect.go里面bmap函数会添加该字段,以及后续几个字段
</span><span class="c1"></span>	<span class="c1">//keys Type		  // key类型
</span><span class="c1"></span>	<span class="c1">//elems Type	          // value类型
</span><span class="c1"></span>	<span class="c1">//overflow unsafe.Pointer // 解决冲突的链表指针
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h3 id="runtimemakemap-代码">runtime.makemap 代码</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/map.go
</span><span class="c1">// 以上示例 hint=209
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">makemap</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">hint</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">)</span> <span class="o">*</span><span class="nx">hmap</span> <span class="p">{</span>
	<span class="c1">// 判断 hint * size 是否溢出
</span><span class="c1"></span>	<span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">hint</span><span class="p">),</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">mem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span> <span class="p">{</span>
		<span class="nx">hint</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="c1">// 初始化Hmap
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">h</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">hmap</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 生成哈希因子
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span> <span class="p">=</span> <span class="nf">fastrand</span><span class="p">()</span>

	<span class="nx">B</span> <span class="o">:=</span> <span class="nb">uint8</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="c1">// 找到一个 B，使得 map 的装载因子在正常范围内
</span><span class="c1"></span>	<span class="c1">// 这里hint=209,因此B=5, overLoadFactor 详细内容后面有分析
</span><span class="c1"></span>	<span class="k">for</span> <span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">hint</span><span class="p">,</span> <span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">B</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="p">=</span> <span class="nx">B</span>
	<span class="c1">// 如果hint&gt;8,那么h.B就一定不等于0了
</span><span class="c1"></span>        <span class="c1">// 所以如果hint&lt;=8, 就不会初始化桶吗? - 是的, 会在写入的时候初始化
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">nextOverflow</span> <span class="o">*</span><span class="nx">bmap</span>
		<span class="c1">// 这里显然就是生成桶了
</span><span class="c1"></span>		<span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">nextOverflow</span> <span class="p">=</span> <span class="nf">makeBucketArray</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="c1">// 如果需要生成extra桶
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">nextOverflow</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">mapextra</span><span class="p">)</span>
			<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">nextOverflow</span> <span class="p">=</span> <span class="nx">nextOverflow</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">h</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>overLoadFactor</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">count</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">B</span> <span class="kt">uint8</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// bucketCnt = 8
</span><span class="c1"></span>	<span class="c1">// loadFactorNum = 13
</span><span class="c1"></span>	<span class="c1">// loadFactorDen = 2
</span><span class="c1"></span>	<span class="c1">// 如果 B = 0
</span><span class="c1"></span>	<span class="c1">// count &gt; 8 &amp;&amp; count &gt; 13 * (1 &lt;&lt; ( 0 &amp; 63)) / 2
</span><span class="c1"></span>	<span class="c1">// B = 0 :  count &gt; 8 &amp;&amp; count &gt; 6.5
</span><span class="c1"></span>	<span class="c1">// B = 1 :  count &gt; 8 &amp;&amp; count &gt; 13
</span><span class="c1"></span>	<span class="c1">// B = 2 :  count &gt; 8 &amp;&amp; count &gt; 26
</span><span class="c1"></span>	<span class="c1">// B = 3 :  count &gt; 8 &amp;&amp; count &gt; 52
</span><span class="c1"></span>	<span class="c1">// B = 4 :  count &gt; 8 &amp;&amp; count &gt; 104
</span><span class="c1"></span>	<span class="c1">// B = 5 :  count &gt; 8 &amp;&amp; count &gt; 208
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">count</span> <span class="p">&gt;</span> <span class="nx">bucketCnt</span> <span class="o">&amp;&amp;</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">loadFactorNum</span><span class="o">*</span><span class="p">(</span><span class="nf">bucketShift</span><span class="p">(</span><span class="nx">B</span><span class="p">)</span><span class="o">/</span><span class="nx">loadFactorDen</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">bucketShift</span><span class="p">(</span><span class="nx">b</span> <span class="kt">uint8</span><span class="p">)</span> <span class="kt">uintptr</span> <span class="p">{</span>
	<span class="c1">// const PtrSize = 4 &lt;&lt; (^uintptr(0) &gt;&gt; 63)
</span><span class="c1"></span>	<span class="c1">// 这里对0取反 == math.MaxUint64, 然后向右位移63那么结果就是1,所以PtrSize = 8
</span><span class="c1"></span>	<span class="c1">// 1 &lt;&lt; ( b &amp; 8*8-1)
</span><span class="c1"></span>	<span class="c1">// 也就是b对一个8位的全是1的与运算, 就是取低八位
</span><span class="c1"></span>	<span class="k">return</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nx">b</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="o">*</span><span class="mi">8</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>makeBucketArray</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">makeBucketArray</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">uint8</span><span class="p">,</span> <span class="nx">dirtyalloc</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">(</span><span class="nx">buckets</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">nextOverflow</span> <span class="o">*</span><span class="nx">bmap</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 假设b=5, base = 1 &lt;&lt; 5 = 32
</span><span class="c1"></span>	<span class="nx">base</span> <span class="o">:=</span> <span class="nf">bucketShift</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
	<span class="nx">nbuckets</span> <span class="o">:=</span> <span class="nx">base</span>
	<span class="k">if</span> <span class="nx">b</span> <span class="o">&gt;=</span> <span class="mi">4</span> <span class="p">{</span>
		<span class="c1">// nbuckets = 32+2,
</span><span class="c1"></span>		<span class="nx">nbuckets</span> <span class="o">+=</span> <span class="nf">bucketShift</span><span class="p">(</span><span class="nx">b</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span>
		<span class="nx">sz</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">size</span> <span class="o">*</span> <span class="nx">nbuckets</span>
		<span class="nx">up</span> <span class="o">:=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nx">sz</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">up</span> <span class="o">!=</span> <span class="nx">sz</span> <span class="p">{</span>
			<span class="nx">nbuckets</span> <span class="p">=</span> <span class="nx">up</span> <span class="o">/</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">size</span>
		<span class="p">}</span>
	<span class="p">}</span>
        <span class="c1">// 这里会生成nbucket大小的桶
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">dirtyalloc</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="c1">// 调用mallocgc分配一个连续的内存空间
</span><span class="c1"></span>		<span class="nx">buckets</span> <span class="p">=</span> <span class="nf">newarray</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">nbuckets</span><span class="p">))</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">buckets</span> <span class="p">=</span> <span class="nx">dirtyalloc</span>
		<span class="nx">size</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">size</span> <span class="o">*</span> <span class="nx">nbuckets</span>
		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">memclrHasPointers</span><span class="p">(</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">base</span> <span class="o">!=</span> <span class="nx">nbuckets</span> <span class="p">{</span>
		<span class="nx">nextOverflow</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">base</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
		<span class="nx">last</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">buckets</span><span class="p">,</span> <span class="p">(</span><span class="nx">nbuckets</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
		<span class="nx">last</span><span class="p">.</span><span class="nf">setoverflow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nx">buckets</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">buckets</span><span class="p">,</span> <span class="nx">nextOverflow</span>
<span class="p">}</span>

</code></pre></div><h3 id="runtimemapassign-map写入">runtime.mapassign map写入</h3>
<blockquote>
<p>runtime.mapassign_fast64 或runtime.mapassign_fast32类似runtime.mapassign, 我们这里直接看mapassign</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mapassign</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">h</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;assignment to entry in nil map&#34;</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="o">...</span>
	<span class="c1">// 这里说明map并发不安全
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">hashWriting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;concurrent map writes&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 根据key 和哈希因子生成哈希
</span><span class="c1"></span>	<span class="nx">hash</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span><span class="p">))</span>
	<span class="c1">// 异或之后下次两个肯定不同了, 就会 throw(&#34;concurrent map writes&#34;)
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="p">^=</span> <span class="nx">hashWriting</span>
        <span class="c1">// 如果是nil, 写入的时候会初始化
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="c1">// 调用mallocgc分配一个大小为h.bucket.size的内存空间
</span><span class="c1"></span>                <span class="c1">// 所以如果make初始化的时候, hint&lt;=8的话, 是在这里初始化
</span><span class="c1"></span>		<span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span> <span class="p">=</span> <span class="nf">newobject</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">)</span> <span class="c1">// newarray(t.bucket, 1)
</span><span class="c1"></span>	<span class="p">}</span>
<span class="c1">// 核心代码
</span><span class="c1"></span><span class="nx">again</span><span class="p">:</span>
	<span class="c1">// bucketMask(h.B) = 2^h.B -1
</span><span class="c1"></span>	<span class="c1">// bucket就是得到hash值的 低B位, 就是要放到哪个桶的索引
</span><span class="c1"></span>	<span class="nx">bucket</span> <span class="o">:=</span> <span class="nx">hash</span> <span class="o">&amp;</span> <span class="nf">bucketMask</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span>
	<span class="c1">// 是否扩容
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nf">growing</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// 迁移数据
</span><span class="c1"></span>		<span class="nf">growWork</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">bucket</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// h.buckets 是桶的初始地址
</span><span class="c1"></span>	<span class="c1">// add就可以找到需要放入的桶的 地址
</span><span class="c1"></span>	<span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">bucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
	<span class="c1">// 根据hash得到高8位
</span><span class="c1"></span>	<span class="nx">top</span> <span class="o">:=</span> <span class="nf">tophash</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">inserti</span> <span class="o">*</span><span class="kt">uint8</span>
	<span class="kd">var</span> <span class="nx">insertk</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
	<span class="kd">var</span> <span class="nx">elem</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="nx">bucketloop</span><span class="p">:</span>
	<span class="c1">// 这里两层循环
</span><span class="c1"></span>	<span class="c1">// 外层是对 overflow的溢出链表进行循环
</span><span class="c1"></span>	<span class="c1">// 内层是对 当个bmap的bucketCnt个数组进行循环
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
		<span class="c1">// 内层
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="c1">// 先比较看tophash是否相同
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">top</span> <span class="p">{</span> <span class="c1">// 不相同
</span><span class="c1"></span>				<span class="c1">// tophash为空的
</span><span class="c1"></span>				<span class="k">if</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="nx">inserti</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="c1">// 保留该桶的槽点地址,后续如果没有找到key,是需要写入到该地址的
</span><span class="c1"></span>					<span class="nx">inserti</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
					<span class="c1">// 根据bmap结构体结构 计算出key的地址
</span><span class="c1"></span>					<span class="nx">insertk</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
					<span class="c1">// 根据bmap结构体结构 计算出value的地址, 多一个bucketCnt*uintptr(t.keysize)的偏移量
</span><span class="c1"></span>					<span class="nx">elem</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">emptyRest</span> <span class="p">{</span>
					<span class="k">break</span> <span class="nx">bucketloop</span>
				<span class="p">}</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="c1">// 如果tophash相同
</span><span class="c1"></span>			<span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">k</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="c1">// 如果不是我们需要找的key,就继续内层循环
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">!</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="c1">// 走到这里说明,找到了我们要的key, 你们就要更新它
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">needkeyupdate</span><span class="p">()</span> <span class="p">{</span>
				<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="c1">// 得到elem的地址
</span><span class="c1"></span>			<span class="nx">elem</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
			<span class="c1">// 找到了就可以去done了, 不需要继续循环
</span><span class="c1"></span>			<span class="k">goto</span> <span class="nx">done</span>
		<span class="p">}</span>
		<span class="c1">// 链表下一个节点
</span><span class="c1"></span>		<span class="nx">ovf</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
		<span class="c1">// 已经是链表的尾巴
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">ovf</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="c1">// 递归
</span><span class="c1"></span>		<span class="nx">b</span> <span class="p">=</span> <span class="nx">ovf</span>
	<span class="p">}</span>

	<span class="c1">// 走到这里说明 没有找到我们要找的key
</span><span class="c1"></span>
	<span class="c1">// 做一次扩容判断, 两个条件会扩容
</span><span class="c1"></span>	<span class="c1">// 1. h.count+1 &gt; 8 &amp;&amp; h.count+1 &gt; 6.5 * 2^h.B ,这种情况说明桶快要满了, 因为满的情况就是h.count = 8 * 2^h.B
</span><span class="c1"></span>	<span class="c1">// 2. h.noverflow &gt;= 2 ^ h.B (B超过15会被赋值为15) , 这种情况说明溢出链表过长, 性能很差
</span><span class="c1"></span>	<span class="c1">// 以上情况如果满足, 并且当前没有正在扩容
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">growing</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">count</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="o">||</span> <span class="nf">tooManyOverflowBuckets</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">noverflow</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">))</span> <span class="p">{</span>
		<span class="c1">// 开始扩容, 详细见下方
</span><span class="c1"></span>		<span class="nf">hashGrow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">)</span>
		<span class="k">goto</span> <span class="nx">again</span> <span class="c1">// Growing the table invalidates everything, so try again
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="c1">// 如果前面没有找到空槽位, 那么就需要添加链表了, 因为前面break的时候 b.overflow(t) == nil了, 已经找到尾巴了
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">inserti</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 新建一个bmap
</span><span class="c1"></span>		<span class="nx">newb</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">newoverflow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
		<span class="c1">// 插入第一个槽点, index=0
</span><span class="c1"></span>		<span class="nx">inserti</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">newb</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="c1">// 找到插入的key的地址
</span><span class="c1"></span>		<span class="nx">insertk</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">newb</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="p">)</span>
		<span class="c1">// 根据key的地址继续偏移 找到value的地址
</span><span class="c1"></span>		<span class="nx">elem</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">insertk</span><span class="p">,</span> <span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="c1">// key是指针的话需要取值
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">kmem</span> <span class="o">:=</span> <span class="nf">newobject</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span>
		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">insertk</span><span class="p">)</span> <span class="p">=</span> <span class="nx">kmem</span>
		<span class="nx">insertk</span> <span class="p">=</span> <span class="nx">kmem</span>
	<span class="p">}</span>
	<span class="c1">// value是指针的话需要取值
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectelem</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">vmem</span> <span class="o">:=</span> <span class="nf">newobject</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elem</span><span class="p">)</span>
		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">elem</span><span class="p">)</span> <span class="p">=</span> <span class="nx">vmem</span>
	<span class="p">}</span>
	<span class="c1">// key写到insertk的位置
</span><span class="c1"></span>	<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">insertk</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
	<span class="o">*</span><span class="nx">inserti</span> <span class="p">=</span> <span class="nx">top</span>
	<span class="c1">// count++
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">count</span><span class="o">++</span>

<span class="nx">done</span><span class="p">:</span>
	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">hashWriting</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;concurrent map writes&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;^=</span> <span class="nx">hashWriting</span>
	<span class="c1">// 如果elem是指针,就做一次取值
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectelem</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">elem</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">elem</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">elem</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>tophash</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">tophash</span><span class="p">(</span><span class="nx">hash</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">uint8</span> <span class="p">{</span>
	<span class="c1">// 把hash结果向右移动 8*8-8位, 也就是只保留高8位
</span><span class="c1"></span>	<span class="nx">top</span> <span class="o">:=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">hash</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="o">*</span><span class="mi">8</span> <span class="o">-</span> <span class="mi">8</span><span class="p">))</span>
	<span class="c1">// minTopHash = 5
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">top</span> <span class="p">&lt;</span> <span class="nx">minTopHash</span> <span class="p">{</span>
		<span class="nx">top</span> <span class="o">+=</span> <span class="nx">minTopHash</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">top</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>tooManyOverflowBuckets</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">tooManyOverflowBuckets</span><span class="p">(</span><span class="nx">noverflow</span> <span class="kt">uint16</span><span class="p">,</span> <span class="nx">B</span> <span class="kt">uint8</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">B</span> <span class="p">&gt;</span> <span class="mi">15</span> <span class="p">{</span>
		<span class="nx">B</span> <span class="p">=</span> <span class="mi">15</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">noverflow</span> <span class="o">&gt;=</span> <span class="nb">uint16</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="nx">B</span><span class="o">&amp;</span><span class="mi">15</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3 id="runtimehashgrow-扩容">runtime.hashGrow 扩容</h3>
<p><img src="/images/golang/map-1.png" alt=""></p>
<ul>
<li>首先做一个简单的说明</li>
</ul>
<pre><code>扩容的两个条件已经说过了,
第一个条件是因为桶都快要满了, 我们知道一个bmap中的kv最多可以是8个, 剩下的通过overflow链表保存, 装载因子达到6.5说明已经很满了,8的话就是已经满了
这种情况是翻倍扩容, 我们直接对h.B +1 即可, buckets长度会翻倍, 由 2^B -&gt; 2^(B+1)

第二个条件是对第一点的补充, 当我们插入很多的kv,然后又删除了很多的kv,可能会出现很长的overflow链表, 但是有很多的桶的槽点是空的, 这种情况我们h.count是不大的,导致我们的装载因子不一定会大于6.5,无法触发第一条扩容, 所以我们需要通过另一个统计数 h.noveflow , 就是overflow的大小的近似值, 如果 h.noverflow &gt;= 2 ^ h.B, 我们认为链表过长, 性能很差, 需要扩容
这种情况是等量扩容, 我们生成一个新的buckets数组, 将结果copy过去即可

当出现另外一种极端情况时, 以上扩容都将无效:
如果插入了大量的哈希值相同的key,他们因为哈希值相同都会落入同一个bucket中, 因此当超过8就会使用到overflow
这种情况就由 哈希表 变是一个单链表...

废话不多说... 我们先了解下如何翻倍扩容
首先我们知道,假如B=5,那么我们的buckets数组的索引就是[0~31]
我们先取得hash值,然后与2^B-1(31) 做与运算, 得到低B(5)位, 然后就找到了要放入的桶了
那扩容的时候由于B++变成了6, 因此hash值需要与2^6-1(63)做与运算, 得到低6位
例如hash值低8位是 00100011
1. 当B=5时, 它是落入到索引为3的桶
2. 当B=6时, 它是落入到索引为35(32+2+1)的桶
因此我们知道扩容是需要对原本的桶数据进行数据迁移的

接下来我们继续看看扩容的代码

</code></pre><blockquote>
<p>先看看hashGrow() 做了哪些准备工作, 然后在看看growWork() 如果搬迁数据</p>
</blockquote>
<ul>
<li>hashGrow 仅分配好新的buckets</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/map.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">hashGrow</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">bigger</span> <span class="o">:=</span> <span class="nb">uint8</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="c1">// 如果不是因为 大于哈希因子 6.5*2^h.B的原因
</span><span class="c1"></span>	<span class="c1">// 那就是 太多的溢出桶
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">count</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// 这里就是等量扩容
</span><span class="c1"></span>		<span class="nx">bigger</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="c1">// sameSizeGrow = 8 (1000), 或运算会把该位置为1
</span><span class="c1"></span>		<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="o">|=</span> <span class="nx">sameSizeGrow</span>
	<span class="p">}</span>
	<span class="c1">// 赋值旧的buckets
</span><span class="c1"></span>	<span class="nx">oldbuckets</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span>
	<span class="c1">// 创建新的bucket,并且设置h.B+1
</span><span class="c1"></span>	<span class="nx">newbuckets</span><span class="p">,</span> <span class="nx">nextOverflow</span> <span class="o">:=</span> <span class="nf">makeBucketArray</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="o">+</span><span class="nx">bigger</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="c1">// &amp;^ 按位置0运算, 先进行异或,然后与运算
</span><span class="c1"></span>	<span class="c1">// 右侧数的二进制位为1,
</span><span class="c1"></span>	<span class="c1">// 1. 左侧如果是0,那么异或是1,与之后是0
</span><span class="c1"></span>	<span class="c1">// 2. 左侧如果是1,那么异或是0,与之后也是0
</span><span class="c1"></span>	<span class="c1">// 右侧数的二进制位为0,
</span><span class="c1"></span>	<span class="c1">// 1. 左侧如果是0,那么异或是0,与之后是0
</span><span class="c1"></span>	<span class="c1">// 2. 左侧如果是1,那么异或是1,与之后也是1
</span><span class="c1"></span>	<span class="c1">// 所以只有左侧是1,右侧是0 结果才会为1
</span><span class="c1"></span>	<span class="c1">// 这里 iterator=1,oldIterator=2
</span><span class="c1"></span>	<span class="c1">// 所以低2位都会置为0
</span><span class="c1"></span>	<span class="nx">flags</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;^</span> <span class="p">(</span><span class="nx">iterator</span> <span class="p">|</span> <span class="nx">oldIterator</span><span class="p">)</span>
	<span class="c1">// 如果低位第1位不是0
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">iterator</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// 把flags的 低位第2位置为1
</span><span class="c1"></span>		<span class="nx">flags</span> <span class="o">|=</span> <span class="nx">oldIterator</span>
	<span class="p">}</span>
	<span class="c1">// 可能等量扩容,可能翻倍扩容
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="o">+=</span> <span class="nx">bigger</span>
	<span class="c1">// 标志位
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="p">=</span> <span class="nx">flags</span>
	<span class="c1">// 旧桶
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span> <span class="p">=</span> <span class="nx">oldbuckets</span>
	<span class="c1">// 新桶
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span> <span class="p">=</span> <span class="nx">newbuckets</span>
	<span class="c1">// 扩容进度为0, 还未迁移
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="c1">// 新buckets还没有数据
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">noverflow</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="c1">// 设置extra桶
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// Promote current overflow buckets to the old generation.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">oldoverflow</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;oldoverflow is not nil&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">oldoverflow</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">nextOverflow</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">mapextra</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">nextOverflow</span> <span class="p">=</span> <span class="nx">nextOverflow</span>
	<span class="p">}</span>
	<span class="c1">// 显然这里并没有对哈希表数据进行copy, 实际是在growWork() and evacuate()中进行
</span><span class="c1"></span><span class="p">}</span>

</code></pre></div><ul>
<li>growWork 实际的迁移数据</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 这里bucket是 hash的低B(6)位,已经是扩容了
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">growWork</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">bucket</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// evacuate 传入的是新的bucket和旧的2^B-1进行与的结果, 所以是扩容前的低B(5)位
</span><span class="c1"></span>	<span class="nf">evacuate</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">bucket</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nf">oldbucketmask</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nf">growing</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// 扩容进度
</span><span class="c1"></span>		<span class="nf">evacuate</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>evacuate 迁移</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">evacuate</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">oldbucket</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// oldbucket是旧的低5位哈希值,桶的索引, 找到旧桶的第一个bmap
</span><span class="c1"></span>	<span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span><span class="p">,</span> <span class="nx">oldbucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
	<span class="c1">// newbit = 2^5   = 32
</span><span class="c1"></span>	<span class="nx">newbit</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">noldbuckets</span><span class="p">()</span>
	<span class="c1">// 第一次肯定是没有迁移, true的条件: 1 &lt; b.tophash[0] &lt; 5
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nf">evacuated</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// type evacDst struct {
</span><span class="c1"></span>		<span class="c1">//	b *bmap		 // current destination bucket
</span><span class="c1"></span>		<span class="c1">//	i int		 // key/elem index into b
</span><span class="c1"></span>		<span class="c1">//	k unsafe.Pointer // pointer to current key storage
</span><span class="c1"></span>		<span class="c1">//	e unsafe.Pointer // pointer to current elem storage
</span><span class="c1"></span>		<span class="c1">// }
</span><span class="c1"></span>		<span class="kd">var</span> <span class="nx">xy</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="nx">evacDst</span>
		<span class="nx">x</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="c1">// 新的bmap
</span><span class="c1"></span>		<span class="nx">x</span><span class="p">.</span><span class="nx">b</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">oldbucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
		<span class="c1">// 根据bmap得到key的地址,先保存作为目标地址
</span><span class="c1"></span>		<span class="nx">x</span><span class="p">.</span><span class="nx">k</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="p">)</span>
		<span class="c1">// 根据bmap得到value的地址
</span><span class="c1"></span>		<span class="nx">x</span><span class="p">.</span><span class="nx">e</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">k</span><span class="p">,</span> <span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
		<span class="c1">// 不是等量扩容的情况,那就是翻倍扩容
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">sameSizeGrow</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">y</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
			<span class="c1">// 比如前面的例子哈希值低8位: 00100011
</span><span class="c1"></span>			<span class="c1">// oldbucket=3,newbit=32
</span><span class="c1"></span>			<span class="c1">// 所以该哈希值会被迁移到 索引为35的桶位置
</span><span class="c1"></span>			<span class="nx">y</span><span class="p">.</span><span class="nx">b</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="p">(</span><span class="nx">oldbucket</span><span class="o">+</span><span class="nx">newbit</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
			<span class="c1">// key value的地址, 先保存作为目标地址
</span><span class="c1"></span>			<span class="nx">y</span><span class="p">.</span><span class="nx">k</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">y</span><span class="p">.</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="p">)</span>
			<span class="nx">y</span><span class="p">.</span><span class="nx">e</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">y</span><span class="p">.</span><span class="nx">k</span><span class="p">,</span> <span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
		<span class="p">}</span>
		<span class="c1">// 这里同样是两层for循环
</span><span class="c1"></span>		<span class="k">for</span> <span class="p">;</span> <span class="nx">b</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="p">)</span>
			<span class="nx">e</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
			<span class="c1">// 内层循环
</span><span class="c1"></span>			<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">e</span> <span class="p">=</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nf">add</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)),</span> <span class="nf">add</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span> <span class="p">{</span>
				<span class="nx">top</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
				<span class="k">if</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="nx">top</span><span class="p">)</span> <span class="p">{</span>
					<span class="c1">// evacuatedX	 = 2 // k/v是有效的, 并且是分配到前半部分桶(3)
</span><span class="c1"></span>					<span class="c1">// evacuatedY	 = 3 // k/v是有效的, 并且是分配到后半部分桶(3+32)
</span><span class="c1"></span>					<span class="c1">// evacuatedEmpty = 4 // 本身就是空槽, 这里只是作为标记位,标记已经迁移了
</span><span class="c1"></span>					<span class="c1">// minTopHash	 = 5 // minimum tophash for a normal filled cell.
</span><span class="c1"></span>					<span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">evacuatedEmpty</span>
					<span class="k">continue</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">top</span> <span class="p">&lt;</span> <span class="nx">minTopHash</span> <span class="p">{</span>
					<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad map state&#34;</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="nx">k2</span> <span class="o">:=</span> <span class="nx">k</span>
				<span class="c1">//指针
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>
					<span class="nx">k2</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k2</span><span class="p">))</span>
				<span class="p">}</span>
				<span class="kd">var</span> <span class="nx">useY</span> <span class="kt">uint8</span>
				<span class="c1">// 不是等量扩容
</span><span class="c1"></span>				<span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">sameSizeGrow</span><span class="p">()</span> <span class="p">{</span>
					<span class="c1">// 计算哈希
</span><span class="c1"></span>					<span class="nx">hash</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">k2</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span><span class="p">))</span>
					<span class="c1">// 正在迭代 ; 相同的key但是哈希不通
</span><span class="c1"></span>					<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">iterator</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">t</span><span class="p">.</span><span class="nf">reflexivekey</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">k2</span><span class="p">,</span> <span class="nx">k2</span><span class="p">)</span> <span class="p">{</span>
						<span class="c1">// NaNs
</span><span class="c1"></span>						<span class="nx">useY</span> <span class="p">=</span> <span class="nx">top</span> <span class="o">&amp;</span> <span class="mi">1</span>
						<span class="nx">top</span> <span class="p">=</span> <span class="nf">tophash</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="c1">// newbit是32
</span><span class="c1"></span>						<span class="k">if</span> <span class="nx">hash</span><span class="o">&amp;</span><span class="nx">newbit</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
							<span class="c1">// 最高位是1的话就要去 后半部分桶
</span><span class="c1"></span>							<span class="nx">useY</span> <span class="p">=</span> <span class="mi">1</span>
						<span class="p">}</span>
					<span class="p">}</span>
				<span class="p">}</span>

				<span class="k">if</span> <span class="nx">evacuatedX</span><span class="o">+</span><span class="mi">1</span> <span class="o">!=</span> <span class="nx">evacuatedY</span> <span class="o">||</span> <span class="nx">evacuatedX</span><span class="p">^</span><span class="mi">1</span> <span class="o">!=</span> <span class="nx">evacuatedY</span> <span class="p">{</span>
					<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad evacuatedN&#34;</span><span class="p">)</span>
				<span class="p">}</span>

				<span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">evacuatedX</span> <span class="o">+</span> <span class="nx">useY</span> <span class="c1">// evacuatedX + 1 == evacuatedY
</span><span class="c1"></span>				<span class="nx">dst</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">xy</span><span class="p">[</span><span class="nx">useY</span><span class="p">]</span>				 <span class="c1">// evacuation destination
</span><span class="c1"></span>				<span class="c1">// 如果等于8,说明满了
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">dst</span><span class="p">.</span><span class="nx">i</span> <span class="o">==</span> <span class="nx">bucketCnt</span> <span class="p">{</span>
					<span class="c1">// 放到链表去
</span><span class="c1"></span>					<span class="nx">dst</span><span class="p">.</span><span class="nx">b</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">newoverflow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">dst</span><span class="p">.</span><span class="nx">b</span><span class="p">)</span>
					<span class="nx">dst</span><span class="p">.</span><span class="nx">i</span> <span class="p">=</span> <span class="mi">0</span>
					<span class="nx">dst</span><span class="p">.</span><span class="nx">k</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">dst</span><span class="p">.</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="p">)</span>
					<span class="nx">dst</span><span class="p">.</span><span class="nx">e</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">dst</span><span class="p">.</span><span class="nx">k</span><span class="p">,</span> <span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
				<span class="p">}</span>
				<span class="nx">dst</span><span class="p">.</span><span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">dst</span><span class="p">.</span><span class="nx">i</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">bucketCnt</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="p">=</span> <span class="nx">top</span> <span class="c1">// mask dst.i as an optimization, to avoid a bounds check
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>
					<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">dst</span><span class="p">.</span><span class="nx">k</span><span class="p">)</span> <span class="p">=</span> <span class="nx">k2</span> <span class="c1">// copy pointer
</span><span class="c1"></span>				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">dst</span><span class="p">.</span><span class="nx">k</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="c1">// copy elem
</span><span class="c1"></span>				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectelem</span><span class="p">()</span> <span class="p">{</span>
					<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">dst</span><span class="p">.</span><span class="nx">e</span><span class="p">)</span> <span class="p">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">e</span><span class="p">)</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">dst</span><span class="p">.</span><span class="nx">e</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="nx">dst</span><span class="p">.</span><span class="nx">i</span><span class="o">++</span>
				<span class="nx">dst</span><span class="p">.</span><span class="nx">k</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">dst</span><span class="p">.</span><span class="nx">k</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
				<span class="nx">dst</span><span class="p">.</span><span class="nx">e</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">dst</span><span class="p">.</span><span class="nx">e</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="c1">// 如果没有正在迭代老的桶, 就清除buckets, 帮助gc
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">oldIterator</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">b</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span><span class="p">,</span> <span class="nx">oldbucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">))</span>
			<span class="nx">ptr</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">dataOffset</span><span class="p">)</span>
			<span class="nx">n</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)</span> <span class="o">-</span> <span class="nx">dataOffset</span>
			<span class="nf">memclrHasPointers</span><span class="p">(</span><span class="nx">ptr</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">//
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">oldbucket</span> <span class="o">==</span> <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span> <span class="p">{</span>
		<span class="nf">advanceEvacuationMark</span><span class="p">(</span><span class="nx">h</span><span class="p">,</span> <span class="nx">t</span><span class="p">,</span> <span class="nx">newbit</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>sameSizeGrow</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">)</span> <span class="nf">sameSizeGrow</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// sameSizeGrow = 8 (1000)
</span><span class="c1"></span>	<span class="c1">// 扩容标志位进行与运算, 如果都是1, 说明是等量扩容
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">sameSizeGrow</span> <span class="o">!=</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>advanceEvacuationMark</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">advanceEvacuationMark</span><span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">newbit</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span><span class="o">++</span>
	<span class="nx">stop</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span> <span class="o">+</span> <span class="mi">1024</span>
	<span class="k">if</span> <span class="nx">stop</span> <span class="p">&gt;</span> <span class="nx">newbit</span> <span class="p">{</span>
		<span class="nx">stop</span> <span class="p">=</span> <span class="nx">newbit</span>
	<span class="p">}</span>
	<span class="c1">// 寻找没有搬迁的bucket
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span> <span class="o">!=</span> <span class="nx">stop</span> <span class="o">&amp;&amp;</span> <span class="nf">bucketEvacuated</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="c1">// 如果已经等于 2^B了,当然是全部的桶都搬迁完了
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span> <span class="o">==</span> <span class="nx">newbit</span> <span class="p">{</span> <span class="c1">// newbit == # of oldbuckets
</span><span class="c1"></span>		<span class="c1">// 搬迁结束
</span><span class="c1"></span>		<span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">oldoverflow</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="c1">// sameSizeGrow =8 (1000) 所以是把第4位置0 , 下次sameSizeGrow() 函数就是false了
</span><span class="c1"></span>		<span class="c1">// 清除正在扩容的标识
</span><span class="c1"></span>		<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;^=</span> <span class="nx">sameSizeGrow</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h3 id="runtimemapaccess1-map读取">runtime.mapaccess1 map读取</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mapaccess1</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">callerpc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
		<span class="nx">pc</span> <span class="o">:=</span> <span class="nf">funcPC</span><span class="p">(</span><span class="nx">mapaccess1</span><span class="p">)</span>
		<span class="nf">racereadpc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">h</span><span class="p">),</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
		<span class="nf">raceReadObjectPC</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">msanenabled</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">msanread</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">h</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">h</span><span class="p">.</span><span class="nx">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hashMightPanic</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// see issue 23734
</span><span class="c1"></span>		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">zeroVal</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">hashWriting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;concurrent map read and map write&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 算一下哈希值
</span><span class="c1"></span>	<span class="nx">hash</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span><span class="p">))</span>
	<span class="c1">// m = 2^B -1
</span><span class="c1"></span>	<span class="nx">m</span> <span class="o">:=</span> <span class="nf">bucketMask</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span>
	<span class="c1">// bmap
</span><span class="c1"></span>	<span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="p">(</span><span class="nx">hash</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
	<span class="c1">// 如果存在oldbuckets, 说明可能在扩容 搬迁
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span><span class="p">;</span> <span class="nx">c</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 不是等量扩容
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">sameSizeGrow</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// 翻倍扩容 需要缩小一倍m
</span><span class="c1"></span>			<span class="nx">m</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
		<span class="p">}</span>
		<span class="c1">// old bmap
</span><span class="c1"></span>		<span class="nx">oldb</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="p">(</span><span class="nx">hash</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
		<span class="c1">// 如果不在搬迁
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nf">evacuated</span><span class="p">(</span><span class="nx">oldb</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// 那就开始读oldb
</span><span class="c1"></span>			<span class="nx">b</span> <span class="p">=</span> <span class="nx">oldb</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 得到哈希的高8位
</span><span class="c1"></span>	<span class="nx">top</span> <span class="o">:=</span> <span class="nf">tophash</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span>
<span class="nx">bucketloop</span><span class="p">:</span>
	<span class="c1">// 两层循环
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">;</span> <span class="nx">b</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="c1">// 高8位如果都不同,那就可以继续下一个
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">top</span> <span class="p">{</span>
				<span class="c1">// 如果是空槽就break
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">emptyRest</span> <span class="p">{</span>
					<span class="k">break</span> <span class="nx">bucketloop</span>
				<span class="p">}</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">k</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="c1">// 如果找到了key
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">// 得到value的地址
</span><span class="c1"></span>				<span class="nx">e</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
				<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectelem</span><span class="p">()</span> <span class="p">{</span>
					<span class="nx">e</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">e</span><span class="p">))</span>
				<span class="p">}</span>
				<span class="c1">// 返回
</span><span class="c1"></span>				<span class="k">return</span> <span class="nx">e</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 找不到就返回0
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">zeroVal</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="p">}</span>

</code></pre></div><ul>
<li><a href="https://juejin.cn/post/6844903848587296781">深度解密Go语言之 map</a></li>
<li><a href="https://www.bilibili.com/video/BV1Q4411W7MR">Go夜读 map 源码阅读分析（20190529第44期）</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Go学习 Gmp模型</title>
			<link>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-gmp%E6%A8%A1%E5%9E%8B/</link>
			<pubDate>Wed, 17 Nov 2021 09:31:09 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-gmp%E6%A8%A1%E5%9E%8B/</guid>
			<description>GMP模型 为什么需要P  如果没有P, 所有的G都必须在一个全局的队列中, 然后M一个个从全局队列中获取, 这种共享内存的方式并发必须需要加锁 如果没有P, 当前g1中包含了创建新协程g2(go func)时, 当前的M1还得继续执行g1, 因此M1必须主动转移g2给另外一个线程M2去执行,这就造成了不必要的转移,浪费cpu资源, 因为g1 g2是相关的, 如果都在本地M1上执行更好, 而不是调度出去执行  简介  全局队列（Global Queue）：存放等待运行的G。 P的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G&amp;rsquo;时，G&amp;rsquo;优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。 P列表：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS(可配置)个。 M：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列拿一批G放到P的本地队列，或从其他P的本地队列偷一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。 g0: 一个比一比g大的多栈(64k), 可以用于 创建goroutine, deferproc函数里新建_defer,垃圾回收相关工资  何时会创建 P : 由启动时环境变量$GOMAXPROCS或者是由runtime的方法GOMAXPROCS()决定, 运行时系统就会创建 M : 如果P找不到空闲的M去绑定,就会创建M 调度器策略 work stealing : 当本地G队列为空时, 尝试从全局队列或者其他的线程绑定的P偷取G,而不是销毁线程 hand off : 当g阻塞时,实际是当前M线程会阻塞, 如果是同步模式,M和G会一起阻塞 如果是非同步模式,G会被&amp;quot;net poller&amp;quot;代理进入阻塞,M不会阻塞,继续执行其他的G,效率更高 gmp结构体  m  // src/runtime/runtime2.go type m struct { g0 *g // 用于执行调度指令的 Goroutine 	gsignal *g // 处理 signal 的 g 	tls [6]uintptr // 线程本地存储 	curg *g // 当前运行的用户 Goroutine 	p puintptr // 执行 go 代码时持有的 p (如果没有执行则为 nil) 	preemptoff string // if !</description>
			<content type="html"><![CDATA[<h3 id="gmp模型">GMP模型</h3>
<p><img src="images/golang/gmp-jiagou.png" alt=""></p>
<h4 id="为什么需要p">为什么需要P</h4>
<ul>
<li>如果没有P, 所有的G都必须在一个全局的队列中, 然后M一个个从全局队列中获取, 这种共享内存的方式并发必须需要加锁</li>
<li>如果没有P, 当前g1中包含了创建新协程g2(go func)时, 当前的M1还得继续执行g1, 因此M1必须主动转移g2给另外一个线程M2去执行,这就造成了不必要的转移,浪费cpu资源, 因为g1 g2是相关的, 如果都在本地M1上执行更好, 而不是调度出去执行</li>
</ul>
<h4 id="简介">简介</h4>
<ul>
<li>全局队列（Global Queue）：存放等待运行的G。</li>
<li>P的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G&rsquo;时，G&rsquo;优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。</li>
<li>P列表：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS(可配置)个。</li>
<li>M：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列拿一批G放到P的本地队列，或从其他P的本地队列偷一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。</li>
<li>g0: 一个比一比g大的多栈(64k), 可以用于 创建goroutine, deferproc函数里新建_defer,垃圾回收相关工资</li>
</ul>
<h4 id="何时会创建">何时会创建</h4>
<pre><code>P : 由启动时环境变量$GOMAXPROCS或者是由runtime的方法GOMAXPROCS()决定, 运行时系统就会创建
M : 如果P找不到空闲的M去绑定,就会创建M
</code></pre><h4 id="调度器策略">调度器策略</h4>
<pre><code>work stealing : 当本地G队列为空时, 尝试从全局队列或者其他的线程绑定的P偷取G,而不是销毁线程
hand off : 当g阻塞时,实际是当前M线程会阻塞,
        如果是同步模式,M和G会一起阻塞
        如果是非同步模式,G会被&quot;net poller&quot;代理进入阻塞,M不会阻塞,继续执行其他的G,效率更高
</code></pre><p><img src="images/golang/gmp.jpeg" alt=""></p>
<h4 id="gmp结构体">gmp结构体</h4>
<ul>
<li>m</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/runtime2.go
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">m</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">g0</span>         <span class="o">*</span><span class="nx">g</span>          <span class="c1">// 用于执行调度指令的 Goroutine
</span><span class="c1"></span>	<span class="nx">gsignal</span>    <span class="o">*</span><span class="nx">g</span>          <span class="c1">// 处理 signal 的 g
</span><span class="c1"></span>	<span class="nx">tls</span>        <span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="kt">uintptr</span>  <span class="c1">// 线程本地存储
</span><span class="c1"></span>	<span class="nx">curg</span>       <span class="o">*</span><span class="nx">g</span>          <span class="c1">// 当前运行的用户 Goroutine
</span><span class="c1"></span>	<span class="nx">p</span>          <span class="nx">puintptr</span>    <span class="c1">// 执行 go 代码时持有的 p (如果没有执行则为 nil)
</span><span class="c1"></span>	<span class="nx">preemptoff</span> <span class="kt">string</span>      <span class="c1">// if != &#34;&#34;, keep curg running on this m
</span><span class="c1"></span>	<span class="nx">spinning</span>   <span class="kt">bool</span>        <span class="c1">// m 当前没有运行 work 且正处于寻找 work 的活跃状态,自旋和非自旋状态
</span><span class="c1"></span>	<span class="nx">blocked</span>    <span class="kt">bool</span>        <span class="c1">// m is blocked on a note
</span><span class="c1"></span>	<span class="nx">freeWait</span>   <span class="kt">uint32</span>      <span class="c1">// if == 0, safe to free g0 and delete m (atomic)
</span><span class="c1"></span>	<span class="nx">cgoCallers</span> <span class="o">*</span><span class="nx">cgoCallers</span> <span class="c1">// cgo 调用崩溃的 cgo 回溯
</span><span class="c1"></span>	<span class="nx">alllink</span>    <span class="o">*</span><span class="nx">m</span>          <span class="c1">// 在 allm 上
</span><span class="c1"></span>	<span class="nx">mcache</span>     <span class="o">*</span><span class="nx">mcache</span>     <span class="c1">// 当前线程上进行内存分配的本地缓存 mcache
</span><span class="c1"></span>	<span class="nx">freelink</span>   <span class="o">*</span><span class="nx">m</span>          <span class="c1">// on sched.freem
</span><span class="c1"></span>	<span class="o">...</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>p</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/runtime2.go
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">p</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">id</span>           <span class="kt">int32</span>
	<span class="nx">status</span>       <span class="kt">uint32</span>         <span class="c1">// p 的状态 pidle/prunning/...
</span><span class="c1"></span>	<span class="nx">link</span>         <span class="nx">puintptr</span>       <span class="c1">// 链表
</span><span class="c1"></span>	<span class="nx">m</span>            <span class="nx">muintptr</span>       <span class="c1">// 反向链接到关联的 m （nil 则表示 idle）
</span><span class="c1"></span>	<span class="nx">mcache</span>       <span class="o">*</span><span class="nx">mcache</span>        <span class="c1">// mcache
</span><span class="c1"></span>	<span class="nx">pcache</span>       <span class="nx">pageCache</span>      <span class="c1">// pageCache
</span><span class="c1"></span>	<span class="nx">deferpool</span>    <span class="p">[</span><span class="mi">5</span><span class="p">][]</span><span class="o">*</span><span class="nx">_defer</span>   <span class="c1">// 不同大小的可用的 defer 结构池
</span><span class="c1"></span>	<span class="nx">deferpoolbuf</span> <span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">32</span><span class="p">]</span><span class="o">*</span><span class="nx">_defer</span> <span class="c1">// buf
</span><span class="c1"></span>	<span class="nx">runqhead</span>     <span class="kt">uint32</span>         <span class="c1">// 可运行的 Goroutine 队列，可无锁访问
</span><span class="c1"></span>	<span class="nx">runqtail</span>     <span class="kt">uint32</span>         <span class="c1">// 尾
</span><span class="c1"></span>	<span class="nx">runq</span>         <span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="nx">guintptr</span>  <span class="c1">// 本地队列
</span><span class="c1"></span>	<span class="nx">runnext</span>      <span class="nx">guintptr</span>       <span class="c1">// 下一个要执行的g
</span><span class="c1"></span>	<span class="nx">timersLock</span>   <span class="nx">mutex</span>
	<span class="nx">timers</span>       <span class="p">[]</span><span class="o">*</span><span class="nx">timer</span>
	<span class="nx">preempt</span>      <span class="kt">bool</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>g</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/runtime2.go
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">g</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">stack</span> <span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">lo</span> <span class="kt">uintptr</span>
		<span class="nx">hi</span> <span class="kt">uintptr</span>
	<span class="p">}</span> <span class="c1">// 栈内存 界限：[stack.lo, stack.hi)
</span><span class="c1"></span>	<span class="nx">stackguard0</span> <span class="kt">uintptr</span>
	<span class="nx">stackguard1</span> <span class="kt">uintptr</span>

	<span class="nx">_panic</span>   <span class="o">*</span><span class="nx">_panic</span>
	<span class="nx">_defer</span>   <span class="o">*</span><span class="nx">_defer</span>
	<span class="nx">m</span>        <span class="o">*</span><span class="nx">m</span>             <span class="c1">// 当前的 m
</span><span class="c1"></span>	<span class="nx">sched</span>    <span class="nx">gobuf</span>          <span class="c1">// 保存g和调度信息
</span><span class="c1"></span>	<span class="nx">stktopsp</span> <span class="kt">uintptr</span>        <span class="c1">// 期望 sp 位于栈顶，用于回溯检查
</span><span class="c1"></span>	<span class="nx">param</span>    <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// wakeup 唤醒时候传递的参数
</span><span class="c1"></span>	<span class="nx">goid</span>     <span class="kt">int64</span>          <span class="c1">// goid
</span><span class="c1"></span>	<span class="nx">preempt</span>  <span class="kt">bool</span>           <span class="c1">// 抢占信号，stackguard0 = stackpreempt 的副本
</span><span class="c1"></span>	<span class="nx">timer</span>    <span class="o">*</span><span class="nx">timer</span>         <span class="c1">// 为 time.Sleep 缓存的计时器
</span><span class="c1"></span>	<span class="o">...</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">gobuf</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">sp</span>   <span class="kt">uintptr</span>        <span class="c1">// 存储 sp 寄存器的值
</span><span class="c1"></span>	<span class="nx">pc</span>   <span class="kt">uintptr</span>        <span class="c1">// 存储 ip 寄存器的值
</span><span class="c1"></span>	<span class="nx">g</span>    <span class="nx">guintptr</span>       <span class="c1">// 指向 goroutine
</span><span class="c1"></span>	<span class="nx">ctxt</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 这必须是一个指针，以便GC对其进行扫描
</span><span class="c1"></span>	<span class="nx">ret</span>  <span class="nx">sys</span><span class="p">.</span><span class="nx">Uintreg</span>    <span class="c1">// 保存系统调用的返回值
</span><span class="c1"></span>	<span class="nx">lr</span>   <span class="kt">uintptr</span>
	<span class="nx">bp</span>   <span class="kt">uintptr</span> <span class="c1">// for GOEXPERIMENT=framepointer
</span><span class="c1"></span><span class="p">}</span>

</code></pre></div><ul>
<li>调度器 schedt
<ul>
<li>管理了能够将 G 和 M 进行绑定的 M 队列</li>
<li>管理了空闲的 P 链表（队列）</li>
<li>管理了 G 的全局队列</li>
<li>管理了可被复用的 G 的全局缓存</li>
<li>管理了 defer 池</li>
</ul>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/runtime2.go
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">schedt</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">lock</span>       <span class="nx">mutex</span>
	<span class="nx">ngsys</span>      <span class="kt">uint32</span>   <span class="c1">// 系统 goroutine的数量; 自增
</span><span class="c1"></span>	<span class="nx">pidle</span>      <span class="nx">puintptr</span> <span class="c1">// 空闲 p 链表
</span><span class="c1"></span>	<span class="nx">npidle</span>     <span class="kt">uint32</span>   <span class="c1">// 空闲 p 数量
</span><span class="c1"></span>	<span class="nx">nmspinning</span> <span class="kt">uint32</span>   <span class="c1">// 自旋状态的 M 的数量
</span><span class="c1"></span>	<span class="nx">runq</span>       <span class="nx">gQueue</span>   <span class="c1">// 全局 G 队列
</span><span class="c1"></span>	<span class="nx">runqsize</span>   <span class="kt">int32</span>    <span class="c1">// 全局队列大小
</span><span class="c1"></span>	<span class="nx">gFree</span>      <span class="kd">struct</span> <span class="p">{</span> <span class="c1">// 有效 dead G 的全局缓存.
</span><span class="c1"></span>		<span class="nx">lock</span>    <span class="nx">mutex</span> <span class="c1">// 锁
</span><span class="c1"></span>		<span class="nx">stack</span>   <span class="nx">gList</span> <span class="c1">// 包含栈的 Gs
</span><span class="c1"></span>		<span class="nx">noStack</span> <span class="nx">gList</span> <span class="c1">// 没有栈的 Gs
</span><span class="c1"></span>		<span class="nx">n</span>       <span class="kt">int32</span>
	<span class="p">}</span>
	<span class="nx">sudoglock</span>  <span class="nx">mutex</span>  <span class="c1">// sudog 锁
</span><span class="c1"></span>	<span class="nx">sudogcache</span> <span class="o">*</span><span class="nx">sudog</span> <span class="c1">// sudog 结构的集中缓存
</span><span class="c1"></span>	<span class="nx">deferlock</span>  <span class="nx">mutex</span>  <span class="c1">// 不同大小的有效的 defer 结构的池
</span><span class="c1"></span>	<span class="nx">deferpool</span>  <span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">*</span><span class="nx">_defer</span>

	<span class="o">...</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">gQueue</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">head</span> <span class="nx">guintptr</span>
	<span class="nx">tail</span> <span class="nx">guintptr</span>
<span class="p">}</span>
</code></pre></div><h3 id="go函数真正的入口">go函数真正的入口</h3>
<h4 id="通过gdb调试-找到入口文件">通过gdb调试, 找到入口文件</h4>
<pre><code class="language-assembly" data-lang="assembly"># GOFLAGS=&quot;-ldflags=-compressdwarf=false&quot; go build gdb-main.go

# gdb gdb-main
(gdb) info files
Symbols from &quot;/Users/zhangzw/work/go/github.com/zhangzw001/learngo/basic/gdb/gdb-main&quot;.
Local exec file:
	`/Users/zhangzw/work/go/github.com/zhangzw001/learngo/basic/gdb/gdb-main', file type mach-o-x86-64.
	Entry point: 0x1065600
	0x0000000001001000 - 0x00000000010a2e8a is .text
	0x00000000010a2ea0 - 0x00000000010a2fa2 is __TEXT.__symbol_stub1
	...
(gdb) b *0x1065600  // 上面的Entry point后面的地址
Breakpoint 1 at 0x1065600: file /usr/local/go/src/runtime/rt0_darwin_amd64.s, line 8.   // 这里是mac
</code></pre><h4 id="继续查看">继续查看</h4>
<pre><code class="language-assembly" data-lang="assembly">// src/runtime/rt0_amd64.s
TEXT _rt0_amd64_linux(SB),NOSPLIT,$-8
	JMP	_rt0_amd64(SB) //跳转到 _rt0_amd64

TEXT _rt0_amd64(SB),NOSPLIT,$-8
	MOVQ	0(SP), DI	// argc
	LEAQ	8(SP), SI	// argv
	JMP	runtime·rt0_go(SB)// 又跳转到runtime·rt0_go


</code></pre><h4 id="来到核心入口代码">来到核心入口代码</h4>
<pre><code class="language-assembly" data-lang="assembly">// src/runtime/asm_amd64.s
TEXT runtime·rt0_go&lt;ABIInternal&gt;(SB),NOSPLIT,$0
        ...
        // DI 现在是g0的地址
        MOVQ	$runtime·g0(SB), DI
        // BX = SP-64*1024+104 准备64k的内存空间
        LEAQ	(-64*1024+104)(SP), BX
        // 设置 g.stackguard0
        MOVQ	BX, g_stackguard0(DI)   
        // 设置 g.stackguard1   
        MOVQ	BX, g_stackguard1(DI)
        // g0 栈的low低地址
        MOVQ	BX, (g_stack+stack_lo)(DI)
        // g0 栈的high高地址
        MOVQ	SP, (g_stack+stack_hi)(DI)
	...
        // m0的tls成员
        LEAQ	runtime·m0+m_tls(SB), DI
        // 通过fs段寄存器找到m.tls
        CALL	runtime·settls(SB)
        // 获得fs段地址放入BX = m0.tls[1]
        get_tls(BX)
        MOVQ	$0x123, g(BX)
        MOVQ	runtime·m0+m_tls(SB), AX
        // AX肯定还是$0x123
        CMPQ	AX, $0x123
        // EQ的话就跳2行执行
        JEQ 2(PC)
        CALL	runtime·abort(SB)
ok:
	get_tls(BX)
        // DX 现在是g0的地址
	LEAL	runtime·g0(SB), DX
        // m0.tls[0] = DX
	MOVL	DX, g(BX)
        // AX 现在是m0的地址
	LEAL	runtime·m0(SB), AX
        // m0 和g0绑定
	// m0.g0 = &amp;g0
	MOVL	DX, m_g0(AX)
	// g0.m0 = &amp;m0
	MOVL	AX, g_m(DX)

        CLD				// convention is D is always left cleared
	CALL	runtime·check(SB)  // 运行时类型检查，主要是校验编译器的翻译工作是否正确
	MOVL	16(SP), AX	   // copy argc
	MOVL	AX, 0(SP)
	MOVQ	24(SP), AX	   // copy argv
	MOVQ	AX, 8(SP)
	CALL	runtime·args(SB)	  //系统参数传递，主要是将系统参数转换传递给程序使用
	CALL	runtime·osinit(SB)	  //系统基本参数设置，主要是获取 CPU 核心数和内存物理页大小
	CALL	runtime·schedinit(SB)     //进行各种运行时组件的初始化，包含调度器、内存分配器、堆、栈、GC 等一大堆初始化工作。会进行 p 的初始化，并将 m0 和某一个 p 进行绑定。

	// 创建一个新的goroutine来运行程序
        // 主要工作是运行 main goroutine，虽然在runtime·rt0_go 中指向的是$runtime·mainPC，但实质指向的是 runtime.main。
	MOVQ	$runtime·mainPC(SB), AX
        // 入栈新的goroutine的地址
        PUSHQ	AX	  
        // main函数参数个数是0
        PUSHL	$0	                  // arg size
        // 创建一个新的 goroutine，且绑定 runtime.main 方法（也就是应用程序中的入口 main 方法）。并将其放入 m0 绑定的p的本地队列中去，以便后续调度。
	CALL	runtime·newproc(SB)       
        // 出站
	POPL	AX
	POPL	AX

	// start this M
	CALL	runtime·mstart(SB)
        // 以下不会执行, 万一mstart返回了,这里直接abort crash掉
	CALL	runtime·abort(SB)
	RET
</code></pre><h3 id="schedinit-运行时初始化">schedinit 运行时初始化</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/proc.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">schedinit</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">lockRankSched</span><span class="p">)</span>
        <span class="o">...</span>
	<span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heapStats</span><span class="p">.</span><span class="nx">noPLock</span><span class="p">,</span> <span class="nx">lockRankLeafRank</span><span class="p">)</span>
        <span class="c1">// g0
</span><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">racectx</span><span class="p">,</span> <span class="nx">raceprocctx0</span> <span class="p">=</span> <span class="nf">raceinit</span><span class="p">()</span>
	<span class="p">}</span>
        <span class="c1">// 设置全局变量 最大的m线程数量
</span><span class="c1"></span>	<span class="nx">sched</span><span class="p">.</span><span class="nx">maxmcount</span> <span class="p">=</span> <span class="mi">10000</span>

	<span class="c1">// The world starts stopped.
</span><span class="c1"></span>	<span class="nf">worldStopped</span><span class="p">()</span>

	<span class="nf">moduledataverify</span><span class="p">()</span>
	<span class="nf">stackinit</span><span class="p">()</span>
	<span class="nf">mallocinit</span><span class="p">()</span>
	<span class="nf">fastrandinit</span><span class="p">()</span>  <span class="c1">// must run before mcommoninit
</span><span class="c1"></span>        <span class="c1">// 初始化 m0, 详细见后面
</span><span class="c1"></span>	<span class="nf">mcommoninit</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="nf">cpuinit</span><span class="p">()</span>       <span class="c1">// must run before alginit
</span><span class="c1"></span>	<span class="nf">alginit</span><span class="p">()</span>       <span class="c1">// maps must not be used before this call
</span><span class="c1"></span>	<span class="nf">modulesinit</span><span class="p">()</span>   <span class="c1">// provides activeModules
</span><span class="c1"></span>	<span class="nf">typelinksinit</span><span class="p">()</span> <span class="c1">// uses maps, activeModules
</span><span class="c1"></span>	<span class="nf">itabsinit</span><span class="p">()</span>     <span class="c1">// uses activeModules
</span><span class="c1"></span>
	<span class="nf">sigsave</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">sigmask</span><span class="p">)</span>
	<span class="nx">initSigmask</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">sigmask</span>

	<span class="nf">goargs</span><span class="p">()</span>
	<span class="nf">goenvs</span><span class="p">()</span>
	<span class="nf">parsedebugvars</span><span class="p">()</span>
	<span class="nf">gcinit</span><span class="p">()</span>
        <span class="c1">// 锁
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span> <span class="p">=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nf">nanotime</span><span class="p">())</span>
	<span class="nx">procs</span> <span class="o">:=</span> <span class="nx">ncpu</span>
        <span class="c1">// 读一下是否设置了env
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nf">atoi32</span><span class="p">(</span><span class="nf">gogetenv</span><span class="p">(</span><span class="s">&#34;GOMAXPROCS&#34;</span><span class="p">));</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">procs</span> <span class="p">=</span> <span class="nx">n</span>
	<span class="p">}</span>
        <span class="c1">// 初始化p,详细见后面
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">procresize</span><span class="p">(</span><span class="nx">procs</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;unknown runnable goroutine during bootstrap&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// World is effectively started now, as P&#39;s can run.
</span><span class="c1"></span>	<span class="nf">worldStarted</span><span class="p">()</span>
        <span class="o">...</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>mcommoninit m初始化</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mcommoninit</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">,</span> <span class="nx">id</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// g0
</span><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="c1">// g0 stack won&#39;t make sense for user (and is not necessary unwindable).
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span> <span class="o">!=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span> <span class="p">{</span>
		<span class="nf">callers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">createstack</span><span class="p">[:])</span>
	<span class="p">}</span>

	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="c1">// 设置mp id, 初始化传入的id=-1
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">id</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">mp</span><span class="p">.</span><span class="nx">id</span> <span class="p">=</span> <span class="nx">id</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// 取一个id,m0=0,之后的递增 , 详细见后面
</span><span class="c1"></span>		<span class="nx">mp</span><span class="p">.</span><span class="nx">id</span> <span class="p">=</span> <span class="nf">mReserveID</span><span class="p">()</span>
	<span class="p">}</span>
        <span class="c1">// rand初始化
</span><span class="c1"></span>	<span class="nx">mp</span><span class="p">.</span><span class="nx">fastrand</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nf">int64Hash</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">mp</span><span class="p">.</span><span class="nx">id</span><span class="p">),</span> <span class="nx">fastrandseed</span><span class="p">))</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">fastrand</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nf">int64Hash</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nf">cputicks</span><span class="p">()),</span> <span class="p">^</span><span class="nx">fastrandseed</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">fastrand</span><span class="p">[</span><span class="mi">0</span><span class="p">]|</span><span class="nx">mp</span><span class="p">.</span><span class="nx">fastrand</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">mp</span><span class="p">.</span><span class="nx">fastrand</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="p">}</span>
        <span class="c1">// 设置信号
</span><span class="c1"></span>	<span class="nf">mpreinit</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">gsignal</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">mp</span><span class="p">.</span><span class="nx">gsignal</span><span class="p">.</span><span class="nx">stackguard1</span> <span class="p">=</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">gsignal</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
	<span class="p">}</span>

	<span class="c1">// Add to allm so garbage collector doesn&#39;t free g-&gt;m
</span><span class="c1"></span>	<span class="c1">// when it is just in a register or thread-local storage.
</span><span class="c1"></span>	<span class="nx">mp</span><span class="p">.</span><span class="nx">alllink</span> <span class="p">=</span> <span class="nx">allm</span>

	<span class="c1">// NumCgoCall() iterates over allm w/o schedlock,
</span><span class="c1"></span>	<span class="c1">// so we need to publish it safely.
</span><span class="c1"></span>	<span class="nf">atomicstorep</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allm</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">mp</span><span class="p">))</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// Allocate memory to hold a cgo traceback if the cgo call crashes.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">iscgo</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;solaris&#34;</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;illumos&#34;</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;windows&#34;</span> <span class="p">{</span>
		<span class="nx">mp</span><span class="p">.</span><span class="nx">cgoCallers</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">cgoCallers</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>mReserveID m自增id</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mReserveID</span><span class="p">()</span> <span class="kt">int64</span> <span class="p">{</span>
        <span class="c1">// 加锁, 操作全局变量sched
</span><span class="c1"></span>	<span class="nf">assertLockHeld</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="c1">// 满了
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">mnext</span><span class="o">+</span><span class="mi">1</span> <span class="p">&lt;</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">mnext</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: thread ID overflow&#34;</span><span class="p">)</span>
	<span class="p">}</span>
        <span class="c1">// 得到id
</span><span class="c1"></span>	<span class="nx">id</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">mnext</span>
	<span class="nx">sched</span><span class="p">.</span><span class="nx">mnext</span><span class="o">++</span>
        <span class="c1">// 检查是否超过 maxcount
</span><span class="c1"></span>	<span class="nf">checkmcount</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">id</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>mpreinit</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mpreinit</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// new 一个 g 结构体对象，然后从堆上为其分配栈，并设置 g 的 stack 成员和两个 stackgard 成员
</span><span class="c1"></span>	<span class="nx">mp</span><span class="p">.</span><span class="nx">gsignal</span> <span class="p">=</span> <span class="nf">malg</span><span class="p">(</span><span class="mi">32</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="c1">// OS X wants &gt;= 8K
</span><span class="c1"></span>	<span class="nx">mp</span><span class="p">.</span><span class="nx">gsignal</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="nx">mp</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>malg</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">malg</span><span class="p">(</span><span class="nx">stacksize</span> <span class="kt">int32</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
        <span class="c1">// new 结构体
</span><span class="c1"></span>	<span class="nx">newg</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">g</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">stacksize</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">stacksize</span> <span class="p">=</span> <span class="nf">round2</span><span class="p">(</span><span class="nx">_StackSystem</span> <span class="o">+</span> <span class="nx">stacksize</span><span class="p">)</span>
                <span class="c1">// g0来分配堆栈
</span><span class="c1"></span>		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span> <span class="p">=</span> <span class="nf">stackalloc</span><span class="p">(</span><span class="nb">uint32</span><span class="p">(</span><span class="nx">stacksize</span><span class="p">))</span>
		<span class="p">})</span>
		<span class="nx">newg</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
		<span class="nx">newg</span><span class="p">.</span><span class="nx">stackguard1</span> <span class="p">=</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
		<span class="c1">// Clear the bottom word of the stack. We record g
</span><span class="c1"></span>		<span class="c1">// there on gsignal stack during VDSO on ARM and ARM64.
</span><span class="c1"></span>		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">))</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">newg</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>systemstack</li>
</ul>
<pre><code class="language-assembly" data-lang="assembly">// 切换到g0 执行
// func systemstack(fn func())
TEXT runtime·systemstack(SB), NOSPLIT, $0-8
	MOVQ	fn+0(FP), DI	// DI = fn
        // CX = m0.tls[1]
	get_tls(CX)
        // AX = m0.tls[0], 为啥这是g? 去看runtime·gogo代码, 我们设置过m0.tls[0] =g
	MOVQ	g(CX), AX	// AX = g
	MOVQ	g_m(AX), BX	// BX = m

	CMPQ	AX, m_gsignal(BX)
	JEQ	noswitch

	MOVQ	m_g0(BX), DX	// DX = g0
	CMPQ	AX, DX
	JEQ	noswitch

	CMPQ	AX, m_curg(BX)
	JNE	bad

	// switch stacks
	// save our state in g-&gt;sched. Pretend to
	// be systemstack_switch if the G stack is scanned.
	MOVQ	$runtime·systemstack_switch(SB), SI
	MOVQ	SI, (g_sched+gobuf_pc)(AX)
	MOVQ	SP, (g_sched+gobuf_sp)(AX)
	MOVQ	AX, (g_sched+gobuf_g)(AX)
	MOVQ	BP, (g_sched+gobuf_bp)(AX)

	// DX是g0
	MOVQ	DX, g(CX)
        // 保存sp
	MOVQ	(g_sched+gobuf_sp)(DX), BX
	// make it look like mstart called systemstack on g0, to stop traceback
	SUBQ	$8, BX
	MOVQ	$runtime·mstart(SB), DX
	MOVQ	DX, 0(BX)
	MOVQ	BX, SP

	// 这里调用了fn函数
	MOVQ	DI, DX
	MOVQ	0(DI), DI
	CALL	DI

	// switch back to g
	get_tls(CX)
	MOVQ	g(CX), AX
	MOVQ	g_m(AX), BX
	MOVQ	m_curg(BX), AX
	MOVQ	AX, g(CX)
	MOVQ	(g_sched+gobuf_sp)(AX), SP
	MOVQ	$0, (g_sched+gobuf_sp)(AX)
	RET

        ...

</code></pre><ul>
<li>procresize 如何分配p</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">procresize</span><span class="p">(</span><span class="nx">nprocs</span> <span class="kt">int32</span><span class="p">)</span> <span class="o">*</span><span class="nx">p</span> <span class="p">{</span>
	<span class="nf">assertLockHeld</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nf">assertWorldStopped</span><span class="p">()</span>

	<span class="nx">old</span> <span class="o">:=</span> <span class="nx">gomaxprocs</span>
	<span class="k">if</span> <span class="nx">old</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">nprocs</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;procresize: invalid arg&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGomaxprocs</span><span class="p">(</span><span class="nx">nprocs</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// update statistics
</span><span class="c1"></span>	<span class="nx">now</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">procresizetime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">sched</span><span class="p">.</span><span class="nx">totaltime</span> <span class="o">+=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">old</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nx">now</span> <span class="o">-</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">procresizetime</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">sched</span><span class="p">.</span><span class="nx">procresizetime</span> <span class="p">=</span> <span class="nx">now</span>

	<span class="nx">maskWords</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">nprocs</span> <span class="o">+</span> <span class="mi">31</span><span class="p">)</span> <span class="o">/</span> <span class="mi">32</span>

	<span class="c1">// 第一次allp肯定是0
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">nprocs</span> <span class="p">&gt;</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">allp</span><span class="p">))</span> <span class="p">{</span>
		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
                <span class="c1">// cap(allp) 第一次肯定是0
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">nprocs</span> <span class="o">&lt;=</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">allp</span><span class="p">))</span> <span class="p">{</span>
			<span class="nx">allp</span> <span class="p">=</span> <span class="nx">allp</span><span class="p">[:</span><span class="nx">nprocs</span><span class="p">]</span>
                <span class="c1">// 第一次是走else
</span><span class="c1"></span>                <span class="c1">// 如果运行过程中存在手工调整p的情况, 减小了也可能走这里
</span><span class="c1"></span>		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="c1">// 生成p的数组
</span><span class="c1"></span>			<span class="nx">nallp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">nprocs</span><span class="p">)</span>
                        <span class="c1">// 会需要需要减小的情况, 需要把原来的p copy过来
</span><span class="c1"></span>                        <span class="c1">// 初始化的话,allp肯定是空的
</span><span class="c1"></span>			<span class="nb">copy</span><span class="p">(</span><span class="nx">nallp</span><span class="p">,</span> <span class="nx">allp</span><span class="p">[:</span><span class="nb">cap</span><span class="p">(</span><span class="nx">allp</span><span class="p">)])</span>
                        <span class="c1">// 设置一下全局变量
</span><span class="c1"></span>			<span class="nx">allp</span> <span class="p">=</span> <span class="nx">nallp</span>
		<span class="p">}</span>
                <span class="o">...</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// initialize new P&#39;s
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">old</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">nprocs</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">pp</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="k">if</span> <span class="nx">pp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">pp</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
		<span class="p">}</span>
                <span class="c1">// 详细内容见后面
</span><span class="c1"></span>		<span class="nx">pp</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
                <span class="c1">// p存入到allp中
</span><span class="c1"></span>		<span class="nf">atomicstorep</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allp</span><span class="p">[</span><span class="nx">i</span><span class="p">]),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">pp</span><span class="p">))</span>
	<span class="p">}</span>
        <span class="c1">// 初始化是g0
</span><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">id</span> <span class="p">&lt;</span> <span class="nx">nprocs</span> <span class="p">{</span>
		<span class="c1">// continue to use the current P
</span><span class="c1"></span>		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Prunning</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">mcache</span><span class="p">.</span><span class="nf">prepareForSweep</span><span class="p">()</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">...</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="p">=</span> <span class="mi">0</span>
                <span class="c1">// 取队列的第0个p
</span><span class="c1"></span>		<span class="nx">p</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1">//
</span><span class="c1"></span>		<span class="nx">p</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="mi">0</span>
                <span class="c1">// 把p设置为idle
</span><span class="c1"></span>		<span class="nx">p</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pidle</span>
                <span class="c1">// p0 和 m0 关联起来, 详细内容见后面
</span><span class="c1"></span>		<span class="nf">acquirep</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
			<span class="nf">traceGoStart</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// g.m.p is now set, so we no longer need mcache0 for bootstrapping.
</span><span class="c1"></span>	<span class="nx">mcache0</span> <span class="p">=</span> <span class="kc">nil</span>

	<span class="c1">// 如果是手工缩小p就 释放
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">nprocs</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">old</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
                <span class="c1">// 这里释放主要是把一些本地的g都加到全局队列中去
</span><span class="c1"></span>                <span class="c1">// 然后p都设置为dead, 这里并没有去删除,方便下次需要直接调用
</span><span class="c1"></span>		<span class="nx">p</span><span class="p">.</span><span class="nf">destroy</span><span class="p">()</span>
		<span class="c1">// can&#39;t free P itself because it can be referenced by an M in syscall
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="c1">// 对p队列做一次伸缩
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">allp</span><span class="p">))</span> <span class="o">!=</span> <span class="nx">nprocs</span> <span class="p">{</span>
		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
		<span class="nx">allp</span> <span class="p">=</span> <span class="nx">allp</span><span class="p">[:</span><span class="nx">nprocs</span><span class="p">]</span>
		<span class="nx">idlepMask</span> <span class="p">=</span> <span class="nx">idlepMask</span><span class="p">[:</span><span class="nx">maskWords</span><span class="p">]</span>
		<span class="nx">timerpMask</span> <span class="p">=</span> <span class="nx">timerpMask</span><span class="p">[:</span><span class="nx">maskWords</span><span class="p">]</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">runnablePs</span> <span class="o">*</span><span class="nx">p</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">nprocs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
                <span class="c1">// g0.m.p是p0, 不用加入到空闲队列
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">==</span> <span class="nx">p</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
                <span class="c1">// 设置idle
</span><span class="c1"></span>		<span class="nx">p</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pidle</span>
                <span class="c1">// 可运行的空闲队列,详细见后面
</span><span class="c1"></span>		<span class="k">if</span> <span class="nf">runqempty</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
                        <span class="c1">// 放入全局空闲链表, 详细见后面
</span><span class="c1"></span>			<span class="nf">pidleput</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="c1">// mget() 获取一个m 绑定到这个p上去执行
</span><span class="c1"></span>			<span class="nx">p</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nf">mget</span><span class="p">())</span>
                        <span class="c1">// 设置链表
</span><span class="c1"></span>			<span class="nx">p</span><span class="p">.</span><span class="nx">link</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">runnablePs</span><span class="p">)</span>
			<span class="nx">runnablePs</span> <span class="p">=</span> <span class="nx">p</span>
		<span class="p">}</span>
	<span class="p">}</span>
        <span class="c1">// 对randomOrder的队列做一个随机处理, 为了后续有偷取的时候更随机,调度更公平
</span><span class="c1"></span>	<span class="nx">stealOrder</span><span class="p">.</span><span class="nf">reset</span><span class="p">(</span><span class="nb">uint32</span><span class="p">(</span><span class="nx">nprocs</span><span class="p">))</span>
	<span class="kd">var</span> <span class="nx">int32p</span> <span class="o">*</span><span class="kt">int32</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">gomaxprocs</span> <span class="c1">// make compiler check that gomaxprocs is an int32
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">((</span><span class="o">*</span><span class="kt">uint32</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">int32p</span><span class="p">)),</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">nprocs</span><span class="p">))</span>
        <span class="c1">// 返回本地任务链表p头, allp队列里的第一个可执行的p
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">runnablePs</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>init p初始化函数</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">pp</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="nf">init</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// id就是索引了
</span><span class="c1"></span>	<span class="nx">pp</span><span class="p">.</span><span class="nx">id</span> <span class="p">=</span> <span class="nx">id</span>
        <span class="c1">// 新建的p开始是stop状态
</span><span class="c1"></span>	<span class="nx">pp</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pgcstop</span>
	<span class="o">...</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>acquirep</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">acquirep</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 继续追
</span><span class="c1"></span>	<span class="nf">wirep</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
	<span class="nx">_p_</span><span class="p">.</span><span class="nx">mcache</span><span class="p">.</span><span class="nf">prepareForSweep</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceProcStart</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>wirep</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">wirep</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// g0
</span><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
        <span class="c1">// 第一次是g0.m.p == 0  
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;wirep: already in go&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span> <span class="o">!=</span> <span class="nx">_Pidle</span> <span class="p">{</span>
		<span class="nx">id</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">id</span> <span class="p">=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">id</span>
		<span class="p">}</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;wirep: p-&gt;m=&#34;</span><span class="p">,</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">,</span> <span class="s">&#34;(&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="s">&#34;) p-&gt;status=&#34;</span><span class="p">,</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;wirep: invalid p state&#34;</span><span class="p">)</span>
	<span class="p">}</span>
        <span class="c1">// g0.m.p = p0
</span><span class="c1"></span>	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
        <span class="c1">// p0.m0 = m0
</span><span class="c1"></span>	<span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">)</span>
        <span class="c1">// 现在就可以设置为running了
</span><span class="c1"></span>	<span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Prunning</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>runqempty</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">runqempty</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
        <span class="c1">// 这里是无锁的方式判断
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">head</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">)</span>
		<span class="nx">tail</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span><span class="p">)</span>
		<span class="nx">runnext</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Loaduintptr</span><span class="p">((</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span><span class="p">)))</span>
		<span class="k">if</span> <span class="nx">tail</span> <span class="o">==</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">head</span> <span class="o">==</span> <span class="nx">tail</span> <span class="o">&amp;&amp;</span> <span class="nx">runnext</span> <span class="o">==</span> <span class="mi">0</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>pidleput</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">pidleput</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">assertLockHeld</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="k">if</span> <span class="p">!</span><span class="nf">runqempty</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;pidleput: P has non-empty run queue&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">updateTimerPMask</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="c1">// clear if there are no timers.
</span><span class="c1"></span>	<span class="nx">idlepMask</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span>
        <span class="c1">// sched.pidle 是全局空闲p链表的最后一个
</span><span class="c1"></span>        <span class="c1">// 当前p的link记录
</span><span class="c1"></span>	<span class="nx">_p_</span><span class="p">.</span><span class="nx">link</span> <span class="p">=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">pidle</span>
        <span class="c1">// 然后把sched.pidle 设置为当前p, 这样就连起来了
</span><span class="c1"></span>	<span class="nx">sched</span><span class="p">.</span><span class="nx">pidle</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// TODO: fast atomic
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>到 runtime·schedinit时的状态图, 来自<img src="https://qcrao.com/ishare/go-scheduler" alt="https://qcrao.com">的图:</p>
<p><img src="/images/golang/gmp-1.png" alt=""></p>
<hr>
<pre><code class="language-assembly" data-lang="assembly">        MOVQ	$runtime·mainPC(SB), AX
        // 入栈新的goroutine的地址
        PUSHQ	AX	  
        // main函数参数个数是0
        PUSHL	$0
        // 创建goroutine
        CALL	runtime·newproc(SB)       
        POPL	AX
        POPL	AX
</code></pre><blockquote>
<p>gmp已经初始化的差不多了, 现在可以创建main goroutine了</p>
</blockquote>
<h3 id="创建g-newproc">创建g newproc</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/proc.go
</span><span class="c1">// 两个参数, 一个是函数siz,一个是函数地址
</span><span class="c1">// type funcval struct {
</span><span class="c1">// 	fn uintptr
</span><span class="c1">// 	// variable-size, fn-specific data here
</span><span class="c1">// }
</span><span class="c1">// 函数栈从高到底依次是:
</span><span class="c1">// fn的参数        这里是高地址, &amp;fn+sys.PtrSize
</span><span class="c1">// fn的地址        这里是&amp;fn
</span><span class="c1">// fn的size
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newproc</span><span class="p">(</span><span class="nx">siz</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">fn</span> <span class="o">*</span><span class="nx">funcval</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// fn的第一个参数
</span><span class="c1"></span>	<span class="nx">argp</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">fn</span><span class="p">),</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span>
        <span class="c1">// g0
</span><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
        <span class="c1">// 调用者的pc,call pc就是调用者的下一个指令, 我们看到runtime·rt0_go中, call runtime-newproc后 POPL AX了
</span><span class="c1"></span>        <span class="c1">// 所以这里的调用者pc 就是 AX地址, AX 是 main的地址
</span><span class="c1"></span>	<span class="nx">pc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
        <span class="c1">// systemstack 的作用是切换到 g0 栈执行作为参数的函数
</span><span class="c1"></span>        <span class="c1">// 用 g0 系统栈创建 goroutine 对象
</span><span class="c1"></span>        <span class="c1">// 传递的参数包括 fn 函数入口地址，argp 参数起始地址，siz 参数长度，调用方 pc（goroutine）
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
                <span class="c1">// 真正的创建go
</span><span class="c1"></span>		<span class="nx">newg</span> <span class="o">:=</span> <span class="nf">newproc1</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">argp</span><span class="p">,</span> <span class="nx">siz</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
                <span class="c1">// 获取到本地绑定的p
</span><span class="c1"></span>		<span class="nx">_p_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
                <span class="c1">// 将这里新创建的 g 放入 p 的本地队列或直接放入全局队列
</span><span class="c1"></span>                <span class="c1">// true 表示放入执行队列的下一个，false 表示放入队尾
</span><span class="c1"></span>		<span class="nf">runqput</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">newg</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>

		<span class="k">if</span> <span class="nx">mainStarted</span> <span class="p">{</span>
			<span class="nf">wakep</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">})</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>newproc1 核心创建goroutine</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/proc.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newproc1</span><span class="p">(</span><span class="nx">fn</span> <span class="o">*</span><span class="nx">funcval</span><span class="p">,</span> <span class="nx">argp</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">narg</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">callergp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">callerpc</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
        <span class="c1">// g0, systemstack 切换的
</span><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
        <span class="c1">// go 命令后面的函数肯定不能是nil
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">fn</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">throwing</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1">// do not dump full stacks
</span><span class="c1"></span>		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;go of nil func value&#34;</span><span class="p">)</span>
	<span class="p">}</span>
        <span class="c1">// 绑定m
</span><span class="c1"></span>	<span class="nf">acquirem</span><span class="p">()</span> <span class="c1">// disable preemption because it can be holding p in a local var
</span><span class="c1"></span>	<span class="nx">siz</span> <span class="o">:=</span> <span class="nx">narg</span>
        <span class="c1">// 内存对齐, &amp;^ 7 会把低三位全部置为0
</span><span class="c1"></span>	<span class="nx">siz</span> <span class="p">=</span> <span class="p">(</span><span class="nx">siz</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;^</span> <span class="mi">7</span>

        <span class="o">...</span>
        <span class="c1">// 当前g0所绑定的p
</span><span class="c1"></span>	<span class="nx">_p_</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
        <span class="c1">// 从p的本地队列获取一个g,空的话会从全局拿一个,初始化肯定是nil 详细见后面
</span><span class="c1"></span>	<span class="nx">newg</span> <span class="o">:=</span> <span class="nf">gfget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">newg</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="c1">// 分配一个2k空间的g
</span><span class="c1"></span>		<span class="nx">newg</span> <span class="p">=</span> <span class="nf">malg</span><span class="p">(</span><span class="nx">_StackMin</span><span class="p">)</span>
                <span class="c1">// 设置为dead状态
</span><span class="c1"></span>		<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">newg</span><span class="p">,</span> <span class="nx">_Gidle</span><span class="p">,</span> <span class="nx">_Gdead</span><span class="p">)</span>
                <span class="c1">// 加入到 allgs 全局队列中
</span><span class="c1"></span>		<span class="nf">allgadd</span><span class="p">(</span><span class="nx">newg</span><span class="p">)</span> <span class="c1">// publishes with a g-&gt;status of Gdead so GC scanner doesn&#39;t look at uninitialized stack.
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;newproc1: newg missing stack&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">newg</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">_Gdead</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;newproc1: new g is not Gdead&#34;</span><span class="p">)</span>
	<span class="p">}</span>
        <span class="c1">// 计算内存空间
</span><span class="c1"></span>	<span class="nx">totalSize</span> <span class="o">:=</span> <span class="mi">4</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">RegSize</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">siz</span><span class="p">)</span> <span class="o">+</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">MinFrameSize</span> <span class="c1">// extra space in case of reads slightly beyond frame
</span><span class="c1"></span>        <span class="c1">// 对于arm环境的sys.SpAlign=16,其他的是1
</span><span class="c1"></span>	<span class="nx">totalSize</span> <span class="o">+=</span> <span class="o">-</span><span class="nx">totalSize</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nx">SpAlign</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>                  <span class="c1">// align to spAlign
</span><span class="c1"></span>        <span class="c1">// 预留空间, 确定sp栈顶的位置
</span><span class="c1"></span>	<span class="nx">sp</span> <span class="o">:=</span> <span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="o">-</span> <span class="nx">totalSize</span>
        <span class="c1">// 确定参数入栈位置
</span><span class="c1"></span>	<span class="nx">spArg</span> <span class="o">:=</span> <span class="nx">sp</span>
        <span class="o">...</span>
	<span class="k">if</span> <span class="nx">narg</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="c1">// argp 是fn的第一个参数地址
</span><span class="c1"></span>                <span class="c1">// 这是copy 参数到新的g栈的spArg参数位置
</span><span class="c1"></span>		<span class="nf">memmove</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">spArg</span><span class="p">),</span> <span class="nx">argp</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">narg</span><span class="p">))</span>
                <span class="o">...</span>
	<span class="p">}</span>
        <span class="c1">// 把 newg.sched 结构体成员的所有成员设置为 0
</span><span class="c1"></span>	<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">))</span>
        <span class="c1">// 设置 newg 的 sched 成员，调度器需要依靠这些字段才能把 goroutine 调度到 CPU 上运行
</span><span class="c1"></span>	<span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span> <span class="p">=</span> <span class="nx">sp</span>
	<span class="nx">newg</span><span class="p">.</span><span class="nx">stktopsp</span> <span class="p">=</span> <span class="nx">sp</span>
        <span class="c1">// 设置newg被调度时的第一个指令, Goexit函数地址,
</span><span class="c1"></span>        <span class="c1">// sys.PCQuantum =1, +1表示goexit函数的第一条指令?
</span><span class="c1"></span>	<span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="nf">funcPC</span><span class="p">(</span><span class="nx">goexit</span><span class="p">)</span> <span class="o">+</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PCQuantum</span> <span class="c1">// +PCQuantum 这样前一条指令就在同一个函数中了
</span><span class="c1"></span>	<span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nf">guintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">newg</span><span class="p">))</span>
        <span class="c1">// 设置newg.sched的 sp和pc等信息,pc设为fn的地址了 详细见后面
</span><span class="c1"></span>	<span class="nf">gostartcallfn</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">,</span> <span class="nx">fn</span><span class="p">)</span>
        <span class="c1">// 设置为调用者pc
</span><span class="c1"></span>	<span class="nx">newg</span><span class="p">.</span><span class="nx">gopc</span> <span class="p">=</span> <span class="nx">callerpc</span>
	<span class="nx">newg</span><span class="p">.</span><span class="nx">ancestors</span> <span class="p">=</span> <span class="nf">saveAncestors</span><span class="p">(</span><span class="nx">callergp</span><span class="p">)</span>
	<span class="nx">newg</span><span class="p">.</span><span class="nx">startpc</span> <span class="p">=</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">fn</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">newg</span><span class="p">.</span><span class="nx">labels</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span><span class="p">.</span><span class="nx">labels</span>
	<span class="p">}</span>
        <span class="c1">// runtime. 前缀的属于系统goroutine
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">isSystemGoroutine</span><span class="p">(</span><span class="nx">newg</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ngsys</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
        <span class="c1">// g的状态设置为可运行
</span><span class="c1"></span>	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">newg</span><span class="p">,</span> <span class="nx">_Gdead</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span> <span class="o">==</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcacheend</span> <span class="p">{</span>
                <span class="c1">// Sched.goidgen 为最后一个分配的 id，相当于一个全局计数器
</span><span class="c1"></span>		<span class="c1">// 这一批必须为 [sched.goidgen+1, sched.goidgen+GoidCacheBatch].
</span><span class="c1"></span>		<span class="c1">// 启动时 sched.goidgen=0, 因此主 Goroutine 的 goid 为 1
</span><span class="c1"></span>		<span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span> <span class="p">=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">goidgen</span><span class="p">,</span> <span class="nx">_GoidCacheBatch</span><span class="p">)</span>
		<span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span> <span class="o">-=</span> <span class="nx">_GoidCacheBatch</span> <span class="o">-</span> <span class="mi">1</span>
		<span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcacheend</span> <span class="p">=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span> <span class="o">+</span> <span class="nx">_GoidCacheBatch</span>
	<span class="p">}</span>
        <span class="c1">// 生成goid
</span><span class="c1"></span>	<span class="nx">newg</span><span class="p">.</span><span class="nx">goid</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span><span class="p">)</span>
	<span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span><span class="o">++</span>
	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nx">newg</span><span class="p">.</span><span class="nx">racectx</span> <span class="p">=</span> <span class="nf">racegostart</span><span class="p">(</span><span class="nx">callerpc</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGoCreate</span><span class="p">(</span><span class="nx">newg</span><span class="p">,</span> <span class="nx">newg</span><span class="p">.</span><span class="nx">startpc</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">releasem</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">newg</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>gfget</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/proc.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">gfget</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
<span class="nx">retry</span><span class="p">:</span>
        <span class="c1">// 如果p本地空闲队列为空 并且全局空闲队列不空
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(!</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="o">||</span> <span class="p">!</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">noStack</span><span class="p">.</span><span class="nf">empty</span><span class="p">())</span> <span class="p">{</span>
                <span class="c1">// 操作全局,上锁
</span><span class="c1"></span>		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="c1">// Move a batch of free Gs to the P.
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span> <span class="p">&lt;</span> <span class="mi">32</span> <span class="p">{</span>
			<span class="c1">// 从全局拿一个g
</span><span class="c1"></span>			<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">gp</span> <span class="p">=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">noStack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
				<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="k">break</span>
				<span class="p">}</span>
			<span class="p">}</span>
                        <span class="c1">// 全局的n--
</span><span class="c1"></span>			<span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span><span class="o">--</span>
                        <span class="c1">// 全局的放入到p本地队列中
</span><span class="c1"></span>			<span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
			<span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
                <span class="c1">// 本地队列加一个了, 然后再去retry一下
</span><span class="c1"></span>		<span class="k">goto</span> <span class="nx">retry</span>
	<span class="p">}</span>
        <span class="c1">// 如果本地不为空直接取
</span><span class="c1"></span>        <span class="c1">// 如果本地为空 并且全局也是空, 初始化的情况,也得取一个nil
</span><span class="c1"></span>        <span class="c1">// 直接从本地的p空闲队列取出
</span><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="c1">// 初始化的情况
</span><span class="c1"></span>		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span><span class="o">--</span>
	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Stack was deallocated in gfput. Allocate a new one.
</span><span class="c1"></span>		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span> <span class="p">=</span> <span class="nf">stackalloc</span><span class="p">(</span><span class="nx">_FixedStack</span><span class="p">)</span>
		<span class="p">})</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
			<span class="nf">racemalloc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">),</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span><span class="o">-</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">msanenabled</span> <span class="p">{</span>
			<span class="nf">msanmalloc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">),</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span><span class="o">-</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">gp</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>gostartcallfn</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gostartcallfn</span><span class="p">(</span><span class="nx">gobuf</span> <span class="o">*</span><span class="nx">gobuf</span><span class="p">,</span> <span class="nx">fv</span> <span class="o">*</span><span class="nx">funcval</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">fn</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
	<span class="k">if</span> <span class="nx">fv</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="c1">// goroutine入口, 初始化时是 runtime.main()
</span><span class="c1"></span>		<span class="nx">fn</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">fv</span><span class="p">.</span><span class="nx">fn</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">fn</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nf">funcPC</span><span class="p">(</span><span class="nx">nilfunc</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="nf">gostartcall</span><span class="p">(</span><span class="nx">gobuf</span><span class="p">,</span> <span class="nx">fn</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">fv</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">gostartcall</span><span class="p">(</span><span class="nx">buf</span> <span class="o">*</span><span class="nx">gobuf</span><span class="p">,</span> <span class="nx">fn</span><span class="p">,</span> <span class="nx">ctxt</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// newg.sched.sp
</span><span class="c1"></span>	<span class="nx">sp</span> <span class="o">:=</span> <span class="nx">buf</span><span class="p">.</span><span class="nx">sp</span>
	<span class="k">if</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">RegSize</span> <span class="p">&gt;</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="p">{</span>
		<span class="nx">sp</span> <span class="o">-=</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sp</span><span class="p">))</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
        <span class="c1">// newg.sched.sp下移8
</span><span class="c1"></span>	<span class="nx">sp</span> <span class="o">-=</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
        <span class="c1">// newg.sched.pc之前是记录我们newg函数的第一条指令 goexit函数,给他保存到sp位置
</span><span class="c1"></span>        <span class="c1">// 伪装fn是被goexit调用, 这样fn执行完sp上移8 就执行了goexit函数了
</span><span class="c1"></span>	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sp</span><span class="p">))</span> <span class="p">=</span> <span class="nx">buf</span><span class="p">.</span><span class="nx">pc</span>
        <span class="c1">// 更新为最新的sp
</span><span class="c1"></span>	<span class="nx">buf</span><span class="p">.</span><span class="nx">sp</span> <span class="p">=</span> <span class="nx">sp</span>
        <span class="c1">// 把newg.sched.pc 设置为fn的地址
</span><span class="c1"></span>        <span class="c1">// 当goroutine执行的时候, 就先执行了buf.pc地址的函数fn
</span><span class="c1"></span>	<span class="nx">buf</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span>
	<span class="nx">buf</span><span class="p">.</span><span class="nx">ctxt</span> <span class="p">=</span> <span class="nx">ctxt</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>runqput</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// runqput 尝试将 g 放到本地可执行队列里。
</span><span class="c1">// 如果 next 为假，runqput 将 g 添加到可运行队列的尾部
</span><span class="c1">// 如果 next 为真，runqput 将 g 添加到 p.runnext 字段
</span><span class="c1">// 如果 run queue 满了，runnext 将 g 放到全局队列里
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">runqput</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">next</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 如果是设置了随机模式?
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">randomizeScheduler</span> <span class="o">&amp;&amp;</span> <span class="nx">next</span> <span class="o">&amp;&amp;</span> <span class="nf">fastrand</span><span class="p">()</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">next</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="p">}</span>
        <span class="c1">// 如果需要放入队尾
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">next</span> <span class="p">{</span>
	<span class="nx">retryNext</span><span class="p">:</span>
                <span class="c1">// 原本的p队列的next保存
</span><span class="c1"></span>		<span class="nx">oldnext</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span>
                <span class="c1">// 将新的gp放到runnext位置执行
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span><span class="p">.</span><span class="nf">cas</span><span class="p">(</span><span class="nx">oldnext</span><span class="p">,</span> <span class="nf">guintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gp</span><span class="p">)))</span> <span class="p">{</span>
                        <span class="c1">// 有其它线程在操作 oldnext 成员，需要重试
</span><span class="c1"></span>			<span class="k">goto</span> <span class="nx">retryNext</span>
		<span class="p">}</span>
                <span class="c1">// 不用管
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">oldnext</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
                <span class="c1">// 把oldnext设置为了gp, 后续会对他入队尾的
</span><span class="c1"></span>		<span class="nx">gp</span> <span class="p">=</span> <span class="nx">oldnext</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="p">}</span>

<span class="nx">retry</span><span class="p">:</span>
	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadAcq</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">)</span> <span class="c1">// load-acquire, synchronize with consumers
</span><span class="c1"></span>	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span>
        <span class="c1">// 没满
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">t</span><span class="o">-</span><span class="nx">h</span> <span class="p">&lt;</span> <span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))</span> <span class="p">{</span>
                <span class="c1">// gp 入到队尾的, 可能是newg,也可能是oldnext
</span><span class="c1"></span>		<span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">[</span><span class="nx">t</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))].</span><span class="nf">set</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
                <span class="c1">// 原子操作
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreRel</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span><span class="p">,</span> <span class="nx">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// store-release, makes the item available for consumption
</span><span class="c1"></span>		<span class="k">return</span>
	<span class="p">}</span>
        <span class="c1">// 如果本地满了, 把本地的一半 和gp 放到全局队列中去,详细见后面
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">runqputslow</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// 现在本地队列没满, 再试一次
</span><span class="c1"></span>	<span class="k">goto</span> <span class="nx">retry</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>runqputslow</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">runqputslow</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">t</span> <span class="kt">uint32</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
        <span class="c1">// 新建一个本地队列一半(128)+1大小的队列
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">batch</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="nx">g</span>

	<span class="c1">// First, grab a batch from local queue.
</span><span class="c1"></span>        <span class="c1">// 如果满了, t-h=256
</span><span class="c1"></span>	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">t</span> <span class="o">-</span> <span class="nx">h</span>
        <span class="c1">// n = 128
</span><span class="c1"></span>	<span class="nx">n</span> <span class="p">=</span> <span class="nx">n</span> <span class="o">/</span> <span class="mi">2</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="o">!=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runqputslow: queue is not full&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">batch</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">[(</span><span class="nx">h</span><span class="o">+</span><span class="nx">i</span><span class="p">)</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))].</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="p">}</span>
        <span class="c1">// CasRel 如果未false, 那就说明本地队列没满, 直接返回
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">CasRel</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">h</span><span class="o">+</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// cas-release, commits consume
</span><span class="c1"></span>		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
        <span class="c1">// 索引为128的是队尾, gp放到队尾
</span><span class="c1"></span>	<span class="nx">batch</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="p">=</span> <span class="nx">gp</span>
        <span class="c1">// 如果是随机调度
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">randomizeScheduler</span> <span class="p">{</span>
                <span class="c1">// 把这个batch队列打乱
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">j</span> <span class="o">:=</span> <span class="nf">fastrandn</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
			<span class="nx">batch</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">batch</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">batch</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">batch</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 设置为链表
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">batch</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">schedlink</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">batch</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
	<span class="p">}</span>
        <span class="c1">// 定义个g队列元素
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">q</span> <span class="nx">gQueue</span>
	<span class="nx">q</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">batch</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="nx">q</span><span class="p">.</span><span class="nx">tail</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">batch</span><span class="p">[</span><span class="nx">n</span><span class="p">])</span>

	<span class="c1">// 上锁,
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="c1">// 放到全局队列中
</span><span class="c1"></span>	<span class="nf">globrunqputbatch</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">q</span><span class="p">,</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>globrunqputbatch</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">globrunqputbatch</span><span class="p">(</span><span class="nx">batch</span> <span class="o">*</span><span class="nx">gQueue</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">assertLockHeld</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="c1">// 操作链表的函数
</span><span class="c1"></span>	<span class="nx">sched</span><span class="p">.</span><span class="nx">runq</span><span class="p">.</span><span class="nf">pushBackAll</span><span class="p">(</span><span class="o">*</span><span class="nx">batch</span><span class="p">)</span>
	<span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="o">+=</span> <span class="nx">n</span>
	<span class="o">*</span><span class="nx">batch</span> <span class="p">=</span> <span class="nx">gQueue</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">q</span> <span class="o">*</span><span class="nx">gQueue</span><span class="p">)</span> <span class="nf">pushBackAll</span><span class="p">(</span><span class="nx">q2</span> <span class="nx">gQueue</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">q2</span><span class="p">.</span><span class="nx">tail</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">q2</span><span class="p">.</span><span class="nx">tail</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">schedlink</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="k">if</span> <span class="nx">q</span><span class="p">.</span><span class="nx">tail</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="c1">// 如果当前的q(sched.runq)的tail不是0,那么先把指向 batch.head
</span><span class="c1"></span>		<span class="nx">q</span><span class="p">.</span><span class="nx">tail</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">schedlink</span> <span class="p">=</span> <span class="nx">q2</span><span class="p">.</span><span class="nx">head</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// 如果sched.runq.tail 是空的, 那么就batch.head就是全局队列的head
</span><span class="c1"></span>		<span class="nx">q</span><span class="p">.</span><span class="nx">head</span> <span class="p">=</span> <span class="nx">q2</span><span class="p">.</span><span class="nx">head</span>
	<span class="p">}</span>
        <span class="c1">// 设置新的队尾
</span><span class="c1"></span>	<span class="nx">q</span><span class="p">.</span><span class="nx">tail</span> <span class="p">=</span> <span class="nx">q2</span><span class="p">.</span><span class="nx">tail</span>
<span class="p">}</span>

</code></pre></div><p>现在在goroutine的堆上结构体如下, 来自<img src="https://qcrao.com/ishare/go-scheduler" alt="https://qcrao.com">的图:</p>
<p><img src="/images/golang/gmp-2.png" alt=""></p>
<h3 id="开始调度-mstart">开始调度 mstart()</h3>
<ul>
<li>mstart()</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/proc.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">mstart</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// g0
</span><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="p">..</span>
	<span class="nf">mstart1</span><span class="p">()</span>

	<span class="c1">// 退出线程
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">mStackIsSystemAllocated</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">osStack</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="nf">mexit</span><span class="p">(</span><span class="nx">osStack</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h4 id="实质逻辑-mstart1">实质逻辑 mstart1()</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/proc.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">mstart1</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 必须是g0
</span><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">_g_</span> <span class="o">!=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad runtime·mstart&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 记录pc,sp到当前的g0.sched
</span><span class="c1"></span>	<span class="nf">save</span><span class="p">(</span><span class="nf">getcallerpc</span><span class="p">(),</span> <span class="nf">getcallersp</span><span class="p">())</span>
	<span class="nf">asminit</span><span class="p">()</span>  
	<span class="nf">minit</span><span class="p">()</span>
	<span class="c1">// 若当前 g 所绑定的 m 是 m0，
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nx">m0</span> <span class="p">{</span>
		<span class="nf">mstartm0</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">// 运行启动函数,初始化过程中，fn == nil
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">fn</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mstartfn</span><span class="p">;</span> <span class="nx">fn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">fn</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">//若当前 g 所绑定的 m 不是 m0，
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="nx">m0</span> <span class="p">{</span>
		<span class="c1">//则需要调用 acquirep 方法获取并绑定 p，也就是 m 与 p 绑定。
</span><span class="c1"></span>		<span class="nf">acquirep</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">nextp</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">nextp</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
        <span class="c1">// 调度, 永不退出
</span><span class="c1"></span>	<span class="nf">schedule</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><h4 id="真正的调度-schedule">真正的调度 schedule()</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">schedule</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// g0
</span><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;schedule: holding locks&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedg</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">stoplockedm</span><span class="p">()</span>
		<span class="nf">execute</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedg</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="kc">false</span><span class="p">)</span> <span class="c1">// Never returns.
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="c1">// We should not schedule away from a g that is executing a cgo call,
</span><span class="c1"></span>	<span class="c1">// since the cgo call is using the m&#39;s g0 stack.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">incgo</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;schedule: in cgo&#34;</span><span class="p">)</span>
	<span class="p">}</span>

<span class="nx">top</span><span class="p">:</span>
        <span class="c1">// 获取一个p
</span><span class="c1"></span>	<span class="nx">pp</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
        <span class="c1">// 抢占信号
</span><span class="c1"></span>	<span class="nx">pp</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">=</span> <span class="kc">false</span>

	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="c1">// 会调用 stopm()
</span><span class="c1"></span>		<span class="nf">gcstopm</span><span class="p">()</span>
		<span class="k">goto</span> <span class="nx">top</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">runSafePointFn</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">runSafePointFn</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">runnext</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">runqhead</span> <span class="o">!=</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">runqtail</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;schedule: spinning with local work&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nf">checkTimers</span><span class="p">(</span><span class="nx">pp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span>
	<span class="kd">var</span> <span class="nx">inheritTime</span> <span class="kt">bool</span>

	<span class="nx">tryWakeP</span> <span class="o">:=</span> <span class="kc">false</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="o">||</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">shutdown</span> <span class="p">{</span>
		<span class="nx">gp</span> <span class="p">=</span> <span class="nf">traceReader</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
			<span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
			<span class="nx">tryWakeP</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">gp</span> <span class="p">=</span> <span class="nx">gcController</span><span class="p">.</span><span class="nf">findRunnableGCWorker</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
		<span class="nx">tryWakeP</span> <span class="p">=</span> <span class="nx">tryWakeP</span> <span class="o">||</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span>
	<span class="p">}</span>
        <span class="c1">// 初始化肯定是nil
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// schedule函数调度每61次就 取一次全局队列的g,防止饿死
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">schedtick</span><span class="o">%</span><span class="mi">61</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
                        <span class="c1">// 这里第一个参数是本地p,第二个参数是需要从全局取多少个g, 详细见后面
</span><span class="c1"></span>			<span class="nx">gp</span> <span class="p">=</span> <span class="nf">globrunqget</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
        <span class="c1">// 如果gp还是nil
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="c1">// 本地取,详细见后面
</span><span class="c1"></span>		<span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="p">=</span> <span class="nf">runqget</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>

	<span class="p">}</span>
        <span class="c1">// 如果还是nil
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="c1">// 是时候去偷一点了, 详细见后面
</span><span class="c1"></span>		<span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="p">=</span> <span class="nf">findrunnable</span><span class="p">()</span> <span class="c1">// blocks until work is available
</span><span class="c1"></span>	<span class="p">}</span>
        <span class="c1">// m如果是自旋
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">{</span>
		<span class="nf">resetspinning</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">disable</span><span class="p">.</span><span class="nx">user</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nf">schedEnabled</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// Scheduling of this goroutine is disabled. Put it on
</span><span class="c1"></span>		<span class="c1">// the list of pending runnable goroutines for when we
</span><span class="c1"></span>		<span class="c1">// re-enable user scheduling and look again.
</span><span class="c1"></span>		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">if</span> <span class="nf">schedEnabled</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// Something re-enabled scheduling while we
</span><span class="c1"></span>			<span class="c1">// were acquiring the lock.
</span><span class="c1"></span>			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">sched</span><span class="p">.</span><span class="nx">disable</span><span class="p">.</span><span class="nx">runnable</span><span class="p">.</span><span class="nf">pushBack</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
			<span class="nx">sched</span><span class="p">.</span><span class="nx">disable</span><span class="p">.</span><span class="nx">n</span><span class="o">++</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="k">goto</span> <span class="nx">top</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">tryWakeP</span> <span class="p">{</span>
		<span class="nf">wakep</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">lockedm</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Hands off own p to the locked m,
</span><span class="c1"></span>		<span class="c1">// then blocks waiting for a new p.
</span><span class="c1"></span>		<span class="nf">startlockedm</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="nx">top</span>
	<span class="p">}</span>
        <span class="c1">// 当前的schedule() 是g0
</span><span class="c1"></span>        <span class="c1">// 调度,看下如何切换到gp去执行 详细见后面
</span><span class="c1"></span>	<span class="nf">execute</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>globrunqget 全局队列获取g</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">globrunqget</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">max</span> <span class="kt">int32</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
	<span class="nf">assertLockHeld</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="c1">// 全局队列有没有
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
        <span class="c1">// 设置默认n
</span><span class="c1"></span>	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span><span class="o">/</span><span class="nx">gomaxprocs</span> <span class="o">+</span> <span class="mi">1</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="p">{</span>
		<span class="nx">n</span> <span class="p">=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span>
	<span class="p">}</span>
        <span class="c1">// 只需要get 最大max个g
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">max</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="nx">max</span> <span class="p">{</span>
		<span class="nx">n</span> <span class="p">=</span> <span class="nx">max</span>
	<span class="p">}</span>
        <span class="c1">// n不能超过当前p的队列长度的一半
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span> <span class="p">{</span>
		<span class="nx">n</span> <span class="p">=</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
	<span class="p">}</span>
        <span class="c1">// 全局减去 n
</span><span class="c1"></span>	<span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="o">-=</span> <span class="nx">n</span>
        <span class="c1">// 全局出队列
</span><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runq</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
	<span class="nx">n</span><span class="o">--</span>
        <span class="c1">// 批量出队列
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">;</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span><span class="o">--</span> <span class="p">{</span>
		<span class="nx">gp1</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runq</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
                <span class="c1">// n&gt;1的情况, 从全局取出g加入到本地p队列的队尾
</span><span class="c1"></span>		<span class="nf">runqput</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">gp1</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
	<span class="p">}</span>
        <span class="c1">// 从全局只取一个返回
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">gp</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>runqget</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">runqget</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
                <span class="c1">// p队列的下一个
</span><span class="c1"></span>		<span class="nx">next</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span>
		<span class="k">if</span> <span class="nx">next</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
                <span class="c1">// 再次确定是否有变化
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span><span class="p">.</span><span class="nf">cas</span><span class="p">(</span><span class="nx">next</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">next</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="kc">true</span>
		<span class="p">}</span>
	<span class="p">}</span>
        <span class="c1">// 如果next == 0
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
                <span class="c1">// 原子取 p队列头地址的值
</span><span class="c1"></span>		<span class="nx">h</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadAcq</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">)</span> <span class="c1">// load-acquire, synchronize with other consumers
</span><span class="c1"></span>                <span class="c1">// p队列尾
</span><span class="c1"></span>		<span class="nx">t</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span>
                <span class="c1">// 如果相等就是空队列了
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">t</span> <span class="o">==</span> <span class="nx">h</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span>
		<span class="p">}</span>
                <span class="c1">// 如果队列中有 g , 就从开头拿一个
</span><span class="c1"></span>		<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">[</span><span class="nx">h</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))].</span><span class="nf">ptr</span><span class="p">()</span>
                <span class="c1">// 原子操作，防止这中间被其他线程因为偷工作而修改
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CasRel</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">h</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// cas-release, commits consume
</span><span class="c1"></span>			<span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>findrunnable</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">findrunnable</span><span class="p">()</span> <span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

<span class="nx">top</span><span class="p">:</span>
	<span class="nx">_p_</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
        <span class="c1">// 这里要停止当前的m
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">gcstopm</span><span class="p">()</span>
		<span class="k">goto</span> <span class="nx">top</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runSafePointFn</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">runSafePointFn</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="nx">now</span><span class="p">,</span> <span class="nx">pollUntil</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nf">checkTimers</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">fingwait</span> <span class="o">&amp;&amp;</span> <span class="nx">fingwake</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">wakefing</span><span class="p">();</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">ready</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="o">*</span><span class="nx">cgo_yield</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">asmcgocall</span><span class="p">(</span><span class="o">*</span><span class="nx">cgo_yield</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 从本地找一个g
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="o">:=</span> <span class="nf">runqget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">);</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span>
	<span class="p">}</span>

	<span class="c1">// 从全局找一个g
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">globrunqget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nf">netpollinited</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">netpollWaiters</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">list</span> <span class="o">:=</span> <span class="nf">netpoll</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="p">!</span><span class="nx">list</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// non-blocking
</span><span class="c1"></span>			<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">list</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
			<span class="nf">injectglist</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">list</span><span class="p">)</span>
			<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
				<span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 从其他的p中偷取
</span><span class="c1"></span>	<span class="nx">procs</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">)</span>
	<span class="nx">ranTimer</span> <span class="o">:=</span> <span class="kc">false</span>
	<span class="c1">// 当前m现在不在自旋状态 并且
</span><span class="c1"></span>        <span class="c1">// 自旋的m数量 超过 idle的p数量的一半, 说明有很多m在找工作, 那我就停一下
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="o">&amp;&amp;</span> <span class="mi">2</span><span class="o">*</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nx">procs</span><span class="o">-</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="nx">stop</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">{</span>
                <span class="c1">// 设置为自旋状态
</span><span class="c1"></span>		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">=</span> <span class="kc">true</span>
                <span class="c1">// 原子操作, 让全局的自旋状态m到总数加一
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
        <span class="c1">// 偷的次数
</span><span class="c1"></span>	<span class="kd">const</span> <span class="nx">stealTries</span> <span class="p">=</span> <span class="mi">4</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">stealTries</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">stealTimersOrRunNextG</span> <span class="o">:=</span> <span class="nx">i</span> <span class="o">==</span> <span class="nx">stealTries</span><span class="o">-</span><span class="mi">1</span>
                <span class="c1">// 每次偷的过程 也是一个for循环
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">enum</span> <span class="o">:=</span> <span class="nx">stealOrder</span><span class="p">.</span><span class="nf">start</span><span class="p">(</span><span class="nf">fastrand</span><span class="p">());</span> <span class="p">!</span><span class="nx">enum</span><span class="p">.</span><span class="nf">done</span><span class="p">();</span> <span class="nx">enum</span><span class="p">.</span><span class="nf">next</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="nx">top</span>
			<span class="p">}</span>
                        <span class="c1">// 随机找一个p2
</span><span class="c1"></span>			<span class="nx">p2</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="nx">enum</span><span class="p">.</span><span class="nf">position</span><span class="p">()]</span>
                        <span class="c1">// 不能是自己
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">_p_</span> <span class="o">==</span> <span class="nx">p2</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">stealTimersOrRunNextG</span> <span class="o">&amp;&amp;</span> <span class="nx">timerpMask</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="nx">enum</span><span class="p">.</span><span class="nf">position</span><span class="p">())</span> <span class="p">{</span>
				<span class="nx">tnow</span><span class="p">,</span> <span class="nx">w</span><span class="p">,</span> <span class="nx">ran</span> <span class="o">:=</span> <span class="nf">checkTimers</span><span class="p">(</span><span class="nx">p2</span><span class="p">,</span> <span class="nx">now</span><span class="p">)</span>
				<span class="nx">now</span> <span class="p">=</span> <span class="nx">tnow</span>
				<span class="k">if</span> <span class="nx">w</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">pollUntil</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">w</span> <span class="p">&lt;</span> <span class="nx">pollUntil</span><span class="p">)</span> <span class="p">{</span>
					<span class="nx">pollUntil</span> <span class="p">=</span> <span class="nx">w</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">ran</span> <span class="p">{</span>
					<span class="k">if</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="o">:=</span> <span class="nf">runqget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">);</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
						<span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span>
					<span class="p">}</span>
					<span class="nx">ranTimer</span> <span class="p">=</span> <span class="kc">true</span>
				<span class="p">}</span>
			<span class="p">}</span>
                        <span class="c1">// p如果是idle就不用浪费时间去偷了
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">!</span><span class="nx">idlepMask</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="nx">enum</span><span class="p">.</span><span class="nf">position</span><span class="p">())</span> <span class="p">{</span>
                                <span class="c1">// 真正的偷, 详细见后面
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">runqsteal</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">p2</span><span class="p">,</span> <span class="nx">stealTimersOrRunNextG</span><span class="p">);</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">ranTimer</span> <span class="p">{</span>
		<span class="c1">// Running a timer may have made some goroutine ready.
</span><span class="c1"></span>		<span class="k">goto</span> <span class="nx">top</span>
	<span class="p">}</span>

<span class="c1">// 几种情况会走到stop
</span><span class="c1">// 1. 如果很多的m都在偷取
</span><span class="c1">// 2. 本地g空, 全局也是空, 偷也没偷到...
</span><span class="c1"></span><span class="nx">stop</span><span class="p">:</span>
        <span class="o">...</span>

	<span class="nx">delta</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">pollUntil</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// checkTimers ensures that polluntil &gt; now.
</span><span class="c1"></span>		<span class="nx">delta</span> <span class="p">=</span> <span class="nx">pollUntil</span> <span class="o">-</span> <span class="nx">now</span>
	<span class="p">}</span>
        <span class="c1">// 返回一个nil g
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">,</span> <span class="nx">otherReady</span> <span class="o">:=</span> <span class="nf">beforeIdle</span><span class="p">(</span><span class="nx">delta</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="c1">// 修改为可运行
</span><span class="c1"></span>		<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
			<span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">otherReady</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="nx">top</span>
	<span class="p">}</span>
        <span class="c1">// 快照
</span><span class="c1"></span>	<span class="nx">allpSnapshot</span> <span class="o">:=</span> <span class="nx">allp</span>
	<span class="nx">idlepMaskSnapshot</span> <span class="o">:=</span> <span class="nx">idlepMask</span>
	<span class="nx">timerpMaskSnapshot</span> <span class="o">:=</span> <span class="nx">timerpMask</span>

	<span class="c1">// return P and block
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runSafePointFn</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">goto</span> <span class="nx">top</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">globrunqget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
	<span class="p">}</span>
        <span class="c1">// 解除绑定,g与p,m与p, 并且设置p为idle, 详细见后面
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">releasep</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">_p_</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;findrunnable: wrong p&#34;</span><span class="p">)</span>
	<span class="p">}</span>
        <span class="c1">// 放入空闲列表, 详细见后面
</span><span class="c1"></span>	<span class="nf">pidleput</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="c1">// m的自旋状态
</span><span class="c1"></span>	<span class="nx">wasSpinning</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">{</span>
                <span class="c1">// 改为 非自旋
</span><span class="c1"></span>		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">=</span> <span class="kc">false</span>
		<span class="k">if</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;findrunnable: negative nmspinning&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 再一次检查所有的p队列
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">_p_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allpSnapshot</span> <span class="p">{</span>
                <span class="c1">// 任何一个p队列不为空的话
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">idlepMaskSnapshot</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="nb">uint32</span><span class="p">(</span><span class="nx">id</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nf">runqempty</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="p">{</span>
			<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
                        <span class="c1">// 就从全局取一个p
</span><span class="c1"></span>			<span class="nx">_p_</span> <span class="p">=</span> <span class="nf">pidleget</span><span class="p">()</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">_p_</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                                <span class="c1">// p和m,g绑定起来
</span><span class="c1"></span>				<span class="nf">acquirep</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
				<span class="k">if</span> <span class="nx">wasSpinning</span> <span class="p">{</span>
					<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">=</span> <span class="kc">true</span>
					<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
				<span class="p">}</span>
                                <span class="c1">// 继续
</span><span class="c1"></span>				<span class="k">goto</span> <span class="nx">top</span>
			<span class="p">}</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>
        <span class="o">...</span>
        <span class="c1">// 实在没办法了, stop m , 详细见后面
</span><span class="c1"></span>	<span class="nf">stopm</span><span class="p">()</span>
	<span class="k">goto</span> <span class="nx">top</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>randomEnum</li>
</ul>
<pre><code>// 以上的这个for循环
for enum := stealOrder.start(fastrand()); !enum.done(); enum.next() {
}

type randomEnum struct {
	i     uint32
	count uint32
	pos   uint32
	inc   uint32
}
type randomOrder struct {
	count    uint32
	coprimes []uint32
}
// start函数
func (ord *randomOrder) start(i uint32) randomEnum {
	return randomEnum{
		count: ord.count,
		pos:   i % ord.count,         // pos是i对count的取余
		inc:   ord.coprimes[i%uint32(len(ord.coprimes))],
	}
}
func (enum *randomEnum) done() bool {
	return enum.i == enum.count
}
func (enum *randomEnum) next() {
     enum.i++
     enum.pos = (enum.pos + enum.inc) % enum.count
}
</code></pre><ul>
<li>runqsteal</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">runqsteal</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">p2</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">stealRunNextG</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
        <span class="c1">// 偷取者的队列尾, 执行到这里_p_队列有可能还是空, 但也有可能不是空了
</span><span class="c1"></span>	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span>
        <span class="c1">// 这里第一个参数是被偷者, 第二个是偷取者的队列地址, 第三个是偷取者的队尾, 第四个是否偷取下一个
</span><span class="c1"></span>	<span class="nx">n</span> <span class="o">:=</span> <span class="nf">runqgrab</span><span class="p">(</span><span class="nx">p2</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">,</span> <span class="nx">t</span><span class="p">,</span> <span class="nx">stealRunNextG</span><span class="p">)</span>
        <span class="c1">// runqgrab 返回0 , 说明p2队列是空的
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nx">n</span><span class="o">--</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">[(</span><span class="nx">t</span><span class="o">+</span><span class="nx">n</span><span class="p">)</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))].</span><span class="nf">ptr</span><span class="p">()</span>
        <span class="c1">// runqgrab 返回1
</span><span class="c1"></span>        <span class="c1">// 1. 可能是p2队列是空的, 但是next不空, 所以取到了一个
</span><span class="c1"></span>        <span class="c1">// 2. 可能是只一半刚好就是1
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">gp</span>
	<span class="p">}</span>
        <span class="c1">// 得到_p_.runqhead的值
</span><span class="c1"></span>	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadAcq</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">)</span> <span class="c1">// load-acquire, synchronize with consumers
</span><span class="c1"></span>        <span class="c1">// 不能偷的自己都放不下了
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">t</span><span class="o">-</span><span class="nx">h</span><span class="o">+</span><span class="nx">n</span> <span class="o">&gt;=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runqsteal: runq overflow&#34;</span><span class="p">)</span>
	<span class="p">}</span>
        <span class="c1">// 偷来了这么多, 更新一下自己的队列尾
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreRel</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span><span class="p">,</span> <span class="nx">t</span><span class="o">+</span><span class="nx">n</span><span class="p">)</span> <span class="c1">// store-release, makes the item available for consumption
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">gp</span>
<span class="p">}</span>

<span class="c1">// batch是一个ringbuffer, 你p本地队列肯定是不会超过256, batchHead就是偷取者的tail
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">runqgrab</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">batch</span> <span class="o">*</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="nx">guintptr</span><span class="p">,</span> <span class="nx">batchHead</span> <span class="kt">uint32</span><span class="p">,</span> <span class="nx">stealRunNextG</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">uint32</span> <span class="p">{</span>
        <span class="c1">// 这里的_p_ 是被偷者
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
                <span class="c1">// 被偷者p2的本地队列头
</span><span class="c1"></span>		<span class="nx">h</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadAcq</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">)</span> <span class="c1">// load-acquire, synchronize with other consumers
</span><span class="c1"></span>                <span class="c1">// 被偷者p2的本地队列尾
</span><span class="c1"></span>		<span class="nx">t</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadAcq</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span><span class="p">)</span> <span class="c1">// load-acquire, synchronize with the producer
</span><span class="c1"></span>		<span class="nx">n</span> <span class="o">:=</span> <span class="nx">t</span> <span class="o">-</span> <span class="nx">h</span>
		<span class="nx">n</span> <span class="p">=</span> <span class="nx">n</span> <span class="o">-</span> <span class="nx">n</span><span class="o">/</span><span class="mi">2</span>
                <span class="c1">// 被偷者也是个空的?
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                        <span class="c1">// 偷不偷下一个
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">stealRunNextG</span> <span class="p">{</span>
				<span class="c1">// 偷
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">next</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span><span class="p">;</span> <span class="nx">next</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
					<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span> <span class="o">==</span> <span class="nx">_Prunning</span> <span class="p">{</span>
                                                <span class="c1">// next的g如果正在执行的话, 那就给他们一点时间
</span><span class="c1"></span>						<span class="k">if</span> <span class="nx">GOOS</span> <span class="o">!=</span> <span class="s">&#34;windows&#34;</span> <span class="p">{</span>
                                                        <span class="c1">// 非windows, 给3us, channel 一次同步的的接收发送需要 50ns 左右
</span><span class="c1"></span>							<span class="nf">usleep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
						<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                                                        <span class="c1">// windows的给1us
</span><span class="c1"></span>							<span class="nf">osyield</span><span class="p">()</span>
						<span class="p">}</span>
					<span class="p">}</span>
					<span class="k">if</span> <span class="p">!</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span><span class="p">.</span><span class="nf">cas</span><span class="p">(</span><span class="nx">next</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
						<span class="k">continue</span>
					<span class="p">}</span>
                                        <span class="c1">// 把偷取者的队列的队尾 设置为p2的下一个
</span><span class="c1"></span>					<span class="nx">batch</span><span class="p">[</span><span class="nx">batchHead</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">batch</span><span class="p">))]</span> <span class="p">=</span> <span class="nx">next</span>
                                        <span class="c1">// 偷到了一个
</span><span class="c1"></span>					<span class="k">return</span> <span class="mi">1</span>
				<span class="p">}</span>
			<span class="p">}</span>
                        <span class="c1">// 返回0 , 说明啥也没偷到
</span><span class="c1"></span>			<span class="k">return</span> <span class="mi">0</span>
		<span class="p">}</span>
                <span class="c1">// 偷的数量不能超过 被偷者队列的一半, 毕竟是别人的东西不能太过分
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// read inconsistent h and t
</span><span class="c1"></span>			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
                        <span class="c1">// 从被偷者的队列中取出g
</span><span class="c1"></span>			<span class="nx">g</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">[(</span><span class="nx">h</span><span class="o">+</span><span class="nx">i</span><span class="p">)</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))]</span>
                        <span class="c1">// 设置到偷取者的队列中
</span><span class="c1"></span>			<span class="nx">batch</span><span class="p">[(</span><span class="nx">batchHead</span><span class="o">+</span><span class="nx">i</span><span class="p">)</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">batch</span><span class="p">))]</span> <span class="p">=</span> <span class="nx">g</span>
		<span class="p">}</span>
                <span class="c1">// 偷走了一半, 要更新一个被偷者的队列头指针
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CasRel</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">h</span><span class="o">+</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// cas-release, commits consume
</span><span class="c1"></span>                        <span class="c1">// 偷到了n个
</span><span class="c1"></span>			<span class="k">return</span> <span class="nx">n</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>releasep</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">releasep</span><span class="p">()</span> <span class="o">*</span><span class="nx">p</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;releasep: invalid arg&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">_p_</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span> <span class="o">||</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span> <span class="o">!=</span> <span class="nx">_Prunning</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;releasep: m=&#34;</span><span class="p">,</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">,</span> <span class="s">&#34; m-&gt;p=&#34;</span><span class="p">,</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="s">&#34; p-&gt;m=&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">),</span> <span class="s">&#34; p-&gt;status=&#34;</span><span class="p">,</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;releasep: invalid p state&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceProcStop</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
	<span class="p">}</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pidle</span>
	<span class="k">return</span> <span class="nx">_p_</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>pidleget</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">pidleget</span><span class="p">()</span> <span class="o">*</span><span class="nx">p</span> <span class="p">{</span>
	<span class="nf">assertLockHeld</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">_p_</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">pidle</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">_p_</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// Timer may get added at any time now.
</span><span class="c1"></span>		<span class="nx">timerpMask</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span>
		<span class="nx">idlepMask</span><span class="p">.</span><span class="nf">clear</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span>
                <span class="c1">// 全局的idle p链表改成 当前p的link, 也就是上一个
</span><span class="c1"></span>		<span class="nx">sched</span><span class="p">.</span><span class="nx">pidle</span> <span class="p">=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">link</span>
                <span class="c1">// 全局的idle p链表减一
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// TODO: fast atomic
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">_p_</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>stopm</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">stopm</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;stopm holding locks&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;stopm holding p&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;stopm spinning&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="c1">// m放到全局空闲队列
</span><span class="c1"></span>	<span class="nf">mput</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">)</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="c1">// 休眠
</span><span class="c1"></span>	<span class="nf">mPark</span><span class="p">()</span>
	<span class="nf">acquirep</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">nextp</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">nextp</span> <span class="p">=</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">mput</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">assertLockHeld</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">schedlink</span> <span class="p">=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">midle</span>
	<span class="nx">sched</span><span class="p">.</span><span class="nx">midle</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
	<span class="nx">sched</span><span class="p">.</span><span class="nx">nmidle</span><span class="o">++</span>
	<span class="nf">checkdead</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">mPark</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">g</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nf">notesleep</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">g</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">park</span><span class="p">)</span>
		<span class="nf">noteclear</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">g</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">park</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">!</span><span class="nf">mDoFixup</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>notesleep</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">notesleep</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">note</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;notesleep not on g0&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">semacreate</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Casuintptr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">n</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">)))</span> <span class="p">{</span>
		<span class="c1">// Must be locked (got wakeup).
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">key</span> <span class="o">!=</span> <span class="nx">locked</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;notesleep - waitm out of sync&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// Queued. Sleep.
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">blocked</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="k">if</span> <span class="o">*</span><span class="nx">cgo_yield</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="c1">// 休眠, mac和linux版本会不一样
</span><span class="c1"></span>                <span class="c1">// linux是futexsleep()
</span><span class="c1"></span>		<span class="nf">semasleep</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// Sleep for an arbitrary-but-moderate interval to poll libc interceptors.
</span><span class="c1"></span>		<span class="kd">const</span> <span class="nx">ns</span> <span class="p">=</span> <span class="mf">10e6</span>
		<span class="k">for</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Loaduintptr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">n</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">semasleep</span><span class="p">(</span><span class="nx">ns</span><span class="p">)</span>
			<span class="nf">asmcgocall</span><span class="p">(</span><span class="o">*</span><span class="nx">cgo_yield</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">blocked</span> <span class="p">=</span> <span class="kc">false</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>semasleep mac</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/os_darwin.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">semasleep</span><span class="p">(</span><span class="nx">ns</span> <span class="kt">int64</span><span class="p">)</span> <span class="kt">int32</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">start</span> <span class="kt">int64</span>
	<span class="k">if</span> <span class="nx">ns</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">start</span> <span class="p">=</span> <span class="nf">nanotime</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span>
	<span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">mutex</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">count</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">mp</span><span class="p">.</span><span class="nx">count</span><span class="o">--</span>
			<span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">mutex</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">ns</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">spent</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span> <span class="o">-</span> <span class="nx">start</span>
			<span class="k">if</span> <span class="nx">spent</span> <span class="o">&gt;=</span> <span class="nx">ns</span> <span class="p">{</span>
				<span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">mutex</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
			<span class="p">}</span>
			<span class="kd">var</span> <span class="nx">t</span> <span class="nx">timespec</span>
			<span class="nx">t</span><span class="p">.</span><span class="nf">setNsec</span><span class="p">(</span><span class="nx">ns</span> <span class="o">-</span> <span class="nx">spent</span><span class="p">)</span>
			<span class="nx">err</span> <span class="o">:=</span> <span class="nf">pthread_cond_timedwait_relative_np</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">mutex</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">t</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">_ETIMEDOUT</span> <span class="p">{</span>
				<span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">mutex</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nf">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">mutex</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>futexsleep linux</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/os_linux.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">futexsleep</span><span class="p">(</span><span class="nx">addr</span> <span class="o">*</span><span class="kt">uint32</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">uint32</span><span class="p">,</span> <span class="nx">ns</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">ns</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">futex</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">addr</span><span class="p">),</span> <span class="nx">_FUTEX_WAIT_PRIVATE</span><span class="p">,</span> <span class="nx">val</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">ts</span> <span class="nx">timespec</span>
	<span class="nx">ts</span><span class="p">.</span><span class="nf">setNsec</span><span class="p">(</span><span class="nx">ns</span><span class="p">)</span>
	<span class="nf">futex</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">addr</span><span class="p">),</span> <span class="nx">_FUTEX_WAIT_PRIVATE</span><span class="p">,</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ts</span><span class="p">),</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>execute 执行goroutine</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">execute</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 这个还是g0
</span><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
        <span class="c1">// 修改当前的g为gp
</span><span class="c1"></span>	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span> <span class="p">=</span> <span class="nx">gp</span>
        <span class="c1">// 把gp.m 设置为g0.m
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span>
        <span class="c1">// 设置gp为running
</span><span class="c1"></span>	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">waitsince</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="c1">// 抢占标识
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">=</span> <span class="kc">false</span>
        <span class="c1">// gp的堆
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
        <span class="c1">// inheritTime = false,说明是新的时间片
</span><span class="c1"></span>        <span class="c1">// 当为true的时候, 是说明gp是抢过来的nextG
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">inheritTime</span> <span class="p">{</span>
                <span class="c1">// 调度次数, 前面每61次调度 就会从全局取一次 用到了
</span><span class="c1"></span>		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">schedtick</span><span class="o">++</span>
	<span class="p">}</span>

	<span class="c1">// Check whether the profiler needs to be turned on or off.
</span><span class="c1"></span>	<span class="nx">hz</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">profilehz</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">profilehz</span> <span class="o">!=</span> <span class="nx">hz</span> <span class="p">{</span>
		<span class="nf">setThreadCPUProfiler</span><span class="p">(</span><span class="nx">hz</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="c1">// GoSysExit has to happen when we have a P, but before GoStart.
</span><span class="c1"></span>		<span class="c1">// So we emit it here.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">syscallsp</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">sysblocktraced</span> <span class="p">{</span>
			<span class="nf">traceGoSysExit</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sysexitticks</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nf">traceGoStart</span><span class="p">()</span>
	<span class="p">}</span>
        <span class="c1">// gogo才是从g0的栈空间切换到gp的堆的实现, 这里是plan9汇编代码调用寄存器实现的 , 详细见后面
</span><span class="c1"></span>	<span class="nf">gogo</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>gogo</li>
</ul>
<pre><code class="language-assembly" data-lang="assembly">TEXT runtime·gogo(SB), NOSPLIT, $16-8
        // BX = &amp;gp.sched
	MOVQ	buf+0(FP), BX
        // DX = gp.sched.g
	MOVQ	gobuf_g(BX), DX
        // 将 g 放入到 tls[0]
        // 把要运行的 g 的指针放入线程本地存储
        // 等到runtime·systemstack中, 我们就能通过tls获取到g 结构体对象，从而找到与之关联的 m 和 p
        // 运行这条指令之前，线程本地存储存放的是 g0 的地址
        // DX偏移0的地址, CX = gp.sched.g
	MOVQ	0(DX), CX		// make sure g != nil
        // 获取fs段基地址放入CX,其实就是m0.tls[1]的地址,CX的地址=m0.tls[1],
        // 就是为了找到fs段基地址, 这样偏移-8就能找到m0.tls[0]
	get_tls(CX)
        // 再将DX(gp.sched.g) 写入到CX偏移-8的位置, 也就是m0.tls[0]
	MOVQ	DX, g(CX)
        // 对gobuf的sp,ret,ctxt,bp字段保存到寄存器
	MOVQ	gobuf_sp(BX), SP
	MOVQ	gobuf_ret(BX), AX
	MOVQ	gobuf_ctxt(BX), DX
	MOVQ	gobuf_bp(BX), BP
        // 清理,上面已经保存了, 帮助gc
	MOVQ	$0, gobuf_sp(BX)
	MOVQ	$0, gobuf_ret(BX)
	MOVQ	$0, gobuf_ctxt(BX)
	MOVQ	$0, gobuf_bp(BX)
        // &amp;gp.sched的pc存入BX
	MOVQ	gobuf_pc(BX), BX
        // 跳到到BX地址开始执行
	JMP	BX

</code></pre><p>现在调度的流程如下图, 来自<img src="https://qcrao.com/ishare/go-scheduler" alt="https://qcrao.com">的图:</p>
<p><img src="/images/golang/gmp-3.png" alt=""></p>
<h3 id="终于到main了">终于到main()了</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/proc.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// gp了, 这个不是g0了,因为通过gogo已经切换了
</span><span class="c1"></span>	<span class="nx">g</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="c1">// Racectx of m0-&gt;g0 is used only as the parent of the main goroutine.
</span><span class="c1"></span>	<span class="c1">// It must not be used for anything else.
</span><span class="c1"></span>	<span class="nx">g</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span><span class="p">.</span><span class="nx">racectx</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="c1">// maxstacksize 设置
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="o">==</span> <span class="mi">8</span> <span class="p">{</span>
		<span class="nx">maxstacksize</span> <span class="p">=</span> <span class="mi">1000000000</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">maxstacksize</span> <span class="p">=</span> <span class="mi">250000000</span>
	<span class="p">}</span>

	<span class="nx">maxstackceiling</span> <span class="p">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">maxstacksize</span>

	<span class="c1">// Allow newproc to start new Ms.
</span><span class="c1"></span>	<span class="nx">mainStarted</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="k">if</span> <span class="nx">GOARCH</span> <span class="o">!=</span> <span class="s">&#34;wasm&#34;</span> <span class="p">{</span> <span class="c1">// no threads on wasm yet, so no sysmon
</span><span class="c1"></span>		<span class="c1">// For runtime_syscall_doAllThreadsSyscall, we
</span><span class="c1"></span>		<span class="c1">// register sysmon is not ready for the world to be
</span><span class="c1"></span>		<span class="c1">// stopped.
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonStarting</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="c1">// 通过g0来新建m
</span><span class="c1"></span>		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
                        <span class="c1">// sysmon监控线程 详细见后面
</span><span class="c1"></span>			<span class="nf">newm</span><span class="p">(</span><span class="nx">sysmon</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="p">})</span>
	<span class="p">}</span>


	<span class="nf">lockOSThread</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">g</span><span class="p">.</span><span class="nx">m</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="nx">m0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime.main not on m0&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">m0</span><span class="p">.</span><span class="nx">doesPark</span> <span class="p">=</span> <span class="kc">true</span>

	<span class="nx">runtimeInitTime</span> <span class="p">=</span> <span class="nf">nanotime</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">runtimeInitTime</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;nanotime returning zero&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">inittrace</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">inittrace</span><span class="p">.</span><span class="nx">id</span> <span class="p">=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">goid</span>
		<span class="nx">inittrace</span><span class="p">.</span><span class="nx">active</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>
        <span class="c1">// runtime包初始化, 详细见后面
</span><span class="c1"></span>	<span class="nf">doInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">runtime_inittask</span><span class="p">)</span> <span class="c1">// Must be before defer.
</span><span class="c1"></span>
	<span class="c1">// Defer unlock so that runtime.Goexit during init does the unlock too.
</span><span class="c1"></span>	<span class="nx">needUnlock</span> <span class="o">:=</span> <span class="kc">true</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">needUnlock</span> <span class="p">{</span>
			<span class="nf">unlockOSThread</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}()</span>
        <span class="c1">// 开启gc
</span><span class="c1"></span>	<span class="nf">gcenable</span><span class="p">()</span>

	<span class="nx">main_init_done</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">iscgo</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">_cgo_thread_start</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;_cgo_thread_start missing&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">GOOS</span> <span class="o">!=</span> <span class="s">&#34;windows&#34;</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">_cgo_setenv</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;_cgo_setenv missing&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">_cgo_unsetenv</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;_cgo_unsetenv missing&#34;</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">_cgo_notify_runtime_init_done</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;_cgo_notify_runtime_init_done missing&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// Start the template thread in case we enter Go from
</span><span class="c1"></span>		<span class="c1">// a C-created thread and need to create a new thread.
</span><span class="c1"></span>		<span class="nf">startTemplateThread</span><span class="p">()</span>
		<span class="nf">cgocall</span><span class="p">(</span><span class="nx">_cgo_notify_runtime_init_done</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="p">}</span>
        <span class="c1">// main包初始化,递归
</span><span class="c1"></span>	<span class="nf">doInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">main_inittask</span><span class="p">)</span>

	<span class="c1">// Disable init tracing after main init done to avoid overhead
</span><span class="c1"></span>	<span class="c1">// of collecting statistics in malloc and newproc
</span><span class="c1"></span>	<span class="nx">inittrace</span><span class="p">.</span><span class="nx">active</span> <span class="p">=</span> <span class="kc">false</span>

	<span class="nb">close</span><span class="p">(</span><span class="nx">main_init_done</span><span class="p">)</span>

	<span class="nx">needUnlock</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="nf">unlockOSThread</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">isarchive</span> <span class="o">||</span> <span class="nx">islibrary</span> <span class="p">{</span>
		<span class="c1">// A program compiled with -buildmode=c-archive or c-shared
</span><span class="c1"></span>		<span class="c1">// has a main, but it is not executed.
</span><span class="c1"></span>		<span class="k">return</span>
	<span class="p">}</span>
        <span class="c1">// go:linkname main_main main.main
</span><span class="c1"></span>        <span class="c1">// func main_main()
</span><span class="c1"></span>	<span class="nx">fn</span> <span class="o">:=</span> <span class="nx">main_main</span> <span class="c1">// make an indirect call, as the linker doesn&#39;t know the address of the main package when laying down the runtime
</span><span class="c1"></span>        <span class="c1">// 执行main.main, 就是我们写的代码了
</span><span class="c1"></span>        <span class="nf">fn</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nf">racefini</span><span class="p">()</span>
	<span class="p">}</span>
        <span class="c1">// 函数执行完之后
</span><span class="c1"></span>        <span class="c1">// 如果有defer
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">runningPanicDefers</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Running deferred functions should not take long.
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">c</span> <span class="p">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="nx">c</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">runningPanicDefers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
                        <span class="c1">// 继续调度
</span><span class="c1"></span>			<span class="nf">Gosched</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">panicking</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">gopark</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">waitReasonPanicWait</span><span class="p">,</span> <span class="nx">traceEvGoStop</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
        <span class="c1">// main的话直接退出
</span><span class="c1"></span>	<span class="nf">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1">// 这里肯定是执行不到的
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
                <span class="c1">// 如果执行到这里, 也会报nil错误
</span><span class="c1"></span>		<span class="kd">var</span> <span class="nx">x</span> <span class="o">*</span><span class="kt">int32</span>
		<span class="o">*</span><span class="nx">x</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>doInit</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">doInit</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">initTask</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="nx">t</span><span class="p">.</span><span class="nx">state</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">2</span><span class="p">:</span> <span class="c1">// fully initialized
</span><span class="c1"></span>		<span class="k">return</span>
	<span class="k">case</span> <span class="mi">1</span><span class="p">:</span> <span class="c1">// initialization in progress
</span><span class="c1"></span>		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;recursive call during initialization - linker skew&#34;</span><span class="p">)</span>
	<span class="k">default</span><span class="p">:</span> <span class="c1">// not initialized yet
</span><span class="c1"></span>		<span class="nx">t</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// initialization in progress
</span><span class="c1"></span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">t</span><span class="p">.</span><span class="nx">ndeps</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">p</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">t</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="nx">i</span><span class="p">)</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span>
			<span class="nx">t2</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="nx">initTask</span><span class="p">)(</span><span class="nx">p</span><span class="p">)</span>
			<span class="nf">doInit</span><span class="p">(</span><span class="nx">t2</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">nfns</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">t</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="mi">2</span> <span class="c1">// initialization done
</span><span class="c1"></span>			<span class="k">return</span>
		<span class="p">}</span>

		<span class="kd">var</span> <span class="p">(</span>
			<span class="nx">start</span>  <span class="kt">int64</span>
			<span class="nx">before</span> <span class="nx">tracestat</span>
		<span class="p">)</span>

		<span class="k">if</span> <span class="nx">inittrace</span><span class="p">.</span><span class="nx">active</span> <span class="p">{</span>
			<span class="nx">start</span> <span class="p">=</span> <span class="nf">nanotime</span><span class="p">()</span>
			<span class="c1">// Load stats non-atomically since tracinit is updated only by this init go routine.
</span><span class="c1"></span>			<span class="nx">before</span> <span class="p">=</span> <span class="nx">inittrace</span>
		<span class="p">}</span>

		<span class="nx">firstFunc</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">t</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="nx">t</span><span class="p">.</span><span class="nx">ndeps</span><span class="p">)</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">t</span><span class="p">.</span><span class="nx">nfns</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">p</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">firstFunc</span><span class="p">,</span> <span class="nx">i</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span>
			<span class="nx">f</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kd">func</span><span class="p">())(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">))</span>
			<span class="nf">f</span><span class="p">()</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">inittrace</span><span class="p">.</span><span class="nx">active</span> <span class="p">{</span>
			<span class="nx">end</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>
			<span class="c1">// Load stats non-atomically since tracinit is updated only by this init go routine.
</span><span class="c1"></span>			<span class="nx">after</span> <span class="o">:=</span> <span class="nx">inittrace</span>

			<span class="nx">pkg</span> <span class="o">:=</span> <span class="nf">funcpkgpath</span><span class="p">(</span><span class="nf">findfunc</span><span class="p">(</span><span class="nf">funcPC</span><span class="p">(</span><span class="nx">firstFunc</span><span class="p">)))</span>

			<span class="kd">var</span> <span class="nx">sbuf</span> <span class="p">[</span><span class="mi">24</span><span class="p">]</span><span class="kt">byte</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;init &#34;</span><span class="p">,</span> <span class="nx">pkg</span><span class="p">,</span> <span class="s">&#34; @&#34;</span><span class="p">)</span>
			<span class="nb">print</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nf">fmtNSAsMS</span><span class="p">(</span><span class="nx">sbuf</span><span class="p">[:],</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">start</span><span class="o">-</span><span class="nx">runtimeInitTime</span><span class="p">))),</span> <span class="s">&#34; ms, &#34;</span><span class="p">)</span>
			<span class="nb">print</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nf">fmtNSAsMS</span><span class="p">(</span><span class="nx">sbuf</span><span class="p">[:],</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">end</span><span class="o">-</span><span class="nx">start</span><span class="p">))),</span> <span class="s">&#34; ms clock, &#34;</span><span class="p">)</span>
			<span class="nb">print</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nf">itoa</span><span class="p">(</span><span class="nx">sbuf</span><span class="p">[:],</span> <span class="nx">after</span><span class="p">.</span><span class="nx">bytes</span><span class="o">-</span><span class="nx">before</span><span class="p">.</span><span class="nx">bytes</span><span class="p">)),</span> <span class="s">&#34; bytes, &#34;</span><span class="p">)</span>
			<span class="nb">print</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nf">itoa</span><span class="p">(</span><span class="nx">sbuf</span><span class="p">[:],</span> <span class="nx">after</span><span class="p">.</span><span class="nx">allocs</span><span class="o">-</span><span class="nx">before</span><span class="p">.</span><span class="nx">allocs</span><span class="p">)),</span> <span class="s">&#34; allocs&#34;</span><span class="p">)</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="nx">t</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="mi">2</span> <span class="c1">// initialization done
</span><span class="c1"></span>	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><blockquote>
<p>看到这里, 我们发现main.main执行完之后就 exit(0)退出了, 我们想起来之前设置了goexit() 来假装作为goroutine的调用者, 希望调用完返回后来执行goexit() 继续处理</p>
<p>显然这里并不是这样, main goroutine函数是应该执行完的退出, 在gogo函数中我们看到的确是JMP BX跳过去执行的, 并非CALL
如果是其他的goroutine会调用goexit() , 也就是执行 newg.sched.pc = funcPC(goexit) + sys.PCQuantum</p>
</blockquote>
<ul>
<li>runtime.goexit</li>
</ul>
<pre><code class="language-assembly" data-lang="assembly">// src/runtime/asm_amd64.s
TEXT runtime·goexit&lt;ABIInternal&gt;(SB),NOSPLIT,$0-0
	BYTE	$0x90	// NOP
	CALL	runtime·goexit1(SB)	// does not return
	// traceback from goexit1 must hit code range of goexit
	BYTE	$0x90	// NOP
</code></pre><ul>
<li>goexit1</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">goexit1</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nf">racegoend</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGoEnd</span><span class="p">()</span>
	<span class="p">}</span>
        <span class="c1">// 切换到g0然后执行goexit0 函数
</span><span class="c1"></span>	<span class="nf">mcall</span><span class="p">(</span><span class="nx">goexit0</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>mcall</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// runtime/asm_amd64.s
</span><span class="c1">// 切换到m-&gt;g0的栈上,调用fn(g)函数
</span><span class="c1"></span><span class="nx">TEXT</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">mcall</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">NOSPLIT</span><span class="p">,</span> <span class="err">$</span><span class="mi">0</span><span class="o">-</span><span class="mi">8</span>
	<span class="nx">MOVQ</span>	<span class="nx">fn</span><span class="o">+</span><span class="mi">0</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">DI</span>  <span class="c1">//FP是当前栈帧起始地址, fn(goexit0)函数指针存到DI寄存器
</span><span class="c1"></span>	<span class="nf">get_tls</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>    <span class="c1">//tls 是线程局部存储，将这个存储的开始位置存到 CX
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">),</span> <span class="nx">AX</span>	<span class="c1">// g(CX)还是宏，在tls上可以拿到g，也就是当前正在跑的g，把这个g的地址存到AX寄存器
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="mi">0</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">BX</span>	<span class="c1">// caller&#39;s PC
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nx">BX</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_pc</span><span class="p">)(</span><span class="nx">AX</span><span class="p">)</span>    <span class="c1">//把BX(caller&#39;s PC)存入到AX的g-&gt;sched的gobuf-&gt;pc字段
</span><span class="c1"></span>	<span class="nx">LEAQ</span>	<span class="nx">fn</span><span class="o">+</span><span class="mi">0</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">BX</span>	<span class="c1">// caller&#39;s SP, fn函数
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nx">BX</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_sp</span><span class="p">)(</span><span class="nx">AX</span><span class="p">)</span>    <span class="c1">//把BX(caller&#39;s SP)存入到AX的g-&gt;sched的gobuf-&gt;sp字段
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nx">AX</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_g</span><span class="p">)(</span><span class="nx">AX</span><span class="p">)</span>     <span class="c1">//把g本身也存起来
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nx">BP</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_bp</span><span class="p">)(</span><span class="nx">AX</span><span class="p">)</span>    <span class="c1">//把BP(当前栈底)存入到AX的g-&gt;sched的gobuf-&gt;bp字段
</span><span class="c1"></span>
	<span class="c1">// switch to m-&gt;g0 &amp; its stack, call fn
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">),</span> <span class="nx">BX</span>     <span class="c1">//把g存入BX
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nf">g_m</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">BX</span>   <span class="c1">//根据g得到m存入BX
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nf">m_g0</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">SI</span>  <span class="c1">//根据m得到g0存入SI
</span><span class="c1"></span>	<span class="nx">CMPQ</span>	<span class="nx">SI</span><span class="p">,</span> <span class="nx">AX</span>	<span class="c1">// if g == m-&gt;g0 call badmcall
</span><span class="c1"></span>	<span class="nx">JNE</span>	<span class="mi">3</span><span class="p">(</span><span class="nx">PC</span><span class="p">)</span>      <span class="c1">//JNE表示不等于的时候转移, if g != m-&gt;g0 , 那就跳3行
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="err">$</span><span class="nx">runtime</span><span class="err">·</span><span class="nf">badmcall</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>         
	<span class="nx">JMP</span>	<span class="nx">AX</span>
	<span class="nx">MOVQ</span>	<span class="nx">SI</span><span class="p">,</span> <span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>	<span class="c1">// g = m-&gt;g0, 直接把SI的m-&gt;g0 复制给g, 那现在的g就是m-&gt;g0, 成功切换到g0
</span><span class="c1"></span>	<span class="nf">MOVQ</span>	<span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_sp</span><span class="p">)(</span><span class="nx">SI</span><span class="p">),</span> <span class="nx">SP</span>	<span class="c1">// sp = m-&gt;g0-&gt;sched.sp, 直接拿g0中的sp值给SP寄存器了
</span><span class="c1"></span>	<span class="nx">PUSHQ</span>	<span class="nx">AX</span>        <span class="c1">//AX就是g,将g入栈保存
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nx">DI</span><span class="p">,</span> <span class="nx">DX</span>    <span class="c1">//DI里面保存的是fn函数, 现在存入到DX
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="mi">0</span><span class="p">(</span><span class="nx">DI</span><span class="p">),</span> <span class="nx">DI</span>
	<span class="nx">CALL</span>	<span class="nx">DI</span>        <span class="c1">//调用fn
</span><span class="c1"></span>	<span class="nx">POPQ</span>	<span class="nx">AX</span>        <span class="c1">//将g出栈
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="err">$</span><span class="nx">runtime</span><span class="err">·</span><span class="nf">badmcall2</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>
	<span class="nx">JMP</span>	<span class="nx">AX</span>
	<span class="nx">RET</span>    <span class="c1">//return
</span></code></pre></div><ul>
<li>goexit0</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">goexit0</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// g0
</span><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
        <span class="c1">// gp切换到dead状态
</span><span class="c1"></span>	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gdead</span><span class="p">)</span>
	<span class="k">if</span> <span class="nf">isSystemGoroutine</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ngsys</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
        <span class="c1">// 清理数据
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">locked</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">lockedm</span> <span class="o">!=</span> <span class="mi">0</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">lockedm</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedg</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">preemptStop</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">paniconfault</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span> <span class="p">=</span> <span class="kc">nil</span> <span class="c1">// should be true already but just in case.
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span> <span class="p">=</span> <span class="kc">nil</span> <span class="c1">// non-nil for Goexit during panic. points at stack-allocated data.
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">writebuf</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">waitreason</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">labels</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">timer</span> <span class="p">=</span> <span class="kc">nil</span>

	<span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Flush assist credit to the global pool. This gives
</span><span class="c1"></span>		<span class="c1">// better information to pacing if the application is
</span><span class="c1"></span>		<span class="c1">// rapidly creating an exiting goroutines.
</span><span class="c1"></span>		<span class="nx">assistWorkPerByte</span> <span class="o">:=</span> <span class="nf">float64frombits</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">assistWorkPerByte</span><span class="p">))</span>
		<span class="nx">scanCredit</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">assistWorkPerByte</span> <span class="o">*</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span><span class="p">))</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">bgScanCredit</span><span class="p">,</span> <span class="nx">scanCredit</span><span class="p">)</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
        <span class="c1">// 解绑g和m,清理curg
</span><span class="c1"></span>	<span class="nf">dropg</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">GOARCH</span> <span class="o">==</span> <span class="s">&#34;wasm&#34;</span> <span class="p">{</span> <span class="c1">// no threads yet on wasm
</span><span class="c1"></span>		<span class="nf">gfput</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="nx">gp</span><span class="p">)</span>
		<span class="nf">schedule</span><span class="p">()</span> <span class="c1">// never returns
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedInt</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;invalid m-&gt;lockedInt = &#34;</span><span class="p">,</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedInt</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;internal lockOSThread error&#34;</span><span class="p">)</span>
	<span class="p">}</span>
        <span class="c1">// gp放到gfree list中,详细见后面
</span><span class="c1"></span>	<span class="nf">gfput</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="nx">gp</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">locked</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">GOOS</span> <span class="o">!=</span> <span class="s">&#34;plan9&#34;</span> <span class="p">{</span> <span class="c1">// See golang.org/issue/22227.
</span><span class="c1"></span>			<span class="nf">gogo</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span><span class="p">.</span><span class="nx">sched</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedExt</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">schedule</span><span class="p">()</span>
<span class="p">}</span>

</code></pre></div><ul>
<li>gfput</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gfput</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// gfree里面放的都是dead
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">_Gdead</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gfput: bad status (not Gdead)&#34;</span><span class="p">)</span>
	<span class="p">}</span>
        <span class="c1">// 堆大小
</span><span class="c1"></span>	<span class="nx">stksize</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="o">-</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span>
        <span class="c1">// _FixedStack 通常就是2048, 可能和系统相关
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">stksize</span> <span class="o">!=</span> <span class="nx">_FixedStack</span> <span class="p">{</span>
		<span class="c1">// 这种不是2k的goroutine就释放了
</span><span class="c1"></span>		<span class="nf">stackfree</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">)</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
        <span class="c1">// 否则, 2k大小的g 堆是保留的, 放入到gfree队列中
</span><span class="c1"></span>	<span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
	<span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span><span class="o">++</span>
        <span class="c1">// 如果本地p的gfree长度超过64
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span> <span class="o">&gt;=</span> <span class="mi">64</span> <span class="p">{</span>
                <span class="c1">// 那么就加锁, 塞给全局gfree
</span><span class="c1"></span>		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
                <span class="c1">// 只保留31个
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span> <span class="o">&gt;=</span> <span class="mi">32</span> <span class="p">{</span>
			<span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span><span class="o">--</span>
			<span class="nx">gp</span> <span class="p">=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">noStack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><p>实际上还有一个sysmon进程, 这个进程会后台一直执行, 通过newm直接创建, 并不需要g和p的协作</p>
<p>&hellip;</p>
<h3 id="附录">附录</h3>
<ul>
<li><a href="https://qcrao.com/ishare/go-scheduler/#true%E8%B0%83%E5%BA%A6%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%BB%BA%E7%AB%8B">qcrao分享 go调度详细源码分析</a></li>
<li><a href="http://mp.weixin.qq.com/mp/homepage?__biz=MzU1OTg5NDkzOA==&amp;hid=1&amp;sn=8fc2b63f53559bc0cee292ce629c4788&amp;scene=18#wechat_redirect">go语言调度器源代码情景分析</a></li>
<li><a href="https://eddycjy.com/posts/go/go-bootstrap0/">详解 Go 程序的启动流程，你知道 g0，m0 是什么吗？</a></li>
<li><a href="https://golang.design/under-the-hood/zh-cn/part2runtime/ch06sched/schedule/">go语言原本 调度</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/344842279">g0</a></li>
<li><a href="https://talkgo.org/t/topic/31">golang 中 goroutine 的调度</a></li>
<li>rancher_rancher_net</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Go学习 Go汇编plan9</title>
			<link>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-go%E6%B1%87%E7%BC%96plan9/</link>
			<pubDate>Fri, 12 Nov 2021 10:19:57 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-go%E6%B1%87%E7%BC%96plan9/</guid>
			<description>在此之前,什么是函数栈? 先了解下几个汇编寄存器 通用寄存器包括: 1. 数据寄存器 AX:累加寄存器 BX:基地址寄存器 CX:计数器寄存器 DX:数据寄存器 2. 指针寄存器 SP:堆栈指针, 栈顶 BP:基址指针, 栈底 IP:指令指针,(或者PC) cpu下一条要执行指令的内存地址 3. 变址寄存器 SI:源变址 DI:目的变址 golang伪寄存器: FP: Frame pointer: arguments and locals.(指向当前frame的起始位置) FP+0 使用形如 symbol+offset(FP) 的方式，引用函数的输入参数。例如 arg0+0(FP)，arg1+8(FP)，使用 FP 不加 symbol 时，无法通过编译，在汇编层面来讲，symbol 并没有什么用，加 symbol 主要是为了提升代码可读性。另外，官方文档虽然将伪寄存器 FP 称之为 frame pointer，实际上它根本不是 frame pointer，按照传统的 x86 的习惯来讲，frame pointer 是指向整个 stack frame 底部的 BP 寄存器。假如当前的 callee 函数是 add，在 add 的代码中引用 FP，该 FP 指向的位置不在 callee 的 stack frame 之内，而是在 caller 的 stack frame 上。 PC: Program counter: jumps and branches.</description>
			<content type="html"><![CDATA[<h3 id="在此之前什么是函数栈">在此之前,什么是函数栈?</h3>
<h3 id="先了解下几个汇编寄存器">先了解下几个汇编寄存器</h3>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">通用寄存器包括:
1. 数据寄存器
    AX:累加寄存器
    BX:基地址寄存器
    CX:计数器寄存器
    DX:数据寄存器
2. 指针寄存器
    SP:堆栈指针, 栈顶
    BP:基址指针, 栈底
    IP:指令指针,<span class="o">(</span>或者PC<span class="o">)</span> cpu下一条要执行指令的内存地址
3. 变址寄存器
    SI:源变址
    DI:目的变址

golang伪寄存器:
FP: Frame pointer: arguments and locals.<span class="o">(</span>指向当前frame的起始位置<span class="o">)</span> FP+0
    使用形如 symbol+offset<span class="o">(</span>FP<span class="o">)</span> 的方式，引用函数的输入参数。例如 arg0+0<span class="o">(</span>FP<span class="o">)</span>，arg1+8<span class="o">(</span>FP<span class="o">)</span>，使用 FP 不加 symbol 时，无法通过编译，在汇编层面来讲，symbol 并没有什么用，加 symbol 主要是为了提升代码可读性。另外，官方文档虽然将伪寄存器 FP 称之为 frame pointer，实际上它根本不是 frame pointer，按照传统的 x86 的习惯来讲，frame pointer 是指向整个 stack frame 底部的 BP 寄存器。假如当前的 callee 函数是 add，在 add 的代码中引用 FP，该 FP 指向的位置不在 callee 的 stack frame 之内，而是在 <span class="nb">caller</span> 的 stack frame 上。
PC: Program counter: jumps and branches.<span class="o">(</span>指向下一条要执行的指令的位置<span class="o">)</span>
    实际上就是在体系结构的知识中常见的 pc 寄存器，在 x86 平台下对应 ip 寄存器，amd64 上则是 rip。除了个别跳转之外，手写 plan9 代码与 PC 寄存器打交道的情况较少。
SB: Static base pointer: global symbols.<span class="o">(</span>指向全局变量的位置,可以看着是程序的起始地址<span class="o">)</span>
    全局静态基指针，一般用来声明函数或全局变量，在之后的函数知识和示例部分会看到具体用法
SP: Stack pointer: top of stack.<span class="o">(</span>指向当前栈顶<span class="o">)</span>
    plan9 的这个 SP 寄存器指向当前栈帧的局部变量的开始位置，使用形如 symbol+offset<span class="o">(</span>SP<span class="o">)</span> 的方式，引用函数的局部变量。offset 的合法取值是 <span class="o">[</span>-framesize, 0<span class="o">)</span>，注意是个左闭右开的区间。假如局部变量都是 <span class="m">8</span> 字节，那么第一个局部变量就可以用 localvar0-8<span class="o">(</span>SP<span class="o">)</span> 来表示。这也是一个词不表意的寄存器。与硬件寄存器 SP 是两个不同的东西，在栈帧 size 为 <span class="m">0</span> 的情况下，伪寄存器 SP 和硬件寄存器 SP 指向同一位置。手写汇编代码时，如果是 symbol+offset<span class="o">(</span>SP<span class="o">)</span> 形式，则表示伪寄存器 SP。如果是 offset<span class="o">(</span>SP<span class="o">)</span> 则表示硬件寄存器 SP。务必注意。对于编译输出<span class="o">(</span>go tool compile -S / go tool objdump<span class="o">)</span>的代码来讲，目前所有的 SP 都是硬件寄存器 SP，无论是否带 symbol。

汇编指令:
PUSH: 入栈, 将内容保存栈中,并且SP下移<span class="o">(</span>减小<span class="o">)</span>
POP: 出栈,读取栈中结果,并且SP上移<span class="o">(</span>增加<span class="o">)</span>
CALL: 函数调用,这里记录A为调用者,B为被调用者, 代码段读到call指令时,call后面跟的是B的地址,
    1. call: 入栈call下一条指令地址<span class="o">(</span>因为call执行完,你还得接着call后面的指令继续执行<span class="o">)</span>,同时SP下移<span class="o">(</span>入栈了肯定要下移<span class="o">)</span>
    2. call: IP指令指针跳转到B的地址处
    3. 执行B函数: 分配B需要的栈大小,比如24字节,直接将SP下移SP-24,分配B函数栈帧大小
    4. 执行B函数: 入栈BP寄存器中保存的A函数的栈底地址, A的栈底BP值保存在SP+16的位置,后续用于恢复
    5. 执行B函数: BP改为SP+16,这里假定16个字节是B函数的剩下的指令
RET: 函数返回
    6. 执行B函数: 首先需要恢复调用者A的BP,我们第4步入栈了,此时出栈就能得到A函数之前入栈保存的BP值
    7. 执行B函数: B函数执行完了,肯定要释放栈空间,所以SP+24
    8. RET: 继续出栈,此时就是第1步入栈的内容,
    9. RET: 跳转到出栈的地址,就是call调用后的位置
</code></pre></div><ul>
<li><a href="https://www.zhihu.com/zvideo/1308359170928799744">函数栈视频讲解</a></li>
<li><a href="https://blog.csdn.net/u011555996/article/details/80153141">x86汇编指令说明</a></li>
</ul>
<h3 id="函数栈">函数栈</h3>
<ul>
<li>栈,每个goroutine都有自己的栈, 一般顺序为 SP栈顶(低地址)-&gt;存储参数,返回值,局部变量-&gt;BP栈底(高地址)</li>
<li>栈帧,一个栈由多个栈帧组成, 每个函数对应一段栈帧,栈帧表示着函数间的调用关系</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">
                                       <span class="nb">caller</span>                                                                                 
                                 +------------------+                                                                         
                                 <span class="p">|</span>                  <span class="p">|</span>                                                                         
       +----------------------&gt;  --------------------                                                                         
       <span class="p">|</span>                         <span class="p">|</span>                  <span class="p">|</span>                                                                         
       <span class="p">|</span>                         <span class="p">|</span> <span class="nb">caller</span> parent BP <span class="p">|</span>                                                                         
       <span class="p">|</span>           BP<span class="o">(</span>pseudo SP<span class="o">)</span> --------------------                                                                         
       <span class="p">|</span>                         <span class="p">|</span>                  <span class="p">|</span>                                                                         
       <span class="p">|</span>                         <span class="p">|</span>   Local VarX     <span class="p">|</span>                                                                         
       <span class="p">|</span>                         --------------------                                                                         
       <span class="p">|</span>                         <span class="p">|</span>                  <span class="p">|</span>                                                                         
       <span class="p">|</span>                         <span class="p">|</span>   .......        <span class="p">|</span>                                                                         
       <span class="p">|</span>                         --------------------                                                                         
       <span class="p">|</span>                         <span class="p">|</span>                  <span class="p">|</span>                                                                         
       <span class="p">|</span>                         <span class="p">|</span>   Local VarN     <span class="p">|</span>                                                                         
                                 --------------------                                                                         
 <span class="nb">caller</span> stack frame              <span class="p">|</span>                  <span class="p">|</span>                                                                         
                                 <span class="p">|</span>   callee arg2    <span class="p">|</span>                                                                         
       <span class="p">|</span>                         <span class="p">|</span>------------------<span class="p">|</span>                                                                         
       <span class="p">|</span>                         <span class="p">|</span>                  <span class="p">|</span>                                                                         
       <span class="p">|</span>                         <span class="p">|</span>   callee arg1    <span class="p">|</span>                                                                         
       <span class="p">|</span>                         <span class="p">|</span>------------------<span class="p">|</span>                                                                         
       <span class="p">|</span>                         <span class="p">|</span>                  <span class="p">|</span>                                                                         
       <span class="p">|</span>                         <span class="p">|</span>   callee arg0    <span class="p">|</span>                                                                         
       <span class="p">|</span>                         ----------------------------------------------+   FP<span class="o">(</span>virtual register<span class="o">)</span>                       
       <span class="p">|</span>                         <span class="p">|</span>                  <span class="p">|</span>                          <span class="p">|</span>                                              
       <span class="p">|</span>                         <span class="p">|</span>   <span class="k">return</span> addr    <span class="p">|</span>  parent <span class="k">return</span> address   <span class="p">|</span>                                              
       +----------------------&gt;  +------------------+---------------------------    &lt;-------------------------------+         
                                                    <span class="p">|</span>  <span class="nb">caller</span> BP               <span class="p">|</span>                                    <span class="p">|</span>         
                                                    <span class="p">|</span>  <span class="o">(</span><span class="nb">caller</span> frame pointer<span class="o">)</span>  <span class="p">|</span>                                    <span class="p">|</span>         
                                     BP<span class="o">(</span>pseudo SP<span class="o">)</span>  ----------------------------                                    <span class="p">|</span>         
                                                    <span class="p">|</span>                          <span class="p">|</span>                                    <span class="p">|</span>         
                                                    <span class="p">|</span>     Local Var0           <span class="p">|</span>                                    <span class="p">|</span>         
                                                    ----------------------------                                    <span class="p">|</span>         
                                                    <span class="p">|</span>                          <span class="p">|</span>                                              
                                                    <span class="p">|</span>     Local Var1           <span class="p">|</span>                                              
                                                    ----------------------------                            callee stack frame
                                                    <span class="p">|</span>                          <span class="p">|</span>                                              
                                                    <span class="p">|</span>       .....              <span class="p">|</span>                                              
                                                    ----------------------------                                    <span class="p">|</span>         
                                                    <span class="p">|</span>                          <span class="p">|</span>                                    <span class="p">|</span>         
                                                    <span class="p">|</span>     Local VarN           <span class="p">|</span>                                    <span class="p">|</span>         
                                  SP<span class="o">(</span>Real Register<span class="o">)</span> ----------------------------                                    <span class="p">|</span>         
                                                    <span class="p">|</span>                          <span class="p">|</span>                                    <span class="p">|</span>         
                                                    <span class="p">|</span>                          <span class="p">|</span>                                    <span class="p">|</span>         
                                                    <span class="p">|</span>                          <span class="p">|</span>                                    <span class="p">|</span>         
                                                    <span class="p">|</span>                          <span class="p">|</span>                                    <span class="p">|</span>         
                                                    <span class="p">|</span>                          <span class="p">|</span>                                    <span class="p">|</span>         
                                                    +--------------------------+    &lt;-------------------------------+         

                                                              callee
</code></pre></div><ul>
<li><a href="https://www.bilibili.com/video/BV1Xb411J7Yk">曹大讲解go plan9汇编 视频</a></li>
<li><a href="https://github.com/cch123/asmshare/blob/master/layout.md">曹大讲解go plan9汇编 资料</a></li>
</ul>
<h3 id="例子1">例子1</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="err">#</span> <span class="nx">cat</span> <span class="nx">函数栈</span><span class="p">.</span><span class="k">go</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="c1">// go代码直接实现累加
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sumGo</span><span class="p">(</span><span class="nx">rl</span>  <span class="p">[]</span><span class="kt">int64</span><span class="p">)</span> <span class="kt">int64</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">a</span> <span class="kt">int64</span>
	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span> <span class="p">;</span><span class="nx">i</span> <span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">rl</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">a</span> <span class="o">+=</span> <span class="nx">rl</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">a</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">l</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int64</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">}</span>
	<span class="nf">sumGo</span><span class="p">(</span><span class="nx">l</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><blockquote>
<p>反编译或者编译的汇编结果看其一即可, 差别不大</p>
</blockquote>
<ul>
<li>反编译看汇编</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="err">#</span> <span class="nx">先build生成二进制</span>
<span class="k">go</span> <span class="nx">build</span> <span class="nx">函数栈</span><span class="p">.</span><span class="k">go</span>
<span class="err">#</span> <span class="nx">在反编译</span>
<span class="k">go</span> <span class="nx">tool</span> <span class="nx">objdump</span> <span class="nx">函数栈</span><span class="p">|</span><span class="nx">grep</span> <span class="s">&#34;函数栈.go&#34;</span>
</code></pre></div><ul>
<li>编译看汇编</li>
</ul>
<pre><code class="language-assembly" data-lang="assembly">//MOV 指令有有好几种后缀 MOVB MOVW MOVL MOVQ 分别对应的是 1 字节 、2 字节 、4 字节、8 字节

go tool compile -S 函数栈.go|egrep &quot;函数栈.go|funcid&quot;
&quot;&quot;.sumGo STEXT nosplit size=43 args=0x20 locals=0x0 funcid=0x0
	0x0000 00000 (函数栈.go:4)	TEXT	&quot;&quot;.sumGo(SB), NOSPLIT|ABIInternal, $0-32
	0x0000 00000 (函数栈.go:6)	MOVQ	&quot;&quot;.rl+16(SP), AX  // 这里都是物理sp寄存器, AX=len(rl),我们知道slice结构体是struct{array,len,cap},每个字段都是8字节
	0x0005 00005 (函数栈.go:6)	MOVQ	&quot;&quot;.rl+8(SP), CX   // CX=&amp;rl[0]
	0x000a 00010 (函数栈.go:6)	XORL	DX, DX            // 相同的值异或肯定都是0,DX=0
	0x000c 00012 (函数栈.go:6)	XORL	BX, BX            // BX=0
	0x000e 00014 (函数栈.go:6)	JMP	32                    // 跳到 32行 CMPQ	DX, AX
	0x0010 00016 (函数栈.go:6)	LEAQ	1(DX), SI         //装入有效地址, 1(DX)偏移地址存入SI, SI= DX+1 ~ i+1
	0x0014 00020 (函数栈.go:7)	MOVQ	(CX)(DX*8), DI    // 指针*CX移动i*8字节? 所以 DI=rl[i]
	0x0018 00024 (函数栈.go:7)	ADDQ	DI, BX            // BX += DI  ~ += rl[i]
	0x001b 00027 (函数栈.go:6)	MOVQ	SI, DX            // DX = SI ~ i
	0x001e 00030 (函数栈.go:6)	NOP                       // 空操作?
	0x0020 00032 (函数栈.go:6)	CMPQ	DX, AX            // 比较DX是否小于AX ?
	0x0023 00035 (函数栈.go:6)	JLT	16                    // 小于 就跳转到16行
	0x0025 00037 (函数栈.go:9)	MOVQ	BX, &quot;&quot;.~r1+32(SP) // 否则 BX结果写到 32(SP)的栈中
	0x002a 00042 (函数栈.go:9)	RET
&quot;&quot;.main STEXT nosplit size=14 args=0x0 locals=0x0 funcid=0x0
	0x0000 00000 (函数栈.go:14)	TEXT	&quot;&quot;.main(SB), NOSPLIT|ABIInternal, $0-0
	0x0000 00000 (函数栈.go:16)	XORL	AX, AX
	0x0002 00002 (函数栈.go:6)	JMP	7
	0x0004 00004 (函数栈.go:6)	INCQ	AX
	0x0007 00007 (函数栈.go:6)	CMPQ	AX, $3
	0x000b 00011 (函数栈.go:6)	JLT	4
	0x000d 00013 (函数栈.go:16)	RET
</code></pre><h3 id="例子2">例子2</h3>
<pre><code class="language-assembly" data-lang="assembly">//sum_amd64.s
#include &quot;textflag.h&quot;

// func sumAsm(sl []int64) int64
TEXT ·sumAsm(SB), NOSPLIT, $0-32
    MOVQ $0, SI
    MOVQ sl+0(FP), BX // &amp;sl[0], addr of the first elem
    MOVQ sl+8(FP), CX // len(sl)
    INCQ CX           // CX++, 因为要循环 len 次

start:
    DECQ CX       // CX--
    JZ   done
    ADDQ (BX), SI // SI += *BX
    ADDQ $8, BX   // 指针移动
    JMP  start

done:
    MOVQ SI, ret+24(FP)
    RET

// 函数栈.go
// go plan9实现累加
func sumAsm(rl []int64) int64

func main() {
	l := []int64{1,2,3}
	// 当前目录执行 go build . , 然后执行二进制文件即可
	sumAsm(l)
}
</code></pre><h3 id="例子3">例子3</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">myFunction</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">myFunction</span><span class="p">(</span><span class="mi">66</span><span class="p">,</span> <span class="mi">77</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><blockquote>
<p>我们通过 -N 去掉编译器优化, -l 去掉内联</p>
</blockquote>
<pre><code class="language-assembly" data-lang="assembly">go tool compile -S -N -l compile-1.go
&quot;&quot;.myFunction STEXT nosplit size=49 args=0x20 locals=0x0 funcid=0x0
	0x0000 00000 (compile-1.go:3)	TEXT	&quot;&quot;.myFunction(SB), NOSPLIT|ABIInternal, $0-32
	0x0000 00000 (compile-1.go:3)	FUNCDATA	$0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
	0x0000 00000 (compile-1.go:3)	FUNCDATA	$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
	0x0000 00000 (compile-1.go:3)	MOVQ	$0, &quot;&quot;.~r2+24(SP)
	0x0009 00009 (compile-1.go:3)	MOVQ	$0, &quot;&quot;.~r3+32(SP)
	0x0012 00018 (compile-1.go:4)	MOVQ	&quot;&quot;.a+8(SP), AX      // AX =66
	0x0017 00023 (compile-1.go:4)	ADDQ	&quot;&quot;.b+16(SP), AX     // AX = 66+77=143
	0x001c 00028 (compile-1.go:4)	MOVQ	AX, &quot;&quot;.~r2+24(SP)   // 24(SP) = 143
	0x0021 00033 (compile-1.go:4)	MOVQ	&quot;&quot;.a+8(SP), AX      // AX =66
	0x0026 00038 (compile-1.go:4)	SUBQ	&quot;&quot;.b+16(SP), AX     // AX = 66-77=-11
	0x002b 00043 (compile-1.go:4)	MOVQ	AX, &quot;&quot;.~r3+32(SP)   // 32(SP) = -11
	0x0030 00048 (compile-1.go:4)	RET
	0x0000 48 c7 44 24 18 00 00 00 00 48 c7 44 24 20 00 00  H.D$.....H.D$ ..
	0x0010 00 00 48 8b 44 24 08 48 03 44 24 10 48 89 44 24  ..H.D$.H.D$.H.D$
	0x0020 18 48 8b 44 24 08 48 2b 44 24 10 48 89 44 24 20  .H.D$.H+D$.H.D$
	0x0030 c3                                               .
&quot;&quot;.main STEXT size=71 args=0x0 locals=0x28 funcid=0x0
	0x0000 00000 (compile-1.go:7)	TEXT	&quot;&quot;.main(SB), ABIInternal, $40-0
	0x0000 00000 (compile-1.go:7)	MOVQ	(TLS), CX
	0x0009 00009 (compile-1.go:7)	CMPQ	SP, 16(CX)
	0x000d 00013 (compile-1.go:7)	PCDATA	$0, $-2
	0x000d 00013 (compile-1.go:7)	JLS	64
	0x000f 00015 (compile-1.go:7)	PCDATA	$0, $-1
	0x000f 00015 (compile-1.go:7)	SUBQ	$40, SP     // 分配40字节的栈空间
	0x0013 00019 (compile-1.go:7)	MOVQ	BP, 32(SP)  // main函数的基址指针入栈
	0x0018 00024 (compile-1.go:7)	LEAQ	32(SP), BP
	0x001d 00029 (compile-1.go:7)	FUNCDATA	$0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
	0x001d 00029 (compile-1.go:7)	FUNCDATA	$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
	0x001d 00029 (compile-1.go:8)	MOVQ	$66, (SP)   // 第一个参数放到sp
	0x0025 00037 (compile-1.go:8)	MOVQ	$77, 8(SP)  // 第二个参数放到sp+8 地址
	0x002e 00046 (compile-1.go:8)	PCDATA	$1, $0
	0x002e 00046 (compile-1.go:8)	CALL	&quot;&quot;.myFunction(SB)   // 调用函数
	0x0033 00051 (compile-1.go:9)	MOVQ	32(SP), BP
	0x0038 00056 (compile-1.go:9)	ADDQ	$40, SP
	0x003c 00060 (compile-1.go:9)	RET
	0x003d 00061 (compile-1.go:9)	NOP
	0x003d 00061 (compile-1.go:7)	PCDATA	$1, $-1
	0x003d 00061 (compile-1.go:7)	PCDATA	$0, $-2
	0x003d 00061 (compile-1.go:7)	NOP
	0x0040 00064 (compile-1.go:7)	CALL	runtime.morestack_noctxt(SB)
	0x0045 00069 (compile-1.go:7)	PCDATA	$0, $-1
	0x0045 00069 (compile-1.go:7)	JMP	0
	0x0000 65 48 8b 0c 25 00 00 00 00 48 3b 61 10 76 31 48  eH..%....H;a.v1H
	0x0010 83 ec 28 48 89 6c 24 20 48 8d 6c 24 20 48 c7 04  ..(H.l$ H.l$ H..
	0x0020 24 42 00 00 00 48 c7 44 24 08 4d 00 00 00 e8 00  $B...H.D$.M.....
	0x0030 00 00 00 48 8b 6c 24 20 48 83 c4 28 c3 0f 1f 00  ...H.l$ H..(....
	0x0040 e8 00 00 00 00 eb b9                             .......
	rel 5+4 t=17 TLS+0
	rel 47+4 t=8 &quot;&quot;.myFunction+0
	rel 65+4 t=8 runtime.morestack_noctxt+0
</code></pre><p><img src="images/golang/func-stack.png" alt=""></p>
<h3 id="plan9汇编的编写格式">plan9汇编的编写格式</h3>
<pre><code>                              参数及返回值大小
                                  |
 TEXT pkgname·add(SB),NOSPLIT,$32-32
       |        |               |
      包名     函数名         栈帧大小(局部变量+可能需要的额外调用函数的参数空间的总大小，但不包括调用其它函数时的 ret address 的大小)
</code></pre><h3 id="附录">附录</h3>
<ul>
<li><a href="https://golang.design/under-the-hood/zh-cn/part1basic/ch01basic/asm/">go语言原本</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Go学习 Channel源码分析</title>
			<link>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-channel%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
			<pubDate>Wed, 10 Nov 2021 15:18:42 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-channel%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
			<description>根据以下代码我们逐个看下channel的实现 package main /* $ go tool compile -S channel源码分析.go|grep runtime|grep chan|grep -v &amp;#34;print&amp;#34; 0x003a 00058 (channel源码分析.go:32)	CALL	runtime.newobject(SB) 0x0060 00096 (channel源码分析.go:32)	CALL	runtime.makechan(SB) 0x006a 00106 (channel源码分析.go:32)	CMPL	runtime.writeBarrier(SB), $0 0x0097 00151 (channel源码分析.go:34)	CALL	runtime.newproc(SB) 0x00b1 00177 (channel源码分析.go:40)	CALL	runtime.chanrecv1(SB) 0x00cb 00203 (channel源码分析.go:42)	CALL	runtime.chanrecv2(SB) 0x0100 00256 (channel源码分析.go:44)	CALL	runtime.chanrecv2(SB) 0x0120 00288 (channel源码分析.go:47)	CALL	runtime.makechan(SB) 0x012a 00298 (channel源码分析.go:47)	CMPL	runtime.writeBarrier(SB), $0 0x01eb 00491 (channel源码分析.go:50)	CALL	runtime.selectgo(SB) 0x02c0 00704 (channel源码分析.go:47)	CALL	runtime.</description>
			<content type="html"><![CDATA[<h3 id="根据以下代码我们逐个看下channel的实现">根据以下代码我们逐个看下channel的实现</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="cm">/*
</span><span class="cm">$ go tool compile -S channel源码分析.go|grep runtime|grep chan|grep -v &#34;print&#34;
</span><span class="cm">	0x003a 00058 (channel源码分析.go:32)	CALL	runtime.newobject(SB)
</span><span class="cm">	0x0060 00096 (channel源码分析.go:32)	CALL	runtime.makechan(SB)
</span><span class="cm">	0x006a 00106 (channel源码分析.go:32)	CMPL	runtime.writeBarrier(SB), $0
</span><span class="cm">	0x0097 00151 (channel源码分析.go:34)	CALL	runtime.newproc(SB)
</span><span class="cm">	0x00b1 00177 (channel源码分析.go:40)	CALL	runtime.chanrecv1(SB)
</span><span class="cm">	0x00cb 00203 (channel源码分析.go:42)	CALL	runtime.chanrecv2(SB)
</span><span class="cm">	0x0100 00256 (channel源码分析.go:44)	CALL	runtime.chanrecv2(SB)
</span><span class="cm">	0x0120 00288 (channel源码分析.go:47)	CALL	runtime.makechan(SB)
</span><span class="cm">	0x012a 00298 (channel源码分析.go:47)	CMPL	runtime.writeBarrier(SB), $0
</span><span class="cm">	0x01eb 00491 (channel源码分析.go:50)	CALL	runtime.selectgo(SB)
</span><span class="cm">	0x02c0 00704 (channel源码分析.go:47)	CALL	runtime.gcWriteBarrier(SB)
</span><span class="cm">	0x02d2 00722 (channel源码分析.go:32)	CALL	runtime.gcWriteBarrier(SB)
</span><span class="cm">	0x02e0 00736 (channel源码分析.go:30)	CALL	runtime.morestack_noctxt(SB)
</span><span class="cm">	rel 97+4 t=8 runtime.makechan+0
</span><span class="cm">	rel 178+4 t=8 runtime.chanrecv1+0
</span><span class="cm">	rel 204+4 t=8 runtime.chanrecv2+0
</span><span class="cm">	rel 257+4 t=8 runtime.chanrecv2+0
</span><span class="cm">	rel 289+4 t=8 runtime.makechan+0
</span><span class="cm">	0x0035 00053 (channel源码分析.go:35)	CALL	runtime.chansend1(SB)
</span><span class="cm">	0x0052 00082 (channel源码分析.go:36)	CALL	runtime.chansend1(SB)
</span><span class="cm">	0x0063 00099 (channel源码分析.go:37)	CALL	runtime.closechan(SB)
</span><span class="cm">	0x0072 00114 (channel源码分析.go:34)	CALL	runtime.morestack_noctxt(SB)
</span><span class="cm">	rel 54+4 t=8 runtime.chansend1+0
</span><span class="cm">	rel 83+4 t=8 runtime.chansend1+0
</span><span class="cm">	rel 100+4 t=8 runtime.closechan+0
</span><span class="cm">*/</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 1 runtime.makechan
</span><span class="c1"></span>	<span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span><span class="nb">int64</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">31</span><span class="p">))</span>
	<span class="c1">// 2 runtime.chansend1
</span><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">c</span> <span class="o">&lt;-</span> <span class="mi">1</span>
		<span class="nx">c</span> <span class="o">&lt;-</span> <span class="mi">2</span>
		<span class="nb">close</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
	<span class="p">}()</span>
	<span class="c1">// 3 runtime.chanrecv1
</span><span class="c1"></span>	<span class="o">&lt;-</span><span class="nx">c</span>
	<span class="c1">// 4 runtime.chanrecv2
</span><span class="c1"></span>	<span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="o">&lt;-</span><span class="nx">c</span>
	<span class="c1">//   runtime.chanrecv2
</span><span class="c1"></span>	<span class="k">for</span> <span class="k">range</span>  <span class="nx">c</span> <span class="p">{</span>
	<span class="p">}</span>
	<span class="c1">//print(a, ok)
</span><span class="c1"></span>	<span class="nx">c</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="nx">Loop</span><span class="p">:</span>
	<span class="c1">// 5 runtime.selectgo
</span><span class="c1"></span>	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">c</span> <span class="o">&lt;-</span> <span class="mi">1</span><span class="p">:</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;write\n&#34;</span><span class="p">)</span>
		<span class="k">goto</span> <span class="nx">Loop</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">c</span><span class="p">:</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;read1\n&#34;</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">c</span><span class="p">:</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;read2 &#34;</span><span class="p">,</span> <span class="nx">ok</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;default\n&#34;</span><span class="p">)</span>
	<span class="p">}</span>

<span class="p">}</span>


</code></pre></div><h3 id="1-channel的初始化和内存分配-runtimemakechan">1. channel的初始化和内存分配-runtime.makechan</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">hchan</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">qcount</span>   <span class="kt">uint</span>           <span class="c1">// queue 里面有效用户元素，这个字段是在元素出对，入队改变的；
</span><span class="c1"></span>    <span class="nx">dataqsiz</span> <span class="kt">uint</span>           <span class="c1">// 环大小,初始化的时候赋值，之后不再改变，指明数组 buffer 的大小；
</span><span class="c1"></span>    <span class="nx">buf</span>      <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 指明 buffer 数组的地址，初始化赋值，之后不会再改变；
</span><span class="c1"></span>    <span class="nx">elemsize</span> <span class="kt">uint16</span>         <span class="c1">// 指明元素的大小，和 dataqsiz 配合使用就能知道 buffer 内存块的大小了；
</span><span class="c1"></span>    <span class="nx">closed</span>   <span class="kt">uint32</span>
    <span class="nx">elemtype</span> <span class="o">*</span><span class="nx">_type</span>         <span class="c1">// 元素类型，初始化赋值；
</span><span class="c1"></span>    <span class="nx">sendx</span>    <span class="kt">uint</span>           <span class="c1">// send index
</span><span class="c1"></span>    <span class="nx">recvx</span>    <span class="kt">uint</span>           <span class="c1">// receive index
</span><span class="c1"></span>    <span class="nx">recvq</span>    <span class="nx">waitq</span>          <span class="c1">// 等待 recv 响应的对象列表，抽象成 waiters
</span><span class="c1"></span>    <span class="nx">sendq</span>    <span class="nx">waitq</span>          <span class="c1">// 等待 sedn 响应的对象列表，抽象成 waiters
</span><span class="c1"></span>    <span class="nx">lock</span>     <span class="nx">mutex</span>          <span class="c1">// 锁
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">waitq</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">first</span> <span class="o">*</span><span class="nx">sudog</span>       <span class="c1">//
</span><span class="c1"></span>	<span class="nx">last</span>  <span class="o">*</span><span class="nx">sudog</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">sudog</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">g</span> <span class="o">*</span><span class="nx">g</span>
	<span class="nx">next</span> <span class="o">*</span><span class="nx">sudog</span>        <span class="c1">// 链表下一个
</span><span class="c1"></span>	<span class="nx">prev</span> <span class="o">*</span><span class="nx">sudog</span>        <span class="c1">// 链表上一个
</span><span class="c1"></span>	<span class="nx">elem</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// data element (may point to stack)
</span><span class="c1"></span>    <span class="o">...</span>
	<span class="nx">isSelect</span> <span class="kt">bool</span>
	<span class="nx">success</span> <span class="kt">bool</span>
	<span class="nx">parent</span>   <span class="o">*</span><span class="nx">sudog</span> <span class="c1">// semaRoot binary tree
</span><span class="c1"></span>	<span class="nx">waitlink</span> <span class="o">*</span><span class="nx">sudog</span> <span class="c1">// g.waiting list or semaRoot
</span><span class="c1"></span>	<span class="nx">waittail</span> <span class="o">*</span><span class="nx">sudog</span> <span class="c1">// semaRoot
</span><span class="c1"></span>	<span class="nx">c</span>        <span class="o">*</span><span class="nx">hchan</span> <span class="c1">// channel
</span><span class="c1"></span><span class="p">}</span>

</code></pre></div><blockquote>
<p>这是我们初始化channel使用的make方法</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// makechan需要传入的参数也很明显, 就是make(chan int, 2) 中的两个参数
</span><span class="c1">// chantype=int 和 size=2
</span><span class="c1">// 这里返回的 *hchan 就是channel的结构体
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">makechan</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">chantype</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">hchan</span> <span class="p">{</span>
	<span class="nx">elem</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">elem</span>
    <span class="o">...</span>
    <span class="c1">// 这里mem 是 elem.size * uintptr(size)
</span><span class="c1"></span>	<span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">))</span>
    <span class="o">...</span>

	<span class="kd">var</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span>
	<span class="k">switch</span> <span class="p">{</span>
    <span class="c1">// size == 0
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">mem</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
		<span class="c1">// 这里hchanSize=0, 所以mallocgc函数直接返回了unsafe.Pointer(&amp;zerobase)
</span><span class="c1"></span>		<span class="nx">c</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">hchan</span><span class="p">)(</span><span class="nf">mallocgc</span><span class="p">(</span><span class="nx">hchanSize</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">()</span>

	<span class="k">case</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
		<span class="c1">// 元素不包括指针类型
</span><span class="c1"></span>		<span class="nx">c</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">hchan</span><span class="p">)(</span><span class="nf">mallocgc</span><span class="p">(</span><span class="nx">hchanSize</span><span class="o">+</span><span class="nx">mem</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">c</span><span class="p">),</span> <span class="nx">hchanSize</span><span class="p">)</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="c1">// 元素包含指针类型
</span><span class="c1"></span>		<span class="nx">c</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">hchan</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">mem</span><span class="p">,</span> <span class="nx">elem</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
	<span class="p">}</span>
    <span class="c1">// channel 元素大小，如果是 int，那么就是 8 字节；
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">elemsize</span> <span class="p">=</span> <span class="nb">uint16</span><span class="p">(</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
    <span class="c1">// channel的类型就是make的时候传入的类型, 例如chantype=int时,elem就是int的*_type
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span> <span class="p">=</span> <span class="nx">elem</span>
    <span class="c1">// channel的数组大小, cap容量
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">=</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span>
	<span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">lockRankHchan</span><span class="p">)</span>

    <span class="o">...</span>
	<span class="k">return</span> <span class="nx">c</span>
<span class="p">}</span>

</code></pre></div><h3 id="2-channel的接收方法-chanrecv">2. channel的接收方法-chanrecv</h3>
<ul>
<li>runtime.chanrecv1 其实是chanrecv的封装</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">chanrecv1</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">elem</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">chanrecv</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">elem</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>runtime.chanrecv2 也是chanrecv的封装</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">chanrecv2</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">elem</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">(</span><span class="nx">received</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">received</span> <span class="p">=</span> <span class="nf">chanrecv</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">elem</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></div><p>显而易见的是,他们传参都是一样, 只不过chanrecv2接收了bool的返回值
那另外一个true是什么意义呢?</p>
<ul>
<li>runtime.chanrecv</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">chanrecv</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">ep</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">block</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">(</span><span class="nx">selected</span><span class="p">,</span> <span class="nx">received</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">...</span>
    <span class="c1">// 如果没有make分配内存
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nf">gopark</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">waitReasonChanReceiveNilChan</span><span class="p">,</span> <span class="nx">traceEvGoStop</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;unreachable&#34;</span><span class="p">)</span>
	<span class="p">}</span>

    <span class="c1">// 如果block=false并且channel为空
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="o">&amp;&amp;</span> <span class="nf">empty</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 继续判断是否已经关闭了
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">closed</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
        <span class="c1">// 再次判断是防止判断是否关闭的时间段内 channel有数据
</span><span class="c1"></span>		<span class="k">if</span> <span class="nf">empty</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
				<span class="nf">raceacquire</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">ep</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>
    <span class="o">...</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
    <span class="c1">// 已经关闭的channel,但是并没有读到数据, 所以return true ,false
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
			<span class="nf">raceacquire</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
		<span class="p">}</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">ep</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span>
	<span class="p">}</span>
    <span class="c1">// 正常读取到数据的情况, 能从发送的队列中获取到非空, return true,true
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">();</span> <span class="nx">sg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">recv</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="nx">ep</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span> <span class="p">},</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span>
	<span class="p">}</span>
    <span class="c1">// channel数组长度大于0,有buf,说明队列可以接收
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="c1">// 从buf中取
</span><span class="c1"></span>		<span class="nx">qp</span> <span class="o">:=</span> <span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
			<span class="nf">racenotify</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">ep</span><span class="p">,</span> <span class="nx">qp</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">qp</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="o">++</span>
        <span class="c1">// 环
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span><span class="o">--</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span>
	<span class="p">}</span>
    <span class="c1">// block=false,也就是在select{} 中,所以return false,false 直接跳过
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span>
	<span class="p">}</span>
    <span class="c1">// 获取当前的g
</span><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
    <span class="c1">// 需要一个sudog
</span><span class="c1"></span>	<span class="nx">mysg</span> <span class="o">:=</span> <span class="nf">acquireSudog</span><span class="p">()</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="k">if</span> <span class="nx">t0</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
	<span class="p">}</span>
    <span class="c1">// 把当前这个接收方ep保存到sudog的elem中
</span><span class="c1"></span>	<span class="nx">mysg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="nx">ep</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">waitlink</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="nx">mysg</span>
    <span class="c1">// 设置sudog的g
</span><span class="c1"></span>	<span class="nx">mysg</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nx">gp</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">isSelect</span> <span class="p">=</span> <span class="kc">false</span>
    <span class="c1">// 设置sudog的channel
</span><span class="c1"></span>	<span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="nx">c</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="c1">// 把这个sudog放到 接收双向队列中,所以sudog这个等待队列中是保存了阻塞的g 和channel的
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>

	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store8</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">parkingOnChan</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1">// goroutine切换,下面会具体分析, 这里会阻塞
</span><span class="c1"></span>	<span class="nf">gopark</span><span class="p">(</span><span class="nx">chanparkcommit</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">),</span> <span class="nx">waitReasonChanReceive</span><span class="p">,</span> <span class="nx">traceEvGoBlockRecv</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

	<span class="c1">// 切换goroutine的时候会保留现场, 当恢复是可以继续执行
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">mysg</span> <span class="o">!=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;G waiting list is corrupted&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">activeStackChans</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="k">if</span> <span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">blockevent</span><span class="p">(</span><span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span><span class="o">-</span><span class="nx">t0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">success</span> <span class="o">:=</span> <span class="nx">mysg</span><span class="p">.</span><span class="nx">success</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="c1">// 从sudog队列删除
</span><span class="c1"></span>	<span class="nf">releaseSudog</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">success</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>recv</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">recv</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">sg</span> <span class="o">*</span><span class="nx">sudog</span><span class="p">,</span> <span class="nx">ep</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">unlockf</span> <span class="kd">func</span><span class="p">(),</span> <span class="nx">skip</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>   <span class="c1">// 如果是同步的
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
			<span class="nf">racesync</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">sg</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>    <span class="c1">//并且接受者不等于nil
</span><span class="c1"></span>			<span class="c1">// copy data from sender
</span><span class="c1"></span>            <span class="c1">// sg 是发送方队列
</span><span class="c1"></span>            <span class="c1">// ep 是接收方
</span><span class="c1"></span>            <span class="c1">// 直接从发送方 copy到接收方, 不通过channel buf
</span><span class="c1"></span>			<span class="nf">recvDirect</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="nx">ep</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 根据索引得到缓存队列的buf
</span><span class="c1"></span>		<span class="nx">qp</span> <span class="o">:=</span> <span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
			<span class="nf">racenotify</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
			<span class="nf">racenotify</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">,</span> <span class="nx">sg</span><span class="p">)</span>
		<span class="p">}</span>
        <span class="c1">// 从channel的buf队列拷贝数据到接收方
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">ep</span><span class="p">,</span> <span class="nx">qp</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// 如果ep是nil,说明buf没有元素了
</span><span class="c1"></span>		<span class="c1">// 直接从发送方的sudog队列 写到 buf中
</span><span class="c1"></span>		<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">qp</span><span class="p">,</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="o">++</span>
		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="c1">// c.sendx = (c.sendx+1) % c.dataqsiz
</span><span class="c1"></span>	<span class="p">}</span>
    <span class="c1">// 发送方已经读过了, 设置为nil
</span><span class="c1"></span>	<span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="c1">// 得到发送方的goroutine
</span><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">g</span>
    <span class="c1">// 释放锁
</span><span class="c1"></span>	<span class="nf">unlockf</span><span class="p">()</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sg</span><span class="p">)</span>
	<span class="nx">sg</span><span class="p">.</span><span class="nx">success</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="k">if</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nf">goready</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">skip</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>    <span class="c1">//将 gp 作为下一个立即被执行的 Goroutine
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">recvDirect</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">sg</span> <span class="o">*</span><span class="nx">sudog</span><span class="p">,</span> <span class="nx">dst</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// dst is on our stack or the heap, src is on another stack.
</span><span class="c1"></span>	<span class="c1">// The channel is locked, so src will not move during this
</span><span class="c1"></span>	<span class="c1">// operation.
</span><span class="c1"></span>	<span class="nx">src</span> <span class="o">:=</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span>
	<span class="nf">typeBitsBulkBarrier</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">dst</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">src</span><span class="p">),</span> <span class="nx">t</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
	<span class="nf">memmove</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">src</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>gopark</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gopark</span><span class="p">(</span><span class="nx">unlockf</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">lock</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">reason</span> <span class="nx">waitReason</span><span class="p">,</span> <span class="nx">traceEv</span> <span class="kt">byte</span><span class="p">,</span> <span class="nx">traceskip</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">reason</span> <span class="o">!=</span> <span class="nx">waitReasonSleep</span> <span class="p">{</span>
		<span class="nf">checkTimeouts</span><span class="p">()</span> <span class="c1">// timeouts may expire while two goroutines keep the scheduler busy
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">curg</span>
	<span class="nx">status</span> <span class="o">:=</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">status</span> <span class="o">!=</span> <span class="nx">_Grunning</span> <span class="o">&amp;&amp;</span> <span class="nx">status</span> <span class="o">!=</span> <span class="nx">_Gscanrunning</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gopark: bad g status&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">waitlock</span> <span class="p">=</span> <span class="nx">lock</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">waitunlockf</span> <span class="p">=</span> <span class="nx">unlockf</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">waitreason</span> <span class="p">=</span> <span class="nx">reason</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">waittraceev</span> <span class="p">=</span> <span class="nx">traceEv</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">waittraceskip</span> <span class="p">=</span> <span class="nx">traceskip</span>
	<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
	<span class="nf">mcall</span><span class="p">(</span><span class="nx">park_m</span><span class="p">)</span>  <span class="c1">// 这是核心代码
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><ul>
<li>park_m</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// park continuation on g0.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">park_m</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
    <span class="c1">// 更新gp状态由_Grunning 为 _Gwaiting
</span><span class="c1"></span>	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">)</span>
    <span class="c1">// 移除gp与m的绑定关系
</span><span class="c1"></span>	<span class="nf">dropg</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">fn</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">waitunlockf</span><span class="p">;</span> <span class="nx">fn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">ok</span> <span class="o">:=</span> <span class="nf">fn</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">waitlock</span><span class="p">)</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">waitunlockf</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">waitlock</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
				<span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
			<span class="nf">execute</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span> <span class="c1">// Schedule it back, never returns.
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>
    <span class="c1">// 重新调度goroutine
</span><span class="c1"></span>	<span class="nf">schedule</span><span class="p">()</span> <span class="c1">// schedule() -&gt; execute() -&gt; gogo
</span><span class="c1"></span><span class="p">}</span>

</code></pre></div><ul>
<li>gogo 通过gobuf恢复g</li>
</ul>
<pre><code>// func gogo(buf *gobuf)
// restore state from Gobuf; longjmp
TEXT runtime·gogo(SB), NOSPLIT, $16-8
	MOVQ	buf+0(FP), BX		// gobuf
	MOVQ	gobuf_g(BX), DX
	MOVQ	0(DX), CX		// make sure g != nil
	get_tls(CX)
	MOVQ	DX, g(CX)
	MOVQ	gobuf_sp(BX), SP	// restore SP
	MOVQ	gobuf_ret(BX), AX
	MOVQ	gobuf_ctxt(BX), DX
	MOVQ	gobuf_bp(BX), BP
	MOVQ	$0, gobuf_sp(BX)	// clear to help garbage collector
	MOVQ	$0, gobuf_ret(BX)
	MOVQ	$0, gobuf_ctxt(BX)
	MOVQ	$0, gobuf_bp(BX)
	MOVQ	gobuf_pc(BX), BX
	JMP	BX
</code></pre><ul>
<li>mcall</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 在.go文件中,如下没有函数体, 所以asm定义的$0表示没有内部变量,只有一个参数没有返回值,所以是$8
</span><span class="c1">// runtime/asm_amd64.s
</span><span class="c1">// func mcall(fn func(*g))
</span><span class="c1">// 切换到m-&gt;g0的栈上,调用fn(g)函数
</span><span class="c1">// fn函数不能返回,它应该调用gogo(&amp;g-&gt;sched)来运行g
</span><span class="c1">// 注意这个·是UTF8值=U+00B7,并不是英文的.
</span><span class="c1"></span><span class="nx">TEXT</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">mcall</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">NOSPLIT</span><span class="p">,</span> <span class="err">$</span><span class="mi">0</span><span class="o">-</span><span class="mi">8</span>
	<span class="nx">MOVQ</span>	<span class="nx">fn</span><span class="o">+</span><span class="mi">0</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">DI</span>  <span class="c1">//FP是当前栈帧起始地址, fn函数指针存到DI寄存器
</span><span class="c1"></span>	<span class="nf">get_tls</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>    <span class="c1">//tls 是线程局部存储，将这个存储的开始位置存到 CX
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">),</span> <span class="nx">AX</span>	<span class="c1">// g(CX)还是宏，在tls上可以拿到g，也就是当前正在跑的g，把这个g的地址存到AX寄存器
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="mi">0</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">BX</span>	<span class="c1">// caller&#39;s PC
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nx">BX</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_pc</span><span class="p">)(</span><span class="nx">AX</span><span class="p">)</span>    <span class="c1">//把BX(caller&#39;s PC)存入到AX的g-&gt;sched的gobuf-&gt;pc字段
</span><span class="c1"></span>	<span class="nx">LEAQ</span>	<span class="nx">fn</span><span class="o">+</span><span class="mi">0</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">BX</span>	<span class="c1">// caller&#39;s SP, fn函数
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nx">BX</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_sp</span><span class="p">)(</span><span class="nx">AX</span><span class="p">)</span>    <span class="c1">//把BX(caller&#39;s SP)存入到AX的g-&gt;sched的gobuf-&gt;sp字段
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nx">AX</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_g</span><span class="p">)(</span><span class="nx">AX</span><span class="p">)</span>     <span class="c1">//把g本身也存起来
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nx">BP</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_bp</span><span class="p">)(</span><span class="nx">AX</span><span class="p">)</span>    <span class="c1">//把BP(当前栈底)存入到AX的g-&gt;sched的gobuf-&gt;bp字段
</span><span class="c1"></span>
	<span class="c1">// switch to m-&gt;g0 &amp; its stack, call fn
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">),</span> <span class="nx">BX</span>     <span class="c1">//把g存入BX
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nf">g_m</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">BX</span>   <span class="c1">//根据g得到m存入BX
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nf">m_g0</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">SI</span>  <span class="c1">//根据m得到g0存入SI
</span><span class="c1"></span>	<span class="nx">CMPQ</span>	<span class="nx">SI</span><span class="p">,</span> <span class="nx">AX</span>	<span class="c1">// if g == m-&gt;g0 call badmcall
</span><span class="c1"></span>	<span class="nx">JNE</span>	<span class="mi">3</span><span class="p">(</span><span class="nx">PC</span><span class="p">)</span>      <span class="c1">//JNE表示不等于的时候转移, if g != m-&gt;g0 , 那就跳3行
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="err">$</span><span class="nx">runtime</span><span class="err">·</span><span class="nf">badmcall</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>         
	<span class="nx">JMP</span>	<span class="nx">AX</span>
	<span class="nx">MOVQ</span>	<span class="nx">SI</span><span class="p">,</span> <span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>	<span class="c1">// g = m-&gt;g0, 直接把SI的m-&gt;g0 复制给g, 那现在的g就是m-&gt;g0, 成功切换到g0
</span><span class="c1"></span>	<span class="nf">MOVQ</span>	<span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_sp</span><span class="p">)(</span><span class="nx">SI</span><span class="p">),</span> <span class="nx">SP</span>	<span class="c1">// sp = m-&gt;g0-&gt;sched.sp, 直接拿g0中的sp值给SP寄存器了
</span><span class="c1"></span>	<span class="nx">PUSHQ</span>	<span class="nx">AX</span>        <span class="c1">//AX就是g,将g入栈保存
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nx">DI</span><span class="p">,</span> <span class="nx">DX</span>    <span class="c1">//DI里面保存的是fn函数, 现在存入到DX
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="mi">0</span><span class="p">(</span><span class="nx">DI</span><span class="p">),</span> <span class="nx">DI</span>
	<span class="nx">CALL</span>	<span class="nx">DI</span>        <span class="c1">//调用fn
</span><span class="c1"></span>	<span class="nx">POPQ</span>	<span class="nx">AX</span>        <span class="c1">//将g出栈
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="err">$</span><span class="nx">runtime</span><span class="err">·</span><span class="nf">badmcall2</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>
	<span class="nx">JMP</span>	<span class="nx">AX</span>
	<span class="nx">RET</span>    <span class="c1">//return
</span></code></pre></div><h3 id="3-channel的发送方法-chansend">3. channel的发送方法-chansend</h3>
<ul>
<li>runtime.chansend1 是对runtime.chansend的封装</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">chansend1</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">elem</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">chansend</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">elem</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="nf">getcallerpc</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>runtime.chansend</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">chansend</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">ep</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">block</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">callerpc</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c1">// 如果是个nil的channel
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="c1">// 如果是在select中, 那么直接返回false,不会选中
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
        <span class="c1">// goroutine切换
</span><span class="c1"></span>		<span class="nf">gopark</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">waitReasonChanSendNilChan</span><span class="p">,</span> <span class="nx">traceEvGoStop</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;unreachable&#34;</span><span class="p">)</span>
	<span class="p">}</span>
    <span class="o">...</span>
    <span class="c1">// block=fasle 并且c没有关闭 并且 c满了, 此时也不能发送成功的
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nf">full</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">t0</span> <span class="kt">int64</span>
	<span class="k">if</span> <span class="nx">blockprofilerate</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">t0</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
	<span class="p">}</span>
    <span class="c1">// 开启锁
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
    <span class="c1">// 关闭了的channel不能send
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;send on closed channel&#34;</span><span class="p">))</span>
	<span class="p">}</span>
    <span class="c1">// 能从接受的队列返回非空,dequeue()是从链表首部取出
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">();</span> <span class="nx">sg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="c1">// 这里send -&gt; goready -&gt; ready
</span><span class="c1"></span>		<span class="nf">send</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="nx">ep</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span> <span class="p">},</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>
    <span class="c1">// qcount还没有达到最大值, channel未满
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="p">&lt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
        <span class="c1">// sendx是索引, chanbuf会通过c.buf初始地址+索引*c.elemsize(元素类型大小)得到 send的地址
</span><span class="c1"></span>		<span class="nx">qp</span> <span class="o">:=</span> <span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
			<span class="nf">racenotify</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">qp</span><span class="p">,</span> <span class="nx">ep</span><span class="p">)</span>
        <span class="c1">// 索引递增
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="o">++</span>
        <span class="c1">// 环
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span>
        <span class="c1">//len()递增
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span><span class="o">++</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>
    <span class="c1">// 如果block=false, select的情况时间return false跳过case情况即可
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">mysg</span> <span class="o">:=</span> <span class="nf">acquireSudog</span><span class="p">()</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="k">if</span> <span class="nx">t0</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
	<span class="p">}</span>
	<span class="c1">// No stack splits between assigning elem and enqueuing mysg
</span><span class="c1"></span>	<span class="c1">// on gp.waiting where copystack can find it.
</span><span class="c1"></span>	<span class="nx">mysg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="nx">ep</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">waitlink</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nx">gp</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">isSelect</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="nx">c</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="nx">mysg</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store8</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">parkingOnChan</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1">// 这里阻塞
</span><span class="c1"></span>	<span class="nf">gopark</span><span class="p">(</span><span class="nx">chanparkcommit</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">),</span> <span class="nx">waitReasonChanSend</span><span class="p">,</span> <span class="nx">traceEvGoBlockSend</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

	<span class="nf">KeepAlive</span><span class="p">(</span><span class="nx">ep</span><span class="p">)</span>

	<span class="c1">// 唤醒逻辑
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">mysg</span> <span class="o">!=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;G waiting list is corrupted&#34;</span><span class="p">)</span>
	<span class="p">}</span>
    <span class="c1">//
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">activeStackChans</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="nx">closed</span> <span class="o">:=</span> <span class="p">!</span><span class="nx">mysg</span><span class="p">.</span><span class="nx">success</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="k">if</span> <span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">blockevent</span><span class="p">(</span><span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span><span class="o">-</span><span class="nx">t0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nf">releaseSudog</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">closed</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;chansend: spurious wakeup&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;send on closed channel&#34;</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

</code></pre></div><h3 id="4-channel的关闭方法-chanclose">4. channel的关闭方法-chanclose</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 传参是个channel
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">closechan</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// nil的会panic
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;close of nil channel&#34;</span><span class="p">))</span>
	<span class="p">}</span>
    <span class="c1">// 锁
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
    <span class="c1">// 已经close的不能再次close
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;close of closed channel&#34;</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="o">...</span>
    <span class="c1">// 设置为已经关闭
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="p">=</span> <span class="mi">1</span>
    <span class="c1">// glist用于保存g
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">glist</span> <span class="nx">gList</span>
    <span class="c1">// 释放接收方
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
        <span class="c1">// 循环取 接收方队列
</span><span class="c1"></span>		<span class="nx">sg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>
        <span class="c1">// 如果第一个都是nil了, 直接break
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">sg</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
        <span class="c1">// 清理
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span><span class="p">)</span>
			<span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">g</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sg</span><span class="p">)</span>
		<span class="nx">sg</span><span class="p">.</span><span class="nx">success</span> <span class="p">=</span> <span class="kc">false</span>
		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
			<span class="nf">raceacquireg</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
		<span class="p">}</span>
		<span class="nx">glist</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
	<span class="p">}</span>
    <span class="c1">// 是否发送方, 可能导致panic
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">sg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">sg</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="k">if</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">g</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sg</span><span class="p">)</span>
		<span class="nx">sg</span><span class="p">.</span><span class="nx">success</span> <span class="p">=</span> <span class="kc">false</span>
		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
			<span class="nf">raceacquireg</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
		<span class="p">}</span>
		<span class="nx">glist</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// Ready all Gs now that we&#39;ve dropped the channel lock.
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">!</span><span class="nx">glist</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">glist</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">schedlink</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nf">goready</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>    <span class="c1">//将 gp 作为下一个立即被执行的 Goroutine
</span><span class="c1"></span>	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h3 id="5-select-的逻辑">5. select 的逻辑</h3>
<ul>
<li>首先看下空的select</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">select</span> <span class="p">{}</span>
<span class="p">}</span>
<span class="c1">// 这里直接被优化为block
</span><span class="c1"></span><span class="k">go</span> <span class="nx">tool</span> <span class="nx">compile</span> <span class="o">-</span><span class="nx">S</span> <span class="k">select</span><span class="o">/</span><span class="nx">select源码分析</span><span class="p">.</span><span class="k">go</span><span class="p">|</span><span class="nx">grep</span> <span class="nx">runtime</span>
	<span class="mh">0x0020</span> <span class="mo">00032</span> <span class="p">(</span><span class="k">select</span><span class="o">/</span><span class="nx">select源码分析</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">4</span><span class="p">)</span>	<span class="nx">CALL</span>	<span class="nx">runtime</span><span class="p">.</span><span class="nf">block</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
	<span class="mh">0x0026</span> <span class="mo">0003</span><span class="mi">8</span> <span class="p">(</span><span class="k">select</span><span class="o">/</span><span class="nx">select源码分析</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">3</span><span class="p">)</span>	<span class="nx">CALL</span>	<span class="nx">runtime</span><span class="p">.</span><span class="nf">morestack_noctxt</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
	<span class="nx">rel</span> <span class="mi">33</span><span class="o">+</span><span class="mi">4</span> <span class="nx">t</span><span class="p">=</span><span class="mi">8</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">block</span><span class="o">+</span><span class="mi">0</span>
	<span class="nx">rel</span> <span class="mi">39</span><span class="o">+</span><span class="mi">4</span> <span class="nx">t</span><span class="p">=</span><span class="mi">8</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">morestack_noctxt</span><span class="o">+</span><span class="mi">0</span>
</code></pre></div><ul>
<li>仅default,没有case的情况</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">select</span> <span class="p">{</span>
	<span class="k">default</span><span class="p">:</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 这里更是优化什么也没执行
</span><span class="c1"></span><span class="k">go</span> <span class="nx">tool</span> <span class="nx">compile</span> <span class="o">-</span><span class="nx">S</span> <span class="k">select</span><span class="o">/</span><span class="nx">select源码分析</span><span class="p">.</span><span class="k">go</span>
<span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">main</span> <span class="nx">STEXT</span> <span class="nx">nosplit</span> <span class="nx">size</span><span class="p">=</span><span class="mi">1</span> <span class="nx">args</span><span class="p">=</span><span class="mh">0x0</span> <span class="nx">locals</span><span class="p">=</span><span class="mh">0x0</span> <span class="nx">funcid</span><span class="p">=</span><span class="mh">0x0</span>
	<span class="mh">0x0000</span> <span class="mo">00000</span> <span class="p">(</span><span class="k">select</span><span class="o">/</span><span class="nx">select源码分析</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">3</span><span class="p">)</span>	<span class="nx">TEXT</span>	<span class="s">&#34;&#34;</span><span class="p">.</span><span class="nf">main</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">NOSPLIT</span><span class="p">|</span><span class="nx">ABIInternal</span><span class="p">,</span> <span class="err">$</span><span class="mi">0</span><span class="o">-</span><span class="mi">0</span>
	<span class="mh">0x0000</span> <span class="mo">00000</span> <span class="p">(</span><span class="k">select</span><span class="o">/</span><span class="nx">select源码分析</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>	<span class="nx">RET</span>
</code></pre></div><ul>
<li>仅一个case的时候</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">c</span> <span class="o">&lt;-</span> <span class="mi">1</span><span class="p">:</span>   <span class="c1">// 会优化为if c &lt;- 1 {}
</span><span class="c1"></span>	<span class="k">default</span><span class="p">:</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 这里会直接调用到 runtime.selectnbsend ,如果是读就调用 runtime.selectnbrecv
</span><span class="c1"></span><span class="k">go</span> <span class="nx">tool</span> <span class="nx">compile</span> <span class="o">-</span><span class="nx">S</span> <span class="k">select</span><span class="o">/</span><span class="nx">select源码分析</span><span class="p">.</span><span class="k">go</span><span class="p">|</span><span class="nx">grep</span> <span class="nx">runtime</span>
	<span class="mh">0x0031</span> <span class="mo">0004</span><span class="mi">9</span> <span class="p">(</span><span class="k">select</span><span class="o">/</span><span class="nx">select源码分析</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">4</span><span class="p">)</span>	<span class="nx">CALL</span>	<span class="nx">runtime</span><span class="p">.</span><span class="nf">makechan</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
	<span class="mh">0x0057</span> <span class="mo">000</span><span class="mi">87</span> <span class="p">(</span><span class="k">select</span><span class="o">/</span><span class="nx">select源码分析</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>	<span class="nx">CALL</span>	<span class="nx">runtime</span><span class="p">.</span><span class="nf">selectnbsend</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
	<span class="mh">0x0080</span> <span class="mo">0012</span><span class="mi">8</span> <span class="p">(</span><span class="k">select</span><span class="o">/</span><span class="nx">select源码分析</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">3</span><span class="p">)</span>	<span class="nx">CALL</span>	<span class="nx">runtime</span><span class="p">.</span><span class="nf">morestack_noctxt</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>

<span class="c1">// selectnbsend是一个带bool返回值的chansend的封装
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">selectnbsend</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">elem</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">(</span><span class="nx">selected</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">chansend</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">elem</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="nf">getcallerpc</span><span class="p">())</span>
<span class="p">}</span>

<span class="c1">// selectnbrecv同样是一个带bool返回值的chanrecv的封装
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">selectnbrecv</span><span class="p">(</span><span class="nx">elem</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">)</span> <span class="p">(</span><span class="nx">selected</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">selected</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nf">chanrecv</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">elem</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>超过一个case的时候</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">c</span> <span class="o">&lt;-</span> <span class="mi">1</span><span class="p">:</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">c</span><span class="p">:</span>
	<span class="k">default</span><span class="p">:</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 这里会直接调用到selectgo, heap sort随机化分支的触发顺序
</span><span class="c1"></span><span class="k">go</span> <span class="nx">tool</span> <span class="nx">compile</span> <span class="o">-</span><span class="nx">S</span> <span class="k">select</span><span class="o">/</span><span class="nx">select源码分析</span><span class="p">.</span><span class="k">go</span><span class="p">|</span><span class="nx">grep</span> <span class="nx">runtime</span>
	<span class="mh">0x0035</span> <span class="mo">00053</span> <span class="p">(</span><span class="k">select</span><span class="o">/</span><span class="nx">select源码分析</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">4</span><span class="p">)</span>	<span class="nx">CALL</span>	<span class="nx">runtime</span><span class="p">.</span><span class="nf">makechan</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
	<span class="mh">0x00a1</span> <span class="mo">00161</span> <span class="p">(</span><span class="k">select</span><span class="o">/</span><span class="nx">select源码分析</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>	<span class="nx">CALL</span>	<span class="nx">runtime</span><span class="p">.</span><span class="nf">selectgo</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
	<span class="mh">0x00d5</span> <span class="mo">00213</span> <span class="p">(</span><span class="k">select</span><span class="o">/</span><span class="nx">select源码分析</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">3</span><span class="p">)</span>	<span class="nx">CALL</span>	<span class="nx">runtime</span><span class="p">.</span><span class="nf">morestack_noctxt</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
</code></pre></div><ul>
<li>selectgo</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">scase</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">c</span>    <span class="o">*</span><span class="nx">hchan</span>         <span class="c1">// chan
</span><span class="c1"></span>	<span class="nx">elem</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// data element
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">selectgo</span><span class="p">(</span><span class="nx">cas0</span> <span class="o">*</span><span class="nx">scase</span><span class="p">,</span> <span class="nx">order0</span> <span class="o">*</span><span class="kt">uint16</span><span class="p">,</span> <span class="nx">pc0</span> <span class="o">*</span><span class="kt">uintptr</span><span class="p">,</span> <span class="nx">nsends</span><span class="p">,</span> <span class="nx">nrecvs</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">block</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">..</span>
	<span class="c1">// NOTE: In order to maintain a lean stack size, the number of scases
</span><span class="c1"></span>	<span class="c1">// is capped at 65536.
</span><span class="c1"></span>	<span class="nx">cas1</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">]</span><span class="nx">scase</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">cas0</span><span class="p">))</span>
	<span class="nx">order1</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">17</span><span class="p">]</span><span class="kt">uint16</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">order0</span><span class="p">))</span>
    <span class="c1">// 用于记录chan和data
</span><span class="c1"></span>	<span class="nx">ncases</span> <span class="o">:=</span> <span class="nx">nsends</span> <span class="o">+</span> <span class="nx">nrecvs</span>
	<span class="nx">scases</span> <span class="o">:=</span> <span class="nx">cas1</span><span class="p">[:</span><span class="nx">ncases</span><span class="p">:</span><span class="nx">ncases</span><span class="p">]</span>
    <span class="c1">// 存储channel的scases数组的索引,控制channel执行顺序
</span><span class="c1"></span>	<span class="nx">pollorder</span> <span class="o">:=</span> <span class="nx">order1</span><span class="p">[:</span><span class="nx">ncases</span><span class="p">:</span><span class="nx">ncases</span><span class="p">]</span>
    <span class="c1">// 随机锁
</span><span class="c1"></span>	<span class="nx">lockorder</span> <span class="o">:=</span> <span class="nx">order1</span><span class="p">[</span><span class="nx">ncases</span><span class="p">:][:</span><span class="nx">ncases</span><span class="p">:</span><span class="nx">ncases</span><span class="p">]</span>
    <span class="o">...</span>
    <span class="c1">// 这里主要是对scase中的chan判断是否nil,做一个elem初始化
</span><span class="c1"></span>    <span class="c1">// 另外对pollorder 进行随机处理
</span><span class="c1"></span>    <span class="nx">norder</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">scases</span> <span class="p">{</span>
		<span class="nx">cas</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">scases</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>

		<span class="c1">// Omit cases without channels from the poll and lock orders.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="kc">nil</span> <span class="c1">// allow GC
</span><span class="c1"></span>			<span class="k">continue</span>
		<span class="p">}</span>
        <span class="c1">// 首先随机生成一个uint32的j
</span><span class="c1"></span>		<span class="nx">j</span> <span class="o">:=</span> <span class="nf">fastrandn</span><span class="p">(</span><span class="nb">uint32</span><span class="p">(</span><span class="nx">norder</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="c1">// 然后从pollorder从把j索引的值覆盖给 norder的位置
</span><span class="c1"></span>		<span class="nx">pollorder</span><span class="p">[</span><span class="nx">norder</span><span class="p">]</span> <span class="p">=</span> <span class="nx">pollorder</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
        <span class="c1">// 把scases数组的索引, 存入到pollorder数组中
</span><span class="c1"></span>		<span class="nx">pollorder</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint16</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
        <span class="c1">// norder &lt;= i
</span><span class="c1"></span>		<span class="nx">norder</span><span class="o">++</span>
	<span class="p">}</span>
    <span class="c1">// norder &lt;= i的, 所以pollorder中不包括cas.c==nil的chan
</span><span class="c1"></span>	<span class="nx">pollorder</span> <span class="p">=</span> <span class="nx">pollorder</span><span class="p">[:</span><span class="nx">norder</span><span class="p">]</span>
	<span class="nx">lockorder</span> <span class="p">=</span> <span class="nx">lockorder</span><span class="p">[:</span><span class="nx">norder</span><span class="p">]</span>

    <span class="c1">// 堆排
</span><span class="c1"></span>	<span class="c1">// sort the cases by Hchan address to get the locking order.
</span><span class="c1"></span>	<span class="c1">// simple heap sort, to guarantee n log n time and constant stack footprint.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">lockorder</span> <span class="p">{</span>
		<span class="nx">j</span> <span class="o">:=</span> <span class="nx">i</span>
		<span class="c1">// Start with the pollorder to permute cases on the same channel.
</span><span class="c1"></span>		<span class="nx">c</span> <span class="o">:=</span> <span class="nx">scases</span><span class="p">[</span><span class="nx">pollorder</span><span class="p">[</span><span class="nx">i</span><span class="p">]].</span><span class="nx">c</span>
        <span class="c1">// 这里的sortkey() 就是hchan的地址
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">j</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">scases</span><span class="p">[</span><span class="nx">lockorder</span><span class="p">[(</span><span class="nx">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">]].</span><span class="nx">c</span><span class="p">.</span><span class="nf">sortkey</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">c</span><span class="p">.</span><span class="nf">sortkey</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">k</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
			<span class="nx">lockorder</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">lockorder</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span>
			<span class="nx">j</span> <span class="p">=</span> <span class="nx">k</span>
		<span class="p">}</span>
		<span class="nx">lockorder</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">pollorder</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">lockorder</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="nx">o</span> <span class="o">:=</span> <span class="nx">lockorder</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">c</span> <span class="o">:=</span> <span class="nx">scases</span><span class="p">[</span><span class="nx">o</span><span class="p">].</span><span class="nx">c</span>
		<span class="nx">lockorder</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">lockorder</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="nx">k</span> <span class="o">:=</span> <span class="nx">j</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
			<span class="k">if</span> <span class="nx">k</span> <span class="o">&gt;=</span> <span class="nx">i</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">k</span><span class="o">+</span><span class="mi">1</span> <span class="p">&lt;</span> <span class="nx">i</span> <span class="o">&amp;&amp;</span> <span class="nx">scases</span><span class="p">[</span><span class="nx">lockorder</span><span class="p">[</span><span class="nx">k</span><span class="p">]].</span><span class="nx">c</span><span class="p">.</span><span class="nf">sortkey</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">scases</span><span class="p">[</span><span class="nx">lockorder</span><span class="p">[</span><span class="nx">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]].</span><span class="nx">c</span><span class="p">.</span><span class="nf">sortkey</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">k</span><span class="o">++</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nf">sortkey</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">scases</span><span class="p">[</span><span class="nx">lockorder</span><span class="p">[</span><span class="nx">k</span><span class="p">]].</span><span class="nx">c</span><span class="p">.</span><span class="nf">sortkey</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">lockorder</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">lockorder</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span>
				<span class="nx">j</span> <span class="p">=</span> <span class="nx">k</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">lockorder</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">o</span>
	<span class="p">}</span>
    <span class="o">...</span>
	<span class="c1">// 所有chan加锁
</span><span class="c1"></span>	<span class="nf">sellock</span><span class="p">(</span><span class="nx">scases</span><span class="p">,</span> <span class="nx">lockorder</span><span class="p">)</span>

	<span class="kd">var</span> <span class="p">(</span>
		<span class="nx">gp</span>     <span class="o">*</span><span class="nx">g</span>
		<span class="nx">sg</span>     <span class="o">*</span><span class="nx">sudog</span>
		<span class="nx">c</span>      <span class="o">*</span><span class="nx">hchan</span>
		<span class="nx">k</span>      <span class="o">*</span><span class="nx">scase</span>
		<span class="nx">sglist</span> <span class="o">*</span><span class="nx">sudog</span>
		<span class="nx">sgnext</span> <span class="o">*</span><span class="nx">sudog</span>
		<span class="nx">qp</span>     <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
		<span class="nx">nextp</span>  <span class="o">**</span><span class="nx">sudog</span>
	<span class="p">)</span>

	<span class="c1">// 1  检查chan是否就绪(可send or recv)
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">casi</span> <span class="kt">int</span>
	<span class="kd">var</span> <span class="nx">cas</span> <span class="o">*</span><span class="nx">scase</span>
	<span class="kd">var</span> <span class="nx">caseSuccess</span> <span class="kt">bool</span>
	<span class="kd">var</span> <span class="nx">caseReleaseTime</span> <span class="kt">int64</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
	<span class="kd">var</span> <span class="nx">recvOK</span> <span class="kt">bool</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">casei</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">pollorder</span> <span class="p">{</span>
        <span class="c1">//
</span><span class="c1"></span>		<span class="nx">casi</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">casei</span><span class="p">)</span>
		<span class="nx">cas</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">scases</span><span class="p">[</span><span class="nx">casi</span><span class="p">]</span>
		<span class="nx">c</span> <span class="p">=</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">c</span>

		<span class="k">if</span> <span class="nx">casi</span> <span class="o">&gt;=</span> <span class="nx">nsends</span> <span class="p">{</span>
			<span class="nx">sg</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">sg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="nx">recv</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="nx">bufrecv</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="nx">rclose</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
				<span class="nf">racereadpc</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">(),</span> <span class="nf">casePC</span><span class="p">(</span><span class="nx">casi</span><span class="p">),</span> <span class="nx">chansendpc</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="nx">sclose</span>
			<span class="p">}</span>
			<span class="nx">sg</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">sg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="nx">send</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="p">&lt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="nx">bufsend</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
    <span class="c1">// 这里block是通过reflect_rselect函数中判断dflt==-1传入的, dflt只有在case default存在的时候才被修改
</span><span class="c1"></span>    <span class="c1">// 所以如果select中没有写default, 到这里后续就要阻塞了
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
		<span class="nf">selunlock</span><span class="p">(</span><span class="nx">scases</span><span class="p">,</span> <span class="nx">lockorder</span><span class="p">)</span>
		<span class="nx">casi</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
		<span class="k">goto</span> <span class="nx">retc</span>
	<span class="p">}</span>

	<span class="c1">// 2 入队所有的chan, 阻塞之前当然要保留case后阻塞的channel
</span><span class="c1"></span>	<span class="nx">gp</span> <span class="p">=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gp.waiting != nil&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">nextp</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">casei</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">lockorder</span> <span class="p">{</span>
		<span class="nx">casi</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">casei</span><span class="p">)</span>
		<span class="nx">cas</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">scases</span><span class="p">[</span><span class="nx">casi</span><span class="p">]</span>
		<span class="nx">c</span> <span class="p">=</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">c</span>
		<span class="nx">sg</span> <span class="o">:=</span> <span class="nf">acquireSudog</span><span class="p">()</span>
		<span class="nx">sg</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nx">gp</span>
		<span class="nx">sg</span><span class="p">.</span><span class="nx">isSelect</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="c1">// No stack splits between assigning elem and enqueuing
</span><span class="c1"></span>		<span class="c1">// sg on gp.waiting where copystack can find it.
</span><span class="c1"></span>		<span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span>
		<span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="k">if</span> <span class="nx">t0</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
		<span class="p">}</span>
		<span class="nx">sg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="nx">c</span>
		<span class="c1">// Construct waiting list in lock order.
</span><span class="c1"></span>		<span class="o">*</span><span class="nx">nextp</span> <span class="p">=</span> <span class="nx">sg</span>
		<span class="nx">nextp</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">sg</span><span class="p">.</span><span class="nx">waitlink</span>
        <span class="c1">// 对channel进行入队保存
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">casi</span> <span class="p">&lt;</span> <span class="nx">nsends</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="nx">sg</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="nx">sg</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store8</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">parkingOnChan</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1">// 阻塞
</span><span class="c1"></span>	<span class="nf">gopark</span><span class="p">(</span><span class="nx">selparkcommit</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">waitReasonSelect</span><span class="p">,</span> <span class="nx">traceEvGoBlockSelect</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">activeStackChans</span> <span class="p">=</span> <span class="kc">false</span>

	<span class="nf">sellock</span><span class="p">(</span><span class="nx">scases</span><span class="p">,</span> <span class="nx">lockorder</span><span class="p">)</span>

	<span class="nx">gp</span><span class="p">.</span><span class="nx">selectDone</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">sg</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">sudog</span><span class="p">)(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">param</span><span class="p">)</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>

	<span class="c1">// pass 3 - dequeue from unsuccessful chans
</span><span class="c1"></span>	<span class="c1">// otherwise they stack up on quiet channels
</span><span class="c1"></span>	<span class="c1">// record the successful case, if any.
</span><span class="c1"></span>	<span class="c1">// We singly-linked up the SudoGs in lock order.
</span><span class="c1"></span>	<span class="nx">casi</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
	<span class="nx">cas</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">caseSuccess</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="nx">sglist</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span>
	<span class="c1">// Clear all elem before unlinking from gp.waiting.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">sg1</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span><span class="p">;</span> <span class="nx">sg1</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">sg1</span> <span class="p">=</span> <span class="nx">sg1</span><span class="p">.</span><span class="nx">waitlink</span> <span class="p">{</span>
		<span class="nx">sg1</span><span class="p">.</span><span class="nx">isSelect</span> <span class="p">=</span> <span class="kc">false</span>
		<span class="nx">sg1</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="nx">sg1</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="kc">nil</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">casei</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">lockorder</span> <span class="p">{</span>
		<span class="nx">k</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">scases</span><span class="p">[</span><span class="nx">casei</span><span class="p">]</span>
		<span class="k">if</span> <span class="nx">sg</span> <span class="o">==</span> <span class="nx">sglist</span> <span class="p">{</span>
			<span class="c1">// sg has already been dequeued by the G that woke us up.
</span><span class="c1"></span>			<span class="nx">casi</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">casei</span><span class="p">)</span>
			<span class="nx">cas</span> <span class="p">=</span> <span class="nx">k</span>
			<span class="nx">caseSuccess</span> <span class="p">=</span> <span class="nx">sglist</span><span class="p">.</span><span class="nx">success</span>
			<span class="k">if</span> <span class="nx">sglist</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">caseReleaseTime</span> <span class="p">=</span> <span class="nx">sglist</span><span class="p">.</span><span class="nx">releasetime</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">c</span> <span class="p">=</span> <span class="nx">k</span><span class="p">.</span><span class="nx">c</span>
			<span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="nx">casei</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">nsends</span> <span class="p">{</span>
				<span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">dequeueSudoG</span><span class="p">(</span><span class="nx">sglist</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">dequeueSudoG</span><span class="p">(</span><span class="nx">sglist</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">sgnext</span> <span class="p">=</span> <span class="nx">sglist</span><span class="p">.</span><span class="nx">waitlink</span>
		<span class="nx">sglist</span><span class="p">.</span><span class="nx">waitlink</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="nf">releaseSudog</span><span class="p">(</span><span class="nx">sglist</span><span class="p">)</span>
		<span class="nx">sglist</span> <span class="p">=</span> <span class="nx">sgnext</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">cas</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;selectgo: bad wakeup&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">c</span> <span class="p">=</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">c</span>

	<span class="k">if</span> <span class="nx">debugSelect</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;wait-return: cas0=&#34;</span><span class="p">,</span> <span class="nx">cas0</span><span class="p">,</span> <span class="s">&#34; c=&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="s">&#34; cas=&#34;</span><span class="p">,</span> <span class="nx">cas</span><span class="p">,</span> <span class="s">&#34; send=&#34;</span><span class="p">,</span> <span class="nx">casi</span> <span class="p">&lt;</span> <span class="nx">nsends</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">casi</span> <span class="p">&lt;</span> <span class="nx">nsends</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">caseSuccess</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="nx">sclose</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">recvOK</span> <span class="p">=</span> <span class="nx">caseSuccess</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">casi</span> <span class="p">&lt;</span> <span class="nx">nsends</span> <span class="p">{</span>
			<span class="nf">raceReadObjectPC</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nf">casePC</span><span class="p">(</span><span class="nx">casi</span><span class="p">),</span> <span class="nx">chansendpc</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">raceWriteObjectPC</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nf">casePC</span><span class="p">(</span><span class="nx">casi</span><span class="p">),</span> <span class="nx">chanrecvpc</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">msanenabled</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">casi</span> <span class="p">&lt;</span> <span class="nx">nsends</span> <span class="p">{</span>
			<span class="nf">msanread</span><span class="p">(</span><span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">msanwrite</span><span class="p">(</span><span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nf">selunlock</span><span class="p">(</span><span class="nx">scases</span><span class="p">,</span> <span class="nx">lockorder</span><span class="p">)</span>
	<span class="k">goto</span> <span class="nx">retc</span>

<span class="nx">bufrecv</span><span class="p">:</span>
	<span class="c1">// can receive from buffer
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">raceWriteObjectPC</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nf">casePC</span><span class="p">(</span><span class="nx">casi</span><span class="p">),</span> <span class="nx">chanrecvpc</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nf">racenotify</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">msanenabled</span> <span class="o">&amp;&amp;</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">msanwrite</span><span class="p">(</span><span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">recvOK</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="nx">qp</span> <span class="p">=</span> <span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">qp</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">qp</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="o">++</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span><span class="o">--</span>
	<span class="nf">selunlock</span><span class="p">(</span><span class="nx">scases</span><span class="p">,</span> <span class="nx">lockorder</span><span class="p">)</span>
	<span class="k">goto</span> <span class="nx">retc</span>

<span class="nx">bufsend</span><span class="p">:</span>
	<span class="c1">// can send to buffer
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nf">racenotify</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="nf">raceReadObjectPC</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nf">casePC</span><span class="p">(</span><span class="nx">casi</span><span class="p">),</span> <span class="nx">chansendpc</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">msanenabled</span> <span class="p">{</span>
		<span class="nf">msanread</span><span class="p">(</span><span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="p">),</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="o">++</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span><span class="o">++</span>
	<span class="nf">selunlock</span><span class="p">(</span><span class="nx">scases</span><span class="p">,</span> <span class="nx">lockorder</span><span class="p">)</span>
	<span class="k">goto</span> <span class="nx">retc</span>

<span class="nx">recv</span><span class="p">:</span>
	<span class="c1">// can receive from sleeping sender (sg)
</span><span class="c1"></span>	<span class="nf">recv</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nf">selunlock</span><span class="p">(</span><span class="nx">scases</span><span class="p">,</span> <span class="nx">lockorder</span><span class="p">)</span> <span class="p">},</span> <span class="mi">2</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">debugSelect</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;syncrecv: cas0=&#34;</span><span class="p">,</span> <span class="nx">cas0</span><span class="p">,</span> <span class="s">&#34; c=&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">recvOK</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="k">goto</span> <span class="nx">retc</span>

<span class="nx">rclose</span><span class="p">:</span>
	<span class="c1">// read at end of closed channel
</span><span class="c1"></span>	<span class="nf">selunlock</span><span class="p">(</span><span class="nx">scases</span><span class="p">,</span> <span class="nx">lockorder</span><span class="p">)</span>
	<span class="nx">recvOK</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="k">if</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nf">raceacquire</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
	<span class="p">}</span>
	<span class="k">goto</span> <span class="nx">retc</span>

<span class="nx">send</span><span class="p">:</span>
	<span class="c1">// can send to a sleeping receiver (sg)
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nf">raceReadObjectPC</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nf">casePC</span><span class="p">(</span><span class="nx">casi</span><span class="p">),</span> <span class="nx">chansendpc</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">msanenabled</span> <span class="p">{</span>
		<span class="nf">msanread</span><span class="p">(</span><span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">send</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nf">selunlock</span><span class="p">(</span><span class="nx">scases</span><span class="p">,</span> <span class="nx">lockorder</span><span class="p">)</span> <span class="p">},</span> <span class="mi">2</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">debugSelect</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;syncsend: cas0=&#34;</span><span class="p">,</span> <span class="nx">cas0</span><span class="p">,</span> <span class="s">&#34; c=&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">goto</span> <span class="nx">retc</span>

<span class="nx">retc</span><span class="p">:</span>
	<span class="k">if</span> <span class="nx">caseReleaseTime</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">blockevent</span><span class="p">(</span><span class="nx">caseReleaseTime</span><span class="o">-</span><span class="nx">t0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">casi</span><span class="p">,</span> <span class="nx">recvOK</span>

<span class="nx">sclose</span><span class="p">:</span>
	<span class="c1">// send on closed channel
</span><span class="c1"></span>	<span class="nf">selunlock</span><span class="p">(</span><span class="nx">scases</span><span class="p">,</span> <span class="nx">lockorder</span><span class="p">)</span>
	<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;send on closed channel&#34;</span><span class="p">))</span>
<span class="p">}</span>

</code></pre></div><blockquote>
<p>具体的select如果优化可以查看 <code>cmd/compile/internal/gc/select.go</code>的<code>walkselectcases</code>函数</p>
</blockquote>
<h3 id="简单总结">简单总结</h3>
<ul>
<li>
<p>channel</p>
<ul>
<li>
<ol>
<li>channel的实现核心结构体hchan, 主要实现是一个环型buf数组,阻塞的时候会添加到一个waitq的双向链表中</li>
</ol>
</li>
<li>
<ol start="2">
<li>双向链表通过sudog实现,sudog会记录goroutine,elem,channel等状态,等到非阻塞时直接将elem地址的内容给发送者或接受者,或者添加到对应channel的buf中</li>
</ol>
</li>
<li>
<ol start="3">
<li>channel的底层都是通过chanrecv和chansend来实现, selectgo主要是通过block的设置来实现非阻塞操作</li>
</ol>
</li>
<li>
<ol start="4">
<li>chanrecv和chansend都是需要通过锁来操作的, 本质是通过共享内存的方式实现的</li>
</ol>
</li>
</ul>
</li>
<li>
<p>select</p>
<ul>
<li>
<ol>
<li>select的selectgo的实现主要是通过block参数设置调用chanrecv或chansend 实现非阻塞操作, 当select中存在default分支时,block在为false,其他情况都是阻塞操作</li>
</ol>
</li>
<li>
<ol start="2">
<li>selectgo 会将每个case的channel索引组成的数组pollorder 进行随机排序 并同时剔除nil channel, 如果存在可发送或者可读取的case 就直接跳转, 如果都没有就判断是否block(即走default),最后会阻塞等待</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="附录">附录</h3>
<blockquote>
<p>bilibili的声音延迟需要设置, youtube正常</p>
</blockquote>
<ul>
<li><a href="https://www.youtube.com/watch?v=d7fFCGGn0Wc">go夜读 channel和select源码分析 youtube</a></li>
<li><a href="https://www.bilibili.com/video/av64926593/">go夜读 channel和select源码分析 bilibili</a></li>
<li><a href="https://docs.google.com/presentation/d/18_9LcMc8u93aITZ6DqeUfRvOcHQYj2gwxhskf0XPX2U/edit#slide=id.g5f3bb3206c_0_5">go夜读 channel和select源码分析 ppt文档</a></li>
<li><a href="https://golang.design/under-the-hood/zh-cn/part1basic/ch03lang/chan/">go语言原本</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/297053654">golang channel 最详细的源码剖析</a></li>
<li><a href="https://blog.csdn.net/a52219600830369/article/details/101143124">golang mcall</a></li>
<li><a href="https://blog.csdn.net/u010853261/article/details/85887948">gopark和goready函数</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Go算法学习 链表 设计链表</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E9%93%BE%E8%A1%A8-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</link>
			<pubDate>Fri, 16 Jul 2021 14:07:27 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E9%93%BE%E8%A1%A8-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</guid>
			<description>show me the code package main import ( &amp;#34;fmt&amp;#34; ) // https://leetcode-cn.com/problems/design-linked-list/  type MyLinkedList struct { Len int // 判断索引是否有效 	Dummy *Node // 伪头, 第-1号索引, .Next 才是 MyLinkedList的第0号索引的内容 } type Node struct { Val int // value 	Next *Node // 链 } // Constructor Initialize your data structure here. func Constructor() MyLinkedList { return MyLinkedList{ Len: 0, // 不包括伪头, 所以是0 	Dummy: &amp;amp;Node{}, // 初始化伪头 	} } // Get the value of the index-th node in the linked list.</description>
			<content type="html"><![CDATA[<h3 id="show-me-the-code">show me the code</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="c1">// https://leetcode-cn.com/problems/design-linked-list/
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">MyLinkedList</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Len</span>   <span class="kt">int</span>   <span class="c1">// 判断索引是否有效
</span><span class="c1"></span>	<span class="nx">Dummy</span> <span class="o">*</span><span class="nx">Node</span> <span class="c1">// 伪头, 第-1号索引, .Next 才是 MyLinkedList的第0号索引的内容
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">Node</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Val</span>  <span class="kt">int</span>   <span class="c1">// value
</span><span class="c1"></span>	<span class="nx">Next</span> <span class="o">*</span><span class="nx">Node</span> <span class="c1">// 链
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// Constructor Initialize your data structure here.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Constructor</span><span class="p">()</span> <span class="nx">MyLinkedList</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">MyLinkedList</span><span class="p">{</span>
		<span class="nx">Len</span><span class="p">:</span>   <span class="mi">0</span><span class="p">,</span>       <span class="c1">// 不包括伪头, 所以是0
</span><span class="c1"></span>		<span class="nx">Dummy</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">Node</span><span class="p">{},</span> <span class="c1">// 初始化伪头
</span><span class="c1"></span>	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Get the value of the index-th node in the linked list. If the index is invalid, return -1.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">my</span> <span class="o">*</span><span class="nx">MyLinkedList</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">index</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c1">// 索引范围是 [0,my.Len),左闭右开
</span><span class="c1"></span>	<span class="c1">// 所以需要小于my.Len
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">index</span> <span class="o">&gt;=</span> <span class="nx">my</span><span class="p">.</span><span class="nx">Len</span> <span class="o">&amp;&amp;</span> <span class="nx">index</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
	<span class="p">}</span>
	<span class="c1">// 指向第0号元素
</span><span class="c1"></span>	<span class="nx">curr</span> <span class="o">:=</span> <span class="nx">my</span><span class="p">.</span><span class="nx">Dummy</span><span class="p">.</span><span class="nx">Next</span>
	<span class="c1">// 找到索引位置
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">;</span> <span class="nx">index</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">index</span><span class="o">--</span> <span class="p">{</span>
		<span class="nx">curr</span> <span class="p">=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Next</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Val</span>
<span class="p">}</span>

<span class="c1">// AddAtHead Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">my</span> <span class="o">*</span><span class="nx">MyLinkedList</span><span class="p">)</span> <span class="nf">AddAtHead</span><span class="p">(</span><span class="nx">val</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">my</span><span class="p">.</span><span class="nf">AddAtIndex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// AddAtTail Append a node of value val to the last element of the linked list. */
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">my</span> <span class="o">*</span><span class="nx">MyLinkedList</span><span class="p">)</span> <span class="nf">AddAtTail</span><span class="p">(</span><span class="nx">val</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">my</span><span class="p">.</span><span class="nf">AddAtIndex</span><span class="p">(</span><span class="nx">my</span><span class="p">.</span><span class="nx">Len</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// AddAtIndex  Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">my</span> <span class="o">*</span><span class="nx">MyLinkedList</span><span class="p">)</span> <span class="nf">AddAtIndex</span><span class="p">(</span><span class="nx">index</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">index</span> <span class="p">&gt;</span> <span class="nx">my</span><span class="p">.</span><span class="nx">Len</span> <span class="o">||</span> <span class="nx">index</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">//  指向第-1号元素(伪头)
</span><span class="c1"></span>	<span class="nx">pre</span> <span class="o">:=</span> <span class="nx">my</span><span class="p">.</span><span class="nx">Dummy</span>
	<span class="c1">// 找到需要删除的索引位置的前置节点pre
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">;</span> <span class="nx">index</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">index</span><span class="o">--</span> <span class="p">{</span>
		<span class="nx">pre</span> <span class="p">=</span> <span class="nx">pre</span><span class="p">.</span><span class="nx">Next</span>
	<span class="p">}</span>
	<span class="c1">// 插入
</span><span class="c1"></span>	<span class="nx">pre</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Node</span><span class="p">{</span><span class="nx">val</span><span class="p">,</span> <span class="nx">pre</span><span class="p">.</span><span class="nx">Next</span><span class="p">}</span>
	<span class="nx">my</span><span class="p">.</span><span class="nx">Len</span><span class="o">++</span>

<span class="p">}</span>

<span class="c1">// DeleteAtIndex Delete the index-th node in the linked list, if the index is valid.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">my</span> <span class="o">*</span><span class="nx">MyLinkedList</span><span class="p">)</span> <span class="nf">DeleteAtIndex</span><span class="p">(</span><span class="nx">index</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 索引是从0到my.Len-1的, 所以大于等于 都是直接return
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">index</span> <span class="o">&gt;=</span> <span class="nx">my</span><span class="p">.</span><span class="nx">Len</span> <span class="o">&amp;&amp;</span> <span class="nx">index</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// 指向第-1号元素(伪头)
</span><span class="c1"></span>	<span class="nx">pre</span> <span class="o">:=</span> <span class="nx">my</span><span class="p">.</span><span class="nx">Dummy</span>
	<span class="c1">// 找到需要删除的索引位置的前置节点pre
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">;</span> <span class="nx">index</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">index</span><span class="o">--</span> <span class="p">{</span>
		<span class="nx">pre</span> <span class="p">=</span> <span class="nx">pre</span><span class="p">.</span><span class="nx">Next</span>
	<span class="p">}</span>
	<span class="c1">// 通过前置节点pre 直接删除对应索引的节点
</span><span class="c1"></span>	<span class="nx">pre</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">pre</span><span class="p">.</span><span class="nx">Next</span><span class="p">.</span><span class="nx">Next</span>
	<span class="nx">my</span><span class="p">.</span><span class="nx">Len</span><span class="o">--</span>
<span class="p">}</span>

<span class="cm">/**
</span><span class="cm"> * Your MyLinkedList object will be instantiated and called as such:
</span><span class="cm"> * obj := Constructor();
</span><span class="cm"> * param_1 := obj.Get(index);
</span><span class="cm"> * obj.AddAtHead(val);
</span><span class="cm"> * obj.AddAtTail(val);
</span><span class="cm"> * obj.AddAtIndex(index,val);
</span><span class="cm"> * obj.DeleteAtIndex(index);
</span><span class="cm"> */</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">my</span> <span class="o">*</span><span class="nx">MyLinkedList</span><span class="p">)</span> <span class="nf">Print</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">curr</span> <span class="o">:=</span> <span class="nx">my</span><span class="p">.</span><span class="nx">Dummy</span><span class="p">.</span><span class="nx">Next</span>
	<span class="k">for</span> <span class="nx">curr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v &#34;</span><span class="p">,</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
		<span class="nx">curr</span> <span class="p">=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Next</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">my</span> <span class="o">*</span><span class="nx">MyLinkedList</span><span class="p">)</span> <span class="nf">Run</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">val</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="nx">s</span> <span class="p">{</span>
	<span class="k">case</span> <span class="s">&#34;addAtHead&#34;</span><span class="p">:</span>
		<span class="nx">my</span><span class="p">.</span><span class="nf">AddAtHead</span><span class="p">(</span><span class="nx">val</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="k">case</span> <span class="s">&#34;addAtTail&#34;</span><span class="p">:</span>
		<span class="nx">my</span><span class="p">.</span><span class="nf">AddAtTail</span><span class="p">(</span><span class="nx">val</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="k">case</span> <span class="s">&#34;addAtIndex&#34;</span><span class="p">:</span>
		<span class="nx">my</span><span class="p">.</span><span class="nf">AddAtIndex</span><span class="p">(</span><span class="nx">val</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">val</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
	<span class="k">case</span> <span class="s">&#34;deleteAtIndex&#34;</span><span class="p">:</span>
		<span class="nx">my</span><span class="p">.</span><span class="nf">DeleteAtIndex</span><span class="p">(</span><span class="nx">val</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="k">case</span> <span class="s">&#34;get&#34;</span><span class="p">:</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">my</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;unknown function &#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Run function :&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="s">&#34;args :&#34;</span><span class="p">,</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">my</span><span class="p">.</span><span class="nx">Len</span><span class="p">)</span>

<span class="p">}</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">func1</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;addAtHead&#34;</span><span class="p">,</span> <span class="s">&#34;addAtTail&#34;</span><span class="p">,</span> <span class="s">&#34;addAtIndex&#34;</span><span class="p">,</span> <span class="s">&#34;get&#34;</span><span class="p">,</span> <span class="s">&#34;deleteAtIndex&#34;</span><span class="p">,</span> <span class="s">&#34;get&#34;</span><span class="p">}</span>
	<span class="nx">args1</span> <span class="o">:=</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">{{</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">3</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">}}</span>

	<span class="nx">myLink</span> <span class="o">:=</span> <span class="nf">Constructor</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">func1</span> <span class="p">{</span>
		<span class="nx">myLink</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="nx">func1</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">args1</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="nx">myLink</span><span class="p">.</span><span class="nf">Print</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go算法学习 动态规划 01背包基础</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-01%E8%83%8C%E5%8C%85%E5%9F%BA%E7%A1%80/</link>
			<pubDate>Mon, 07 Jun 2021 10:06:09 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-01%E8%83%8C%E5%8C%85%E5%9F%BA%E7%A1%80/</guid>
			<description>参考文档  carl 背包理论基础01背包 二维dp carl 背包理论基础01背包 一维dp  背包问题分类 01背包例子 题目说明: 有一堆物品, 背包的容量只有j,想要拿走最贵的东西,怎么装? weight := []int{1,3,4} //kg price := []int{15,20,30} //¥  01背包说明: 每个物品只能使用一次
 动态规划五部曲 1. 定义dp数组 这里我们定义一个dp[i][j]的数组 i代表 物品的下标,0,1,2&amp;hellip; j代表 背包的容量,1kg,3kg,4kg&amp;hellip; dp[i][j]代表 可选的i个物品中,容量为j的背包能装下最大为dp[i][j]的价值
 这里i个物品 是有两种状态, 选择 和不选择
 2. 确定推导公式 首先我们可以想到i个物品的dp[i][j] 是可以由 i-1个物品的情况下, 选择i转入背包 和不装入背包两种情况得到的 那不装入物品i的价值 = dp[i-1][j] 那装入了物品i的价值 = dp[i-1][j-weight[i]] + price[i], 显然装了东西, 背包容量肯定减少, 总价值肯定是增加 那我们dp[i][j] 应该选择哪种情况呢? 答案是选择更大价值的 dp[i][j] = max(dp[i-1][j] , dp[i-1][j-weight[i]] + price[i] ) 3.</description>
			<content type="html"><![CDATA[<h3 id="参考文档">参考文档</h3>
<ul>
<li><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.md">carl 背包理论基础01背包 二维dp</a></li>
<li><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.md">carl 背包理论基础01背包 一维dp</a></li>
</ul>
<h3 id="背包问题分类">背包问题分类</h3>
<p><img src="/assets/markdown-img-paste-20210607100754609.png" alt=""></p>
<h3 id="01背包例子">01背包例子</h3>
<h4 id="题目说明">题目说明:</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">有一堆物品</span><span class="p">,</span> <span class="nx">背包的容量只有j</span><span class="p">,</span><span class="nx">想要拿走最贵的东西</span><span class="p">,</span><span class="nx">怎么装</span><span class="err">?</span>
<span class="nx">weight</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">}</span>  <span class="c1">//kg
</span><span class="c1"></span><span class="nx">price</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">15</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">}</span>    <span class="c1">//¥
</span></code></pre></div><blockquote>
<p>01背包说明: 每个物品只能使用一次</p>
</blockquote>
<h3 id="动态规划五部曲">动态规划五部曲</h3>
<h4 id="1-定义dp数组">1. 定义dp数组</h4>
<p>这里我们定义一个dp[i][j]的数组
i代表 物品的下标,0,1,2&hellip;
j代表 背包的容量,1kg,3kg,4kg&hellip;
dp[i][j]代表 可选的i个物品中,容量为j的背包能装下最大为dp[i][j]的价值</p>
<blockquote>
<p>这里i个物品 是有两种状态, 选择 和不选择</p>
</blockquote>
<h4 id="2-确定推导公式">2. 确定推导公式</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">首先我们可以想到i个物品的dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="nx">是可以由</span> <span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="nx">个物品的情况下</span><span class="p">,</span> <span class="nx">选择i转入背包</span> <span class="nx">和不装入背包两种情况得到的</span>
<span class="nx">那不装入物品i的价值</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span>
<span class="nx">那装入了物品i的价值</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">+</span> <span class="nx">price</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">显然装了东西</span><span class="p">,</span> <span class="nx">背包容量肯定减少</span><span class="p">,</span> <span class="nx">总价值肯定是增加</span>
<span class="nx">那我们dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="nx">应该选择哪种情况呢</span><span class="err">?</span>
<span class="nx">答案是选择更大价值的</span>
<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">,</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">+</span> <span class="nx">price</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">)</span>
</code></pre></div><h4 id="3-初始化">3. 初始化</h4>
<ul>
<li>dp[0][0]</li>
</ul>
<pre><code>现在有i=0 这一个物品可以选择,j=0 说明背包大小是0
那我们只能不选择 重量为weight[0]的物品, 因为装不下嘛
那么什么也没装, 我们的dp[0][0] = 0
</code></pre><ul>
<li>dp[i][0]</li>
</ul>
<pre><code>这种情况, 背包容量都是0, 所以dp[i][0] = 0
</code></pre><ul>
<li>dp[0][j]</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">对于这种情况</span><span class="p">,</span><span class="nx">我们要判断背包容量j</span> <span class="nx">是否大于等于</span> <span class="nx">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">只要大于就装入背包</span>
<span class="k">for</span> <span class="nx">j</span><span class="o">:=</span> <span class="nx">bagWeight</span> <span class="p">;</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="nx">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">;</span> <span class="nx">j</span><span class="o">--</span> <span class="p">{</span>
    <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="nx">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">+</span> <span class="nx">price</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div><h4 id="4-遍历的顺序">4. 遍历的顺序</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">从3</span><span class="p">.</span><span class="nx">初始化</span> <span class="nx">步骤我们可以看到</span><span class="p">,</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span><span class="nx">的遍历是倒序的</span><span class="p">,</span> <span class="nx">为啥需要倒序呢</span><span class="err">?</span>

<span class="nx">首先我们看下如果正序会怎么样</span><span class="p">:</span>
<span class="k">for</span> <span class="nx">j</span><span class="o">:=</span> <span class="nx">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">bagWeight</span> <span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="nx">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">+</span> <span class="nx">price</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span>
<span class="c1">//weight := []int{1,3,4}  //kg
</span><span class="c1">//price := []int{15,20,30}    //¥
</span><span class="c1"></span>
<span class="nx">这里weight</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">bagWeight</span> <span class="p">=</span><span class="mi">4</span>
<span class="nx">当j</span><span class="p">=</span><span class="mi">1</span><span class="nx">时</span>      <span class="p">,</span>  <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">15</span> <span class="p">=</span> <span class="mi">15</span>
<span class="nx">当j</span><span class="p">=</span><span class="mi">2</span><span class="nx">时</span>      <span class="p">,</span>  <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">15</span> <span class="p">=</span><span class="mi">30</span> <span class="c1">// 显然这里price[0]被取了两次
</span><span class="c1"></span>

<span class="nx">我们再来看下倒序的过程</span><span class="p">:</span>
<span class="k">for</span> <span class="nx">j</span><span class="o">:=</span> <span class="nx">bagWeight</span> <span class="p">;</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="nx">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">;</span> <span class="nx">j</span><span class="o">--</span> <span class="p">{</span>
    <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="nx">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">+</span> <span class="nx">price</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span>

<span class="nx">j</span><span class="p">=</span><span class="mi">4</span>       <span class="p">,</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="mi">15</span> <span class="p">=</span> <span class="mi">15</span>
<span class="nx">j</span><span class="p">=</span><span class="mi">3</span>       <span class="p">,</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">15</span> <span class="p">=</span> <span class="mi">15</span>
<span class="nx">j</span><span class="p">=</span><span class="mi">2</span>       <span class="p">,</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">15</span> <span class="p">=</span> <span class="mi">15</span>
<span class="nx">j</span><span class="p">=</span><span class="mi">1</span>       <span class="p">,</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">15</span> <span class="p">=</span> <span class="mi">15</span>

<span class="nx">因为我们的推导公式遍历的顺序</span> <span class="nx">同样倒序遍历j会更方便</span>
</code></pre></div><h4 id="5-自己手工写一下结果是否正确">5. 自己手工写一下结果是否正确</h4>
<p><img src="/assets/markdown-img-paste-20210607112304945.png" alt=""></p>
<h3 id="show-me-the-code">show me the code</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">test_2_wei_bag_problem</span><span class="p">(</span><span class="nx">weight</span><span class="p">,</span> <span class="nx">price</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">target</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c1">// 定义dp数组
</span><span class="c1"></span>	<span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">weight</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dp</span> <span class="p">{</span>
		<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">target</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 初始化
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">weight</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="nx">target</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="nx">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="nx">j</span><span class="o">--</span> <span class="p">{</span>
		<span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="nx">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="nx">price</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="c1">// 推导公式
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">weight</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// 正序, j从0 开始
</span><span class="c1"></span>		<span class="c1">//[0 15 15 15 15]
</span><span class="c1"></span>		<span class="c1">//[0 15 15 20 35]
</span><span class="c1"></span>		<span class="c1">//[0 15 15 20 35]
</span><span class="c1"></span>		<span class="c1">//for  j := 0;j&lt;= target ; j++ {
</span><span class="c1"></span>		<span class="c1">//	if j &lt; weight[i] {
</span><span class="c1"></span>		<span class="c1">//		// 因为只有这一种情况, 没办法拿到dp[i-1][j-weight[i]]
</span><span class="c1"></span>		<span class="c1">//		dp[i][j] = dp[i-1][j]
</span><span class="c1"></span>		<span class="c1">//	}else {
</span><span class="c1"></span>		<span class="c1">//		dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+price[i])
</span><span class="c1"></span>		<span class="c1">//	}
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">//}
</span><span class="c1"></span>		<span class="c1">// 正序, 舍弃无用的遍历
</span><span class="c1"></span>		<span class="c1">//[0 15 15 15 15]
</span><span class="c1"></span>		<span class="c1">//[0 0  0  20 35]
</span><span class="c1"></span>		<span class="c1">//[0 0  0  0  35]
</span><span class="c1"></span>		<span class="k">for</span>  <span class="nx">j</span> <span class="o">:=</span> <span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span><span class="nx">j</span><span class="o">&lt;=</span> <span class="nx">target</span> <span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="o">+</span><span class="nx">price</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="p">}</span>
		<span class="c1">// 倒序
</span><span class="c1"></span>		<span class="c1">//[0 15 15 15 15]
</span><span class="c1"></span>		<span class="c1">//[0 0  0  20 35]
</span><span class="c1"></span>		<span class="c1">//[0 0  0  0  35]
</span><span class="c1"></span>		<span class="c1">//for j := target; j &gt;= weight[i]; j-- {
</span><span class="c1"></span>		<span class="c1">//	dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+price[i])
</span><span class="c1"></span>		<span class="c1">//}
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span> <span class="p">;</span><span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">dp</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">weight</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">target</span><span class="p">]</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">weight</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">}</span>
	<span class="nx">price</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">15</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">}</span>
	<span class="nf">bag01</span><span class="p">(</span><span class="nx">weight</span><span class="p">,</span><span class="nx">price</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><h3 id="dp数组优化">dp数组优化</h3>
<pre><code>//[0 15 15 15 15]
//[0 0  0  20 35]
//[0 0  0  0  35]
</code></pre><p>推导公式:  <code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+price[i])</code>
这里我们发现i 主要是用来保留了状态,  我们可以将i层的覆盖到i-1层, 因此状态压缩后的推导公式:
<code>dp[j] = max(dp[j], dp[j-weight[i]]+price[i])</code></p>
<h3 id="动态规划五部曲-1">动态规划五部曲</h3>
<h4 id="1-dp数组定义">1. dp数组定义</h4>
<p>dp[j] 表示背包容量为j,装的物品最大价值为dp[j]</p>
<h4 id="2-dp推导公式">2. dp推导公式</h4>
<p><code>dp[j] = max(dp[j], dp[j-weight[i]]+price[i])</code></p>
<h4 id="3-初始化-1">3. 初始化</h4>
<p>dp[0] 背包容量为0的话, 装的物品最大价值当然也是0</p>
<h4 id="4-遍历的顺序-1">4. 遍历的顺序</h4>
<p>推导遍历的i顺序 当然是从0&lt;=i &lt;len(weight)
那么推导的j顺序呢?</p>
<p>首先我们看一下正序:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span> <span class="p">;</span><span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">weight</span><span class="p">)</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="c1">// 这里必须倒序
</span><span class="c1"></span>    <span class="c1">//for j:= target; j &gt;= weight[i] ; j-- {
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">j</span><span class="o">:=</span> <span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">target</span> <span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
        <span class="c1">// 递推公式
</span><span class="c1"></span>        <span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="o">+</span><span class="nx">price</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">dp</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 结果
</span><span class="c1"></span><span class="p">[</span><span class="mi">0</span> <span class="mi">15</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">15</span> <span class="mi">30</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">15</span> <span class="mi">30</span> <span class="mi">45</span> <span class="mi">0</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">15</span> <span class="mi">30</span> <span class="mi">45</span> <span class="mi">60</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">15</span> <span class="mi">30</span> <span class="mi">45</span> <span class="mi">60</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">15</span> <span class="mi">30</span> <span class="mi">45</span> <span class="mi">60</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">15</span> <span class="mi">30</span> <span class="mi">45</span> <span class="mi">60</span><span class="p">]</span>
</code></pre></div><p>在j的循环内部对price[i]进行了多次累加</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">当i</span><span class="p">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">j</span><span class="p">=</span><span class="nx">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">]=</span><span class="mi">1</span><span class="p">;</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]=</span><span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="nx">price</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">15</span><span class="p">)</span> <span class="p">=</span> <span class="mi">15</span>
<span class="nx">当i</span><span class="p">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">j</span><span class="p">=</span><span class="nx">j</span><span class="o">++</span><span class="p">=</span><span class="mi">2</span><span class="p">;</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">]=</span><span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="nx">price</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">15</span><span class="o">+</span><span class="mi">15</span><span class="p">)</span> <span class="p">=</span> <span class="mi">30</span>
<span class="nx">当i</span><span class="p">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">j</span><span class="p">=</span><span class="nx">j</span><span class="o">++</span><span class="p">=</span><span class="mi">3</span><span class="p">;</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">3</span><span class="p">]=</span><span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">3</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="nx">price</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">30</span><span class="o">+</span><span class="mi">15</span><span class="p">)</span> <span class="p">=</span> <span class="mi">45</span>
<span class="nx">当i</span><span class="p">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">j</span><span class="p">=</span><span class="nx">j</span><span class="o">++</span><span class="p">=</span><span class="mi">4</span><span class="p">;</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">4</span><span class="p">]=</span><span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">4</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="nx">price</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">45</span><span class="o">+</span><span class="mi">15</span><span class="p">)</span> <span class="p">=</span> <span class="mi">60</span>
</code></pre></div><p>显然这不符合我们的预期, 单个物品只能选取一次</p>
<p>因此这里我们应该使用倒序的方式</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span> <span class="p">;</span><span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">weight</span><span class="p">)</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="c1">// 这里必须倒序
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">j</span><span class="o">:=</span> <span class="nx">target</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">;</span> <span class="nx">j</span><span class="o">--</span> <span class="p">{</span>
        <span class="c1">// 递推公式
</span><span class="c1"></span>        <span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="o">+</span><span class="nx">price</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">dp</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//结果
</span><span class="c1"></span><span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">15</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">15</span> <span class="mi">15</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">15</span> <span class="mi">15</span> <span class="mi">15</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">15</span> <span class="mi">15</span> <span class="mi">15</span> <span class="mi">15</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">15</span> <span class="mi">15</span> <span class="mi">15</span> <span class="mi">35</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">15</span> <span class="mi">15</span> <span class="mi">20</span> <span class="mi">35</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">15</span> <span class="mi">15</span> <span class="mi">20</span> <span class="mi">35</span><span class="p">]</span>
</code></pre></div><h4 id="5-举例推导dp数组">5. 举例推导dp数组</h4>
<p>上面的结果就包含了举例:</p>
<pre><code>i=0, dp=[0 15 15 15 15]
i=1, dp=[0 15 15 20 35]
i=2, dp=[0 15 15 20 35]
</code></pre><h3 id="show-me-the-code-1">show me the code</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">test_1_wei_bag_problem</span><span class="p">(</span><span class="nx">weight</span><span class="p">,</span> <span class="nx">price</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">target</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c1">// 定义 and 初始化
</span><span class="c1"></span>	<span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nx">target</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="c1">// 递推顺序
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span> <span class="p">;</span><span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">weight</span><span class="p">)</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// 这里必须倒序
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">j</span><span class="o">:=</span> <span class="nx">target</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">;</span> <span class="nx">j</span><span class="o">--</span> <span class="p">{</span>
			<span class="c1">// 递推公式
</span><span class="c1"></span>			<span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="o">+</span><span class="nx">price</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="p">}</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">dp</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">target</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">weight</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">}</span>
	<span class="nx">price</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">15</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">test_1_wei_bag_problem</span><span class="p">(</span><span class="nx">weight</span><span class="p">,</span><span class="nx">price</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go算法学习 动态规划 分割等和子集</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</link>
			<pubDate>Thu, 27 May 2021 18:36:38 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</guid>
			<description>dp 一维数组模板  例一
    \ 重量 价值     物品0 1 15   物品1 3 20   物品2 4 30    for i:=0;i&amp;lt; 物品重量列表长度;i++ { for j:= 背包容量;j &amp;gt;= i物品的重量;j-- { dp[j] = max(dp[j], dp[j- 物品i的重量] + 物品i的价值) } } 物品重量: weight := []int{1,3,4} 物品价值: value := []int{15,20,30} for i:=0;i&amp;lt; len(weight);i++ { for j:= target ;j &amp;gt;= weight[i];j-- { dp[j] = max(dp[j], dp[j- weight[i]] + value[i]) } } # 背包问题简单测试 func bag01() { weight := []int{1, 3, 4} value := []int{15, 20, 30} target := 10 dp := make([]int,target+1) for i := 0; i &amp;lt; len(weight); i++ { for j := target; j &amp;gt;= weight[i]; j-- { dp[j] = max(dp[j], dp[j-weight[i]]+value[i]) } } fmt.</description>
			<content type="html"><![CDATA[<h3 id="dp-一维数组模板">dp 一维数组模板</h3>
<blockquote>
<p>例一</p>
</blockquote>
<table>
<thead>
<tr>
<th>\</th>
<th>重量</th>
<th>价值</th>
</tr>
</thead>
<tbody>
<tr>
<td>物品0</td>
<td>1</td>
<td>15</td>
</tr>
<tr>
<td>物品1</td>
<td>3</td>
<td>20</td>
</tr>
<tr>
<td>物品2</td>
<td>4</td>
<td>30</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span> <span class="nx">物品重量列表长度</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">j</span><span class="o">:=</span> <span class="nx">背包容量</span><span class="p">;</span><span class="nx">j</span> <span class="o">&gt;=</span> <span class="nx">i物品的重量</span><span class="p">;</span><span class="nx">j</span><span class="o">--</span> <span class="p">{</span>
        <span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span> <span class="nx">物品i的重量</span><span class="p">]</span> <span class="o">+</span> <span class="nx">物品i的价值</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">物品重量</span><span class="p">:</span>   <span class="nx">weight</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">}</span>
<span class="nx">物品价值</span><span class="p">:</span>   <span class="nx">value</span>  <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">15</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">}</span>

<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">weight</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">j</span><span class="o">:=</span> <span class="nx">target</span> <span class="p">;</span><span class="nx">j</span> <span class="o">&gt;=</span> <span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span><span class="nx">j</span><span class="o">--</span> <span class="p">{</span>
        <span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span> <span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">+</span> <span class="nx">value</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="err">#</span> <span class="nx">背包问题简单测试</span>
<span class="kd">func</span> <span class="nf">bag01</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">weight</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
	<span class="nx">value</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">}</span>
	<span class="nx">target</span> <span class="o">:=</span> <span class="mi">10</span>
	<span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nx">target</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">weight</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="nx">target</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span> <span class="nx">j</span><span class="o">--</span> <span class="p">{</span>
			<span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="nx">weight</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="o">+</span><span class="nx">value</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">dp</span><span class="p">)</span>    <span class="c1">//[0 15 15 20 35 45 45 50 65 65 65]
</span><span class="c1"></span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>  <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>

</code></pre></div><h3 id="show-me-the-code">show me the code</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="c1">//https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.md
</span><span class="c1">//416. 分割等和子集
</span><span class="c1">//题目链接：https://leetcode-cn.com/problems/partition-equal-subset-sum/
</span><span class="c1">//
</span><span class="c1">//题目难易：中等
</span><span class="c1">//
</span><span class="c1">//给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
</span><span class="c1">//
</span><span class="c1">//注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200
</span><span class="c1">//
</span><span class="c1">//示例 1: 输入: [1, 5, 11, 5] 输出: true 解释: 数组可以分割成 [1, 5, 5] 和 [11].   示例 2: 输入: [1, 2, 3, 5] 输出: false 解释: 数组不能分割成两个元素和相等的子集.
</span><span class="c1"></span>
<span class="c1">// 1. 暴力回溯法
</span><span class="c1">// 1,5,11,5
</span><span class="c1">// 找到所有和=22, 取一半 = 11
</span><span class="c1">// 先取第一个数字: 1,1+5,1+11,1+5|1+5+11,1+5+5|1+11+5  存在==11
</span><span class="c1">// 先取第二个数字: 5+11,5+5
</span><span class="c1">// 先取第三个数字: 11+5
</span><span class="c1">// 先取第四个数字: 5
</span><span class="c1">// 回溯遍历可以得到结果, 但是会超时
</span><span class="c1">// 时间复杂度: O(n*n!) ?
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">canPartition</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">sum</span> <span class="o">+=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">sum</span><span class="o">%</span><span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="c1">// 回溯三部曲
</span><span class="c1"></span>	<span class="c1">// 1. 传参:
</span><span class="c1"></span>	<span class="c1">// 2. 终止条件
</span><span class="c1"></span>	<span class="c1">// 3. 单次循环
</span><span class="c1"></span>	<span class="nx">part</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="kc">false</span>
	<span class="kd">var</span> <span class="nx">dfs</span> <span class="kd">func</span><span class="p">(</span><span class="nx">index</span> <span class="kt">int</span><span class="p">)</span>
	<span class="nx">dfs</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">index</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// 终止条件
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">part</span> <span class="p">&gt;</span> <span class="nx">sum</span><span class="o">/</span><span class="mi">2</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">part</span> <span class="o">==</span> <span class="nx">sum</span><span class="o">/</span><span class="mi">2</span> <span class="p">{</span>
			<span class="nx">result</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="c1">// 单次循环,每次取值进行累加
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">index</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">part</span> <span class="o">+=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
			<span class="c1">// 递归
</span><span class="c1"></span>			<span class="nf">dfs</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
			<span class="c1">// 回溯
</span><span class="c1"></span>			<span class="nx">part</span> <span class="o">-=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="c1">// 01背包问题, 元素只能使用一次
</span><span class="c1">// 本次是要求找出 元素和 等于总和/2
</span><span class="c1">// 1. dp数组的定义
</span><span class="c1">// dp[value] 表示 容量为value的背包,所背的物品价值为dp[value]
</span><span class="c1">// 在这里
</span><span class="c1">// dp[value] 表示 容量为value的背包,所存储的最大的值 dp[value]
</span><span class="c1">// 2. dp数组的推导公式
</span><span class="c1">// dp[value] = max(dp[value], dp[value-nums[j]]+nums[j]
</span><span class="c1">// 3. dp数组初始化
</span><span class="c1">// dp[0] = 0
</span><span class="c1">// 4. dp数组的顺序
</span><span class="c1">// 在动态规划：关于01背包问题，你该了解这些！（滚动数组）中就已经说明：如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒叙遍历！
</span><span class="c1">// 5. 举例数组
</span><span class="c1">// dp[value]的数值一定小于等于value, 肯定不能超过最大容量
</span><span class="c1">// 如果dp[value]== value,说明子集合刚好可以凑成总和i, 这里我们的i上限 其实等于 sum/2
</span><span class="c1">// 例如 输入[1,5,11,5], sum/2 = 11
</span><span class="c1">// dp[value] = 0,1,1,1,1,5,6,6,6,6,10,11
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">canPartition2</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">sum</span> <span class="o">+=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">sum</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span>  <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="c1">// max方法
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">max</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
	<span class="nx">max</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
		<span class="k">return</span> <span class="nx">b</span>
	<span class="p">}</span>

	<span class="nx">target</span> <span class="o">:=</span> <span class="nx">sum</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
	<span class="c1">// 1. 定义dp数组
</span><span class="c1"></span>	<span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">target</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="c1">// 3. 初始化
</span><span class="c1"></span>	<span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="c1">// 4. dp数组的顺序
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// 每一个元素一定是不可重复放入，所以从大到小遍历
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">value</span> <span class="o">:=</span> <span class="nx">target</span><span class="p">;</span> <span class="nx">value</span> <span class="o">&gt;=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span> <span class="nx">value</span><span class="o">--</span> <span class="p">{</span>
			<span class="nx">dp</span><span class="p">[</span><span class="nx">value</span><span class="p">]</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">value</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">value</span><span class="o">-</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="o">+</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 等于target 说明整合凑成
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">target</span><span class="p">]</span> <span class="o">==</span> <span class="nx">target</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>



<span class="c1">// 优化版本, 不需要计算值
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">canPartition3</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">sum</span> <span class="o">+=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">sum</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span>  <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="nx">target</span> <span class="o">:=</span> <span class="nx">sum</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
	<span class="c1">// 1. 定义dp数组
</span><span class="c1"></span>	<span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">bool</span><span class="p">,</span> <span class="nx">target</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="c1">// 3. 初始化
</span><span class="c1"></span>	<span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="c1">// 4. dp数组的顺序
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// 每一个元素一定是不可重复放入，所以从大到小遍历
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">value</span> <span class="o">:=</span> <span class="nx">target</span><span class="p">;</span> <span class="nx">value</span> <span class="o">&gt;=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span> <span class="nx">value</span><span class="o">--</span> <span class="p">{</span>
			<span class="nx">dp</span><span class="p">[</span><span class="nx">value</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">value</span><span class="p">]</span><span class="o">||</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">value</span><span class="o">-</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span>
		<span class="p">}</span>
		<span class="c1">// 一旦等于target
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">target</span><span class="p">]</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">true</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>




<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">canPartition</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">5</span><span class="p">}))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">canPartition</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">}))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">canPartition</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">}))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">canPartition</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mi">97</span><span class="p">}))</span>
<span class="p">}</span>


</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go算法学习 动态规划 整数拆分</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/</link>
			<pubDate>Thu, 27 May 2021 11:07:46 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/</guid>
			<description>show me the code package main //https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0343.%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86.md //343. 整数拆分 //题目链接：https://leetcode-cn.com/problems/integer-break/ // //给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 // //示例 1: 输入: 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1。 // //示例 2: 输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 说明: 你可以假设 n 不小于 2 且不大于 58。  // dp[i] 代表 i这个数 拆分得到最大的乘积 // 看看示例 // dp[0],dp[1] 不用考虑, 题目是n大于等于2 // dp[2] = 1 * 1 = 1 只有一个结果  // 1.</description>
			<content type="html"><![CDATA[<h3 id="show-me-the-code">show me the code</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="c1">//https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0343.%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86.md
</span><span class="c1">//343. 整数拆分
</span><span class="c1">//题目链接：https://leetcode-cn.com/problems/integer-break/
</span><span class="c1">//
</span><span class="c1">//给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。
</span><span class="c1">//
</span><span class="c1">//示例 1: 输入: 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1。
</span><span class="c1">//
</span><span class="c1">//示例 2: 输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 说明: 你可以假设 n 不小于 2 且不大于 58。
</span><span class="c1"></span>


<span class="c1">// dp[i] 代表 i这个数 拆分得到最大的乘积
</span><span class="c1">// 看看示例
</span><span class="c1">// dp[0],dp[1] 不用考虑, 题目是n大于等于2
</span><span class="c1">// dp[2] = 1 * 1  = 1 只有一个结果
</span><span class="c1"></span>
<span class="c1">// 1.dp[3] 可以如下拆分
</span><span class="c1">// 	1.1 (3-1) * 1 = 2
</span><span class="c1">// 	1.2 dp[3-1] * 1 = 1	 =&gt; 局部最优: 1 * 1 * 1 = 1
</span><span class="c1">//  这里的dp[3-1] 其实就是我们在对2拆分获取最大乘积
</span><span class="c1">//  1.3 (3-2) * 2 = 2
</span><span class="c1">//  不存在dp[3-2]了
</span><span class="c1">//  所以 dp[3] = 2
</span><span class="c1"></span>
<span class="c1">// 2. dp[4] 可以如下拆分
</span><span class="c1">// 	2.1 (4-1) * 1 = 3
</span><span class="c1">//  2.2 dp[4-1] * 1 = 2	=&gt; 局部最优: 1 * 2 * 1 = 2
</span><span class="c1">//  2.3 (4-2) * 2 = 4
</span><span class="c1">//  2.4 dp[4-2] * 2 = 2 =&gt; 局部最优: 1 * 1 * 2 = 2
</span><span class="c1">//  2.5 (4-3) * 3 = 3
</span><span class="c1">//  所以dp[4] = 4
</span><span class="c1"></span>
<span class="c1">// 3. dp[5] 可以拆分
</span><span class="c1">//  3.1 (5-1) * 1 = 4
</span><span class="c1">//  3.2 dp[5-1] * 1 = 4	=&gt; 局部最优: 2 * 2 * 1 = 4
</span><span class="c1">//  3.3 (5-2) * 2 = 6
</span><span class="c1">//  3.4 dp[5-2] * 2 = 4 =&gt; 局部最优: 1 * 2 * 2 = 4
</span><span class="c1">//  3.5 (5-3) * 3 = 6
</span><span class="c1">//  3.6 dp[5-3] * 3 = 3 =&gt; 局部最优: 1 * 1 * 3 = 3
</span><span class="c1">//  3.7 (5-4) * 4 = 4
</span><span class="c1">//  所以dp[5] = 6
</span><span class="c1"></span>
<span class="c1">// 因此dp[i] 可以得到如下
</span><span class="c1">// 	1. (i-j) * j  拆成两个数字
</span><span class="c1">//  2. dp[i-j] * j ,dp[i-j] 代表i-j可以得到的最大乘积
</span><span class="c1">// 所以dp[i] = max(dp[i], dp[i-j] * j , (i-j)*j)
</span><span class="c1"></span>
<span class="c1">// 1. dp[i]数组定义: i这个正整数可以拆分的最大乘积
</span><span class="c1">// 2. dp数组初始化: dp[2] = 1
</span><span class="c1">// 3. dp推导公式: dp[i] = max(dp[i], dp[i-j] * j , (i-j)*j)
</span><span class="c1">// 4. 顺序: 同样从前往后
</span><span class="c1">// 5. 举例: dp[i] = 0,0,1,2,4,6,9,12,18,27,36
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">integerBreak</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c1">// 1.定义dp数组
</span><span class="c1"></span>	<span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="c1">// 3. 初始化
</span><span class="c1"></span>	<span class="nx">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="c1">// 4. 遍历顺序
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="c1">// 2. dp推导公式
</span><span class="c1"></span>			<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="nx">j</span><span class="p">]</span><span class="o">*</span><span class="nx">j</span><span class="p">,</span> <span class="p">(</span><span class="nx">i</span><span class="o">-</span><span class="nx">j</span><span class="p">)</span><span class="o">*</span><span class="nx">j</span><span class="p">))</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">integerBreak</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="p">}</span>


</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go算法学习 动态规划 不同路径2</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%842/</link>
			<pubDate>Wed, 26 May 2021 18:01:37 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%842/</guid>
			<description>show me the code package main import &amp;#34;fmt&amp;#34; //https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0063.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II.md //63. 不同路径 II //题目链接：https://leetcode-cn.com/problems/unique-paths-ii/ // //一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 // //机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 // //现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？  // 同样根据我们 &amp;lt;&amp;lt; 62. 不同路径&amp;gt;&amp;gt; 的分析可以指定 // dp[i][j] 代表的是 (i,j) 坐标到达的所有路径数 // 显然(i,j) 如果是路障, 那么dp[i][j] = 0 是肯定的, 因为无法到达哈  // 那我们先来举例演示一下 // obstacleGrid = [[0,0,0,0],[0,1,0,1],[1,0,0,0],[0,0,0,0]] // [0,0,0,0] // [0,1,0,1] // [1,0,0,0] // [0,0,0,0] // 我们的dp数组同样初始化为: // 二维数组如下: //[1 1 1 1] //[1 0 0 0] //[0 0 0 0] //[0 0 0 0] // 根据有障碍的数组, 按照dp[i][j] = dp[i][j-1] + dp[i-1][j] 来计算可以得到如下: //[1 1 1 1] //[1 0 1 0] //[0 0 1 1] //[0 0 1 2]  // 动态规划五部曲 // 1.</description>
			<content type="html"><![CDATA[<h3 id="show-me-the-code">show me the code</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="c1">//https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0063.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II.md
</span><span class="c1">//63. 不同路径 II
</span><span class="c1">//题目链接：https://leetcode-cn.com/problems/unique-paths-ii/
</span><span class="c1">//
</span><span class="c1">//一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
</span><span class="c1">//
</span><span class="c1">//机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
</span><span class="c1">//
</span><span class="c1">//现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
</span><span class="c1"></span>
<span class="c1">// 同样根据我们 &lt;&lt; 62. 不同路径&gt;&gt; 的分析可以指定
</span><span class="c1">// dp[i][j] 代表的是 (i,j) 坐标到达的所有路径数
</span><span class="c1">// 显然(i,j) 如果是路障, 那么dp[i][j] = 0 是肯定的, 因为无法到达哈
</span><span class="c1"></span>
<span class="c1">// 那我们先来举例演示一下
</span><span class="c1">// obstacleGrid = [[0,0,0,0],[0,1,0,1],[1,0,0,0],[0,0,0,0]]
</span><span class="c1">// [0,0,0,0]
</span><span class="c1">// [0,1,0,1]
</span><span class="c1">// [1,0,0,0]
</span><span class="c1">// [0,0,0,0]
</span><span class="c1">// 我们的dp数组同样初始化为:
</span><span class="c1">// 二维数组如下:
</span><span class="c1">//[1 1 1 1]
</span><span class="c1">//[1 0 0 0]
</span><span class="c1">//[0 0 0 0]
</span><span class="c1">//[0 0 0 0]
</span><span class="c1">// 根据有障碍的数组, 按照dp[i][j] = dp[i][j-1] + dp[i-1][j] 来计算可以得到如下:
</span><span class="c1">//[1 1 1 1]
</span><span class="c1">//[1 0 1 0]
</span><span class="c1">//[0 0 1 1]
</span><span class="c1">//[0 0 1 2]
</span><span class="c1"></span>
<span class="c1">// 动态规划五部曲
</span><span class="c1">// 1. dp数组定义和含义 : dp[i][j] 同样代表该位置(i,j) 所有路线总和
</span><span class="c1">// 2. dp的推导过程: 同样是 dp[i][j] = dp[i][j-1] +  dp[i-1][j]
</span><span class="c1">// 3. dp数组初始化:
</span><span class="c1">//    3.1 同样是第一行或第一列都初始化为1
</span><span class="c1">//    3.2 但是如果该行有障碍物, 后面的都将是0, 因为不可能到达
</span><span class="c1">// 4. 顺序
</span><span class="c1">// 5. 举例dp数组
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">uniquePathsWithObstacles</span><span class="p">(</span><span class="nx">obstacleGrid</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">,</span><span class="nx">n</span><span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">obstacleGrid</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="nx">obstacleGrid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="c1">// 定义一个dp数组
</span><span class="c1"></span>	<span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span><span class="nx">m</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span><span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dp</span> <span class="p">{</span>
		<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nx">n</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 初始化
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">m</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// 如果是障碍物, 后面的就都是0, 不用循环了
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">obstacleGrid</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]=</span><span class="mi">1</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">n</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">obstacleGrid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">i</span><span class="p">]=</span><span class="mi">1</span>
	<span class="p">}</span>
	<span class="c1">// dp数组推导过程
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">m</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span><span class="o">:=</span><span class="mi">1</span><span class="p">;</span><span class="nx">j</span><span class="p">&lt;</span><span class="nx">n</span><span class="p">;</span><span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="c1">// 如果obstacleGrid[i][j]这个点是障碍物, 那么我们的dp[i][j]保持为0
</span><span class="c1"></span>            <span class="k">if</span> <span class="nx">obstacleGrid</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span> <span class="p">{</span>
				<span class="c1">// 否则我们需要计算当前点可以到达的路径数
</span><span class="c1"></span>				<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span><span class="o">+</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// debug遍历dp
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span><span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dp</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span><span class="p">,</span><span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%.2v,&#34;</span><span class="p">,</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">])</span>
		<span class="p">}</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">m</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">obstacleGrid</span> <span class="o">:=</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">{{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">},{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">},{</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">},{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">}}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">uniquePathsWithObstacles</span><span class="p">(</span><span class="nx">obstacleGrid</span><span class="p">))</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go算法学习 动态规划 不同路径</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</link>
			<pubDate>Wed, 26 May 2021 17:17:21 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</guid>
			<description>show me the code package main import &amp;#34;fmt&amp;#34; //https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.md //62.不同路径 //题目链接：https://leetcode-cn.com/problems/unique-paths/ // //一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 // //机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 // //问总共有多少条不同的路径？ //输入：m = 3, n = 7 输出：28 // //示例 2： 输入：m = 2, n = 3 输出：3 解释： 从左上角开始，总共有 3 条路径可以到达右下角。 // //向右 -&amp;gt; 向右 -&amp;gt; 向下 //向右 -&amp;gt; 向下 -&amp;gt; 向右 //向下 -&amp;gt; 向右 -&amp;gt; 向右 //示例 3： 输入：m = 7, n = 3 输出：28 // //示例 4： 输入：m = 3, n = 3 输出：6 提示： // //1 &amp;lt;= m, n &amp;lt;= 100 //题目数据保证答案小于等于 2 * 10^9  // 动态规划五部曲 // 1.</description>
			<content type="html"><![CDATA[<h3 id="show-me-the-code">show me the code</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="c1">//https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.md
</span><span class="c1">//62.不同路径
</span><span class="c1">//题目链接：https://leetcode-cn.com/problems/unique-paths/
</span><span class="c1">//
</span><span class="c1">//一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
</span><span class="c1">//
</span><span class="c1">//机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
</span><span class="c1">//
</span><span class="c1">//问总共有多少条不同的路径？
</span><span class="c1">//输入：m = 3, n = 7 输出：28
</span><span class="c1">//
</span><span class="c1">//示例 2： 输入：m = 2, n = 3 输出：3 解释： 从左上角开始，总共有 3 条路径可以到达右下角。
</span><span class="c1">//
</span><span class="c1">//向右 -&gt; 向右 -&gt; 向下
</span><span class="c1">//向右 -&gt; 向下 -&gt; 向右
</span><span class="c1">//向下 -&gt; 向右 -&gt; 向右
</span><span class="c1">//示例 3： 输入：m = 7, n = 3 输出：28
</span><span class="c1">//
</span><span class="c1">//示例 4： 输入：m = 3, n = 3 输出：6   提示：
</span><span class="c1">//
</span><span class="c1">//1 &lt;= m, n &lt;= 100
</span><span class="c1">//题目数据保证答案小于等于 2 * 10^9
</span><span class="c1"></span>

<span class="c1">// 动态规划五部曲
</span><span class="c1">// 1. dp数组定义 dp[i][j]
</span><span class="c1">//  从左上角(0,0) 出发到达(i,j) 所有的不同路径: dp[i][j]
</span><span class="c1">// 2. dp推导公式
</span><span class="c1">//  显然  dp[i][j] 有两种情况可以到达
</span><span class="c1">//   1. dp[i][j-1] 向右走一步
</span><span class="c1">//   2. dp[i-1][j] 向下走一步
</span><span class="c1">//  dp[i][j] = dp[i][j-1] +  dp[i-1][j]
</span><span class="c1">// 3. dp数组初始化
</span><span class="c1">//  dp[0][0] = 1
</span><span class="c1">//  dp[0][1] = 1
</span><span class="c1">//  dp[1][0] = 1
</span><span class="c1">//  是这样吗? 错误哈!
</span><span class="c1">//  应该初始化第一排和第一列
</span><span class="c1">//  dp[0][0] = 1
</span><span class="c1">//  dp[0][i] = 1
</span><span class="c1">//  dp[i][0] = 1
</span><span class="c1">// 4. 顺序
</span><span class="c1">// 5. dp数组举例
</span><span class="c1">//  dp[0][0] = 1
</span><span class="c1">//  dp[0][1] = 1
</span><span class="c1">//  dp[1][0] = 1
</span><span class="c1">//  dp[1][1] = dp[0][1] + dp[1][0] = 2
</span><span class="c1">//  dp[1][2] = dp[1][1] + dp[0][2] = 3
</span><span class="c1">//
</span><span class="c1">//  01,01,01,01,01,01,01,
</span><span class="c1">//  01,02,03,04,05,06,07,
</span><span class="c1">//  01,03,06,10,15,21,28,
</span><span class="c1"></span>

<span class="kd">func</span> <span class="nf">uniquePaths</span><span class="p">(</span><span class="nx">m</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c1">// 定义dp数组
</span><span class="c1"></span>	<span class="c1">// 这里的m代表m行, n代表n列
</span><span class="c1"></span>	<span class="c1">// m =3, n = 7
</span><span class="c1"></span>	<span class="c1">// 二维数组如下:
</span><span class="c1"></span>	<span class="c1">//[0 0 0 0 0 0 0]
</span><span class="c1"></span>	<span class="c1">//[0 0 0 0 0 0 0]
</span><span class="c1"></span>	<span class="c1">//[0 0 0 0 0 0 0]
</span><span class="c1"></span>	<span class="c1">// 首先定义dp的行
</span><span class="c1"></span>	<span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span><span class="nx">m</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span><span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dp</span> <span class="p">{</span>
		<span class="c1">// 然后定义每个元素的长度, 也就是二维数组的宽
</span><span class="c1"></span>		<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nx">n</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 初始化dp, 初始化为如下:
</span><span class="c1"></span>	<span class="c1">// 二维数组如下:
</span><span class="c1"></span>	<span class="c1">//[1 1 1 1 1 1 1]
</span><span class="c1"></span>	<span class="c1">//[1 0 0 0 0 0 0]
</span><span class="c1"></span>	<span class="c1">//[1 0 0 0 0 0 0]
</span><span class="c1"></span>	<span class="c1">// 一开始初始化有问题, 只初始化了三个值
</span><span class="c1"></span>	<span class="c1">//dp[1][0] = 1
</span><span class="c1"></span>	<span class="c1">//dp[0][1] = 1
</span><span class="c1"></span>	<span class="c1">// 纠正后如下, 应该初始化第一排和第一列
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">m</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">n</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="p">}</span>
	<span class="c1">// 这里是dp推导过程
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span> <span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">m</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span><span class="o">:=</span><span class="mi">1</span><span class="p">;</span><span class="nx">j</span><span class="p">&lt;</span><span class="nx">n</span><span class="p">;</span><span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 遍历dp来debug哪里出现问题, 比如我开始初始化有问题, 通过dp打印就能发现
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span><span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dp</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span><span class="p">,</span><span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%.2v,&#34;</span><span class="p">,</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">])</span>
		<span class="p">}</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">m</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">uniquePaths</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">))</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go算法学习 二叉树 迭代统一遍历写法</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E4%BA%8C%E5%8F%89%E6%A0%91-%E8%BF%AD%E4%BB%A3%E7%BB%9F%E4%B8%80%E9%81%8D%E5%8E%86%E5%86%99%E6%B3%95/</link>
			<pubDate>Tue, 27 Apr 2021 11:21:41 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E4%BA%8C%E5%8F%89%E6%A0%91-%E8%BF%AD%E4%BB%A3%E7%BB%9F%E4%B8%80%E9%81%8D%E5%8E%86%E5%86%99%E6%B3%95/</guid>
			<description>说明 首先二叉树有三种遍历,针对根节点遍历顺序分别是 前序,中序, 后续
 前序: 中 左 右 中序: 左 中 右 后续: 左 右 中  遍历的写法分为两种:
 递归 迭代  二叉树结构体 type TreeNode struct { Val int Left *TreeNode Right *TreeNode } 1. 递归  递归比较简单, 代码如下:
  1.1 前序遍历 (中 左 右)  func preorderTraversal(root *TreeNode) []int { var result []int var Traversal func( *TreeNode) Traversal = func(node *TreeNode) { if node == nil { return } result = append(result, node.</description>
			<content type="html"><![CDATA[<h3 id="说明">说明</h3>
<p>首先二叉树有三种遍历,针对根节点遍历顺序分别是 前序,中序, 后续</p>
<ul>
<li>前序: 中 左 右</li>
<li>中序: 左 中 右</li>
<li>后续: 左 右 中</li>
</ul>
<p>遍历的写法分为两种:</p>
<ul>
<li>递归</li>
<li>迭代</li>
</ul>
<h3 id="二叉树结构体">二叉树结构体</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">TreeNode</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Val</span>   <span class="kt">int</span>
	<span class="nx">Left</span>  <span class="o">*</span><span class="nx">TreeNode</span>
	<span class="nx">Right</span> <span class="o">*</span><span class="nx">TreeNode</span>
<span class="p">}</span>

</code></pre></div><h3 id="1-递归">1. 递归</h3>
<blockquote>
<p>递归比较简单, 代码如下:</p>
</blockquote>
<ul>
<li>1.1 前序遍历 (中 左 右)</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">preorderTraversal</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">result</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="kd">var</span> <span class="nx">Traversal</span> <span class="kd">func</span><span class="p">(</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span>
	<span class="nx">Traversal</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">node</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">node</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span> <span class="c1">//1 中
</span><span class="c1"></span>		<span class="nf">Traversal</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>              <span class="c1">//2 左
</span><span class="c1"></span>		<span class="nf">Traversal</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>             <span class="c1">//3 右
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="nf">Traversal</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</code></pre></div><p><strong>根据1.1 前序遍历 很容易能写出中序遍历 和后序遍历</strong></p>
<hr>
<h3 id="2-迭代法">2. 迭代法</h3>
<blockquote>
<p>首先这里使用一般的迭代方法</p>
</blockquote>
<ul>
<li>2.1 前序遍历 (中 左 右)</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">preorderTraversal</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">result</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">result</span>
	<span class="p">}</span>
	<span class="nx">stack</span> <span class="o">:=</span> <span class="p">[]</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">{</span><span class="nx">root</span><span class="p">}</span>
	<span class="c1">// 迭代循环
</span><span class="c1"></span>	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// 处理当前节点
</span><span class="c1"></span>		<span class="nx">node</span> <span class="o">:=</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="c1">// 访问的节点就是 结果集的节点
</span><span class="c1"></span>		<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
		<span class="c1">// 先将右节点 入栈
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// 再将左节点 入栈
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</code></pre></div><blockquote>
<p>前序遍历比较简单, 因为前序遍历的节点 就是结果集的节点, 如果是中序遍历呢?</p>
<p>由于中序遍历需要找的最左边的节点, 所以每次访问的节点并不是结果集的节点, 那应该怎么弄呢?</p>
</blockquote>
<ul>
<li>2.1 中序遍历 (左 中 右)</li>
</ul>
<blockquote>
<p>由于每次访问的节点并不是要处理的节点, 访问到左边最后一个节点才开始处理
因此需要将每次遇到的右节点保存到堆栈中</p>
</blockquote>
<blockquote>
<ol>
<li>
<p>第一步先找到最左边的节点,并且将访问的节点都存到堆栈中</p>
</li>
<li>
<p>当发现已经到最左边的节点(==nil) 时, 就需要从堆栈中取出最后一个节点(最左边的节点) ,遍历该节点, 并处理他的右节点</p>
</li>
<li>
<p>然后就拿着右节点 继续遍历 1 2步骤</p>
</li>
</ol>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">inorderTraversal</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">result</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">stack</span> <span class="p">[]</span><span class="o">*</span><span class="nx">TreeNode</span>
	<span class="nx">node</span> <span class="o">:=</span> <span class="nx">root</span>
	<span class="k">for</span> <span class="nx">node</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">node</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span>
			<span class="nx">node</span> <span class="p">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// 已经是最左边的节点了, 就可以推出栈元素了
</span><span class="c1"></span>			<span class="c1">// 栈最后一个元素, 就是左节点
</span><span class="c1"></span>			<span class="nx">node</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="c1">// 添加左节点的
</span><span class="c1"></span>			<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
			<span class="c1">// 再去遍历右节点
</span><span class="c1"></span>			<span class="nx">node</span> <span class="p">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>2.1 后序遍历 (左 右 中)</li>
</ul>
<blockquote>
<p>对比前序遍历 中 左 右 -&gt; 稍作修改为: 中 右 左, 然后倒序输出</p>
<ol>
<li>
<p>把根节点加入堆栈 , 弹出</p>
</li>
<li>
<p>每次判断先判断右边是否nil,然后判断左边是否nil, 把 右左 顺序加入堆栈, 左右顺序弹出</p>
</li>
</ol>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">postorderTraversal</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">result</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">result</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">stack</span> <span class="p">[]</span><span class="o">*</span><span class="nx">TreeNode</span>
	<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">root</span><span class="p">)</span>
	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">cur</span> <span class="o">:=</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">j</span><span class="p">;</span> <span class="p">{</span>
		<span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">result</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">result</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">i</span><span class="o">++</span>
		<span class="nx">j</span><span class="o">--</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</code></pre></div><hr>
<p>经过以上比较,我们发现<strong>递归写法比较统一,迭代写法很不统一,是否有统一的迭代写法呢?</strong></p>
<blockquote>
<p>参考文档</p>
</blockquote>
<ul>
<li><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/bang-ni-dui-er-cha-shu-bu-zai-mi-mang-che-di-chi-t/">来自leetcode 代码随想录 分享</a></li>
</ul>
<h3 id="3-迭代法-统一写法版本">3. 迭代法 统一写法版本</h3>
<ul>
<li>3.1 先序遍历 ( 中 左 右)</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 统一写法  先序遍历 ( 中 左 右)
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">preorderTraversal</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">result</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="nx">stack</span> <span class="o">:=</span> <span class="p">[]</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">{</span><span class="nx">root</span><span class="p">}</span>
	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// 先取一个节点来处理
</span><span class="c1"></span>		<span class="nx">node</span> <span class="o">:=</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="c1">// 判断是否用nil标记了
</span><span class="c1"></span>
		<span class="k">if</span> <span class="nx">node</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// 不是标记节点, 就处理该节点
</span><span class="c1"></span>			<span class="c1">// 怎么处理呢? 就是按照顺序加入到队列中
</span><span class="c1"></span>			<span class="c1">// 右节点入栈
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="c1">// 左节点入栈
</span><span class="c1"></span>
			<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="c1">// 中节点入栈
</span><span class="c1"></span>			<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span>
			<span class="c1">// 中节点以及处理,所以标记
</span><span class="c1"></span>			<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>

		<span class="p">}</span><span class="k">else</span> <span class="p">{</span><span class="c1">// 如果遇到nil,就弹出并加入结果集
</span><span class="c1"></span>			<span class="nx">node</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>3.2 中序遍历(左 中 右)</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 迭代的统一写法 , 中序遍历(左 中 右)
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">inorderTraversal11</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">result</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="nx">stack</span> <span class="o">:=</span>  <span class="p">[]</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">{</span><span class="nx">root</span><span class="p">}</span>
	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// 首先从队列取出一个接地
</span><span class="c1"></span>		<span class="nx">inorder</span> <span class="o">:=</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="c1">// 判断是否为 nil , 不是空说明没有处理过, 因为处理过的节点 紧跟着都加了 nil 标记
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">inorder</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// 如果右边不是 nil, 就加入到队列
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">inorder</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">inorder</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="c1">// 中间节点加入队列
</span><span class="c1"></span>			<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">inorder</span><span class="p">)</span>
			<span class="c1">// 中节点访问过，但是还没有处理，加入空节点做为标记。
</span><span class="c1"></span>			<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span><span class="kc">nil</span> <span class="p">)</span>
			<span class="c1">// 如果左边不是 nil, 就加入到队列
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">inorder</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">inorder</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span> <span class="c1">// 空节点, 说明 nil前面的节点是处理过的, 直接添加到 result即可
</span><span class="c1"></span>			<span class="nx">inorder</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="c1">// 结果集
</span><span class="c1"></span>			<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">inorder</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>

<span class="p">}</span>
</code></pre></div><ul>
<li>3.3 后序遍历( 左 右 中)</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 统一写法 后序遍历( 左 右 中)
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">postorderTraversal</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">result</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="nx">stack</span> <span class="o">:=</span> <span class="p">[]</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">{</span><span class="nx">root</span><span class="p">}</span>
	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">node</span> <span class="o">:=</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="k">if</span> <span class="nx">node</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// 中节点, nil用于标记
</span><span class="c1"></span>			<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">node</span><span class="p">,</span><span class="kc">nil</span> <span class="p">)</span>
			<span class="c1">// 右节点
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="c1">// 左节点
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span><span class="c1">// 遇到标记节点
</span><span class="c1"></span>			<span class="c1">// 在取一次, 标记节点前面的节点就是需要加入结果集的内容
</span><span class="c1"></span>			<span class="nx">node</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>

<span class="p">}</span>
</code></pre></div><hr>
<blockquote>
<p>参考文档</p>
</blockquote>
<ul>
<li><a href="https://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html">Morris Traversal方法遍历二叉树</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/101321696">神级遍历——morris</a></li>
</ul>
<h3 id="4-morris-遍历-o1空间复杂度">4. morris 遍历 (O(1)空间复杂度)</h3>
<ul>
<li>4.1 先序遍历</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// morris 前序遍历写法
</span><span class="c1">// 规则: (规则的目的主要是能找到回溯的路径)
</span><span class="c1">// 1. curr 无左孩子, 那么输出curr 并且右移 (curr = curr.right)
</span><span class="c1">// 2. curr 有左孩子, 那么记录左孩子的最右节点 mostright (所以这里是循环找)
</span><span class="c1">//   2.1 如果mostright.right == nil(找到最右节点), 那么就让他指向curr 并且curr 左移, mostright.right = curr (这就是回溯的路线),curr = curr.left
</span><span class="c1">//   2.2 如果mostright.right == curr(说明已经遍历过),那么就让他指向nil并且curr 右移,mostright.right = nil (还原二叉树),curr = curr.right
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">preorderTraversalMorris</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">curr</span> <span class="o">:=</span> <span class="nx">root</span>
	<span class="k">for</span> <span class="nx">curr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 1. 无左孩子
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Left</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">curr</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
			<span class="nx">curr</span> <span class="p">=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Right</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span>	<span class="c1">// 2. 有左孩子
</span><span class="c1"></span>			<span class="c1">// 先记录一个mostRight
</span><span class="c1"></span>			<span class="nx">mostRight</span> <span class="o">:=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Left</span>
			<span class="c1">// 一直循环找 curr.Left 的最右节点
</span><span class="c1"></span>			<span class="k">for</span> <span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="nx">curr</span> <span class="p">{</span>
				<span class="nx">mostRight</span> <span class="p">=</span> <span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span>
			<span class="p">}</span>
			<span class="c1">// 2.1 如果找到了
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">curr</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>		
				<span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="p">=</span> <span class="nx">curr</span>
				<span class="nx">curr</span> <span class="p">=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Left</span>
			<span class="p">}</span>
			<span class="c1">// 2.2 如果遍历过
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="o">==</span> <span class="nx">curr</span> <span class="p">{</span>
				<span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="p">=</span> <span class="kc">nil</span>
				<span class="nx">curr</span> <span class="p">=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Right</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div><ul>
<li>4.2 中序遍历</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// morris中序遍历
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">inorderTraversalMorris</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">curr</span> <span class="o">:=</span> <span class="nx">root</span>
	<span class="k">for</span> <span class="nx">curr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 1. 无左孩子
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Left</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">curr</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
			<span class="nx">curr</span> <span class="p">=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Right</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span>	<span class="c1">// 2. 有左孩子
</span><span class="c1"></span>			<span class="c1">// 先记录一个mostRight
</span><span class="c1"></span>			<span class="nx">mostRight</span> <span class="o">:=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Left</span>
			<span class="c1">// 一直循环找 curr.Left 的最右节点
</span><span class="c1"></span>			<span class="k">for</span> <span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="nx">curr</span> <span class="p">{</span>
				<span class="nx">mostRight</span> <span class="p">=</span> <span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span>
			<span class="p">}</span>
			<span class="c1">// 2.1 如果找到了
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="p">=</span> <span class="nx">curr</span>
				<span class="nx">curr</span> <span class="p">=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Left</span>
			<span class="p">}</span>
			<span class="c1">// 2.2 如果遍历过
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="o">==</span> <span class="nx">curr</span> <span class="p">{</span>
				<span class="nx">mostRight</span><span class="p">.</span><span class="nx">Right</span> <span class="p">=</span> <span class="kc">nil</span>
				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">curr</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span> <span class="c1">// 和前序遍历的区别, 在这里输出是因为已经遍历过左子树
</span><span class="c1"></span>				<span class="nx">curr</span> <span class="p">=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Right</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go算法学习 回溯 分割回文串</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%9B%9E%E6%BA%AF-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/</link>
			<pubDate>Fri, 23 Apr 2021 09:27:50 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%9B%9E%E6%BA%AF-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/</guid>
			<description>说明  纯暴力搜索, 通常可以抽象为N叉树, 树的深度就是递归的深度
  组合问题(不强调顺序) 1234 =&amp;gt; 12,13,14,23,24,34 切割问题(分割回文串) aab =&amp;gt; [a,a,b],[aa,b] 子集问题 排列问题(强调顺序) 1234 =&amp;gt; 12,13,14,21,23,24&amp;hellip; 棋盘问题(N皇后,数独)  回溯算法模板 func backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归  回溯，撤销处理结果 } } 参考文献  力扣题目: 77.组合 力扣题目: 39.组合总和 力扣题目: 131.分割回文串 代码随想录视频 回溯算法-理论（对应力扣题目：77.组合） 代码随想录视频 回溯算法-组合（对应力扣题目：77.组合） 代码随想录视频 回溯算法-组合剪枝（对应力扣题目：77.组合） 代码随想录视频 回溯算法-分割回文串（对应力扣题目：131.分割回文串） 代码随想录图文 回溯算法：分割回文串  例一 77. 组合 //77. 组合 //给定两个整数 n 和 k，返回 1 .</description>
			<content type="html"><![CDATA[<h3 id="说明">说明</h3>
<blockquote>
<p>纯暴力搜索, 通常可以抽象为N叉树, 树的深度就是递归的深度</p>
</blockquote>
<ul>
<li>组合问题(不强调顺序)   1234 =&gt;  12,13,14,23,24,34</li>
<li>切割问题(分割回文串)   aab  =&gt;  [a,a,b],[aa,b]</li>
<li>子集问题</li>
<li>排列问题(强调顺序)     1234 =&gt; 12,13,14,21,23,24&hellip;</li>
<li>棋盘问题(N皇后,数独)</li>
</ul>
<h3 id="回溯算法模板">回溯算法模板</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">backtracking</span><span class="p">(</span><span class="nx">参数</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">终止条件</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">存放结果</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="nx">选择</span><span class="err">：</span><span class="nx">本层集合中元素</span><span class="err">（</span><span class="nx">树中节点孩子的数量就是集合的大小</span><span class="err">）</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">处理节点</span><span class="p">;</span>
        <span class="nf">backtracking</span><span class="p">(</span><span class="nx">路径</span><span class="err">，</span><span class="nx">选择列表</span><span class="p">);</span> <span class="c1">// 递归
</span><span class="c1"></span>        <span class="nx">回溯</span><span class="err">，</span><span class="nx">撤销处理结果</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h3 id="参考文献">参考文献</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/combinations/">力扣题目: 77.组合</a></li>
<li><a href="https://leetcode-cn.com/problems/combination-sum/">力扣题目: 39.组合总和</a></li>
<li><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">力扣题目: 131.分割回文串</a></li>
<li><a href="https://www.bilibili.com/video/BV1cy4y167mM">代码随想录视频 回溯算法-理论（对应力扣题目：77.组合）</a></li>
<li><a href="https://www.bilibili.com/video/BV1ti4y1L7cv">代码随想录视频 回溯算法-组合（对应力扣题目：77.组合）</a></li>
<li><a href="https://www.bilibili.com/video/BV1wi4y157er/?spm_id_from=autoNext">代码随想录视频 回溯算法-组合剪枝（对应力扣题目：77.组合）</a></li>
<li><a href="https://www.bilibili.com/video/BV1c54y1e7k6">代码随想录视频 回溯算法-分割回文串（对应力扣题目：131.分割回文串）</a></li>
<li><a href="https://mp.weixin.qq.com/s/Pb1epUTbU8fHIht-g_MS5Q">代码随想录图文 回溯算法：分割回文串</a></li>
</ul>
<h3 id="例一-77-组合">例一 77. 组合</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">//77. 组合
</span><span class="c1">//给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。
</span><span class="c1">//
</span><span class="c1">//示例:
</span><span class="c1">//
</span><span class="c1">//输入: n = 4, k = 2
</span><span class="c1">//输出:
</span><span class="c1">//[
</span><span class="c1">//  [2,4],
</span><span class="c1">//  [3,4],
</span><span class="c1">//  [2,3],
</span><span class="c1">//  [1,2],
</span><span class="c1">//  [1,3],
</span><span class="c1">//  [1,4],
</span><span class="c1">//]
</span><span class="c1">//https://leetcode-cn.com/problems/combinations/
</span><span class="c1">// bilibili视频: https://www.bilibili.com/video/BV1ti4y1L7cv/?spm_id_from=autoNext
</span><span class="c1"></span>
<span class="c1">// 思路
</span><span class="c1">// 首先根据回溯算法的模板,这里n代表的就是横向的循环, k影响递归的深度
</span><span class="c1">// n = 4, k = 2
</span><span class="c1">//
</span><span class="c1">// 	  1       2     3   4
</span><span class="c1">//  2 3 4     3 4   4
</span><span class="c1">// 12|13|14 23|24   34
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">combine</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="nx">path</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>

	<span class="c1">// 1. 递归参数和返回值
</span><span class="c1"></span>	<span class="c1">// 2. 递归的终止条件
</span><span class="c1"></span>	<span class="c1">// 3. 单词递归的逻辑
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">backtracking</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
	<span class="nx">backtracking</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">startIndex</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">{</span>
		<span class="c1">// 递归的终止条件
</span><span class="c1"></span>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span> <span class="o">==</span> <span class="nx">k</span> <span class="p">{</span>
			<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nb">append</span><span class="p">([]</span><span class="kt">int</span><span class="p">{},</span><span class="nx">path</span><span class="o">...</span><span class="p">))</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span> <span class="nx">startIndex</span><span class="p">;</span><span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span> <span class="p">;</span><span class="nx">i</span> <span class="o">++</span> <span class="p">{</span>
			<span class="c1">// 寻找组合
</span><span class="c1"></span>			<span class="nx">path</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
			<span class="nf">backtracking</span><span class="p">(</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
			<span class="c1">// 回溯过程
</span><span class="c1"></span>			<span class="nx">path</span> <span class="p">=</span> <span class="nx">path</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">backtracking</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>


</code></pre></div><h3 id="例二-39组合总和">例二: 39.组合总和</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// 思路
</span><span class="c1">//  candidates = [2,3,5], target = 8,
</span><span class="c1">//    		  2     		  3	    	 5
</span><span class="c1">//   	2	  3 	5       3   5 		 5
</span><span class="c1">// 	  235     35    5       35  
</span><span class="c1">// 235 35 5  35 5   
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">combinationSum</span><span class="p">(</span><span class="nx">candidates</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">target</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="nx">path</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="nx">pathInt</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="kd">var</span> <span class="nx">backTracking</span> <span class="kd">func</span><span class="p">(</span><span class="nx">startIndex</span> <span class="kt">int</span><span class="p">)</span>
	<span class="c1">// 递归三部曲
</span><span class="c1"></span>	<span class="c1">// 1. 递归参数, 这里需要开始位置
</span><span class="c1"></span>	<span class="c1">// 2. 终止条件, path的结果和等于target, 或者大于
</span><span class="c1"></span>	<span class="c1">// 3. 单次递归逻辑, 往path里添加结果 , 只要小于target
</span><span class="c1"></span>	<span class="nx">backTracking</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">startIndex</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">pathInt</span> <span class="o">==</span> <span class="nx">target</span> <span class="p">{</span>
			<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nb">append</span><span class="p">([]</span><span class="kt">int</span><span class="p">{},</span><span class="nx">path</span><span class="o">...</span><span class="p">))</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="c1">// 超过target也需要返回, 但是不用保存数据
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">pathInt</span> <span class="p">&gt;</span> <span class="nx">target</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
        <span class="c1">// 可以遍历同一个数字, 但不使用startIndex 前面的值, 应该组合是不可重复的
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span> <span class="nx">startIndex</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">candidates</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>

			<span class="k">if</span> <span class="nx">pathInt</span> <span class="p">&lt;</span> <span class="nx">target</span> <span class="p">{</span>
				<span class="nx">pathInt</span> <span class="o">+=</span> <span class="nx">candidates</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
				<span class="nx">path</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">candidates</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">)</span>
			<span class="p">}</span>
			<span class="c1">// 可以无限使用同一个
</span><span class="c1"></span>			<span class="nf">backTracking</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
			<span class="c1">// 回溯
</span><span class="c1"></span>			<span class="nx">path</span> <span class="p">=</span> <span class="nx">path</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">pathInt</span> <span class="o">-=</span> <span class="nx">candidates</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">backTracking</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>


</code></pre></div><h3 id="例三-131分割回文串">例三: 131.分割回文串</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="c1">// 简单思路
</span><span class="c1">// 切割方式, 按照树的方式:
</span><span class="c1">// 横向→循环,  纵向↓递归
</span><span class="c1">//            		aab
</span><span class="c1">//      a/      	|aa   	\aab 		//第一次切割分成三个节点, a后切割,aa后切割,aab后切割 ,对应代码的 i=0,1,2,其中分割后的结果append到path切片中
</span><span class="c1">//    a/   \b    	|b    	(aab|)		//第二次切割分成四个节点, a|a|,(a|ab|),(aa|b|),(aab|)  带括号的已经是叶子节点,该情况结束,本次递归可以返回
</span><span class="c1">//   b|    (a|ab|) (aa|b|)				//第三次切割分成四个节点, (a|a|b|),(a|ab|),(aa|b|),(aab|)
</span><span class="c1">//  (a|a|b|)
</span><span class="c1">// 以上所有方案为四种切割方式: (a|a|b|) (a|ab|) (aa|b|) (aab|)
</span><span class="c1">// 代码部分需要注意, 在切割a|a|b| 之后需要回溯,想要回溯到 a|ab|,需将path中 a|a|b|的 后面(a|b|)删除, 当path=a,则可以继续切割出 (a|ab|)节点, 后续回溯同样
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">partition</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">result</span> <span class="p">[][]</span><span class="kt">string</span>
	<span class="c1">// 判断是否回文
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">isPalindrome</span> <span class="kd">func</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span>
	<span class="nx">isPalindrome</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">true</span>
		<span class="p">}</span>
		<span class="nx">head</span><span class="p">,</span> <span class="nx">tail</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
		<span class="k">for</span> <span class="nx">head</span> <span class="p">&lt;</span> <span class="nx">tail</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">s</span><span class="p">[</span><span class="nx">head</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">tail</span><span class="p">]</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">false</span>
			<span class="p">}</span>
			<span class="nx">head</span><span class="o">++</span>
			<span class="nx">tail</span><span class="o">--</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">backtracking</span> <span class="kd">func</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">startIndex</span> <span class="kt">int</span><span class="p">)</span>
	<span class="c1">//startIndex 就是切割的位置
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">path</span> <span class="p">[]</span><span class="kt">string</span>
	<span class="nx">backtracking</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">startIndex</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">startIndex</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// 为什么要这样添加, 是因为path这个函数外slice 会最终被修改,导致最后append是相同的数据
</span><span class="c1"></span>			<span class="c1">//var newPath []string
</span><span class="c1"></span>			<span class="c1">//newPath = append(newPath,path...)
</span><span class="c1"></span>			<span class="c1">//result = append(result, newPath)
</span><span class="c1"></span>			<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nb">append</span><span class="p">([]</span><span class="nb">string</span><span class="p">(</span><span class="kc">nil</span><span class="p">),</span> <span class="nx">path</span><span class="o">...</span><span class="p">))</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">startIndex</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="c1">// 假如这里startIndex = 0 , 切割到第一个a后面
</span><span class="c1"></span>			<span class="c1">// i=1 [startIndex:i+1] = [0:1] = a 是回文
</span><span class="c1"></span>			<span class="c1">// i=2 [startIndex:i+1] = [1:2] = a 是回文
</span><span class="c1"></span>			<span class="c1">// i=3 [startIndex:i+1] = [2:3] = b 是回文
</span><span class="c1"></span>			<span class="c1">//fmt.Println(s[startIndex:i+1])
</span><span class="c1"></span>			<span class="k">if</span> <span class="nf">isPalindrome</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">startIndex</span> <span class="p">:</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
				<span class="nx">path</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">s</span><span class="p">[</span><span class="nx">startIndex</span><span class="p">:</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
				<span class="c1">//fmt.Println(&#34;backtracking前&#34;,startIndex,s[startIndex:i+1],path)
</span><span class="c1"></span>
				<span class="c1">// 寻找 i =1 的切割点
</span><span class="c1"></span>				<span class="nf">backtracking</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

				<span class="c1">// 回溯  重要!!!
</span><span class="c1"></span>				<span class="c1">// 每次 backtracking 函数执行返回的时候就是 startIndex == len(s)的时候, 也就是结果path已经添加到result中了
</span><span class="c1"></span>				<span class="c1">// 由于在isPalindrome 中, 所以前面path append了几次, backtracking函数退出的时候这里就会删除几次
</span><span class="c1"></span>				<span class="c1">// 因为是回溯, 当然是要每次删除一个尾部内容
</span><span class="c1"></span>				<span class="nx">path</span> <span class="p">=</span> <span class="nx">path</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
				<span class="c1">//fmt.Println(&#34;backtracking后&#34;,startIndex,s[startIndex:i+1],path)
</span><span class="c1"></span>			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">backtracking</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">partition</span><span class="p">(</span><span class="s">&#34;aab&#34;</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">partition</span><span class="p">(</span><span class="s">&#34;cdadad&#34;</span><span class="p">))</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go算法学习 辗转相除法</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95/</link>
			<pubDate>Fri, 16 Apr 2021 15:56:59 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95/</guid>
			<description></description>
			<content type="html"><![CDATA[<p>原文: <a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653189913&amp;idx=1&amp;sn=8667ba0170aef9b6c34713ce8cea60a8&amp;chksm=8c9905c3bbee8cd56d079bb0a436a46a18eb43061bc9390483f6cca692760f01cb575241ffff&amp;scene=21#wechat_redirect">程序员小灰 辗转相除法 更相减损术</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="c1">// 求最大公约数, 两个数都能整除的最大整数
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">MaxMin</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">a</span>
<span class="p">}</span>

<span class="c1">// 1. 暴力 O(min(a,b))
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">getGreatestCommonDivisor</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">max</span><span class="p">,</span> <span class="nx">min</span> <span class="o">:=</span> <span class="nf">MaxMin</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">max</span><span class="o">%</span><span class="nx">min</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">min</span>
	<span class="p">}</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="nx">min</span>
	<span class="k">for</span> <span class="nx">a</span><span class="o">%</span><span class="nx">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">b</span><span class="o">%</span><span class="nx">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">i</span><span class="o">--</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">i</span>
<span class="p">}</span>

<span class="c1">// 2. 辗转相除法 O(log(max(a,b)))
</span><span class="c1">// 两个数的最大公约数 = 大数对小数取余结果 和小数 的最大公约数
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">getGreatestCommonDivisor2</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nf">MaxMin</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
	<span class="c1">//取余
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">m</span><span class="o">%</span><span class="nx">n</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">m</span><span class="p">,</span> <span class="nx">n</span> <span class="p">=</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">m</span><span class="o">%</span><span class="nx">n</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">n</span>
<span class="p">}</span>

<span class="c1">// 3. 更相减损术(出自算术九章) O(max(a,b))
</span><span class="c1">// 两个数的最大公约数 = 大数减小数结果 和小数的最大公约数
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">getGreatestCommonDivisor3</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nf">MaxMin</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">m</span><span class="o">!=</span><span class="nx">n</span>  <span class="p">{</span>
		<span class="nx">m</span><span class="p">,</span> <span class="nx">n</span> <span class="p">=</span> <span class="nf">MaxMin</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">m</span><span class="o">-</span><span class="nx">n</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">n</span>
<span class="p">}</span>

<span class="c1">// 4. 更相减损术+移位操作
</span><span class="c1">// gcb(a,b)代表 a,b的最大公约数
</span><span class="c1">// 4.1 a,b都是偶数: 	gcb(a,b) = 2 * gcb(a/2,b/2)	= 2 * gcb(a&gt;&gt;1,b&gt;&gt;1)
</span><span class="c1">// 4.2 a,b是奇偶: 	gcb(a,b) = gcb(a,b/2)		= gcb(a,b&gt;&gt;1)
</span><span class="c1">// 4.3 a,b是偶奇: 	gcb(a,b) = 2 * gcb(a/2,b)	= gcb(a&gt;&gt;1,b)
</span><span class="c1">// 4.4 a,b都是奇数: 	gcb(a,b) = gcb((a-b)/2,b)	= gcb((a-b)&gt;&gt;1,b)  因为a-b必然是偶数
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">getGreatestCommonDivisor4</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nf">MaxMin</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">gcb</span> <span class="kd">func</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
	<span class="nx">gcb</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">m</span> <span class="o">==</span> <span class="nx">n</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">n</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">m</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// 偶 偶
</span><span class="c1"></span>				<span class="k">return</span> <span class="nf">gcb</span><span class="p">(</span><span class="nx">m</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">,</span><span class="nx">n</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">m</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// 奇 偶
</span><span class="c1"></span>				<span class="k">return</span> <span class="nf">gcb</span><span class="p">(</span><span class="nf">MaxMin</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span><span class="nx">n</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">))</span>
			<span class="p">}</span><span class="k">else</span> <span class="k">if</span> <span class="nx">m</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>	<span class="c1">// 偶 奇
</span><span class="c1"></span>				<span class="k">return</span> <span class="nf">gcb</span><span class="p">(</span><span class="nf">MaxMin</span><span class="p">(</span><span class="nx">m</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">,</span><span class="nx">n</span><span class="p">))</span>
			<span class="p">}</span><span class="k">else</span> <span class="p">{</span>	<span class="c1">// 奇 奇
</span><span class="c1"></span>				<span class="k">return</span> <span class="nf">gcb</span><span class="p">(</span><span class="nf">MaxMin</span><span class="p">((</span><span class="nx">m</span><span class="o">-</span><span class="nx">n</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">,</span><span class="nx">n</span><span class="p">))</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">n</span> <span class="p">=</span> <span class="nf">gcb</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span><span class="nx">n</span> <span class="p">)</span>
	<span class="k">return</span> <span class="nx">n</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">getGreatestCommonDivisor</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">768</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">getGreatestCommonDivisor2</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">768</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">getGreatestCommonDivisor3</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">248</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">getGreatestCommonDivisor4</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">248</span><span class="p">))</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go算法学习 最小栈的实现</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%9C%80%E5%B0%8F%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
			<pubDate>Fri, 16 Apr 2021 10:09:37 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%9C%80%E5%B0%8F%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
			<description></description>
			<content type="html"><![CDATA[<p>原文: <a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653190073&amp;idx=1&amp;sn=c20c002127e2ce3fe0c71a00aee70806&amp;chksm=8c990563bbee8c75521c54ea8eb44b009ad07266b1e5fbf22926baf9a7b7302c7e4f7657dbb8&amp;scene=21#wechat_redirect">程序员小灰 最小栈的实现</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>


<span class="c1">//题目：实现一个栈，带有出栈（pop），入栈（push），取最小元素（getMin）三个方法。要保证这三个方法的时间复杂度都是O（1）。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">stack</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">V</span> <span class="p">[]</span><span class="kt">int</span>	<span class="c1">// 栈存储
</span><span class="c1"></span>	<span class="nx">Min</span> <span class="p">[]</span><span class="kt">int</span>	<span class="c1">//栈最小值下标存储
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// 入栈
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">stack</span><span class="p">)</span> <span class="nf">Pop</span><span class="p">(</span><span class="nx">a</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 入栈
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nx">V</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
	<span class="c1">// 判断min是否为空
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">Min</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 如果比最小栈 栈顶值小, 就入栈
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">a</span> <span class="p">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">[</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">Min</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 出栈
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">stack</span><span class="p">)</span> <span class="nf">Push</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c1">// 出栈
</span><span class="c1"></span>	<span class="nx">a1</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="c1">// 如果出栈的下标等于最小栈栈顶的值,就删除最小栈栈顶
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">Min</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="c1">// 在删除栈顶
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nx">V</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

	<span class="k">return</span> <span class="nx">a1</span>
<span class="p">}</span>

<span class="c1">//新建堆
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewStack</span><span class="p">(</span><span class="nx">l</span> <span class="o">...</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">stack</span><span class="p">{</span>
	<span class="nx">stack1</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">stack</span><span class="p">{}</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">l</span> <span class="p">{</span>
		<span class="nx">stack1</span><span class="p">.</span><span class="nf">Pop</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">stack1</span>
<span class="p">}</span>

<span class="c1">// 查询最小值
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">stack</span><span class="p">)</span> <span class="nf">GetMin</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">min</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">Min</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="k">return</span> <span class="nx">min</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">stack1</span> <span class="o">:=</span> <span class="nf">NewStack</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">14</span><span class="p">}</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">stack1</span><span class="p">.</span><span class="nf">Pop</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">stack1</span><span class="p">)</span>
	<span class="nx">stack1</span><span class="p">.</span><span class="nf">Pop</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">stack1</span><span class="p">)</span>
	<span class="nx">stack1</span><span class="p">.</span><span class="nf">Pop</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">stack1</span><span class="p">)</span>
	<span class="nx">stack1</span><span class="p">.</span><span class="nf">Push</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">stack1</span><span class="p">)</span>

<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go算法学习 找出缺失的整数</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%89%BE%E5%87%BA%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B4%E6%95%B0/</link>
			<pubDate>Thu, 15 Apr 2021 18:09:46 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%89%BE%E5%87%BA%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B4%E6%95%B0/</guid>
			<description>原文: 程序员小灰 找出缺失的整数
实现代码 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;math/rand&amp;#34; &amp;#34;time&amp;#34; ) var ( a []int b []int c []int l = 100 r = rand.New(rand.NewSource(time.Now().UnixNano())) ) func init() { // 1~10 随机数 	tmp := r.Intn(l-1)+1 // 在生成一个不等于tmp的随机数 	var tmp2 int for tmp2 == 0 || tmp2 == tmp { tmp2 = r.Intn(l-1)+1 } fmt.Println(tmp,tmp2) for i:=1 ;i &amp;lt;=l;i++ { if i == tmp { b = append(b, i) continue } a = append(a, i) b = append(b, i) b = append(b, i) } for i:=1 ;i &amp;lt;=l;i++ { if i == tmp ||i == tmp2 { c = append(c,i) continue } c = append(c,i) c = append(c,i) } //fmt.</description>
			<content type="html"><![CDATA[<p>原文: <a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653189951&amp;idx=1&amp;sn=0181c95484b67d108672235b14e5ebbb&amp;chksm=8c9905e5bbee8cf3362ccc4c7e091caa18b5783183ce4475b6f011c09c1cb03847ea4cb5220c&amp;scene=21#wechat_redirect">程序员小灰 找出缺失的整数</a></p>
<h3 id="实现代码">实现代码</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;math/rand&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">a</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="nx">b</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="nx">c</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="nx">l</span> <span class="p">=</span> <span class="mi">100</span>
	<span class="nx">r</span> <span class="p">=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nf">NewSource</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UnixNano</span><span class="p">()))</span>

<span class="p">)</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 1~10 随机数
</span><span class="c1"></span>	<span class="nx">tmp</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="nx">l</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
	<span class="c1">// 在生成一个不等于tmp的随机数
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">tmp2</span> <span class="kt">int</span>
	<span class="k">for</span> <span class="nx">tmp2</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">tmp2</span> <span class="o">==</span> <span class="nx">tmp</span> <span class="p">{</span>
		<span class="nx">tmp2</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="nx">l</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
	<span class="p">}</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">tmp</span><span class="p">,</span><span class="nx">tmp2</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">1</span> <span class="p">;</span><span class="nx">i</span> <span class="o">&lt;=</span><span class="nx">l</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="nx">tmp</span> <span class="p">{</span>
			<span class="nx">b</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">a</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
		<span class="nx">b</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
		<span class="nx">b</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>

	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">1</span> <span class="p">;</span><span class="nx">i</span> <span class="o">&lt;=</span><span class="nx">l</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="nx">tmp</span> <span class="o">||</span><span class="nx">i</span> <span class="o">==</span> <span class="nx">tmp2</span>  <span class="p">{</span>
			<span class="nx">c</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">c</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span>
		<span class="nx">c</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">//fmt.Println(&#34;&gt;&gt;&gt; 有序数组&#34;)
</span><span class="c1"></span>	<span class="c1">//fmt.Println(a)
</span><span class="c1"></span>	<span class="c1">//fmt.Println(b)
</span><span class="c1"></span>	<span class="c1">//fmt.Println(c)
</span><span class="c1"></span>	<span class="nf">random</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
	<span class="nf">random</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
	<span class="nf">random</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
	<span class="c1">//fmt.Println(&#34;&gt;&gt;&gt; 无序数组&#34;)
</span><span class="c1"></span>	<span class="c1">//fmt.Println(a)
</span><span class="c1"></span>	<span class="c1">//fmt.Println(b)
</span><span class="c1"></span>	<span class="c1">//fmt.Println(c)
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// 随机打乱字符串算法
</span><span class="c1">//Fisher-Yates随机置乱算法
</span><span class="c1">//也称高纳德置乱算法
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">random</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)&gt;</span><span class="mi">0</span> <span class="p">{</span>
		<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>
		<span class="nx">tmp</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
		<span class="nx">nums</span><span class="p">[</span><span class="nx">tmp</span><span class="p">]</span> <span class="p">,</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">tmp</span><span class="p">]</span>
		<span class="c1">//对前n-1进行替换
</span><span class="c1"></span>		<span class="nx">nums</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[:</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">//题目：一个无序数组里有99个不重复正整数，范围从1到100，唯独缺少一个整数。如何找出这个缺失的整数？
</span><span class="c1"></span><span class="kd">func</span>  <span class="nf">findInt1</span><span class="p">(</span><span class="nx">a</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">)</span> <span class="kt">int</span>  <span class="p">{</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span> <span class="mi">0</span> <span class="p">;</span><span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">l</span><span class="o">-</span><span class="mi">1</span> <span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">sum</span><span class="o">+=</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="nx">l</span><span class="p">)</span><span class="o">*</span><span class="nx">l</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="nx">sum</span>
<span class="p">}</span>

<span class="c1">//题目扩展：一个无序数组里有若干个正整数，范围从1到100，其中99个整数都出现了偶数次，
</span><span class="c1">//只有一个整数出现了奇数次（比如1,1,2,2,3,3,4,5,5），如何找到这个出现奇数次的整数？
</span><span class="c1">// 思路: 所有的数做 异或
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">findInt2</span><span class="p">(</span><span class="nx">a</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">rst</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span> <span class="mi">1</span> <span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
		<span class="nx">rst</span> <span class="p">^=</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">rst</span>
<span class="p">}</span>

<span class="c1">//题目第二次扩展：一个无序数组里有若干个正整数，范围从1到100，其中98个整数都出现了偶数次，
</span><span class="c1">//只有两个整数出现了奇数次（比如1,1,2,2,3,4,5,5），如何找到这个出现奇数次的整数？
</span><span class="c1">// 思路:
</span><span class="c1">// 1. 先对所有数异或, 异或的结果就是两个奇数的异或结果, 这个数二进制位必定有一位是1
</span><span class="c1">// 2. 按异或结果其中一个1的位置, 将无序数组分成两个数组
</span><span class="c1">//
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">findInt3</span><span class="p">(</span><span class="nx">a</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">a1</span> <span class="o">:=</span> <span class="nf">findInt2</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
	<span class="c1">//fmt.Println(a1)
</span><span class="c1"></span>	<span class="nx">m</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">a1</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">a1</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
		<span class="nx">m</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="c1">//fmt.Println(m)
</span><span class="c1"></span>	<span class="nx">odd</span><span class="p">,</span><span class="nx">even</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// 说明该位 是1
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="nx">m</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
			<span class="nx">odd</span> <span class="p">^=</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
			<span class="nx">even</span> <span class="p">^=</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">odd</span><span class="p">,</span><span class="nx">even</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">findInt1</span><span class="p">(</span><span class="nx">a</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">findInt2</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">findInt3</span><span class="p">(</span><span class="nx">c</span><span class="p">))</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go学习 Goroutine泄露</title>
			<link>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-goroutine%E6%B3%84%E9%9C%B2/</link>
			<pubDate>Thu, 25 Feb 2021 10:43:52 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-goroutine%E6%B3%84%E9%9C%B2/</guid>
			<description>&lt;p&gt;goroutine 泄露常见说明&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>goroutine 泄露常见说明</p>
<blockquote>
<p>参考文档</p>
</blockquote>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/74090074">Go 笔记之如何防止 goroutine 泄露</a></li>
<li><a href="https://juejin.cn/post/6844903901410361358">Go 笔记之如何防止 goroutine 泄露（二）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/68921032">Go 译文之如何构建并发 Pipeline</a></li>
</ul>
<h3 id="泄露情况分类">泄露情况分类</h3>
<ul>
<li>
<ol>
<li>死循环导致goroutine 无法退出</li>
</ol>
</li>
<li>
<ol start="2">
<li>channel泄露</li>
</ol>
<ul>
<li>发送无接收</li>
<li>接收无发送</li>
<li>nil channel 发送和接收都会阻塞, 通过select方式, nil channel不会被select</li>
</ul>
</li>
<li>
<ol start="3">
<li>传统同步机制</li>
</ol>
<ul>
<li>sync.Mutex 使用未释放, 建议Lock 后执行defer  Unlock</li>
<li>sync.WaitGroup 设置的任务数错误导致一直 wait阻塞, 建议每次wg.Add(1)</li>
</ul>
</li>
</ul>
<h3 id="简单实例">简单实例</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="kd">func</span> <span class="nf">Test4</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
	<span class="nx">count</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">())</span>
	<span class="nx">timeout</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">{</span>
            <span class="k">select</span> <span class="p">{</span>
        	<span class="k">case</span> <span class="nx">c</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}:</span>
        		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
        	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
        		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;停止写入 ... &#34;</span><span class="p">)</span>
        		<span class="k">return</span>
        	<span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}()</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">c</span><span class="p">:</span>
			<span class="nx">count</span><span class="o">++</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">timeout</span><span class="p">:</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;timeout ... &#34;</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="mi">50</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">count</span> <span class="p">&gt;</span> <span class="mi">3</span> <span class="p">{</span>
				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;已经写入三次, 准备停止...&#34;</span><span class="p">)</span>
				<span class="nf">cancel</span><span class="p">()</span>
				<span class="k">return</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div><h3 id="自动化测试泄露">自动化测试泄露</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">TestTest4</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">//defer goleak.VerifyNone(t)
</span><span class="c1"></span>	<span class="k">defer</span> <span class="nx">leaktest</span><span class="p">.</span><span class="nf">Check</span><span class="p">(</span><span class="nx">t</span><span class="p">)()</span>
	<span class="nf">Test4</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><h3 id="通过-runtimenumgoroutine-函数计数">通过 runtime.NumGoroutine() 函数计数</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;runtime.NumGoroutine : &#34;</span><span class="p">,</span><span class="nx">runtime</span><span class="p">.</span><span class="nf">NumGoroutine</span><span class="p">())</span>
			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="mi">500</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">test1</span><span class="p">.</span><span class="nf">Test3</span><span class="p">()</span>
	<span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go源码学习 Sort包Search方法</title>
			<link>https://www.ngirl.xyz/golang/go%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-sort%E5%8C%85search%E6%96%B9%E6%B3%95/</link>
			<pubDate>Mon, 25 Jan 2021 14:54:22 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-sort%E5%8C%85search%E6%96%B9%E6%B3%95/</guid>
			<description>&lt;p&gt;Sort包Search方法的实践说明&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>Sort包Search方法的实践说明</p>
<h3 id="首先查看示例">首先查看示例</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;sort&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">data</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span>
	<span class="nx">sort</span><span class="p">.</span><span class="nf">Ints</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
	<span class="c1">// Search 会查询已排序数列 满足条件的最小索引
</span><span class="c1"></span>	<span class="nx">i</span> <span class="o">:=</span> <span class="nx">sort</span><span class="p">.</span><span class="nf">Search</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">),</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;当前查询的index: %v, 查询的结果data[%v]: %v&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="c1">// 因为该列表已经排序, 满足二分条件(即左边全部小于右边)
</span><span class="c1"></span>		<span class="c1">// 当满足条件的时候, 向前查询
</span><span class="c1"></span>		<span class="c1">// 只要满足条件, 前面就可能还有更小的满足条件的值
</span><span class="c1"></span>		<span class="k">return</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">23</span>
	<span class="p">})</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;最终的结果为&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="c1">// 1
</span><span class="c1"></span><span class="p">}</span>

</code></pre></div><h3 id="sort的search源码">sort的Search源码</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Search</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c1">// Define f(-1) == false and f(n) == true.
</span><span class="c1"></span>	<span class="c1">// Invariant: f(i-1) == false, f(j) == true.
</span><span class="c1"></span>	<span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">n</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">j</span> <span class="p">{</span>
		<span class="c1">// 这里左移 实现二分 h = (i+j) / 2
</span><span class="c1"></span>		<span class="nx">h</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">uint</span><span class="p">(</span><span class="nx">i</span><span class="o">+</span><span class="nx">j</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// avoid overflow when computing h
</span><span class="c1"></span>		<span class="c1">// i ≤ h &lt; j
</span><span class="c1"></span>		<span class="c1">// 如果f(h) 为false, 那么就执行 i = h + 1 , 查看 中间位置的下一个值, 向后查询
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nf">f</span><span class="p">(</span><span class="nx">h</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">i</span> <span class="p">=</span> <span class="nx">h</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// preserves f(i-1) == false
</span><span class="c1"></span>		<span class="c1">// 否则f(h) 为true , 那么执行 j = h , 查询的区间由 (i,n) 变成 (i,h) , 向前查询
</span><span class="c1"></span>		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">j</span> <span class="p">=</span> <span class="nx">h</span> <span class="c1">// preserves f(j) == true
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// i == j, f(i-1) == false, and f(j) (= f(i)) == true  =&gt;  answer is i.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">i</span>
<span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go学习 并发的实现原理</title>
			<link>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-%E5%B9%B6%E5%8F%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
			<pubDate>Thu, 14 Jan 2021 17:49:48 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-%E5%B9%B6%E5%8F%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
			<description>&lt;p&gt;go&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>go</p>
<ul>
<li><a href="https://studygolang.com/articles/22390?fr=sidebar">【深度知识】GO语言的goroutine并发原理和调度机制</a></li>
</ul>
<h3 id="go并发的模型">go并发的模型</h3>
<ul>
<li>多线程共享内存</li>
<li>CSP(communicating sequential processes)   - 以通信的方式来共享内存</li>
</ul>
<h3 id="go的csp并发模型是通过goroutine和channel来实现的">Go的CSP并发模型，是通过goroutine和channel来实现的。</h3>
<ul>
<li>goroutine 是Go语言中并发的执行单位。有点抽象，其实就是和传统概念上的&quot;线程“类似，可以理解为&quot;线程“。</li>
<li>channel是Go语言中各个并发结构体(goroutine)之前的通信机制。 通俗的讲，就是各个goroutine之间通信的&quot;管道“，有点类似于Linux中的管道。</li>
</ul>
<h3 id="go线程实现模型mpg">Go线程实现模型MPG</h3>
<ul>
<li>M指的是Machine，一个M直接关联了一个内核线程。由操作系统管理。</li>
<li>P指的是&quot;processor&quot;，代表了M所需的上下文环境，也是处理用户级代码逻辑的处理器。它负责衔接M和G的调度上下文，将等待执行的G与M对接。</li>
<li>G指的是Goroutine，其实本质上也是一种轻量级的线程。包括了调用栈，重要的调度信息，例如channel等。</li>
</ul>
<p><img src="/assets/markdown-img-paste-20210114180539724.png" alt=""></p>
<h3 id="goroutine-小结">Goroutine 小结</h3>
<h4 id="优点">优点：</h4>
<ul>
<li>
<p>1、开销小
POSIX的thread API虽然能够提供丰富的API，例如配置自己的CPU亲和性，申请资源等等，线程在得到了很多与进程相同的控制权的同时，开销也非常的大，在Goroutine中则不需这些额外的开销，所以一个Golang的程序中可以支持10w级别的Goroutine。
每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少（goroutine：2KB ，线程：8MB）</p>
</li>
<li>
<p>2、调度性能好
在Golang的程序中，操作系统级别的线程调度，通常不会做出合适的调度决策。例如在GC时，内存必须要达到一个一致的状态。在Goroutine机制里，Golang可以控制Goroutine的调度，从而在一个合适的时间进行GC。
在应用层模拟的线程，它避免了上下文切换的额外耗费，兼顾了多线程的优点。简化了高并发程序的复杂度。</p>
</li>
</ul>
<h4 id="缺点">缺点：</h4>
<p>协程调度机制无法实现公平调度。</p>]]></content>
		</item>
		
		<item>
			<title>Gee学习-路由trie测试编写</title>
			<link>https://www.ngirl.xyz/golang/gee%E5%AD%A6%E4%B9%A0-%E8%B7%AF%E7%94%B1trie%E6%B5%8B%E8%AF%95%E7%BC%96%E5%86%99/</link>
			<pubDate>Thu, 14 Jan 2021 11:32:54 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/gee%E5%AD%A6%E4%B9%A0-%E8%B7%AF%E7%94%B1trie%E6%B5%8B%E8%AF%95%E7%BC%96%E5%86%99/</guid>
			<description>github地址: github.com/zhangzw001/learnGee
 路由分析测试 package gee import ( &amp;#34;reflect&amp;#34; &amp;#34;testing&amp;#34; ) func TestParsePattern(t *testing.T) { tests := []struct { patterns string parts []string ok bool }{ {&amp;#34;/test/v1/add&amp;#34;, []string{&amp;#34;test&amp;#34;, &amp;#34;v1&amp;#34;, &amp;#34;add&amp;#34;},true }, {&amp;#34;/test/*name/add&amp;#34;, []string{&amp;#34;test&amp;#34;, &amp;#34;*name&amp;#34;},true}, {&amp;#34;/test/:name&amp;#34;, []string{&amp;#34;test&amp;#34;, &amp;#34;:name&amp;#34;},true }, {&amp;#34;/test/:name/abc&amp;#34;, []string{&amp;#34;test&amp;#34;, &amp;#34;:name&amp;#34;, &amp;#34;abc&amp;#34;},true}, {&amp;#34;/test/v1/add&amp;#34;, []string{&amp;#34;testv1&amp;#34;, &amp;#34;add&amp;#34;},false }, {&amp;#34;/test/*name/add&amp;#34;, []string{&amp;#34;test&amp;#34;, &amp;#34;*name&amp;#34;,&amp;#34;add&amp;#34;},false}, {&amp;#34;/test/:name&amp;#34;, []string{&amp;#34;test&amp;#34;, &amp;#34;:&amp;#34;,&amp;#34;name&amp;#34;},false }, {&amp;#34;/test/:name/abc&amp;#34;, []string{&amp;#34;test&amp;#34;, &amp;#34;:name&amp;#34;},false}, } m := make(map[string][]string) for _, test := range tests { m[test.patterns] = test.parts p := parsePattern(test.</description>
			<content type="html"><![CDATA[<p>github地址: <a href="github.com/zhangzw001/learnGee">github.com/zhangzw001/learnGee</a></p>
<hr>
<h3 id="路由分析测试">路由分析测试</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">gee</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;reflect&#34;</span>
	<span class="s">&#34;testing&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">TestParsePattern</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">tests</span> <span class="o">:=</span> <span class="p">[]</span><span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">patterns</span> <span class="kt">string</span>
		<span class="nx">parts</span>    <span class="p">[]</span><span class="kt">string</span>
		<span class="nx">ok</span> <span class="kt">bool</span>
	<span class="p">}{</span>
		<span class="p">{</span><span class="s">&#34;/test/v1/add&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="s">&#34;v1&#34;</span><span class="p">,</span> <span class="s">&#34;add&#34;</span><span class="p">},</span><span class="kc">true</span> <span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;/test/*name/add&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="s">&#34;*name&#34;</span><span class="p">},</span><span class="kc">true</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;/test/:name&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="s">&#34;:name&#34;</span><span class="p">},</span><span class="kc">true</span> <span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;/test/:name/abc&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="s">&#34;:name&#34;</span><span class="p">,</span> <span class="s">&#34;abc&#34;</span><span class="p">},</span><span class="kc">true</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;/test/v1/add&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;testv1&#34;</span><span class="p">,</span> <span class="s">&#34;add&#34;</span><span class="p">},</span><span class="kc">false</span> <span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;/test/*name/add&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="s">&#34;*name&#34;</span><span class="p">,</span><span class="s">&#34;add&#34;</span><span class="p">},</span><span class="kc">false</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;/test/:name&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="s">&#34;:&#34;</span><span class="p">,</span><span class="s">&#34;name&#34;</span><span class="p">},</span><span class="kc">false</span> <span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;/test/:name/abc&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="s">&#34;:name&#34;</span><span class="p">},</span><span class="kc">false</span><span class="p">},</span>
	<span class="p">}</span>

	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">test</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tests</span> <span class="p">{</span>
		<span class="nx">m</span><span class="p">[</span><span class="nx">test</span><span class="p">.</span><span class="nx">patterns</span><span class="p">]</span> <span class="p">=</span> <span class="nx">test</span><span class="p">.</span><span class="nx">parts</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nf">parsePattern</span><span class="p">(</span><span class="nx">test</span><span class="p">.</span><span class="nx">patterns</span><span class="p">)</span>

		<span class="k">if</span> <span class="nx">test</span><span class="p">.</span><span class="nx">ok</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">DeepEqual</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">m</span><span class="p">[</span><span class="nx">test</span><span class="p">.</span><span class="nx">patterns</span><span class="p">])</span> <span class="p">{</span>
				<span class="nx">t</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;expect %v, but actual %v\n&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">[</span><span class="nx">test</span><span class="p">.</span><span class="nx">patterns</span><span class="p">],</span> <span class="nx">p</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">DeepEqual</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">m</span><span class="p">[</span><span class="nx">test</span><span class="p">.</span><span class="nx">patterns</span><span class="p">])</span> <span class="p">{</span>
				<span class="nx">t</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;not expect %v, but actual %v\n&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">[</span><span class="nx">test</span><span class="p">.</span><span class="nx">patterns</span><span class="p">],</span> <span class="nx">p</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>


	<span class="p">}</span>

<span class="p">}</span>


<span class="kd">func</span> <span class="nf">Testrouter_GET</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">tests</span> <span class="o">:=</span> <span class="p">[]</span><span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">method</span>  <span class="kt">string</span>
		<span class="nx">pattern</span> <span class="kt">string</span>
		<span class="nx">parts</span>   <span class="p">[]</span><span class="kt">string</span>
		<span class="nx">ok</span>      <span class="kt">bool</span>
	<span class="p">}{</span>
		<span class="p">{</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="s">&#34;/test1/v1/add&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;/test1/v1/add&#34;</span><span class="p">},</span> <span class="kc">true</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="s">&#34;/test2/*name&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;/test2/name1&#34;</span><span class="p">,</span> <span class="s">&#34;/test2/name1/name2&#34;</span><span class="p">},</span> <span class="kc">true</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="s">&#34;/test3/:file/add&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;/test3/file123/add&#34;</span><span class="p">,</span> <span class="s">&#34;/test3/file_!@#$/add&#34;</span><span class="p">,</span> <span class="s">&#34;/test3/123431/add&#34;</span><span class="p">},</span> <span class="kc">true</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="s">&#34;/test4/:file/add&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;/test4/file123&#34;</span><span class="p">,</span> <span class="s">&#34;/test3/file_!@#$/add123&#34;</span><span class="p">,</span> <span class="s">&#34;/test3/123431/123_@#&#34;</span><span class="p">},</span> <span class="kc">false</span><span class="p">},</span>
		<span class="c1">// 这两条 应该怎么走呢?
</span><span class="c1"></span>		<span class="p">{</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="s">&#34;/hello/*name&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;/hello/geektutu/a/b&#34;</span><span class="p">,</span><span class="s">&#34;hello/geektutu&#34;</span><span class="p">},</span> <span class="kc">true</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="s">&#34;/hello/geektutu&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;hello/geektutu&#34;</span><span class="p">},</span> <span class="kc">true</span><span class="p">},</span>

	<span class="p">}</span>

	<span class="nx">r</span> <span class="o">:=</span> <span class="nf">newRouter</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">test</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tests</span> <span class="p">{</span>
		<span class="nx">r</span><span class="p">.</span><span class="nf">addRoute</span><span class="p">(</span><span class="nx">test</span><span class="p">.</span><span class="nx">method</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">pattern</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">test</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tests</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">part</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">test</span><span class="p">.</span><span class="nx">parts</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">test</span><span class="p">.</span><span class="nx">ok</span> <span class="p">{</span>
				<span class="nx">node</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">getRoute</span><span class="p">(</span><span class="nx">test</span><span class="p">.</span><span class="nx">method</span><span class="p">,</span> <span class="nx">part</span><span class="p">)</span>
				<span class="k">if</span> <span class="nx">node</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nx">t</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;url Path %s, expected : %s, but actual : %s\n&#34;</span><span class="p">,</span> <span class="nx">part</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">pattern</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">)</span>
					<span class="k">continue</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">pattern</span> <span class="o">!=</span> <span class="nx">test</span><span class="p">.</span><span class="nx">pattern</span> <span class="o">&amp;&amp;</span> <span class="nx">test</span><span class="p">.</span><span class="nx">ok</span> <span class="p">{</span>
					<span class="nx">t</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;url Path %s, expected : %s, but actual : %s\n&#34;</span><span class="p">,</span> <span class="nx">part</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">pattern</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">pattern</span><span class="p">)</span>
				<span class="p">}</span>
			<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
				<span class="nx">node</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">getRoute</span><span class="p">(</span><span class="nx">test</span><span class="p">.</span><span class="nx">method</span><span class="p">,</span> <span class="nx">part</span><span class="p">)</span>
				<span class="k">if</span> <span class="nx">node</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="k">continue</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">pattern</span> <span class="o">==</span> <span class="nx">test</span><span class="p">.</span><span class="nx">pattern</span> <span class="p">{</span>
					<span class="nx">t</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;url Path %s, not expected : %s, but actual : %s\n&#34;</span><span class="p">,</span> <span class="nx">part</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">pattern</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">pattern</span><span class="p">)</span>
				<span class="p">}</span>
			<span class="p">}</span>

		<span class="p">}</span>
	<span class="p">}</span>

<span class="p">}</span>

</code></pre></div><h3 id="路由代码">路由代码</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">gee</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;net/http&#34;</span>
	<span class="s">&#34;strings&#34;</span>
<span class="p">)</span>

<span class="c1">// 这里包装router
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">router</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">roots</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">node</span>
	<span class="nx">handlers</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">HandlerFunc</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">newRouter</span><span class="p">()</span> <span class="o">*</span><span class="nx">router</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">router</span><span class="p">{</span>
		<span class="nx">handlers</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">HandlerFunc</span><span class="p">),</span>
		<span class="nx">roots</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">node</span> <span class="p">),</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Only one * is allowed
</span><span class="c1">// 将 /test/v1/add -&gt; [test v1 add]
</span><span class="c1">// /test/*name/add -&gt; [test *name]
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">parsePattern</span><span class="p">(</span><span class="nx">pattern</span> <span class="kt">string</span> <span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="nx">vs</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="nx">pattern</span><span class="p">,</span><span class="s">&#34;/&#34;</span><span class="p">)</span>
	<span class="nx">parts</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span> <span class="p">,</span> <span class="nx">item</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">vs</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">item</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="nx">parts</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">parts</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;*&#39;</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">parts</span>
<span class="p">}</span>

<span class="c1">//
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">router</span><span class="p">)</span> <span class="nf">addRoute</span><span class="p">(</span><span class="nx">method</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">pattern</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">handler</span> <span class="nx">HandlerFunc</span> <span class="p">)</span> <span class="p">{</span>
	<span class="nx">parts</span> <span class="o">:=</span> <span class="nf">parsePattern</span><span class="p">(</span><span class="nx">pattern</span><span class="p">)</span>
	<span class="nx">key</span> <span class="o">:=</span> <span class="nx">method</span><span class="o">+</span><span class="s">&#34;-&#34;</span><span class="o">+</span><span class="nx">pattern</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">roots</span><span class="p">[</span><span class="nx">method</span><span class="p">]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">r</span><span class="p">.</span><span class="nx">roots</span><span class="p">[</span><span class="nx">method</span><span class="p">]</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">node</span><span class="p">{}</span>
	<span class="p">}</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">roots</span><span class="p">[</span><span class="nx">method</span><span class="p">].</span><span class="nf">insert</span><span class="p">(</span><span class="nx">pattern</span><span class="p">,</span><span class="nx">parts</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">handlers</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">handler</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">router</span><span class="p">)</span> <span class="nf">handle</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>

	<span class="nx">n</span><span class="p">,</span> <span class="nx">params</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">getRoute</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Method</span><span class="p">,</span><span class="nx">c</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="o">!=</span> <span class="kc">nil</span>  <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">Params</span> <span class="p">=</span> <span class="nx">params</span>
		<span class="nx">key</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Method</span> <span class="o">+</span> <span class="s">&#34;-&#34;</span> <span class="o">+</span> <span class="nx">n</span><span class="p">.</span><span class="nx">pattern</span>
		<span class="nx">r</span><span class="p">.</span><span class="nx">handlers</span><span class="p">[</span><span class="nx">key</span><span class="p">](</span><span class="nx">c</span><span class="p">)</span>
	<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusNotFound</span><span class="p">,</span><span class="s">&#34;404 not found : %s\n&#34;</span><span class="p">,</span><span class="nx">c</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">router</span><span class="p">)</span> <span class="nf">getRoute</span><span class="p">(</span><span class="nx">method</span> <span class="kt">string</span> <span class="p">,</span> <span class="nx">path</span> <span class="kt">string</span> <span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">node</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">searchParts</span> <span class="o">:=</span> <span class="nf">parsePattern</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span>
	<span class="nx">params</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span>
	<span class="nx">root</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">roots</span><span class="p">[</span><span class="nx">method</span><span class="p">]</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">root</span><span class="p">.</span><span class="nf">search</span><span class="p">(</span><span class="nx">searchParts</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">parts</span> <span class="o">:=</span> <span class="nf">parsePattern</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">pattern</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">part</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">parts</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">part</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;:&#39;</span> <span class="p">{</span>
				<span class="nx">params</span><span class="p">[</span><span class="nx">part</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span> <span class="p">=</span> <span class="nx">searchParts</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">part</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;*&#39;</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">part</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
				<span class="nx">params</span><span class="p">[</span><span class="nx">part</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">searchParts</span><span class="p">[</span><span class="nx">index</span><span class="p">:],</span> <span class="s">&#34;/&#34;</span><span class="p">)</span>
				<span class="k">break</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">params</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// 这里GET方法写在 router 里面
</span><span class="c1">// engine 是包含 router
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">router</span><span class="p">)</span> <span class="nf">GET</span><span class="p">(</span><span class="nx">pattern</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">handler</span> <span class="nx">HandlerFunc</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">r</span><span class="p">.</span><span class="nf">addRoute</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">MethodGet</span><span class="p">,</span><span class="nx">pattern</span><span class="p">,</span><span class="nx">handler</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">router</span><span class="p">)</span> <span class="nf">POST</span><span class="p">(</span><span class="nx">pattern</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">handler</span> <span class="nx">HandlerFunc</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">r</span><span class="p">.</span><span class="nf">addRoute</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">MethodPost</span><span class="p">,</span><span class="nx">pattern</span><span class="p">,</span><span class="nx">handler</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><h3 id="trie-树代码">trie 树代码</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">gee</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;strings&#34;</span>
<span class="p">)</span>

<span class="c1">// 采用 前缀树 方式来实现动态路由
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">node</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">pattern</span> <span class="kt">string</span> <span class="c1">//待匹配路由, 例如  /p/:lang , 是 req.URL.Path
</span><span class="c1"></span>	<span class="nx">part</span> <span class="kt">string</span> <span class="c1">// 路由中一部分, 例如 :lang, 是按照 / 分割的部分
</span><span class="c1"></span>	<span class="nx">children</span> <span class="p">[]</span><span class="o">*</span><span class="nx">node</span> <span class="c1">// 子节点, 例如 [ doc, tutorial, intro ]
</span><span class="c1"></span>	<span class="nx">isWild</span> <span class="kt">bool</span> <span class="c1">// 是否精确匹配, part含有: 或 * 时为true
</span><span class="c1"></span><span class="p">}</span>



<span class="c1">// 第一个匹配成功的节点, 用于插入 insert 方法
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span> <span class="p">)</span> <span class="nf">matchChild</span><span class="p">(</span><span class="nx">part</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">node</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">child</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">n</span><span class="p">.</span><span class="nx">children</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">child</span><span class="p">.</span><span class="nx">part</span> <span class="o">==</span> <span class="nx">part</span> <span class="o">||</span> <span class="nx">child</span><span class="p">.</span><span class="nx">isWild</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">child</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// 所有匹配成功的节点，用于查找 search 方法
</span><span class="c1">//  例如 /test/v1/add
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span><span class="p">)</span> <span class="nf">matchChildren</span><span class="p">(</span><span class="nx">part</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="o">*</span><span class="nx">node</span> <span class="p">{</span>
	<span class="nx">nodes</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">node</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="c1">// 查询方法就是从trie树中查询, 如果查到了添加到列表, 返回查询到的列表
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">child</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">n</span><span class="p">.</span><span class="nx">children</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">child</span><span class="p">.</span><span class="nx">part</span> <span class="o">==</span> <span class="nx">part</span> <span class="o">||</span> <span class="nx">child</span><span class="p">.</span><span class="nx">isWild</span> <span class="p">{</span>
			<span class="nx">nodes</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">nodes</span><span class="p">,</span> <span class="nx">child</span><span class="p">)</span>
			<span class="c1">// 这里加break是让查到的第一个就结束, 不希望路由匹配到多个结果
</span><span class="c1"></span>			<span class="c1">//break
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">nodes</span>
<span class="p">}</span>

<span class="c1">// 插入方法就是 判断 part路由是否已经存在路由节点中 如果是模糊匹配 直接返回
</span><span class="c1">//   if child.part == part || child.isWild {
</span><span class="c1">// 如果没有找到且是精确匹配, 那么就添加到子节点中
</span><span class="c1">//   n.children = append(n.children, child)
</span><span class="c1">//
</span><span class="c1">//  pattern 是完整路由url ,parts 是将 pattern 按照 / 拆分的 每一部分 , 然后height 从0 递归对 parts 进行查询或插入
</span><span class="c1">//
</span><span class="c1">//  这里是一个逆向看的, 可以先去查询 parsePattern 方法
</span><span class="c1">//  例如 /test/v1/add
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span><span class="p">)</span> <span class="nf">insert</span><span class="p">(</span><span class="nx">pattern</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">parts</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">height</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 在node中生成一条 test(node) -&gt; v2(node) -&gt; add(node) 一条trie链表 之后
</span><span class="c1"></span>	<span class="c1">// len(parts == height == 3 , 可以退出
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">parts</span><span class="p">)</span> <span class="o">==</span> <span class="nx">height</span> <span class="p">{</span>
		<span class="nx">n</span><span class="p">.</span><span class="nx">pattern</span> <span class="p">=</span> <span class="nx">pattern</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">//
</span><span class="c1"></span>	<span class="nx">part</span> <span class="o">:=</span> <span class="nx">parts</span><span class="p">[</span><span class="nx">height</span><span class="p">]</span>
	<span class="c1">// 首先取 test 从node中查询, 如果查到了 那么目前查到路由 : /test
</span><span class="c1"></span>	<span class="c1">// 那么继续递归insert, 取v1 去查询,
</span><span class="c1"></span>	<span class="c1">// 如果查到了说明路由存在, 如果没有查到 那么新建这个node,添加到当前node的children, 目前查到路由: /test/v1,
</span><span class="c1"></span>	<span class="c1">// 同样最后可以 在node中生成一条 test(node) -&gt; v2(node) -&gt; add(node) 一条trie链表
</span><span class="c1"></span>	<span class="nx">child</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nf">matchChild</span><span class="p">(</span><span class="nx">part</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">child</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">child</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">node</span><span class="p">{</span>
			<span class="nx">part</span><span class="p">:</span><span class="nx">part</span><span class="p">,</span>
			<span class="nx">isWild</span><span class="p">:</span><span class="nx">part</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;:&#39;</span> <span class="o">||</span> <span class="nx">part</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;*&#39;</span><span class="p">,</span>
		<span class="p">}</span>
		<span class="nx">n</span><span class="p">.</span><span class="nx">children</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">children</span><span class="p">,</span> <span class="nx">child</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">child</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="nx">pattern</span><span class="p">,</span> <span class="nx">parts</span><span class="p">,</span> <span class="nx">height</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 从node中查询节点是否存在, 如果存在就返回
</span><span class="c1">//  例如 /test/v1/add
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span><span class="p">)</span> <span class="nf">search</span><span class="p">(</span><span class="nx">parts</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">height</span> <span class="kt">int</span> <span class="p">)</span> <span class="o">*</span><span class="nx">node</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">parts</span><span class="p">)</span> <span class="o">==</span> <span class="nx">height</span> <span class="o">||</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">part</span><span class="p">,</span><span class="s">&#34;*&#34;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">pattern</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">n</span>
	<span class="p">}</span>
	<span class="nx">part</span> <span class="o">:=</span> <span class="nx">parts</span><span class="p">[</span><span class="nx">height</span><span class="p">]</span>
	<span class="c1">// 这里查询同样是 先查询 test, 如果找到trie树的第一个节点 children = [ test(node) ]
</span><span class="c1"></span>	<span class="c1">// 然后在出现v1, 根据trie结构, v1只能是在test(node) 这个节点的
</span><span class="c1"></span>	<span class="c1">// 这里需要for循环 为什么不直接取 children[0] 呢?
</span><span class="c1"></span>	<span class="c1">// 1. 有可能是因为v1 可能匹配到 /test/v1 也可能匹配到 /test/:version, 所以返回的是2个
</span><span class="c1"></span>	<span class="c1">// 2. 如果让每次matchChildren查询返回一定是唯一呢? 那如果先有路由1:&#34;/hello/geektutu&#34;, 在注册了路由2:&#34;/hello/*name&#34;, 当请求&#34;/hello/geektutu/a/b&#34;的时候就会无法匹配路由2
</span><span class="c1"></span>	<span class="nx">children</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nf">matchChildren</span><span class="p">(</span><span class="nx">part</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">child</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">children</span> <span class="p">{</span>
		<span class="c1">//log.Println(&#34;child:&#34;,child.pattern)
</span><span class="c1"></span>		<span class="nx">result</span> <span class="o">:=</span> <span class="nx">child</span><span class="p">.</span><span class="nf">search</span><span class="p">(</span><span class="nx">parts</span><span class="p">,</span> <span class="nx">height</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">result</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">result</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Gin学习 简单记录form数据获取源码解读</title>
			<link>https://www.ngirl.xyz/golang/gin%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95form%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</link>
			<pubDate>Wed, 13 Jan 2021 14:24:43 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/gin%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95form%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</guid>
			<description>http.request form 数据测试 func main() { e := gin.Default() e.Any(&amp;#34;/test&amp;#34;,func(c *gin.Context) { // 获取所有参数 	_ = c.Request.ParseForm() // log.Println(c.Request.Header[&amp;#34;Content-Type&amp;#34;]) 	// get form 参数, c.Request.URL.Query, err = url.ParseQuery 	log.Println(c.Request.URL.Query()) //log.Println(url.ParseQuery(c.Request.URL.RawQuery)) 	// post form 参数 	log.Println(c.Request.PostForm) // form 参数 	log.Println(c.Request.Form) }) e.Run(&amp;#34;localhost:8123&amp;#34;) }  请求日志
 # curl -XPOST &amp;quot;http://localhost:8123/test&amp;quot; -d &amp;quot;abc=123&amp;amp;q=123&amp;amp;ccc=123123&amp;quot; 2021/01/13 14:31:30 map[] 2021/01/13 14:31:30 map[abc:[123] ccc:[123123] q:[123]] 2021/01/13 14:31:30 map[abc:[123] ccc:[123123] q:[123]] [GIN] 2021/01/13 - 14:31:30 | 200 | 339.</description>
			<content type="html"><![CDATA[<h3 id="httprequest-form-数据测试">http.request form 数据测试</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">Default</span><span class="p">()</span>
	<span class="nx">e</span><span class="p">.</span><span class="nf">Any</span><span class="p">(</span><span class="s">&#34;/test&#34;</span><span class="p">,</span><span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// 获取所有参数
</span><span class="c1"></span>		<span class="nx">_</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nf">ParseForm</span><span class="p">()</span>
		<span class="c1">// log.Println(c.Request.Header[&#34;Content-Type&#34;])
</span><span class="c1"></span>		<span class="c1">// get form 参数, c.Request.URL.Query, err  = url.ParseQuery
</span><span class="c1"></span>		<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nf">Query</span><span class="p">())</span>
		<span class="c1">//log.Println(url.ParseQuery(c.Request.URL.RawQuery))
</span><span class="c1"></span>		<span class="c1">// post form 参数
</span><span class="c1"></span>		<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">PostForm</span><span class="p">)</span>
		<span class="c1">// form 参数
</span><span class="c1"></span>		<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">Form</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="nx">e</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="s">&#34;localhost:8123&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><blockquote>
<p>请求日志</p>
</blockquote>
<pre><code># curl -XPOST &quot;http://localhost:8123/test&quot; -d &quot;abc=123&amp;q=123&amp;ccc=123123&quot;
2021/01/13 14:31:30 map[]
2021/01/13 14:31:30 map[abc:[123] ccc:[123123] q:[123]]
2021/01/13 14:31:30 map[abc:[123] ccc:[123123] q:[123]]
[GIN] 2021/01/13 - 14:31:30 | 200 |     339.106µs |       127.0.0.1 | POST     &quot;/test&quot;

# curl &quot;http://localhost:8123/test?aaa=111&amp;bbbb=2222&quot;
2021/01/13 14:31:38 map[aaa:[111] bbbb:[2222]]
2021/01/13 14:31:38 map[]
2021/01/13 14:31:38 map[aaa:[111] bbbb:[2222]]
[GIN] 2021/01/13 - 14:31:38 | 200 |      73.852µs |       127.0.0.1 | GET      &quot;/test?aaa=111&amp;bbbb=2222&quot;

# curl -XPOST &quot;http://localhost:8123/test?aaa=111&amp;bbbb=2222&quot; -d &quot;abc=123&amp;q=123&amp;ccc=123123&quot;
2021/01/13 14:31:48 map[aaa:[111] bbbb:[2222]]
2021/01/13 14:31:48 map[abc:[123] ccc:[123123] q:[123]]
2021/01/13 14:31:48 map[aaa:[111] abc:[123] bbbb:[2222] ccc:[123123] q:[123]]
[GIN] 2021/01/13 - 14:31:48 | 200 |     119.833µs |       127.0.0.1 | POST     &quot;/test?aaa=111&amp;bbbb=2222&quot;

</code></pre><h3 id="看下parseform-的源码">看下ParseForm 的源码</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="nf">ParseForm</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">PostForm</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 以下方法 会调用 parsePostForm
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Method</span> <span class="o">==</span> <span class="s">&#34;POST&#34;</span> <span class="o">||</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Method</span> <span class="o">==</span> <span class="s">&#34;PUT&#34;</span> <span class="o">||</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Method</span> <span class="o">==</span> <span class="s">&#34;PATCH&#34;</span> <span class="p">{</span>
			<span class="nx">r</span><span class="p">.</span><span class="nx">PostForm</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">parsePostForm</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">PostForm</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">r</span><span class="p">.</span><span class="nx">PostForm</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">url</span><span class="p">.</span><span class="nx">Values</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Form</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 这里  PostForm 会复制到 Form, 所以 Form &gt;= PostForm
</span><span class="c1"></span>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">PostForm</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">r</span><span class="p">.</span><span class="nx">Form</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">url</span><span class="p">.</span><span class="nx">Values</span><span class="p">)</span>
			<span class="nf">copyValues</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Form</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">PostForm</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// 这里 get的参数是在r.URL里面的, 所以通过 ParseQuery 获取get参数
</span><span class="c1"></span>		<span class="kd">var</span> <span class="nx">newValues</span> <span class="nx">url</span><span class="p">.</span><span class="nx">Values</span>
		<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">URL</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="kd">var</span> <span class="nx">e</span> <span class="kt">error</span>
			<span class="nx">newValues</span><span class="p">,</span> <span class="nx">e</span> <span class="p">=</span> <span class="nx">url</span><span class="p">.</span><span class="nf">ParseQuery</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">RawQuery</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">err</span> <span class="p">=</span> <span class="nx">e</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">newValues</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">newValues</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">url</span><span class="p">.</span><span class="nx">Values</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// 最后也会添加 get参数到form, 所以 Form &gt;= url.Query()
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Form</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">r</span><span class="p">.</span><span class="nx">Form</span> <span class="p">=</span> <span class="nx">newValues</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nf">copyValues</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Form</span><span class="p">,</span> <span class="nx">newValues</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></div><h3 id="这里看下-parsepostform">这里看下 parsePostForm</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">parsePostForm</span><span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">(</span><span class="nx">vs</span> <span class="nx">url</span><span class="p">.</span><span class="nx">Values</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Body</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;missing form body&#34;</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">ct</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;Content-Type&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">ct</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">ct</span> <span class="p">=</span> <span class="s">&#34;application/octet-stream&#34;</span>
	<span class="p">}</span>
	<span class="nx">ct</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">mime</span><span class="p">.</span><span class="nf">ParseMediaType</span><span class="p">(</span><span class="nx">ct</span><span class="p">)</span>
	<span class="k">switch</span> <span class="p">{</span>
	<span class="c1">// 这里我们默认的header 就是 application/x-www-form-urlencoded
</span><span class="c1"></span>	<span class="c1">// 可以 log.Println(c.Request.Header[&#34;Content-Type&#34;]) 打印查看
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">ct</span> <span class="o">==</span> <span class="s">&#34;application/x-www-form-urlencoded&#34;</span><span class="p">:</span>
		<span class="kd">var</span> <span class="nx">reader</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Body</span>
		<span class="c1">// 首先初始化 maxFormSize = 2^63 -1
</span><span class="c1"></span>		<span class="nx">maxFormSize</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">63</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Body</span><span class="p">.(</span><span class="o">*</span><span class="nx">maxBytesReader</span><span class="p">);</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
			<span class="c1">// 设置 io.LimitedReader 的  N
</span><span class="c1"></span>			<span class="nx">maxFormSize</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">10</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">)</span> <span class="c1">// 10 MB is a lot of text.
</span><span class="c1"></span>			<span class="c1">// 返回了一个 带限制的 io.LimitedReader, 当然实现了 Reader interfacer
</span><span class="c1"></span>			<span class="nx">reader</span> <span class="p">=</span> <span class="nx">io</span><span class="p">.</span><span class="nf">LimitReader</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Body</span><span class="p">,</span> <span class="nx">maxFormSize</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// 这里会调用 io.LimitedReader 的Read 方法, 通过接口实现
</span><span class="c1"></span>		<span class="c1">// 直接读取post 的body即可
</span><span class="c1"></span>		<span class="nx">b</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadAll</span><span class="p">(</span><span class="nx">reader</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">e</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">err</span> <span class="p">=</span> <span class="nx">e</span>
			<span class="p">}</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nb">int64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span> <span class="p">&gt;</span> <span class="nx">maxFormSize</span> <span class="p">{</span>
			<span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;http: POST too large&#34;</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="c1">// 最终也是调用 url.ParseQuery
</span><span class="c1"></span>		<span class="c1">// 这里 string(b) = abc=123&amp;q=123&amp;ccc=123123
</span><span class="c1"></span>		<span class="nx">vs</span><span class="p">,</span> <span class="nx">e</span> <span class="p">=</span> <span class="nx">url</span><span class="p">.</span><span class="nf">ParseQuery</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">err</span> <span class="p">=</span> <span class="nx">e</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="nx">ct</span> <span class="o">==</span> <span class="s">&#34;multipart/form-data&#34;</span><span class="p">:</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>

</code></pre></div><h3 id="简单看下-iolimitedreader-的read-方法">简单看下 io.LimitedReader 的Read 方法</h3>
<blockquote>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">LimitedReader</span><span class="p">)</span> <span class="nf">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nx">N</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">EOF</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">int64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">))</span> <span class="p">&gt;</span> <span class="nx">l</span><span class="p">.</span><span class="nx">N</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="p">=</span> <span class="nx">p</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nx">l</span><span class="p">.</span><span class="nx">N</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">R</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">N</span> <span class="o">-=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
	<span class="k">return</span>
<span class="p">}</span>

</code></pre></div><h3 id="parsequery-分析">parseQuery 分析</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="kd">func</span> <span class="nf">parseQuery</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Values</span><span class="p">,</span> <span class="nx">query</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 这里的循环结束条件是 query == &#34;&#34;
</span><span class="c1"></span>	<span class="c1">// 那什么时候会空呢?
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">query</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">key</span> <span class="o">:=</span> <span class="nx">query</span>
		<span class="c1">// 这里取到第一个 &amp;或者; 的索引, 然后将 query 分成两半
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">IndexAny</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="s">&#34;&amp;;&#34;</span><span class="p">);</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// 这里会每次 截取后一半 赋值给query, 所以query一直在消耗 第一个&amp;前的数据
</span><span class="c1"></span>			<span class="nx">key</span><span class="p">,</span> <span class="nx">query</span> <span class="p">=</span> <span class="nx">key</span><span class="p">[:</span><span class="nx">i</span><span class="p">],</span> <span class="nx">key</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
		<span class="c1">// 如果 已经没有 &amp; 或者 ; 字符了, 说明只有最后一个字段了, 那么就直接置空 query, 然后读取完key 就可以结束循环了
</span><span class="c1"></span>		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">query</span> <span class="p">=</span> <span class="s">&#34;&#34;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">key</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">value</span> <span class="o">:=</span> <span class="s">&#34;&#34;</span>
		<span class="c1">// 取出 第一个 &amp; 前面的 参数 按照=分割, 从而得到 变量名 和变量值
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Index</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="s">&#34;=&#34;</span><span class="p">);</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="p">=</span> <span class="nx">key</span><span class="p">[:</span><span class="nx">i</span><span class="p">],</span> <span class="nx">key</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
		<span class="p">}</span>
		<span class="nx">key</span><span class="p">,</span> <span class="nx">err1</span> <span class="o">:=</span> <span class="nf">QueryUnescape</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err1</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">err</span> <span class="p">=</span> <span class="nx">err1</span>
			<span class="p">}</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">value</span><span class="p">,</span> <span class="nx">err1</span> <span class="p">=</span> <span class="nf">QueryUnescape</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err1</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">err</span> <span class="p">=</span> <span class="nx">err1</span>
			<span class="p">}</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="c1">// 最后将 post参数写成map结构 写到m (url.Value) 中
</span><span class="c1"></span>		<span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">],</span> <span class="nx">value</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Gin学习 Validator</title>
			<link>https://www.ngirl.xyz/golang/gin%E5%AD%A6%E4%B9%A0-validator/</link>
			<pubDate>Tue, 12 Jan 2021 10:17:46 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/gin%E5%AD%A6%E4%B9%A0-validator/</guid>
			<description>&lt;p&gt;记录一下Gin学习验证器和翻译器模块&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>记录一下Gin学习验证器和翻译器模块</p>
<ul>
<li>github地址: <a href="https://github.com/zhangzw001/learnGin/tree/gin-shouldbind">https://github.com/zhangzw001/learnGin/tree/gin-shouldbind</a></li>
<li>官方文档: <a href="https://godoc.org/github.com/go-playground/validator">https://godoc.org/github.com/go-playground/validator</a></li>
<li>官方示例: <a href="https://github.com/go-playground/validator/tree/v10.4.1/_examples">https://github.com/go-playground/validator/tree/v10.4.1/_examples</a></li>
<li>原文: <a href="https://github.com/xinliangnote/Go">https://github.com/xinliangnote/Go</a></li>
</ul>
<h3 id="功能演示介绍">功能演示介绍</h3>
<blockquote>
<p>首先这个模块是很方便校验接口的输入结构体参数是否符合规则,不用繁琐的自己写参数校验, 翻译器又可以支持不同语言的错误提示,而且可以自定义返回错误格式覆盖默认的格式</p>
</blockquote>
<pre><code>1. 调用localhost:8000/sn/create 执行验证器中间件
2. 调用localhost:8000/v1/product/add 执行验证器,签名等中间件
</code></pre><h3 id="部分相关目录结构">部分相关目录结构</h3>
<pre><code>.
├── config
│   └── env.go
├── controller
│   ├── api
│   │   └── v1.go
│   └── sign
│       └── sign.go
├── docs
│   ├── docs.go
│   ├── swagger.json
│   └── swagger.yaml
├── dto
│   └── api.go
├── go.mod
├── go.sum
├── logs
│   ├── gin-logger.log -&gt; gin-logger.log.20210112-000000.log
│   └── gin-logger.log.20210112-000000.log
├── main.go
├── middleware
│   ├── logger.go
│   ├── response.go
│   ├── sign.go
│   └── validator.go
├── public
│   ├── public.go
│   └── validator.go
└── routers
    └── router.go

</code></pre><h3 id="1-首先定义路由规则">1. 首先定义路由规则</h3>
<h4 id="routersroutergo">routers/router.go</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">routers</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
	<span class="nx">ginSwagger</span> <span class="s">&#34;github.com/swaggo/gin-swagger&#34;</span>
	<span class="s">&#34;github.com/swaggo/gin-swagger/swaggerFiles&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/controller/api&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/controller/sign&#34;</span>
	<span class="c1">// 这里需要导入自己项目的目录,否则swagger页面会报错
</span><span class="c1"></span>	<span class="nx">_</span> <span class="s">&#34;github.com/zhangzw001/learnGin/docs&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/middleware&#34;</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">InitRouter</span><span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Engine</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// swagger 文档
</span><span class="c1"></span>	<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/swagger/*any&#34;</span><span class="p">,</span><span class="nx">ginSwagger</span><span class="p">.</span><span class="nf">WrapHandler</span><span class="p">(</span><span class="nx">swaggerFiles</span><span class="p">.</span><span class="nx">Handler</span><span class="p">))</span>
	<span class="c1">// sign路由
</span><span class="c1"></span>	<span class="nx">Sign</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nf">Group</span><span class="p">(</span><span class="s">&#34;/sn&#34;</span><span class="p">)</span>
	<span class="nx">Sign</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">middleware</span><span class="p">.</span><span class="nf">TranslationMiddleware</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="nx">controllersign</span><span class="p">.</span><span class="nf">RegisterSign</span><span class="p">(</span><span class="nx">Sign</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// api v1版本路由
</span><span class="c1"></span>	<span class="nx">GroupV1</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nf">Group</span><span class="p">(</span><span class="s">&#34;/v1&#34;</span><span class="p">)</span>
	<span class="nx">GroupV1</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">middleware</span><span class="p">.</span><span class="nf">SignMiddleware</span><span class="p">(),</span><span class="nx">middleware</span><span class="p">.</span><span class="nf">TranslationMiddleware</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="nx">controllerapi</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">GroupV1</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="2-看下sign-controller">2. 看下sign controller</h3>
<h4 id="21-controllersignsigngo">2.1 controller/sign/sign.go</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">controllersign</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/dto&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/middleware&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/public&#34;</span>
	<span class="s">&#34;strconv&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Controller</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="nf">RegisterSign</span><span class="p">(</span><span class="nx">router</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">RouterGroup</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">sign</span> <span class="o">:=</span> <span class="nx">Controller</span><span class="p">{}</span>
	<span class="nx">router</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/create&#34;</span><span class="p">,</span> <span class="nx">sign</span><span class="p">.</span><span class="nx">Create</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Add godoc
</span><span class="c1">// @Summary sign接口
</span><span class="c1">// @Description sign接口
</span><span class="c1">// @Tags sign 创建接口
</span><span class="c1">// @ID /sn/create
</span><span class="c1">// @Accept  json
</span><span class="c1">// @Produce  json
</span><span class="c1">// @Param name query string true &#34;名称&#34;
</span><span class="c1">// @Param price query string true &#34;价格&#34;
</span><span class="c1">// @Success 200 {object} middleware.Response{data=dto.ApiOutput} &#34;success&#34;
</span><span class="c1">// @Router /sn/create [get]
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">sign</span> <span class="nx">Controller</span><span class="p">)</span> <span class="nf">Create</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">ts</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">FormatInt</span><span class="p">(</span><span class="nx">public</span><span class="p">.</span><span class="nf">GetTimeUnix</span><span class="p">(),</span> <span class="mi">10</span><span class="p">)</span>

	<span class="nx">params</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">dto</span><span class="p">.</span><span class="nx">ApiUpdateInput</span><span class="p">{}</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">params</span><span class="p">.</span><span class="nf">BindValueParam</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">middleware</span><span class="p">.</span><span class="nf">ResponseError</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="mi">10001</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">paramsSign</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">Form</span>
	<span class="nx">paramsSign</span><span class="p">[</span><span class="s">&#34;ts&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="nx">ts</span><span class="p">}</span>

	<span class="nx">data</span> <span class="o">:=</span> <span class="nx">dto</span><span class="p">.</span><span class="nx">ApiOutput</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span>  <span class="nx">params</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span>
		<span class="nx">Price</span><span class="p">:</span> <span class="nx">params</span><span class="p">.</span><span class="nx">Price</span><span class="p">,</span>
		<span class="nx">Ts</span><span class="p">:</span>    <span class="nx">ts</span><span class="p">,</span>
		<span class="nx">Sn</span><span class="p">:</span>    <span class="nx">public</span><span class="p">.</span><span class="nf">CreateSign</span><span class="p">(</span><span class="nx">paramsSign</span><span class="p">),</span>
	<span class="p">}</span>
	<span class="nx">middleware</span><span class="p">.</span><span class="nf">ResponseSuccess</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h4 id="22-数据传输-dtoapigo">2.2 数据传输 dto.api.go</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="err">#</span><span class="o">/</span><span class="nx">sn</span><span class="o">/</span><span class="nx">create</span> <span class="nx">的输入仅允许两个参数</span>
<span class="kd">type</span> <span class="nx">ApiUpdateInput</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// 这里validate 代表通过validator.v10验证自定义规则 test_tag,默认规则 required 表示必传字段
</span><span class="c1"></span>	<span class="nx">Name</span> <span class="kt">string</span>		<span class="s">`json:&#34;name&#34; form:&#34;name&#34; comment:&#34;名称&#34; example:&#34;abcdef&#34; validate:&#34;required,test_tag&#34;`</span>
    <span class="c1">// 这里仅验证最小值0
</span><span class="c1"></span>	<span class="nx">Price</span> <span class="kt">int</span>	<span class="s">`json:&#34;price&#34; form:&#34;price&#34; comment:&#34;价格&#34; example:&#34;10&#34; validate:&#34;required,min=0&#34;`</span>
<span class="p">}</span>

<span class="c1">// 绑定结构体
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">param</span> <span class="o">*</span><span class="nx">ApiUpdateInput</span><span class="p">)</span> <span class="nf">BindValueParam</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span>  <span class="p">{</span>
	<span class="k">return</span> <span class="nx">public</span><span class="p">.</span><span class="nf">DefaultGetValidParams</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="nx">param</span><span class="p">)</span>
<span class="p">}</span>

<span class="err">#</span> <span class="nx">另外output结构体</span><span class="p">,</span><span class="nx">这里不需要验证器</span>
<span class="kd">type</span> <span class="nx">ApiOutput</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span> <span class="kt">string</span>
	<span class="nx">Price</span> <span class="kt">int</span>
	<span class="nx">Ts</span> <span class="kt">string</span>
	<span class="nx">Sn</span> <span class="kt">string</span>
<span class="p">}</span>


<span class="kd">type</span> <span class="nx">ApiAddInput</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span> <span class="kt">string</span> <span class="s">`json:&#34;name&#34; form:&#34;name&#34; comment:&#34;名称&#34; example:&#34;abc&#34; validate:&#34;required,test_tag,max=24,min=6&#34;`</span>
	<span class="nx">Price</span> <span class="kt">int</span> <span class="s">`json:&#34;price&#34; form:&#34;price&#34; comment:&#34;价格&#34; example:&#34;abc&#34;  validate:&#34;required,min=0&#34;`</span>
	<span class="nx">Ts</span> <span class="kt">string</span> <span class="s">`json:&#34;ts&#34; form:&#34;ts&#34; comment:&#34;有效期&#34; example:&#34;&#34; validate:&#34;required,min=1&#34;`</span>
	<span class="nx">Sn</span> <span class="kt">string</span> <span class="s">`json:&#34;sn&#34; form:&#34;sn&#34; comment:&#34;签名&#34; example:&#34;&#34; validate:&#34;required,min=32,max=32&#34;`</span>
<span class="p">}</span>

<span class="c1">// 绑定结构体
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">param</span> <span class="o">*</span><span class="nx">ApiAddInput</span><span class="p">)</span> <span class="nf">BindValueParam</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span>  <span class="p">{</span>
	<span class="k">return</span> <span class="nx">public</span><span class="p">.</span><span class="nf">DefaultGetValidParams</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="nx">param</span><span class="p">)</span>
<span class="p">}</span>


</code></pre></div><h4 id="23-publicvalidatorgo-调用shouldbind-验证器-和翻译器">2.3 public/validator.go 调用shouldbind ,验证器 和翻译器</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">public</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
	<span class="nx">ut</span> <span class="s">&#34;github.com/go-playground/universal-translator&#34;</span>
	<span class="s">&#34;github.com/go-playground/validator/v10&#34;</span>
	<span class="s">&#34;github.com/pkg/errors&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/config&#34;</span>
	<span class="s">&#34;strings&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">DefaultGetValidParams</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">params</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">ShouldBind</span><span class="p">(</span><span class="nx">params</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="c1">// 获取验证器
</span><span class="c1"></span>	<span class="nx">valid</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">GetValidator</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="c1">// 获取翻译器
</span><span class="c1"></span>	<span class="nx">trans</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">GetTranslate</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="nx">err</span> <span class="p">=</span> <span class="nx">valid</span><span class="p">.</span><span class="nf">Struct</span><span class="p">(</span><span class="nx">params</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">errs</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="nx">validator</span><span class="p">.</span><span class="nx">ValidationErrors</span><span class="p">)</span>
		<span class="nx">sliceErrs</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{}</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span><span class="k">range</span> <span class="nx">errs</span> <span class="p">{</span>
			<span class="nx">sliceErrs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">sliceErrs</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nf">Translate</span><span class="p">(</span><span class="nx">trans</span><span class="p">))</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">sliceErrs</span><span class="p">,</span> <span class="s">&#34;,&#34;</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// 获取验证器
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GetValidator</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">validator</span><span class="p">.</span><span class="nx">Validate</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">ValidatorKey</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;未设置验证器&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">validate</span> <span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">val</span><span class="p">.(</span><span class="o">*</span><span class="nx">validator</span><span class="p">.</span><span class="nx">Validate</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;获取验证器失败&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">validate</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// 获取翻译器
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GetTranslate</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">ut</span><span class="p">.</span><span class="nx">Translator</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">trans</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">TranslatorKey</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;未设置翻译器&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">translator</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">trans</span><span class="p">.(</span><span class="nx">ut</span><span class="p">.</span><span class="nx">Translator</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;获取翻译器失败&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">translator</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

</code></pre></div><h3 id="3-中间件-middlewarevalidatorgo">3. 中间件 middleware/validator.go</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">middleware</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
	<span class="s">&#34;github.com/go-playground/locales/en&#34;</span>
	<span class="s">&#34;github.com/go-playground/locales/zh&#34;</span>
	<span class="nx">ut</span> <span class="s">&#34;github.com/go-playground/universal-translator&#34;</span>
	<span class="s">&#34;github.com/go-playground/validator/v10&#34;</span>
	<span class="nx">en_translations</span> <span class="s">&#34;github.com/go-playground/validator/v10/translations/en&#34;</span>
	<span class="nx">zh_translations</span> <span class="s">&#34;github.com/go-playground/validator/v10/translations/zh&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/config&#34;</span>
	<span class="s">&#34;reflect&#34;</span>
	<span class="s">&#34;regexp&#34;</span>
<span class="p">)</span>


<span class="c1">// 设置验证器+翻译器
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">TranslationMiddleware</span><span class="p">()</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">HandlerFunc</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// 创建验证器实例
</span><span class="c1"></span>		<span class="nx">val</span> <span class="o">:=</span> <span class="nx">validator</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

		<span class="c1">// 设置支持的语言
</span><span class="c1"></span>		<span class="nx">en</span> <span class="o">:=</span> <span class="nx">en</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
		<span class="nx">zh</span> <span class="o">:=</span> <span class="nx">zh</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
		<span class="c1">// 创建翻译器, 支持zh,en两种
</span><span class="c1"></span>		<span class="nx">uni</span> <span class="o">:=</span> <span class="nx">ut</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">zh</span><span class="p">,</span> <span class="nx">zh</span><span class="p">,</span><span class="nx">en</span><span class="p">)</span>
		<span class="c1">// 根据参数取翻译器实例
</span><span class="c1"></span>		<span class="nx">locale</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">DefaultQuery</span><span class="p">(</span><span class="s">&#34;locale&#34;</span><span class="p">,</span><span class="s">&#34;zh&#34;</span><span class="p">)</span>
		<span class="c1">// 获取默认的f.fallback
</span><span class="c1"></span>		<span class="nx">trans</span> <span class="p">,</span><span class="nx">_</span> <span class="o">:=</span> <span class="nx">uni</span><span class="p">.</span><span class="nf">GetTranslator</span><span class="p">(</span><span class="nx">locale</span><span class="p">)</span>

		<span class="c1">// 翻译器注册到验证器
</span><span class="c1"></span>		<span class="k">switch</span> <span class="nx">locale</span> <span class="p">{</span>
		<span class="k">case</span> <span class="s">&#34;en&#34;</span><span class="p">:</span>
			<span class="nx">_</span> <span class="p">=</span> <span class="nx">en_translations</span><span class="p">.</span><span class="nf">RegisterDefaultTranslations</span><span class="p">(</span><span class="nx">val</span><span class="p">,</span><span class="nx">trans</span><span class="p">)</span>
			<span class="nx">val</span><span class="p">.</span><span class="nf">RegisterTagNameFunc</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">fld</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">StructField</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">fld</span><span class="p">.</span><span class="nx">Tag</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;en_comment&#34;</span><span class="p">)</span>
			<span class="p">})</span>
			<span class="k">break</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="nx">_</span> <span class="p">=</span> <span class="nx">zh_translations</span><span class="p">.</span><span class="nf">RegisterDefaultTranslations</span><span class="p">(</span><span class="nx">val</span><span class="p">,</span><span class="nx">trans</span><span class="p">)</span>
			<span class="nx">val</span><span class="p">.</span><span class="nf">RegisterTagNameFunc</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">fld</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">StructField</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">fld</span><span class="p">.</span><span class="nx">Tag</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;comment&#34;</span><span class="p">)</span>
			<span class="p">})</span>

			<span class="c1">// 自定义的验证器
</span><span class="c1"></span>			<span class="nx">val</span><span class="p">.</span><span class="nf">RegisterValidation</span><span class="p">(</span><span class="s">&#34;test_tag&#34;</span><span class="p">,</span><span class="kd">func</span><span class="p">(</span><span class="nx">fl</span> <span class="nx">validator</span><span class="p">.</span><span class="nx">FieldLevel</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
				<span class="nx">matched</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MatchString</span><span class="p">(</span><span class="s">`^[_0-9a-zA-Z]{6,24}$`</span><span class="p">,</span><span class="nx">fl</span><span class="p">.</span><span class="nf">Field</span><span class="p">().</span><span class="nf">String</span><span class="p">())</span>
				<span class="k">return</span> <span class="nx">matched</span>
			<span class="p">})</span>

			<span class="c1">// 自定义的翻译器
</span><span class="c1"></span>			<span class="nx">val</span><span class="p">.</span><span class="nf">RegisterTranslation</span><span class="p">(</span><span class="s">&#34;test_tag&#34;</span><span class="p">,</span><span class="nx">trans</span><span class="p">,</span><span class="kd">func</span><span class="p">(</span><span class="nx">ut</span> <span class="nx">ut</span><span class="p">.</span><span class="nx">Translator</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">ut</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;test_tag&#34;</span><span class="p">,</span><span class="s">&#34;{0} 填写不正确,仅允许数字字母下划线,长度大于6小于24&#34;</span><span class="p">,</span><span class="kc">true</span>  <span class="p">)</span>
			<span class="p">},</span><span class="kd">func</span><span class="p">(</span><span class="nx">ut</span> <span class="nx">ut</span><span class="p">.</span><span class="nx">Translator</span><span class="p">,</span> <span class="nx">fe</span> <span class="nx">validator</span><span class="p">.</span><span class="nx">FieldError</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
				<span class="nx">t</span> <span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">ut</span><span class="p">.</span><span class="nf">T</span><span class="p">(</span><span class="s">&#34;test_tag&#34;</span><span class="p">,</span><span class="nx">fe</span><span class="p">.</span><span class="nf">Field</span><span class="p">())</span>
				<span class="k">return</span> <span class="nx">t</span>
			<span class="p">})</span>
			<span class="k">break</span>
		<span class="p">}</span>

		<span class="c1">// 设置翻译器和验证器
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">TranslatorKey</span><span class="p">,</span><span class="nx">trans</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">ValidatorKey</span><span class="p">,</span><span class="nx">val</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h3 id="4-中间件-middlewaresigngo">4. 中间件 middleware/sign.go</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">middleware</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
	<span class="s">&#34;github.com/pkg/errors&#34;</span>
	<span class="nx">config2</span> <span class="s">&#34;github.com/zhangzw001/learnGin/config&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/public&#34;</span>
	<span class="s">&#34;net/url&#34;</span>
	<span class="s">&#34;strconv&#34;</span>
<span class="p">)</span>



<span class="kd">func</span> <span class="nf">SignMiddleware</span><span class="p">()</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">HandlerFunc</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">method</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">Method</span>
		<span class="kd">var</span> <span class="nx">ts</span> <span class="kt">int64</span>
		<span class="kd">var</span> <span class="nx">sn</span> <span class="kt">string</span>
		<span class="kd">var</span> <span class="nx">req</span> <span class="nx">url</span><span class="p">.</span><span class="nx">Values</span>

		<span class="k">if</span> <span class="nx">method</span> <span class="o">==</span> <span class="s">&#34;GET&#34;</span> <span class="p">{</span>
			<span class="nx">req</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nf">Query</span><span class="p">()</span>
			<span class="nx">sn</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;sn&#34;</span><span class="p">)</span>
			<span class="nx">ts</span><span class="p">,</span> <span class="nx">_</span>  <span class="p">=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">ParseInt</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;ts&#34;</span><span class="p">),</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>

		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">method</span> <span class="o">==</span> <span class="s">&#34;POST&#34;</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nf">ParseForm</span><span class="p">()</span>
			<span class="nx">req</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">PostForm</span>
			<span class="nx">sn</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">PostForm</span><span class="p">(</span><span class="s">&#34;sn&#34;</span><span class="p">)</span>
			<span class="nx">ts</span><span class="p">,</span> <span class="nx">_</span>  <span class="p">=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">ParseInt</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">PostForm</span><span class="p">(</span><span class="s">&#34;ts&#34;</span><span class="p">),</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nf">ResponseError</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="mi">10000</span><span class="p">,</span><span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;Illegal requests&#34;</span><span class="p">))</span>
			<span class="k">return</span>
		<span class="p">}</span>

		<span class="nx">exp</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">ParseInt</span><span class="p">(</span><span class="nx">config2</span><span class="p">.</span><span class="nx">ApiExpiry</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>

		<span class="c1">// 验证过期时间
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">ts</span> <span class="p">&gt;</span> <span class="nx">public</span><span class="p">.</span><span class="nf">GetTimeUnix</span><span class="p">()</span> <span class="o">||</span> <span class="nx">public</span><span class="p">.</span><span class="nf">GetTimeUnix</span><span class="p">()</span> <span class="o">-</span> <span class="nx">ts</span> <span class="o">&gt;=</span> <span class="nx">exp</span> <span class="p">{</span>
			<span class="nf">ResponseError</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="mi">10001</span><span class="p">,</span><span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;Ts Error&#34;</span><span class="p">))</span>
			<span class="k">return</span>
		<span class="p">}</span>

		<span class="c1">// 验证签名
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">sn</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="o">||</span> <span class="nx">sn</span> <span class="o">!=</span> <span class="nx">public</span><span class="p">.</span><span class="nf">CreateSign</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span> <span class="p">{</span>
			<span class="nf">ResponseError</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="mi">10002</span><span class="p">,</span><span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;Sn Error&#34;</span><span class="p">))</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="c1">//
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h3 id="5-统一的返回参-middlewareresponsego">5. 统一的返回参 middleware/response.go</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">middleware</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;encoding/json&#34;</span>
	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">ResponseCode</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">SuccessCode</span> <span class="nx">ResponseCode</span> <span class="p">=</span> <span class="mi">200</span> <span class="o">+</span> <span class="kc">iota</span>
	<span class="nx">StatusCreated</span>
	<span class="nx">StatusAccepted</span>
	<span class="nx">InternalServerError</span> <span class="nx">ResponseCode</span> <span class="p">=</span> <span class="mi">500</span>
	<span class="nx">CustomizeCode</span>           <span class="p">=</span> <span class="mi">1000</span>
	<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Response</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Code</span> <span class="nx">ResponseCode</span> <span class="s">`json:&#34;code&#34;`</span>
	<span class="nx">Msg</span>  <span class="kt">string</span>       <span class="s">`json:&#34;msg&#34;`</span>
	<span class="nx">Data</span> <span class="kd">interface</span><span class="p">{}</span>  <span class="s">`json:&#34;data&#34;`</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">ResponseSuccess</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nx">resp</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Response</span><span class="p">{</span>
		<span class="nx">Code</span><span class="p">:</span> <span class="nx">SuccessCode</span><span class="p">,</span>
		<span class="nx">Msg</span><span class="p">:</span>  <span class="s">&#34;ok&#34;</span><span class="p">,</span>
		<span class="nx">Data</span><span class="p">:</span> <span class="nx">data</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="nx">resp</span><span class="p">)</span>
	<span class="nx">response</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="nx">resp</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;response&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">response</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">ResponseError</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">code</span> <span class="nx">ResponseCode</span><span class="p">,</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">resp</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Response</span><span class="p">{</span>
		<span class="nx">Code</span><span class="p">:</span> <span class="nx">code</span><span class="p">,</span>
		<span class="nx">Msg</span><span class="p">:</span>  <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">(),</span>
		<span class="nx">Data</span><span class="p">:</span> <span class="s">&#34;&#34;</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="nx">resp</span><span class="p">)</span>
	<span class="nx">response</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="nx">resp</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;response&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">response</span><span class="p">))</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">AbortWithError</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><h3 id="6-配置文件-configenvgo">6. 配置文件 config/env.go</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">config</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">PORT</span>      <span class="p">=</span> <span class="s">&#34;:8000&#34;</span>
	<span class="nx">AppName</span>   <span class="p">=</span> <span class="s">&#34;test&#34;</span>
	<span class="nx">AppSecret</span> <span class="p">=</span> <span class="s">&#34;test.123&#34;</span>
	<span class="nx">ApiExpiry</span> <span class="p">=</span> <span class="s">&#34;1200&#34;</span>

	<span class="nx">LogFilePath</span> <span class="p">=</span> <span class="s">&#34;logs&#34;</span>
	<span class="nx">LogFileName</span> <span class="p">=</span> <span class="s">&#34;gin-logger.log&#34;</span>

	<span class="nx">ValidatorKey</span>  <span class="p">=</span> <span class="s">&#34;ValidatorKey&#34;</span>
	<span class="nx">TranslatorKey</span> <span class="p">=</span> <span class="s">&#34;TranslatorKey&#34;</span>
<span class="p">)</span>
</code></pre></div><h3 id="maingo">main.go</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/config&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/routers&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

	<span class="nx">gin</span><span class="p">.</span><span class="nf">SetMode</span><span class="p">(</span><span class="nx">gin</span><span class="p">.</span><span class="nx">DebugMode</span><span class="p">)</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">Default</span><span class="p">()</span>
	<span class="nx">routers</span><span class="p">.</span><span class="nf">InitRouter</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
	<span class="nx">e</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">PORT</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Google资深工程师深度讲解Go语言 Elastic简单使用</title>
			<link>https://www.ngirl.xyz/golang/google%E8%B5%84%E6%B7%B1%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%B7%B1%E5%BA%A6%E8%AE%B2%E8%A7%A3go%E8%AF%AD%E8%A8%80-elastic%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</link>
			<pubDate>Wed, 06 Jan 2021 14:27:27 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/google%E8%B5%84%E6%B7%B1%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%B7%B1%E5%BA%A6%E8%AE%B2%E8%A7%A3go%E8%AF%AD%E8%A8%80-elastic%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</guid>
			<description></description>
			<content type="html"><![CDATA[<h3 id="elastic-检查查询">elastic 检查查询</h3>
<pre><code># 查询 女, 已购房 年龄小于22岁
http://172.16.76.220:9200/crawler/youyuan/_search?q=女  AND 已购房  AND Payload.Age:(&lt;22)
</code></pre>]]></content>
		</item>
		
		<item>
			<title>Google资深工程师深度讲解Go语言 单任务爬虫</title>
			<link>https://www.ngirl.xyz/golang/google%E8%B5%84%E6%B7%B1%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%B7%B1%E5%BA%A6%E8%AE%B2%E8%A7%A3go%E8%AF%AD%E8%A8%80-%E5%8D%95%E4%BB%BB%E5%8A%A1%E7%88%AC%E8%99%AB/</link>
			<pubDate>Mon, 21 Dec 2020 18:03:36 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/google%E8%B5%84%E6%B7%B1%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%B7%B1%E5%BA%A6%E8%AE%B2%E8%A7%A3go%E8%AF%AD%E8%A8%80-%E5%8D%95%E4%BB%BB%E5%8A%A1%E7%88%AC%E8%99%AB/</guid>
			<description>&lt;p&gt;由于教程的代码在zhenai.com更新之后无法访问,所以记录下代码改动&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>由于教程的代码在zhenai.com更新之后无法访问,所以记录下代码改动</p>
<h3 id="问题说明">问题说明</h3>
<p>这里在首页和城市列表页访问是没有问题的, curl请求也是正常, 但是当请求到用户信息的时候, 是需要UA 和cookie的
没有UA 会提示403, 没有cookie会提示 202</p>
<h3 id="fetchergo-代码">fetcher.go 代码</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">fetcher</span>

<span class="kn">import</span> <span class="p">(</span>
 <span class="s">&#34;bufio&#34;</span>
 <span class="s">&#34;fmt&#34;</span>
 <span class="s">&#34;golang.org/x/net/html/charset&#34;</span>
 <span class="s">&#34;golang.org/x/text/encoding&#34;</span>
 <span class="s">&#34;golang.org/x/text/encoding/unicode&#34;</span>
 <span class="s">&#34;golang.org/x/text/transform&#34;</span>
 <span class="s">&#34;io/ioutil&#34;</span>
 <span class="s">&#34;log&#34;</span>
 <span class="s">&#34;net/http&#34;</span>
 <span class="s">&#34;strings&#34;</span>
<span class="p">)</span>


<span class="kd">func</span> <span class="nf">Fetch</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
 <span class="nx">client</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">http</span><span class="p">.</span><span class="nx">Client</span><span class="p">{}</span>
 <span class="nx">newUrl</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Replace</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span> <span class="s">&#34;http://&#34;</span><span class="p">,</span><span class="s">&#34;https://&#34;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
 <span class="nx">request</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">NewRequest</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">MethodGet</span><span class="p">,</span> <span class="nx">newUrl</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
 <span class="p">}</span>
 <span class="c1">//添加header
</span><span class="c1"></span> <span class="nx">request</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Referer&#34;</span><span class="p">,</span><span class="s">&#34;http://www.zhenai.com/&#34;</span><span class="p">)</span>
 <span class="nx">request</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;User-Agent&#34;</span><span class="p">,</span><span class="s">&#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&#34;</span><span class="p">)</span>
 <span class="c1">//这里cookie只有1分钟有效期
</span><span class="c1"></span> <span class="nx">request</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;cookie&#34;</span><span class="p">,</span><span class="s">&#34;FSSBBIl1UgzbN7NO=53ZIxjnyRAeDyH5t9pg7cBA7QAYBxvaF7jmWYAZu2.CGt7mB9u9LeMhKl8ljte21zs7CWozraQ0E5VOTTi2KxSa; FSSBBIl1UgzbN7NP=5U5rnkYdGQG7qqqmCfWUuTapalzEu3wBuwQIl47nXp0HkSYoWXO9YSlekNkkwawdb3zC2rSWIE1_qIWRw3n3..NPhTqKwJXHroqsoGBqaeo_dgsIn64FK2YWZU6Y6L_l6d6tC7YBN8SMAPRcMqpmfS_9Jw.J8tXrIUZ6bUSeDufFFL1lNf8p4Om5i4P2teK4H1gnsMEldbBc9MLc1xhrJ7yLwLZhXr_mi2AhSHpshGFF7BkPzO_5ye_HaYME37Ukhc9MqOaqdytUs.ZebVaXEo7; Hm_lvt_2c8ad67df9e787ad29dbd54ee608f5d2=1608543698; Hm_lpvt_2c8ad67df9e787ad29dbd54ee608f5d2=1608544780; sid=d399176c-21e3-4e91-b550-fa8656de10e1; _exid=Fj3xNob61luAF5gXz5MAJq5CxrtoI86y%2Bqoc4YZ%2F64joUS0XSSIaALTyeW81WLbDLc0Pzw0kcM1r%2FGU1gm%2F2lA%3D%3D; ec=DH5wblNm-1608543720671-6a5cbb1e341df-781494537; _efmdata=HZvSyojNYRIMPbor%2FAzLk%2B5xwF4NLHTxU22OynbdfqEpXG7eNyAO1kHkZ%2FWDHgT7hGdqxoGwjueLMevvIv%2FF3upAu3SmFFc2zAJsHFMNjAc%3D&#34;</span><span class="p">)</span>

 <span class="nx">resp</span> <span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="nx">request</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
 <span class="p">}</span>
 <span class="k">defer</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
 <span class="k">if</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">StatusCode</span> <span class="o">!=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;wrong status code: %d&#34;</span><span class="p">,</span><span class="nx">resp</span><span class="p">.</span><span class="nx">StatusCode</span><span class="p">)</span>
 <span class="p">}</span>

 <span class="nx">bodyReader</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
 <span class="nx">e</span> <span class="o">:=</span> <span class="nf">determineEncoding</span><span class="p">(</span><span class="nx">bodyReader</span><span class="p">)</span>
 <span class="nx">uft8Reader</span> <span class="o">:=</span> <span class="nx">transform</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">bodyReader</span><span class="p">,</span><span class="nx">e</span><span class="p">.</span><span class="nf">NewDecoder</span><span class="p">())</span>
 <span class="k">return</span>  <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadAll</span><span class="p">(</span><span class="nx">uft8Reader</span><span class="p">)</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="nf">determineEncoding</span><span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">bufio</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">Encoding</span> <span class="p">{</span>
 <span class="nx">bytes</span> <span class="p">,</span><span class="nx">err</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Peek</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Fetcher error : %v&#34;</span><span class="p">,</span><span class="nx">err</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">unicode</span><span class="p">.</span><span class="nx">UTF8</span>
 <span class="p">}</span>

 <span class="nx">e</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">charset</span><span class="p">.</span><span class="nf">DetermineEncoding</span><span class="p">(</span><span class="nx">bytes</span><span class="p">,</span><span class="s">&#34;&#34;</span><span class="p">)</span>
 <span class="k">return</span> <span class="nx">e</span>
<span class="p">}</span>

</code></pre></div><h3 id="profile_testgo-测试一下">profile_test.go 测试一下</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">parser</span>

<span class="kn">import</span> <span class="p">(</span>
 <span class="s">&#34;learngo_crawler/fetcher&#34;</span>
 <span class="s">&#34;testing&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">TestParseProfile</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
 <span class="nx">contents</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fetcher</span><span class="p">.</span><span class="nf">Fetch</span><span class="p">(</span><span class="s">&#34;https://album.zhenai.com/u/1715998969&#34;</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
 <span class="p">}</span>
 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s\n&#34;</span><span class="p">,</span><span class="nx">contents</span><span class="p">)</span>
 <span class="nf">ParseProfile</span><span class="p">(</span><span class="nx">contents</span><span class="p">)</span>
<span class="p">}</span>


</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Google资深工程师深度讲解Go语言-广度优先算法学习-迷宫</title>
			<link>https://www.ngirl.xyz/golang/google%E8%B5%84%E6%B7%B1%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%B7%B1%E5%BA%A6%E8%AE%B2%E8%A7%A3go%E8%AF%AD%E8%A8%80-%E5%B9%BF%E5%BA%A6%E6%B7%B1%E5%BA%A6%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E8%BF%B7%E5%AE%AB/</link>
			<pubDate>Fri, 18 Dec 2020 18:00:44 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/google%E8%B5%84%E6%B7%B1%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%B7%B1%E5%BA%A6%E8%AE%B2%E8%A7%A3go%E8%AF%AD%E8%A8%80-%E5%B9%BF%E5%BA%A6%E6%B7%B1%E5%BA%A6%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E8%BF%B7%E5%AE%AB/</guid>
			<description>这里学习了Google吱声工程师深度讲解go语言-迷宫广度优先算法以记录
算法说明 图源: 图解迷宫算法（广度优先遍历)
首先看一张迷宫图, 左右黄色0 表示起始点, 0 表示可以行走, 1表示墙体 迷宫的广度优先算法的意思是, 可以通过0 发现四个方向的1, 然后在通过四个1 发现所有的2, 所有的2探索完 , 在探索3&amp;hellip; 以此类推&amp;hellip; 这里每个点都有三种状态:  未发现 已发现未探索 已探索  最终我们能探索到这样的结果图: 下面是详细代码 代码结构 ── maze ├── maze.go └── maze.in maze.in文件 6 5 0 1 0 0 0 0 0 0 1 0 0 1 0 1 0 1 1 1 0 0 0 1 0 0 1 0 1 0 0 0 maze.go package main import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;os&amp;#34; ) /* maze.</description>
			<content type="html"><![CDATA[<p>这里学习了Google吱声工程师深度讲解go语言-迷宫广度优先算法以记录</p>
<!-- more -->
<h3 id="算法说明">算法说明</h3>
<p>图源: <a href="https://www.pianshen.com/article/8849857777/">图解迷宫算法（广度优先遍历)</a></p>
<h4 id="首先看一张迷宫图-左右黄色0-表示起始点-0-表示可以行走-1表示墙体">首先看一张迷宫图, 左右黄色0 表示起始点, 0 表示可以行走, 1表示墙体</h4>
<p><img src="//zhangzw001.github.io/images/golang/maze-01.png" alt=""></p>
<p>迷宫的广度优先算法的意思是, 可以通过0 发现四个方向的1, 然后在通过四个1 发现所有的2, 所有的2探索完 , 在探索3&hellip;
<img src="//zhangzw001.github.io/images/golang/maze-02.png" alt=""></p>
<p>以此类推&hellip;
<img src="//zhangzw001.github.io/images/golang/maze-03.png" alt=""></p>
<h4 id="这里每个点都有三种状态">这里每个点都有三种状态:</h4>
<ul>
<li>未发现</li>
<li>已发现未探索</li>
<li>已探索</li>
</ul>
<p>最终我们能探索到这样的结果图:
<img src="//zhangzw001.github.io/images/golang/maze-04.png" alt=""></p>
<h3 id="下面是详细代码">下面是详细代码</h3>
<h4 id="代码结构">代码结构</h4>
<pre><code>── maze
   ├── maze.go
   └── maze.in
</code></pre><h4 id="mazein文件">maze.in文件</h4>
<pre><code>6 5
0 1 0 0 0
0 0 0 1 0
0 1 0 1 0
1 1 1 0 0
0 1 0 0 1
0 1 0 0 0
</code></pre><h4 id="mazego">maze.go</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
 <span class="s">&#34;fmt&#34;</span>
 <span class="s">&#34;log&#34;</span>
 <span class="s">&#34;os&#34;</span>
<span class="p">)</span>

<span class="cm">/*
</span><span class="cm">maze.in
</span><span class="cm">6 5
</span><span class="cm">0 1 0 0 0
</span><span class="cm">0 0 0 1 0
</span><span class="cm">0 1 0 1 0
</span><span class="cm">1 1 1 0 0
</span><span class="cm">0 1 0 0 1
</span><span class="cm">0 1 0 0 0
</span><span class="cm">
</span><span class="cm">- 未探索
</span><span class="cm">- 已发现未探索
</span><span class="cm">- 已探索
</span><span class="cm">
</span><span class="cm">- 广度优先算法 -&gt; 把所有的1全部探索完,再探索2
</span><span class="cm">*/</span>

<span class="kd">func</span> <span class="nf">readMaze</span><span class="p">(</span><span class="nx">filename</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
 <span class="nx">file</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
 <span class="p">}</span>
 <span class="k">defer</span> <span class="nx">file</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

 <span class="kd">var</span> <span class="nx">row</span><span class="p">,</span> <span class="nx">col</span> <span class="kt">int</span>
 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fscanf</span><span class="p">(</span><span class="nx">file</span><span class="p">,</span> <span class="s">&#34;%d %d&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">row</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">col</span><span class="p">)</span>
 <span class="nx">maze</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">row</span><span class="p">)</span>
 <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">maze</span> <span class="p">{</span>
  <span class="nx">maze</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">col</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">maze</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fscanf</span><span class="p">(</span><span class="nx">file</span><span class="p">,</span> <span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">maze</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">])</span>
  <span class="p">}</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="nx">maze</span>

<span class="p">}</span>

<span class="kd">type</span> <span class="nx">point</span> <span class="kd">struct</span> <span class="p">{</span>
 <span class="nx">i</span> <span class="kt">int</span>
 <span class="nx">j</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">dirs</span> <span class="p">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="nx">point</span><span class="p">{</span>
 <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="c1">//上
</span><span class="c1"></span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">},</span> <span class="c1">//左
</span><span class="c1"></span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>  <span class="c1">//下
</span><span class="c1"></span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>  <span class="c1">//右
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">//用值类型, 返回新的point
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">point</span><span class="p">)</span> <span class="nf">add</span><span class="p">(</span><span class="nx">po</span> <span class="nx">point</span><span class="p">)</span> <span class="nx">point</span> <span class="p">{</span>
 <span class="k">return</span> <span class="nx">point</span><span class="p">{</span><span class="nx">p</span><span class="p">.</span><span class="nx">i</span> <span class="o">+</span> <span class="nx">po</span><span class="p">.</span><span class="nx">i</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">j</span> <span class="o">+</span> <span class="nx">po</span><span class="p">.</span><span class="nx">j</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">point</span><span class="p">)</span> <span class="nf">notOver</span><span class="p">(</span><span class="nx">grid</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
 <span class="c1">//是否越界
</span><span class="c1"></span> <span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">p</span><span class="p">.</span><span class="nx">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">grid</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">false</span>
 <span class="p">}</span>
 <span class="c1">//if p.j &lt; 0 || p.j &gt;= len(grid[p.i]) {
</span><span class="c1"></span> <span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">j</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">p</span><span class="p">.</span><span class="nx">j</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">false</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">point</span><span class="p">)</span> <span class="nf">at</span><span class="p">(</span><span class="nx">grid</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>

 <span class="k">if</span> <span class="p">!</span><span class="nx">p</span><span class="p">.</span><span class="nf">notOver</span><span class="p">(</span><span class="nx">grid</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">false</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="nx">grid</span><span class="p">[</span><span class="nx">p</span><span class="p">.</span><span class="nx">i</span><span class="p">][</span><span class="nx">p</span><span class="p">.</span><span class="nx">j</span><span class="p">],</span> <span class="kc">true</span>

<span class="p">}</span>
<span class="kd">func</span> <span class="nf">walk</span><span class="p">(</span><span class="nx">maze</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">end</span> <span class="nx">point</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
 <span class="nx">steps</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">maze</span><span class="p">))</span>
 <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">steps</span> <span class="p">{</span>
  <span class="nx">steps</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">maze</span><span class="p">[</span><span class="nx">i</span><span class="p">]))</span>
 <span class="p">}</span>
 <span class="c1">//队列
</span><span class="c1"></span> <span class="nx">Q</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">point</span><span class="p">{</span><span class="nx">start</span><span class="p">}</span>

 <span class="c1">//开始探索
</span><span class="c1"></span> <span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">Q</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
  <span class="c1">// 探索头
</span><span class="c1"></span>  <span class="nx">cur</span> <span class="o">:=</span> <span class="nx">Q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="nx">Q</span> <span class="p">=</span> <span class="nx">Q</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

  <span class="c1">// 终端
</span><span class="c1"></span>  <span class="k">if</span> <span class="nx">cur</span> <span class="o">==</span> <span class="nx">end</span> <span class="p">{</span>
   <span class="k">break</span>
  <span class="p">}</span>

  <span class="c1">// 探索
</span><span class="c1"></span>  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">dir</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dirs</span> <span class="p">{</span>
   <span class="c1">//得到下一个点的坐标
</span><span class="c1"></span>   <span class="nx">next</span> <span class="o">:=</span> <span class="nx">cur</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">dir</span><span class="p">)</span>

   <span class="c1">// maze at next is 0
</span><span class="c1"></span>   <span class="c1">// and steps at next is 0
</span><span class="c1"></span>   <span class="c1">// and next != start
</span><span class="c1"></span>   <span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">next</span><span class="p">.</span><span class="nf">at</span><span class="p">(</span><span class="nx">maze</span><span class="p">)</span>
   <span class="c1">// 撞墙
</span><span class="c1"></span>   <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="o">||</span> <span class="nx">val</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
    <span class="k">continue</span>
   <span class="p">}</span>

   <span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">next</span><span class="p">.</span><span class="nf">at</span><span class="p">(</span><span class="nx">steps</span><span class="p">)</span>
   <span class="c1">// 不等于0 说明走过的
</span><span class="c1"></span>   <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="o">||</span> <span class="nx">val</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="k">continue</span>
   <span class="p">}</span>

   <span class="c1">// 原点
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">next</span> <span class="o">==</span> <span class="nx">start</span> <span class="p">{</span>
    <span class="k">continue</span>
   <span class="p">}</span>

   <span class="c1">//当前步骤数
</span><span class="c1"></span>   <span class="nx">curSteps</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">cur</span><span class="p">.</span><span class="nf">at</span><span class="p">(</span><span class="nx">steps</span><span class="p">)</span>
   <span class="nx">steps</span><span class="p">[</span><span class="nx">next</span><span class="p">.</span><span class="nx">i</span><span class="p">][</span><span class="nx">next</span><span class="p">.</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">curSteps</span> <span class="o">+</span> <span class="mi">1</span>

   <span class="nx">Q</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">Q</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span>
  <span class="p">}</span>
 <span class="p">}</span>

 <span class="k">return</span> <span class="nx">steps</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">walkLine</span><span class="p">(</span><span class="nx">steps</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">end</span> <span class="nx">point</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
 <span class="nx">newTable</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">steps</span><span class="p">))</span>
 <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">newTable</span> <span class="p">{</span>
  <span class="nx">newTable</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">steps</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
 <span class="p">}</span>

 <span class="nx">newTable</span><span class="p">[</span><span class="nx">end</span><span class="p">.</span><span class="nx">i</span><span class="p">][</span><span class="nx">end</span><span class="p">.</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">steps</span><span class="p">[</span><span class="nx">end</span><span class="p">.</span><span class="nx">i</span><span class="p">][</span><span class="nx">end</span><span class="p">.</span><span class="nx">j</span><span class="p">]</span>

 <span class="c1">//这里不需要队列, 因为只会找到一个值
</span><span class="c1"></span> <span class="nx">Q</span> <span class="o">:=</span> <span class="nx">end</span>
 <span class="c1">// 如果不是开头, 就继续找
</span><span class="c1"></span> <span class="k">for</span> <span class="nx">Q</span> <span class="o">!=</span> <span class="nx">start</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">dir</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dirs</span> <span class="p">{</span>
   <span class="c1">//得到下一个点的坐标
</span><span class="c1"></span>   <span class="nx">next</span> <span class="o">:=</span> <span class="nx">Q</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">dir</span><span class="p">)</span>
   <span class="c1">//是否越界
</span><span class="c1"></span>   <span class="k">if</span> <span class="p">!</span><span class="nx">next</span><span class="p">.</span><span class="nf">notOver</span><span class="p">(</span><span class="nx">steps</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">continue</span>
   <span class="p">}</span>
   <span class="c1">// 如果这个[坐标的值]=[当前坐标值]-1, 那就找到了,把这个坐标记录一下, 待会用这个坐标继续探索
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">steps</span><span class="p">[</span><span class="nx">next</span><span class="p">.</span><span class="nx">i</span><span class="p">][</span><span class="nx">next</span><span class="p">.</span><span class="nx">j</span><span class="p">]</span> <span class="o">==</span> <span class="nx">steps</span><span class="p">[</span><span class="nx">Q</span><span class="p">.</span><span class="nx">i</span><span class="p">][</span><span class="nx">Q</span><span class="p">.</span><span class="nx">j</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
    <span class="nx">newTable</span><span class="p">[</span><span class="nx">next</span><span class="p">.</span><span class="nx">i</span><span class="p">][</span><span class="nx">next</span><span class="p">.</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">steps</span><span class="p">[</span><span class="nx">next</span><span class="p">.</span><span class="nx">i</span><span class="p">][</span><span class="nx">next</span><span class="p">.</span><span class="nx">j</span><span class="p">]</span>
    <span class="nx">Q</span> <span class="p">=</span> <span class="nx">next</span>
   <span class="p">}</span>
  <span class="p">}</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="nx">newTable</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;&gt;&gt;&gt;&gt;&gt;&gt; 迷宫图如下:&#34;</span><span class="p">)</span>

 <span class="nx">maze</span> <span class="o">:=</span> <span class="nf">readMaze</span><span class="p">(</span><span class="s">&#34;maze/maze.in&#34;</span><span class="p">)</span>
 <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">row</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">maze</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">val</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">row</span> <span class="p">{</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%3d &#34;</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">()</span>
 <span class="p">}</span>

 <span class="nx">steps</span> <span class="o">:=</span> <span class="nf">walk</span><span class="p">(</span><span class="nx">maze</span><span class="p">,</span> <span class="nx">point</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="nx">point</span><span class="p">{</span><span class="nb">len</span><span class="p">(</span><span class="nx">maze</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">maze</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">})</span>
 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;&gt;&gt;&gt;&gt;&gt;&gt; 探索图如下:&#34;</span><span class="p">)</span>

 <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">row</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">steps</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">val</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">row</span> <span class="p">{</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%3d &#34;</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">()</span>
 <span class="p">}</span>
 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;&gt;&gt;&gt;&gt;&gt;&gt; 行走路线图如下:&#34;</span><span class="p">)</span>
 <span class="nx">newSteps</span> <span class="o">:=</span> <span class="nf">walkLine</span><span class="p">(</span><span class="nx">steps</span><span class="p">,</span> <span class="nx">point</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="nx">point</span><span class="p">{</span><span class="nb">len</span><span class="p">(</span><span class="nx">maze</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">maze</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">})</span>
 <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">row</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">newSteps</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">val</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">row</span> <span class="p">{</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%3d &#34;</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">()</span>
 <span class="p">}</span>
<span class="p">}</span>


</code></pre></div><h4 id="执行结果如下">执行结果如下:</h4>
<pre><code>&gt;&gt;&gt;&gt;&gt;&gt; 迷宫图如下:
  0   1   0   0   0
  0   0   0   1   0
  0   1   0   1   0
  1   1   1   0   0
  0   1   0   0   1
  0   1   0   0   0
&gt;&gt;&gt;&gt;&gt;&gt; 探索图如下:
  0   0   4   5   6
  1   2   3   0   7
  2   0   4   0   8
  0   0   0  10   9
  0   0  12  11   0
  0   0  13  12  13
&gt;&gt;&gt;&gt;&gt;&gt; 行走路线图如下:
  0   0   4   5   6
  1   2   3   0   7
  0   0   0   0   8
  0   0   0  10   9
  0   0   0  11   0
  0   0   0  12  13

</code></pre>]]></content>
		</item>
		
	</channel>
</rss>
