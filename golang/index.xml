<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Golangs on zhangzw</title>
		<link>https://www.ngirl.xyz/golang/</link>
		<description>Recent content in Golangs on zhangzw</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>zh-hans</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Fri, 23 Apr 2021 09:27:50 +0800</lastBuildDate>
		<atom:link href="https://www.ngirl.xyz/golang/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Go算法学习 回溯 分割回文串</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%9B%9E%E6%BA%AF-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/</link>
			<pubDate>Fri, 23 Apr 2021 09:27:50 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%9B%9E%E6%BA%AF-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/</guid>
			<description>说明  纯暴力搜索, 通常可以抽象为N叉树, 树的深度就是递归的深度
  组合问题(不强调顺序) 1234 =&amp;gt; 12,13,14,23,24,34 切割问题(分割回文串) aab =&amp;gt; [a,a,b],[aa,b] 子集问题 排列问题(强调顺序) 1234 =&amp;gt; 12,13,14,21,23,24&amp;hellip; 棋盘问题(N皇后,数独)  回溯算法模板 func backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归  回溯，撤销处理结果 } } 参考文献  力扣题目: 77.组合 力扣题目: 39.组合总和 力扣题目: 131.分割回文串 代码随想录视频 回溯算法-理论（对应力扣题目：77.组合） 代码随想录视频 回溯算法-组合（对应力扣题目：77.组合） 代码随想录视频 回溯算法-组合剪枝（对应力扣题目：77.组合） 代码随想录视频 回溯算法-分割回文串（对应力扣题目：131.分割回文串） 代码随想录图文 回溯算法：分割回文串  例一 77. 组合 //77. 组合 //给定两个整数 n 和 k，返回 1 .</description>
			<content type="html"><![CDATA[<h3 id="说明">说明</h3>
<blockquote>
<p>纯暴力搜索, 通常可以抽象为N叉树, 树的深度就是递归的深度</p>
</blockquote>
<ul>
<li>组合问题(不强调顺序)   1234 =&gt;  12,13,14,23,24,34</li>
<li>切割问题(分割回文串)   aab  =&gt;  [a,a,b],[aa,b]</li>
<li>子集问题</li>
<li>排列问题(强调顺序)     1234 =&gt; 12,13,14,21,23,24&hellip;</li>
<li>棋盘问题(N皇后,数独)</li>
</ul>
<h3 id="回溯算法模板">回溯算法模板</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">backtracking</span><span class="p">(</span><span class="nx">参数</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">终止条件</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">存放结果</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="nx">选择</span><span class="err">：</span><span class="nx">本层集合中元素</span><span class="err">（</span><span class="nx">树中节点孩子的数量就是集合的大小</span><span class="err">）</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">处理节点</span><span class="p">;</span>
        <span class="nf">backtracking</span><span class="p">(</span><span class="nx">路径</span><span class="err">，</span><span class="nx">选择列表</span><span class="p">);</span> <span class="c1">// 递归
</span><span class="c1"></span>        <span class="nx">回溯</span><span class="err">，</span><span class="nx">撤销处理结果</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h3 id="参考文献">参考文献</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/combinations/">力扣题目: 77.组合</a></li>
<li><a href="https://leetcode-cn.com/problems/combination-sum/">力扣题目: 39.组合总和</a></li>
<li><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">力扣题目: 131.分割回文串</a></li>
<li><a href="https://www.bilibili.com/video/BV1cy4y167mM">代码随想录视频 回溯算法-理论（对应力扣题目：77.组合）</a></li>
<li><a href="https://www.bilibili.com/video/BV1ti4y1L7cv">代码随想录视频 回溯算法-组合（对应力扣题目：77.组合）</a></li>
<li><a href="https://www.bilibili.com/video/BV1wi4y157er/?spm_id_from=autoNext">代码随想录视频 回溯算法-组合剪枝（对应力扣题目：77.组合）</a></li>
<li><a href="https://www.bilibili.com/video/BV1c54y1e7k6">代码随想录视频 回溯算法-分割回文串（对应力扣题目：131.分割回文串）</a></li>
<li><a href="https://mp.weixin.qq.com/s/Pb1epUTbU8fHIht-g_MS5Q">代码随想录图文 回溯算法：分割回文串</a></li>
</ul>
<h3 id="例一-77-组合">例一 77. 组合</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">//77. 组合
</span><span class="c1">//给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。
</span><span class="c1">//
</span><span class="c1">//示例:
</span><span class="c1">//
</span><span class="c1">//输入: n = 4, k = 2
</span><span class="c1">//输出:
</span><span class="c1">//[
</span><span class="c1">//  [2,4],
</span><span class="c1">//  [3,4],
</span><span class="c1">//  [2,3],
</span><span class="c1">//  [1,2],
</span><span class="c1">//  [1,3],
</span><span class="c1">//  [1,4],
</span><span class="c1">//]
</span><span class="c1">//https://leetcode-cn.com/problems/combinations/
</span><span class="c1">// bilibili视频: https://www.bilibili.com/video/BV1ti4y1L7cv/?spm_id_from=autoNext
</span><span class="c1"></span>
<span class="c1">// 思路
</span><span class="c1">// 首先根据回溯算法的模板,这里n代表的就是横向的循环, k影响递归的深度
</span><span class="c1">// n = 4, k = 2
</span><span class="c1">//
</span><span class="c1">// 	  1       2     3   4
</span><span class="c1">//  2 3 4     3 4   4
</span><span class="c1">// 12|13|14 23|24   34
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">combine</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="nx">path</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>

	<span class="c1">// 1. 递归参数和返回值
</span><span class="c1"></span>	<span class="c1">// 2. 递归的终止条件
</span><span class="c1"></span>	<span class="c1">// 3. 单词递归的逻辑
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">backtracking</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
	<span class="nx">backtracking</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">startIndex</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">{</span>
		<span class="c1">// 递归的终止条件
</span><span class="c1"></span>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span> <span class="o">==</span> <span class="nx">k</span> <span class="p">{</span>
			<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nb">append</span><span class="p">([]</span><span class="kt">int</span><span class="p">{},</span><span class="nx">path</span><span class="o">...</span><span class="p">))</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span> <span class="nx">startIndex</span><span class="p">;</span><span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span> <span class="p">;</span><span class="nx">i</span> <span class="o">++</span> <span class="p">{</span>
			<span class="c1">// 寻找组合
</span><span class="c1"></span>			<span class="nx">path</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
			<span class="nf">backtracking</span><span class="p">(</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
			<span class="c1">// 回溯过程
</span><span class="c1"></span>			<span class="nx">path</span> <span class="p">=</span> <span class="nx">path</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">backtracking</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>


</code></pre></div><h3 id="例二-39组合总和">例二: 39.组合总和</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// 思路
</span><span class="c1">//  candidates = [2,3,5], target = 8,
</span><span class="c1">//    		  2     		  3	    	 5
</span><span class="c1">//   	2	  3 	5       3   5 		 5
</span><span class="c1">// 	  235     35    5       35  
</span><span class="c1">// 235 35 5  35 5   
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">combinationSum</span><span class="p">(</span><span class="nx">candidates</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">target</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="nx">path</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="nx">pathInt</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="kd">var</span> <span class="nx">backTracking</span> <span class="kd">func</span><span class="p">(</span><span class="nx">startIndex</span> <span class="kt">int</span><span class="p">)</span>
	<span class="c1">// 递归三部曲
</span><span class="c1"></span>	<span class="c1">// 1. 递归参数, 这里需要开始位置
</span><span class="c1"></span>	<span class="c1">// 2. 终止条件, path的结果和等于target, 或者大于
</span><span class="c1"></span>	<span class="c1">// 3. 单次递归逻辑, 往path里添加结果 , 只要小于target
</span><span class="c1"></span>	<span class="nx">backTracking</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">startIndex</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">pathInt</span> <span class="o">==</span> <span class="nx">target</span> <span class="p">{</span>
			<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nb">append</span><span class="p">([]</span><span class="kt">int</span><span class="p">{},</span><span class="nx">path</span><span class="o">...</span><span class="p">))</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="c1">// 超过target也需要返回, 但是不用保存数据
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">pathInt</span> <span class="p">&gt;</span> <span class="nx">target</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
        <span class="c1">// 可以遍历同一个数字, 但不使用startIndex 前面的值, 应该组合是不可重复的
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span> <span class="nx">startIndex</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">candidates</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>

			<span class="k">if</span> <span class="nx">pathInt</span> <span class="p">&lt;</span> <span class="nx">target</span> <span class="p">{</span>
				<span class="nx">pathInt</span> <span class="o">+=</span> <span class="nx">candidates</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
				<span class="nx">path</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">candidates</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">)</span>
			<span class="p">}</span>
			<span class="c1">// 可以无限使用同一个
</span><span class="c1"></span>			<span class="nf">backTracking</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
			<span class="c1">// 回溯
</span><span class="c1"></span>			<span class="nx">path</span> <span class="p">=</span> <span class="nx">path</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">pathInt</span> <span class="o">-=</span> <span class="nx">candidates</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">backTracking</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>


</code></pre></div><h3 id="例三-131分割回文串">例三: 131.分割回文串</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="c1">// 简单思路
</span><span class="c1">// 切割方式, 按照树的方式:
</span><span class="c1">// 横向→循环,  纵向↓递归
</span><span class="c1">//            		aab
</span><span class="c1">//      a/      	|aa   	\aab 		//第一次切割分成三个节点, a后切割,aa后切割,aab后切割 ,对应代码的 i=0,1,2,其中分割后的结果append到path切片中
</span><span class="c1">//    a/   \b    	|b    	(aab|)		//第二次切割分成四个节点, a|a|,(a|ab|),(aa|b|),(aab|)  带括号的已经是叶子节点,该情况结束,本次递归可以返回
</span><span class="c1">//   b|    (a|ab|) (aa|b|)				//第三次切割分成四个节点, (a|a|b|),(a|ab|),(aa|b|),(aab|)
</span><span class="c1">//  (a|a|b|)
</span><span class="c1">// 以上所有方案为四种切割方式: (a|a|b|) (a|ab|) (aa|b|) (aab|)
</span><span class="c1">// 代码部分需要注意, 在切割a|a|b| 之后需要回溯,想要回溯到 a|ab|,需将path中 a|a|b|的 后面(a|b|)删除, 当path=a,则可以继续切割出 (a|ab|)节点, 后续回溯同样
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">partition</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">result</span> <span class="p">[][]</span><span class="kt">string</span>
	<span class="c1">// 判断是否回文
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">isPalindrome</span> <span class="kd">func</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span>
	<span class="nx">isPalindrome</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">true</span>
		<span class="p">}</span>
		<span class="nx">head</span><span class="p">,</span> <span class="nx">tail</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
		<span class="k">for</span> <span class="nx">head</span> <span class="p">&lt;</span> <span class="nx">tail</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">s</span><span class="p">[</span><span class="nx">head</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">tail</span><span class="p">]</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">false</span>
			<span class="p">}</span>
			<span class="nx">head</span><span class="o">++</span>
			<span class="nx">tail</span><span class="o">--</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">backtracking</span> <span class="kd">func</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">startIndex</span> <span class="kt">int</span><span class="p">)</span>
	<span class="c1">//startIndex 就是切割的位置
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">path</span> <span class="p">[]</span><span class="kt">string</span>
	<span class="nx">backtracking</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">startIndex</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">startIndex</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// 为什么要这样添加, 是因为path这个函数外slice 会最终被修改,导致最后append是相同的数据
</span><span class="c1"></span>			<span class="c1">//var newPath []string
</span><span class="c1"></span>			<span class="c1">//newPath = append(newPath,path...)
</span><span class="c1"></span>			<span class="c1">//result = append(result, newPath)
</span><span class="c1"></span>			<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nb">append</span><span class="p">([]</span><span class="nb">string</span><span class="p">(</span><span class="kc">nil</span><span class="p">),</span> <span class="nx">path</span><span class="o">...</span><span class="p">))</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">startIndex</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="c1">// 假如这里startIndex = 0 , 切割到第一个a后面
</span><span class="c1"></span>			<span class="c1">// i=1 [startIndex:i+1] = [0:1] = a 是回文
</span><span class="c1"></span>			<span class="c1">// i=2 [startIndex:i+1] = [1:2] = a 是回文
</span><span class="c1"></span>			<span class="c1">// i=3 [startIndex:i+1] = [2:3] = b 是回文
</span><span class="c1"></span>			<span class="c1">//fmt.Println(s[startIndex:i+1])
</span><span class="c1"></span>			<span class="k">if</span> <span class="nf">isPalindrome</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">startIndex</span> <span class="p">:</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
				<span class="nx">path</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">s</span><span class="p">[</span><span class="nx">startIndex</span><span class="p">:</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
				<span class="c1">//fmt.Println(&#34;backtracking前&#34;,startIndex,s[startIndex:i+1],path)
</span><span class="c1"></span>
				<span class="c1">// 寻找 i =1 的切割点
</span><span class="c1"></span>				<span class="nf">backtracking</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

				<span class="c1">// 回溯  重要!!!
</span><span class="c1"></span>				<span class="c1">// 每次 backtracking 函数执行返回的时候就是 startIndex == len(s)的时候, 也就是结果path已经添加到result中了
</span><span class="c1"></span>				<span class="c1">// 由于在isPalindrome 中, 所以前面path append了几次, backtracking函数退出的时候这里就会删除几次
</span><span class="c1"></span>				<span class="c1">// 因为是回溯, 当然是要每次删除一个尾部内容
</span><span class="c1"></span>				<span class="nx">path</span> <span class="p">=</span> <span class="nx">path</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
				<span class="c1">//fmt.Println(&#34;backtracking后&#34;,startIndex,s[startIndex:i+1],path)
</span><span class="c1"></span>			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">backtracking</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">partition</span><span class="p">(</span><span class="s">&#34;aab&#34;</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">partition</span><span class="p">(</span><span class="s">&#34;cdadad&#34;</span><span class="p">))</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go算法学习 辗转相除法</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95/</link>
			<pubDate>Fri, 16 Apr 2021 15:56:59 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95/</guid>
			<description></description>
			<content type="html"><![CDATA[<p>原文: <a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653189913&amp;idx=1&amp;sn=8667ba0170aef9b6c34713ce8cea60a8&amp;chksm=8c9905c3bbee8cd56d079bb0a436a46a18eb43061bc9390483f6cca692760f01cb575241ffff&amp;scene=21#wechat_redirect">程序员小灰 辗转相除法 更相减损术</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="c1">// 求最大公约数, 两个数都能整除的最大整数
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">MaxMin</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">a</span>
<span class="p">}</span>

<span class="c1">// 1. 暴力 O(min(a,b))
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">getGreatestCommonDivisor</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">max</span><span class="p">,</span> <span class="nx">min</span> <span class="o">:=</span> <span class="nf">MaxMin</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">max</span><span class="o">%</span><span class="nx">min</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">min</span>
	<span class="p">}</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="nx">min</span>
	<span class="k">for</span> <span class="nx">a</span><span class="o">%</span><span class="nx">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">b</span><span class="o">%</span><span class="nx">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">i</span><span class="o">--</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">i</span>
<span class="p">}</span>

<span class="c1">// 2. 辗转相除法 O(log(max(a,b)))
</span><span class="c1">// 两个数的最大公约数 = 大数对小数取余结果 和小数 的最大公约数
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">getGreatestCommonDivisor2</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nf">MaxMin</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
	<span class="c1">//取余
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">m</span><span class="o">%</span><span class="nx">n</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">m</span><span class="p">,</span> <span class="nx">n</span> <span class="p">=</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">m</span><span class="o">%</span><span class="nx">n</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">n</span>
<span class="p">}</span>

<span class="c1">// 3. 更相减损术(出自算术九章) O(max(a,b))
</span><span class="c1">// 两个数的最大公约数 = 大数减小数结果 和小数的最大公约数
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">getGreatestCommonDivisor3</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nf">MaxMin</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">m</span><span class="o">!=</span><span class="nx">n</span>  <span class="p">{</span>
		<span class="nx">m</span><span class="p">,</span> <span class="nx">n</span> <span class="p">=</span> <span class="nf">MaxMin</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">m</span><span class="o">-</span><span class="nx">n</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">n</span>
<span class="p">}</span>

<span class="c1">// 4. 更相减损术+移位操作
</span><span class="c1">// gcb(a,b)代表 a,b的最大公约数
</span><span class="c1">// 4.1 a,b都是偶数: 	gcb(a,b) = 2 * gcb(a/2,b/2)	= 2 * gcb(a&gt;&gt;1,b&gt;&gt;1)
</span><span class="c1">// 4.2 a,b是奇偶: 	gcb(a,b) = gcb(a,b/2)		= gcb(a,b&gt;&gt;1)
</span><span class="c1">// 4.3 a,b是偶奇: 	gcb(a,b) = 2 * gcb(a/2,b)	= gcb(a&gt;&gt;1,b)
</span><span class="c1">// 4.4 a,b都是奇数: 	gcb(a,b) = gcb((a-b)/2,b)	= gcb((a-b)&gt;&gt;1,b)  因为a-b必然是偶数
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">getGreatestCommonDivisor4</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nf">MaxMin</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">gcb</span> <span class="kd">func</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
	<span class="nx">gcb</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">m</span> <span class="o">==</span> <span class="nx">n</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">n</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">m</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// 偶 偶
</span><span class="c1"></span>				<span class="k">return</span> <span class="nf">gcb</span><span class="p">(</span><span class="nx">m</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">,</span><span class="nx">n</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">m</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// 奇 偶
</span><span class="c1"></span>				<span class="k">return</span> <span class="nf">gcb</span><span class="p">(</span><span class="nf">MaxMin</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span><span class="nx">n</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">))</span>
			<span class="p">}</span><span class="k">else</span> <span class="k">if</span> <span class="nx">m</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>	<span class="c1">// 偶 奇
</span><span class="c1"></span>				<span class="k">return</span> <span class="nf">gcb</span><span class="p">(</span><span class="nf">MaxMin</span><span class="p">(</span><span class="nx">m</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">,</span><span class="nx">n</span><span class="p">))</span>
			<span class="p">}</span><span class="k">else</span> <span class="p">{</span>	<span class="c1">// 奇 奇
</span><span class="c1"></span>				<span class="k">return</span> <span class="nf">gcb</span><span class="p">(</span><span class="nf">MaxMin</span><span class="p">((</span><span class="nx">m</span><span class="o">-</span><span class="nx">n</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">,</span><span class="nx">n</span><span class="p">))</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">n</span> <span class="p">=</span> <span class="nf">gcb</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span><span class="nx">n</span> <span class="p">)</span>
	<span class="k">return</span> <span class="nx">n</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">getGreatestCommonDivisor</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">768</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">getGreatestCommonDivisor2</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">768</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">getGreatestCommonDivisor3</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">248</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">getGreatestCommonDivisor4</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">248</span><span class="p">))</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go算法学习 最小栈的实现</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%9C%80%E5%B0%8F%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
			<pubDate>Fri, 16 Apr 2021 10:09:37 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%9C%80%E5%B0%8F%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
			<description></description>
			<content type="html"><![CDATA[<p>原文: <a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653190073&amp;idx=1&amp;sn=c20c002127e2ce3fe0c71a00aee70806&amp;chksm=8c990563bbee8c75521c54ea8eb44b009ad07266b1e5fbf22926baf9a7b7302c7e4f7657dbb8&amp;scene=21#wechat_redirect">程序员小灰 最小栈的实现</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>


<span class="c1">//题目：实现一个栈，带有出栈（pop），入栈（push），取最小元素（getMin）三个方法。要保证这三个方法的时间复杂度都是O（1）。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">stack</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">V</span> <span class="p">[]</span><span class="kt">int</span>	<span class="c1">// 栈存储
</span><span class="c1"></span>	<span class="nx">Min</span> <span class="p">[]</span><span class="kt">int</span>	<span class="c1">//栈最小值下标存储
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// 入栈
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">stack</span><span class="p">)</span> <span class="nf">Pop</span><span class="p">(</span><span class="nx">a</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 入栈
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nx">V</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
	<span class="c1">// 判断min是否为空
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">Min</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 如果比最小栈 栈顶值小, 就入栈
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">a</span> <span class="p">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">[</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">Min</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 出栈
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">stack</span><span class="p">)</span> <span class="nf">Push</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c1">// 出栈
</span><span class="c1"></span>	<span class="nx">a1</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="c1">// 如果出栈的下标等于最小栈栈顶的值,就删除最小栈栈顶
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">Min</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="c1">// 在删除栈顶
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nx">V</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">V</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

	<span class="k">return</span> <span class="nx">a1</span>
<span class="p">}</span>

<span class="c1">//新建堆
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewStack</span><span class="p">(</span><span class="nx">l</span> <span class="o">...</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">stack</span><span class="p">{</span>
	<span class="nx">stack1</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">stack</span><span class="p">{}</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">l</span> <span class="p">{</span>
		<span class="nx">stack1</span><span class="p">.</span><span class="nf">Pop</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">stack1</span>
<span class="p">}</span>

<span class="c1">// 查询最小值
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">stack</span><span class="p">)</span> <span class="nf">GetMin</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">min</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">Min</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Min</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="k">return</span> <span class="nx">min</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">stack1</span> <span class="o">:=</span> <span class="nf">NewStack</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">14</span><span class="p">}</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">stack1</span><span class="p">.</span><span class="nf">Pop</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">stack1</span><span class="p">)</span>
	<span class="nx">stack1</span><span class="p">.</span><span class="nf">Pop</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">stack1</span><span class="p">)</span>
	<span class="nx">stack1</span><span class="p">.</span><span class="nf">Pop</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">stack1</span><span class="p">)</span>
	<span class="nx">stack1</span><span class="p">.</span><span class="nf">Push</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">stack1</span><span class="p">)</span>

<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go算法学习 找出缺失的整数</title>
			<link>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%89%BE%E5%87%BA%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B4%E6%95%B0/</link>
			<pubDate>Thu, 15 Apr 2021 18:09:46 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%89%BE%E5%87%BA%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B4%E6%95%B0/</guid>
			<description>原文: 程序员小灰 找出缺失的整数
实现代码 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;math/rand&amp;#34; &amp;#34;time&amp;#34; ) var ( a []int b []int c []int l = 100 r = rand.New(rand.NewSource(time.Now().UnixNano())) ) func init() { // 1~10 随机数 	tmp := r.Intn(l-1)+1 // 在生成一个不等于tmp的随机数 	var tmp2 int for tmp2 == 0 || tmp2 == tmp { tmp2 = r.Intn(l-1)+1 } fmt.Println(tmp,tmp2) for i:=1 ;i &amp;lt;=l;i++ { if i == tmp { b = append(b, i) continue } a = append(a, i) b = append(b, i) b = append(b, i) } for i:=1 ;i &amp;lt;=l;i++ { if i == tmp ||i == tmp2 { c = append(c,i) continue } c = append(c,i) c = append(c,i) } //fmt.</description>
			<content type="html"><![CDATA[<p>原文: <a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653189951&amp;idx=1&amp;sn=0181c95484b67d108672235b14e5ebbb&amp;chksm=8c9905e5bbee8cf3362ccc4c7e091caa18b5783183ce4475b6f011c09c1cb03847ea4cb5220c&amp;scene=21#wechat_redirect">程序员小灰 找出缺失的整数</a></p>
<h3 id="实现代码">实现代码</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;math/rand&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">a</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="nx">b</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="nx">c</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="nx">l</span> <span class="p">=</span> <span class="mi">100</span>
	<span class="nx">r</span> <span class="p">=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nf">NewSource</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UnixNano</span><span class="p">()))</span>

<span class="p">)</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 1~10 随机数
</span><span class="c1"></span>	<span class="nx">tmp</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="nx">l</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
	<span class="c1">// 在生成一个不等于tmp的随机数
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">tmp2</span> <span class="kt">int</span>
	<span class="k">for</span> <span class="nx">tmp2</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">tmp2</span> <span class="o">==</span> <span class="nx">tmp</span> <span class="p">{</span>
		<span class="nx">tmp2</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="nx">l</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
	<span class="p">}</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">tmp</span><span class="p">,</span><span class="nx">tmp2</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">1</span> <span class="p">;</span><span class="nx">i</span> <span class="o">&lt;=</span><span class="nx">l</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="nx">tmp</span> <span class="p">{</span>
			<span class="nx">b</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">a</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
		<span class="nx">b</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
		<span class="nx">b</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>

	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">1</span> <span class="p">;</span><span class="nx">i</span> <span class="o">&lt;=</span><span class="nx">l</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="nx">tmp</span> <span class="o">||</span><span class="nx">i</span> <span class="o">==</span> <span class="nx">tmp2</span>  <span class="p">{</span>
			<span class="nx">c</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">c</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span>
		<span class="nx">c</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">//fmt.Println(&#34;&gt;&gt;&gt; 有序数组&#34;)
</span><span class="c1"></span>	<span class="c1">//fmt.Println(a)
</span><span class="c1"></span>	<span class="c1">//fmt.Println(b)
</span><span class="c1"></span>	<span class="c1">//fmt.Println(c)
</span><span class="c1"></span>	<span class="nf">random</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
	<span class="nf">random</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
	<span class="nf">random</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
	<span class="c1">//fmt.Println(&#34;&gt;&gt;&gt; 无序数组&#34;)
</span><span class="c1"></span>	<span class="c1">//fmt.Println(a)
</span><span class="c1"></span>	<span class="c1">//fmt.Println(b)
</span><span class="c1"></span>	<span class="c1">//fmt.Println(c)
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// 随机打乱字符串算法
</span><span class="c1">//Fisher-Yates随机置乱算法
</span><span class="c1">//也称高纳德置乱算法
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">random</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)&gt;</span><span class="mi">0</span> <span class="p">{</span>
		<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>
		<span class="nx">tmp</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
		<span class="nx">nums</span><span class="p">[</span><span class="nx">tmp</span><span class="p">]</span> <span class="p">,</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">tmp</span><span class="p">]</span>
		<span class="c1">//对前n-1进行替换
</span><span class="c1"></span>		<span class="nx">nums</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[:</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">//题目：一个无序数组里有99个不重复正整数，范围从1到100，唯独缺少一个整数。如何找出这个缺失的整数？
</span><span class="c1"></span><span class="kd">func</span>  <span class="nf">findInt1</span><span class="p">(</span><span class="nx">a</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">)</span> <span class="kt">int</span>  <span class="p">{</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span> <span class="mi">0</span> <span class="p">;</span><span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">l</span><span class="o">-</span><span class="mi">1</span> <span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">sum</span><span class="o">+=</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="nx">l</span><span class="p">)</span><span class="o">*</span><span class="nx">l</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="nx">sum</span>
<span class="p">}</span>

<span class="c1">//题目扩展：一个无序数组里有若干个正整数，范围从1到100，其中99个整数都出现了偶数次，
</span><span class="c1">//只有一个整数出现了奇数次（比如1,1,2,2,3,3,4,5,5），如何找到这个出现奇数次的整数？
</span><span class="c1">// 思路: 所有的数做 异或
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">findInt2</span><span class="p">(</span><span class="nx">a</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">rst</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span> <span class="mi">1</span> <span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
		<span class="nx">rst</span> <span class="p">^=</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">rst</span>
<span class="p">}</span>

<span class="c1">//题目第二次扩展：一个无序数组里有若干个正整数，范围从1到100，其中98个整数都出现了偶数次，
</span><span class="c1">//只有两个整数出现了奇数次（比如1,1,2,2,3,4,5,5），如何找到这个出现奇数次的整数？
</span><span class="c1">// 思路:
</span><span class="c1">// 1. 先对所有数异或, 异或的结果就是两个奇数的异或结果, 这个数二进制位必定有一位是1
</span><span class="c1">// 2. 按异或结果其中一个1的位置, 将无序数组分成两个数组
</span><span class="c1">//
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">findInt3</span><span class="p">(</span><span class="nx">a</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">a1</span> <span class="o">:=</span> <span class="nf">findInt2</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
	<span class="c1">//fmt.Println(a1)
</span><span class="c1"></span>	<span class="nx">m</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">a1</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">a1</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
		<span class="nx">m</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="c1">//fmt.Println(m)
</span><span class="c1"></span>	<span class="nx">odd</span><span class="p">,</span><span class="nx">even</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// 说明该位 是1
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="nx">m</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
			<span class="nx">odd</span> <span class="p">^=</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
			<span class="nx">even</span> <span class="p">^=</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">odd</span><span class="p">,</span><span class="nx">even</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">findInt1</span><span class="p">(</span><span class="nx">a</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">findInt2</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">findInt3</span><span class="p">(</span><span class="nx">c</span><span class="p">))</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go学习 Goroutine泄露</title>
			<link>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-goroutine%E6%B3%84%E9%9C%B2/</link>
			<pubDate>Thu, 25 Feb 2021 10:43:52 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-goroutine%E6%B3%84%E9%9C%B2/</guid>
			<description>&lt;p&gt;goroutine 泄露常见说明&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>goroutine 泄露常见说明</p>
<blockquote>
<p>参考文档</p>
</blockquote>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/74090074">Go 笔记之如何防止 goroutine 泄露</a></li>
<li><a href="https://juejin.cn/post/6844903901410361358">Go 笔记之如何防止 goroutine 泄露（二）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/68921032">Go 译文之如何构建并发 Pipeline</a></li>
</ul>
<h3 id="泄露情况分类">泄露情况分类</h3>
<ul>
<li>
<ol>
<li>死循环导致goroutine 无法退出</li>
</ol>
</li>
<li>
<ol start="2">
<li>channel泄露</li>
</ol>
<ul>
<li>发送无接收</li>
<li>接收无发送</li>
<li>nil channel 发送和接收都会阻塞, 通过select方式, nil channel不会被select</li>
</ul>
</li>
<li>
<ol start="3">
<li>传统同步机制</li>
</ol>
<ul>
<li>sync.Mutex 使用未释放, 建议Lock 后执行defer  Unlock</li>
<li>sync.WaitGroup 设置的任务数错误导致一直 wait阻塞, 建议每次wg.Add(1)</li>
</ul>
</li>
</ul>
<h3 id="简单实例">简单实例</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="kd">func</span> <span class="nf">Test4</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
	<span class="nx">count</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">())</span>
	<span class="nx">timeout</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">{</span>
            <span class="k">select</span> <span class="p">{</span>
        	<span class="k">case</span> <span class="nx">c</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}:</span>
        		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
        	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
        		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;停止写入 ... &#34;</span><span class="p">)</span>
        		<span class="k">return</span>
        	<span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}()</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">c</span><span class="p">:</span>
			<span class="nx">count</span><span class="o">++</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">timeout</span><span class="p">:</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;timeout ... &#34;</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="mi">50</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">count</span> <span class="p">&gt;</span> <span class="mi">3</span> <span class="p">{</span>
				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;已经写入三次, 准备停止...&#34;</span><span class="p">)</span>
				<span class="nf">cancel</span><span class="p">()</span>
				<span class="k">return</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div><h3 id="自动化测试泄露">自动化测试泄露</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">TestTest4</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">//defer goleak.VerifyNone(t)
</span><span class="c1"></span>	<span class="k">defer</span> <span class="nx">leaktest</span><span class="p">.</span><span class="nf">Check</span><span class="p">(</span><span class="nx">t</span><span class="p">)()</span>
	<span class="nf">Test4</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><h3 id="通过-runtimenumgoroutine-函数计数">通过 runtime.NumGoroutine() 函数计数</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;runtime.NumGoroutine : &#34;</span><span class="p">,</span><span class="nx">runtime</span><span class="p">.</span><span class="nf">NumGoroutine</span><span class="p">())</span>
			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="mi">500</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">test1</span><span class="p">.</span><span class="nf">Test3</span><span class="p">()</span>
	<span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go源码学习 Sort包Search方法</title>
			<link>https://www.ngirl.xyz/golang/go%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-sort%E5%8C%85search%E6%96%B9%E6%B3%95/</link>
			<pubDate>Mon, 25 Jan 2021 14:54:22 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-sort%E5%8C%85search%E6%96%B9%E6%B3%95/</guid>
			<description>&lt;p&gt;Sort包Search方法的实践说明&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>Sort包Search方法的实践说明</p>
<h3 id="首先查看示例">首先查看示例</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;sort&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">data</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span>
	<span class="nx">sort</span><span class="p">.</span><span class="nf">Ints</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
	<span class="c1">// Search 会查询已排序数列 满足条件的最小索引
</span><span class="c1"></span>	<span class="nx">i</span> <span class="o">:=</span> <span class="nx">sort</span><span class="p">.</span><span class="nf">Search</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">),</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;当前查询的index: %v, 查询的结果data[%v]: %v&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="c1">// 因为该列表已经排序, 满足二分条件(即左边全部小于右边)
</span><span class="c1"></span>		<span class="c1">// 当满足条件的时候, 向前查询
</span><span class="c1"></span>		<span class="c1">// 只要满足条件, 前面就可能还有更小的满足条件的值
</span><span class="c1"></span>		<span class="k">return</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">23</span>
	<span class="p">})</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;最终的结果为&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="c1">// 1
</span><span class="c1"></span><span class="p">}</span>

</code></pre></div><h3 id="sort的search源码">sort的Search源码</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Search</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c1">// Define f(-1) == false and f(n) == true.
</span><span class="c1"></span>	<span class="c1">// Invariant: f(i-1) == false, f(j) == true.
</span><span class="c1"></span>	<span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">n</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">j</span> <span class="p">{</span>
		<span class="c1">// 这里左移 实现二分 h = (i+j) / 2
</span><span class="c1"></span>		<span class="nx">h</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">uint</span><span class="p">(</span><span class="nx">i</span><span class="o">+</span><span class="nx">j</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// avoid overflow when computing h
</span><span class="c1"></span>		<span class="c1">// i ≤ h &lt; j
</span><span class="c1"></span>		<span class="c1">// 如果f(h) 为false, 那么就执行 i = h + 1 , 查看 中间位置的下一个值, 向后查询
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nf">f</span><span class="p">(</span><span class="nx">h</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">i</span> <span class="p">=</span> <span class="nx">h</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// preserves f(i-1) == false
</span><span class="c1"></span>		<span class="c1">// 否则f(h) 为true , 那么执行 j = h , 查询的区间由 (i,n) 变成 (i,h) , 向前查询
</span><span class="c1"></span>		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">j</span> <span class="p">=</span> <span class="nx">h</span> <span class="c1">// preserves f(j) == true
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// i == j, f(i-1) == false, and f(j) (= f(i)) == true  =&gt;  answer is i.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">i</span>
<span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go学习 并发的实现原理</title>
			<link>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-%E5%B9%B6%E5%8F%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
			<pubDate>Thu, 14 Jan 2021 17:49:48 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/go%E5%AD%A6%E4%B9%A0-%E5%B9%B6%E5%8F%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
			<description>&lt;p&gt;go&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>go</p>
<ul>
<li><a href="https://studygolang.com/articles/22390?fr=sidebar">【深度知识】GO语言的goroutine并发原理和调度机制</a></li>
</ul>
<h3 id="go并发的模型">go并发的模型</h3>
<ul>
<li>多线程共享内存</li>
<li>CSP(communicating sequential processes)   - 以通信的方式来共享内存</li>
</ul>
<h3 id="go的csp并发模型是通过goroutine和channel来实现的">Go的CSP并发模型，是通过goroutine和channel来实现的。</h3>
<ul>
<li>goroutine 是Go语言中并发的执行单位。有点抽象，其实就是和传统概念上的&quot;线程“类似，可以理解为&quot;线程“。</li>
<li>channel是Go语言中各个并发结构体(goroutine)之前的通信机制。 通俗的讲，就是各个goroutine之间通信的&quot;管道“，有点类似于Linux中的管道。</li>
</ul>
<h3 id="go线程实现模型mpg">Go线程实现模型MPG</h3>
<ul>
<li>M指的是Machine，一个M直接关联了一个内核线程。由操作系统管理。</li>
<li>P指的是&quot;processor&quot;，代表了M所需的上下文环境，也是处理用户级代码逻辑的处理器。它负责衔接M和G的调度上下文，将等待执行的G与M对接。</li>
<li>G指的是Goroutine，其实本质上也是一种轻量级的线程。包括了调用栈，重要的调度信息，例如channel等。</li>
</ul>
<p><img src="/assets/markdown-img-paste-20210114180539724.png" alt=""></p>
<h3 id="goroutine-小结">Goroutine 小结</h3>
<h4 id="优点">优点：</h4>
<ul>
<li>
<p>1、开销小
POSIX的thread API虽然能够提供丰富的API，例如配置自己的CPU亲和性，申请资源等等，线程在得到了很多与进程相同的控制权的同时，开销也非常的大，在Goroutine中则不需这些额外的开销，所以一个Golang的程序中可以支持10w级别的Goroutine。
每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少（goroutine：2KB ，线程：8MB）</p>
</li>
<li>
<p>2、调度性能好
在Golang的程序中，操作系统级别的线程调度，通常不会做出合适的调度决策。例如在GC时，内存必须要达到一个一致的状态。在Goroutine机制里，Golang可以控制Goroutine的调度，从而在一个合适的时间进行GC。
在应用层模拟的线程，它避免了上下文切换的额外耗费，兼顾了多线程的优点。简化了高并发程序的复杂度。</p>
</li>
</ul>
<h4 id="缺点">缺点：</h4>
<p>协程调度机制无法实现公平调度。</p>]]></content>
		</item>
		
		<item>
			<title>Gee学习-路由trie测试编写</title>
			<link>https://www.ngirl.xyz/golang/gee%E5%AD%A6%E4%B9%A0-%E8%B7%AF%E7%94%B1trie%E6%B5%8B%E8%AF%95%E7%BC%96%E5%86%99/</link>
			<pubDate>Thu, 14 Jan 2021 11:32:54 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/gee%E5%AD%A6%E4%B9%A0-%E8%B7%AF%E7%94%B1trie%E6%B5%8B%E8%AF%95%E7%BC%96%E5%86%99/</guid>
			<description>github地址: github.com/zhangzw001/learnGee
 路由分析测试 package gee import ( &amp;#34;reflect&amp;#34; &amp;#34;testing&amp;#34; ) func TestParsePattern(t *testing.T) { tests := []struct { patterns string parts []string ok bool }{ {&amp;#34;/test/v1/add&amp;#34;, []string{&amp;#34;test&amp;#34;, &amp;#34;v1&amp;#34;, &amp;#34;add&amp;#34;},true }, {&amp;#34;/test/*name/add&amp;#34;, []string{&amp;#34;test&amp;#34;, &amp;#34;*name&amp;#34;},true}, {&amp;#34;/test/:name&amp;#34;, []string{&amp;#34;test&amp;#34;, &amp;#34;:name&amp;#34;},true }, {&amp;#34;/test/:name/abc&amp;#34;, []string{&amp;#34;test&amp;#34;, &amp;#34;:name&amp;#34;, &amp;#34;abc&amp;#34;},true}, {&amp;#34;/test/v1/add&amp;#34;, []string{&amp;#34;testv1&amp;#34;, &amp;#34;add&amp;#34;},false }, {&amp;#34;/test/*name/add&amp;#34;, []string{&amp;#34;test&amp;#34;, &amp;#34;*name&amp;#34;,&amp;#34;add&amp;#34;},false}, {&amp;#34;/test/:name&amp;#34;, []string{&amp;#34;test&amp;#34;, &amp;#34;:&amp;#34;,&amp;#34;name&amp;#34;},false }, {&amp;#34;/test/:name/abc&amp;#34;, []string{&amp;#34;test&amp;#34;, &amp;#34;:name&amp;#34;},false}, } m := make(map[string][]string) for _, test := range tests { m[test.patterns] = test.parts p := parsePattern(test.</description>
			<content type="html"><![CDATA[<p>github地址: <a href="github.com/zhangzw001/learnGee">github.com/zhangzw001/learnGee</a></p>
<hr>
<h3 id="路由分析测试">路由分析测试</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">gee</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;reflect&#34;</span>
	<span class="s">&#34;testing&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">TestParsePattern</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">tests</span> <span class="o">:=</span> <span class="p">[]</span><span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">patterns</span> <span class="kt">string</span>
		<span class="nx">parts</span>    <span class="p">[]</span><span class="kt">string</span>
		<span class="nx">ok</span> <span class="kt">bool</span>
	<span class="p">}{</span>
		<span class="p">{</span><span class="s">&#34;/test/v1/add&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="s">&#34;v1&#34;</span><span class="p">,</span> <span class="s">&#34;add&#34;</span><span class="p">},</span><span class="kc">true</span> <span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;/test/*name/add&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="s">&#34;*name&#34;</span><span class="p">},</span><span class="kc">true</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;/test/:name&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="s">&#34;:name&#34;</span><span class="p">},</span><span class="kc">true</span> <span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;/test/:name/abc&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="s">&#34;:name&#34;</span><span class="p">,</span> <span class="s">&#34;abc&#34;</span><span class="p">},</span><span class="kc">true</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;/test/v1/add&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;testv1&#34;</span><span class="p">,</span> <span class="s">&#34;add&#34;</span><span class="p">},</span><span class="kc">false</span> <span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;/test/*name/add&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="s">&#34;*name&#34;</span><span class="p">,</span><span class="s">&#34;add&#34;</span><span class="p">},</span><span class="kc">false</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;/test/:name&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="s">&#34;:&#34;</span><span class="p">,</span><span class="s">&#34;name&#34;</span><span class="p">},</span><span class="kc">false</span> <span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;/test/:name/abc&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="s">&#34;:name&#34;</span><span class="p">},</span><span class="kc">false</span><span class="p">},</span>
	<span class="p">}</span>

	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">test</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tests</span> <span class="p">{</span>
		<span class="nx">m</span><span class="p">[</span><span class="nx">test</span><span class="p">.</span><span class="nx">patterns</span><span class="p">]</span> <span class="p">=</span> <span class="nx">test</span><span class="p">.</span><span class="nx">parts</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nf">parsePattern</span><span class="p">(</span><span class="nx">test</span><span class="p">.</span><span class="nx">patterns</span><span class="p">)</span>

		<span class="k">if</span> <span class="nx">test</span><span class="p">.</span><span class="nx">ok</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">DeepEqual</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">m</span><span class="p">[</span><span class="nx">test</span><span class="p">.</span><span class="nx">patterns</span><span class="p">])</span> <span class="p">{</span>
				<span class="nx">t</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;expect %v, but actual %v\n&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">[</span><span class="nx">test</span><span class="p">.</span><span class="nx">patterns</span><span class="p">],</span> <span class="nx">p</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">DeepEqual</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">m</span><span class="p">[</span><span class="nx">test</span><span class="p">.</span><span class="nx">patterns</span><span class="p">])</span> <span class="p">{</span>
				<span class="nx">t</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;not expect %v, but actual %v\n&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">[</span><span class="nx">test</span><span class="p">.</span><span class="nx">patterns</span><span class="p">],</span> <span class="nx">p</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>


	<span class="p">}</span>

<span class="p">}</span>


<span class="kd">func</span> <span class="nf">Testrouter_GET</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">tests</span> <span class="o">:=</span> <span class="p">[]</span><span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">method</span>  <span class="kt">string</span>
		<span class="nx">pattern</span> <span class="kt">string</span>
		<span class="nx">parts</span>   <span class="p">[]</span><span class="kt">string</span>
		<span class="nx">ok</span>      <span class="kt">bool</span>
	<span class="p">}{</span>
		<span class="p">{</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="s">&#34;/test1/v1/add&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;/test1/v1/add&#34;</span><span class="p">},</span> <span class="kc">true</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="s">&#34;/test2/*name&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;/test2/name1&#34;</span><span class="p">,</span> <span class="s">&#34;/test2/name1/name2&#34;</span><span class="p">},</span> <span class="kc">true</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="s">&#34;/test3/:file/add&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;/test3/file123/add&#34;</span><span class="p">,</span> <span class="s">&#34;/test3/file_!@#$/add&#34;</span><span class="p">,</span> <span class="s">&#34;/test3/123431/add&#34;</span><span class="p">},</span> <span class="kc">true</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="s">&#34;/test4/:file/add&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;/test4/file123&#34;</span><span class="p">,</span> <span class="s">&#34;/test3/file_!@#$/add123&#34;</span><span class="p">,</span> <span class="s">&#34;/test3/123431/123_@#&#34;</span><span class="p">},</span> <span class="kc">false</span><span class="p">},</span>
		<span class="c1">// 这两条 应该怎么走呢?
</span><span class="c1"></span>		<span class="p">{</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="s">&#34;/hello/*name&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;/hello/geektutu/a/b&#34;</span><span class="p">,</span><span class="s">&#34;hello/geektutu&#34;</span><span class="p">},</span> <span class="kc">true</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="s">&#34;/hello/geektutu&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;hello/geektutu&#34;</span><span class="p">},</span> <span class="kc">true</span><span class="p">},</span>

	<span class="p">}</span>

	<span class="nx">r</span> <span class="o">:=</span> <span class="nf">newRouter</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">test</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tests</span> <span class="p">{</span>
		<span class="nx">r</span><span class="p">.</span><span class="nf">addRoute</span><span class="p">(</span><span class="nx">test</span><span class="p">.</span><span class="nx">method</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">pattern</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">test</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tests</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">part</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">test</span><span class="p">.</span><span class="nx">parts</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">test</span><span class="p">.</span><span class="nx">ok</span> <span class="p">{</span>
				<span class="nx">node</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">getRoute</span><span class="p">(</span><span class="nx">test</span><span class="p">.</span><span class="nx">method</span><span class="p">,</span> <span class="nx">part</span><span class="p">)</span>
				<span class="k">if</span> <span class="nx">node</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nx">t</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;url Path %s, expected : %s, but actual : %s\n&#34;</span><span class="p">,</span> <span class="nx">part</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">pattern</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">)</span>
					<span class="k">continue</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">pattern</span> <span class="o">!=</span> <span class="nx">test</span><span class="p">.</span><span class="nx">pattern</span> <span class="o">&amp;&amp;</span> <span class="nx">test</span><span class="p">.</span><span class="nx">ok</span> <span class="p">{</span>
					<span class="nx">t</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;url Path %s, expected : %s, but actual : %s\n&#34;</span><span class="p">,</span> <span class="nx">part</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">pattern</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">pattern</span><span class="p">)</span>
				<span class="p">}</span>
			<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
				<span class="nx">node</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">getRoute</span><span class="p">(</span><span class="nx">test</span><span class="p">.</span><span class="nx">method</span><span class="p">,</span> <span class="nx">part</span><span class="p">)</span>
				<span class="k">if</span> <span class="nx">node</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="k">continue</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">pattern</span> <span class="o">==</span> <span class="nx">test</span><span class="p">.</span><span class="nx">pattern</span> <span class="p">{</span>
					<span class="nx">t</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;url Path %s, not expected : %s, but actual : %s\n&#34;</span><span class="p">,</span> <span class="nx">part</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">pattern</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">pattern</span><span class="p">)</span>
				<span class="p">}</span>
			<span class="p">}</span>

		<span class="p">}</span>
	<span class="p">}</span>

<span class="p">}</span>

</code></pre></div><h3 id="路由代码">路由代码</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">gee</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;net/http&#34;</span>
	<span class="s">&#34;strings&#34;</span>
<span class="p">)</span>

<span class="c1">// 这里包装router
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">router</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">roots</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">node</span>
	<span class="nx">handlers</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">HandlerFunc</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">newRouter</span><span class="p">()</span> <span class="o">*</span><span class="nx">router</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">router</span><span class="p">{</span>
		<span class="nx">handlers</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">HandlerFunc</span><span class="p">),</span>
		<span class="nx">roots</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">node</span> <span class="p">),</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Only one * is allowed
</span><span class="c1">// 将 /test/v1/add -&gt; [test v1 add]
</span><span class="c1">// /test/*name/add -&gt; [test *name]
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">parsePattern</span><span class="p">(</span><span class="nx">pattern</span> <span class="kt">string</span> <span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="nx">vs</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="nx">pattern</span><span class="p">,</span><span class="s">&#34;/&#34;</span><span class="p">)</span>
	<span class="nx">parts</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span> <span class="p">,</span> <span class="nx">item</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">vs</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">item</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="nx">parts</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">parts</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;*&#39;</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">parts</span>
<span class="p">}</span>

<span class="c1">//
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">router</span><span class="p">)</span> <span class="nf">addRoute</span><span class="p">(</span><span class="nx">method</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">pattern</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">handler</span> <span class="nx">HandlerFunc</span> <span class="p">)</span> <span class="p">{</span>
	<span class="nx">parts</span> <span class="o">:=</span> <span class="nf">parsePattern</span><span class="p">(</span><span class="nx">pattern</span><span class="p">)</span>
	<span class="nx">key</span> <span class="o">:=</span> <span class="nx">method</span><span class="o">+</span><span class="s">&#34;-&#34;</span><span class="o">+</span><span class="nx">pattern</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">roots</span><span class="p">[</span><span class="nx">method</span><span class="p">]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">r</span><span class="p">.</span><span class="nx">roots</span><span class="p">[</span><span class="nx">method</span><span class="p">]</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">node</span><span class="p">{}</span>
	<span class="p">}</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">roots</span><span class="p">[</span><span class="nx">method</span><span class="p">].</span><span class="nf">insert</span><span class="p">(</span><span class="nx">pattern</span><span class="p">,</span><span class="nx">parts</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">handlers</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">handler</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">router</span><span class="p">)</span> <span class="nf">handle</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>

	<span class="nx">n</span><span class="p">,</span> <span class="nx">params</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">getRoute</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Method</span><span class="p">,</span><span class="nx">c</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="o">!=</span> <span class="kc">nil</span>  <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">Params</span> <span class="p">=</span> <span class="nx">params</span>
		<span class="nx">key</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Method</span> <span class="o">+</span> <span class="s">&#34;-&#34;</span> <span class="o">+</span> <span class="nx">n</span><span class="p">.</span><span class="nx">pattern</span>
		<span class="nx">r</span><span class="p">.</span><span class="nx">handlers</span><span class="p">[</span><span class="nx">key</span><span class="p">](</span><span class="nx">c</span><span class="p">)</span>
	<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusNotFound</span><span class="p">,</span><span class="s">&#34;404 not found : %s\n&#34;</span><span class="p">,</span><span class="nx">c</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">router</span><span class="p">)</span> <span class="nf">getRoute</span><span class="p">(</span><span class="nx">method</span> <span class="kt">string</span> <span class="p">,</span> <span class="nx">path</span> <span class="kt">string</span> <span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">node</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">searchParts</span> <span class="o">:=</span> <span class="nf">parsePattern</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span>
	<span class="nx">params</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span>
	<span class="nx">root</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">roots</span><span class="p">[</span><span class="nx">method</span><span class="p">]</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">root</span><span class="p">.</span><span class="nf">search</span><span class="p">(</span><span class="nx">searchParts</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">parts</span> <span class="o">:=</span> <span class="nf">parsePattern</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">pattern</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">part</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">parts</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">part</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;:&#39;</span> <span class="p">{</span>
				<span class="nx">params</span><span class="p">[</span><span class="nx">part</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span> <span class="p">=</span> <span class="nx">searchParts</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">part</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;*&#39;</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">part</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
				<span class="nx">params</span><span class="p">[</span><span class="nx">part</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">searchParts</span><span class="p">[</span><span class="nx">index</span><span class="p">:],</span> <span class="s">&#34;/&#34;</span><span class="p">)</span>
				<span class="k">break</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">params</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// 这里GET方法写在 router 里面
</span><span class="c1">// engine 是包含 router
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">router</span><span class="p">)</span> <span class="nf">GET</span><span class="p">(</span><span class="nx">pattern</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">handler</span> <span class="nx">HandlerFunc</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">r</span><span class="p">.</span><span class="nf">addRoute</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">MethodGet</span><span class="p">,</span><span class="nx">pattern</span><span class="p">,</span><span class="nx">handler</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">router</span><span class="p">)</span> <span class="nf">POST</span><span class="p">(</span><span class="nx">pattern</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">handler</span> <span class="nx">HandlerFunc</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">r</span><span class="p">.</span><span class="nf">addRoute</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">MethodPost</span><span class="p">,</span><span class="nx">pattern</span><span class="p">,</span><span class="nx">handler</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><h3 id="trie-树代码">trie 树代码</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">gee</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;strings&#34;</span>
<span class="p">)</span>

<span class="c1">// 采用 前缀树 方式来实现动态路由
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">node</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">pattern</span> <span class="kt">string</span> <span class="c1">//待匹配路由, 例如  /p/:lang , 是 req.URL.Path
</span><span class="c1"></span>	<span class="nx">part</span> <span class="kt">string</span> <span class="c1">// 路由中一部分, 例如 :lang, 是按照 / 分割的部分
</span><span class="c1"></span>	<span class="nx">children</span> <span class="p">[]</span><span class="o">*</span><span class="nx">node</span> <span class="c1">// 子节点, 例如 [ doc, tutorial, intro ]
</span><span class="c1"></span>	<span class="nx">isWild</span> <span class="kt">bool</span> <span class="c1">// 是否精确匹配, part含有: 或 * 时为true
</span><span class="c1"></span><span class="p">}</span>



<span class="c1">// 第一个匹配成功的节点, 用于插入 insert 方法
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span> <span class="p">)</span> <span class="nf">matchChild</span><span class="p">(</span><span class="nx">part</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">node</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">child</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">n</span><span class="p">.</span><span class="nx">children</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">child</span><span class="p">.</span><span class="nx">part</span> <span class="o">==</span> <span class="nx">part</span> <span class="o">||</span> <span class="nx">child</span><span class="p">.</span><span class="nx">isWild</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">child</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// 所有匹配成功的节点，用于查找 search 方法
</span><span class="c1">//  例如 /test/v1/add
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span><span class="p">)</span> <span class="nf">matchChildren</span><span class="p">(</span><span class="nx">part</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="o">*</span><span class="nx">node</span> <span class="p">{</span>
	<span class="nx">nodes</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">node</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="c1">// 查询方法就是从trie树中查询, 如果查到了添加到列表, 返回查询到的列表
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">child</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">n</span><span class="p">.</span><span class="nx">children</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">child</span><span class="p">.</span><span class="nx">part</span> <span class="o">==</span> <span class="nx">part</span> <span class="o">||</span> <span class="nx">child</span><span class="p">.</span><span class="nx">isWild</span> <span class="p">{</span>
			<span class="nx">nodes</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">nodes</span><span class="p">,</span> <span class="nx">child</span><span class="p">)</span>
			<span class="c1">// 这里加break是让查到的第一个就结束, 不希望路由匹配到多个结果
</span><span class="c1"></span>			<span class="c1">//break
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">nodes</span>
<span class="p">}</span>

<span class="c1">// 插入方法就是 判断 part路由是否已经存在路由节点中 如果是模糊匹配 直接返回
</span><span class="c1">//   if child.part == part || child.isWild {
</span><span class="c1">// 如果没有找到且是精确匹配, 那么就添加到子节点中
</span><span class="c1">//   n.children = append(n.children, child)
</span><span class="c1">//
</span><span class="c1">//  pattern 是完整路由url ,parts 是将 pattern 按照 / 拆分的 每一部分 , 然后height 从0 递归对 parts 进行查询或插入
</span><span class="c1">//
</span><span class="c1">//  这里是一个逆向看的, 可以先去查询 parsePattern 方法
</span><span class="c1">//  例如 /test/v1/add
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span><span class="p">)</span> <span class="nf">insert</span><span class="p">(</span><span class="nx">pattern</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">parts</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">height</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 在node中生成一条 test(node) -&gt; v2(node) -&gt; add(node) 一条trie链表 之后
</span><span class="c1"></span>	<span class="c1">// len(parts == height == 3 , 可以退出
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">parts</span><span class="p">)</span> <span class="o">==</span> <span class="nx">height</span> <span class="p">{</span>
		<span class="nx">n</span><span class="p">.</span><span class="nx">pattern</span> <span class="p">=</span> <span class="nx">pattern</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">//
</span><span class="c1"></span>	<span class="nx">part</span> <span class="o">:=</span> <span class="nx">parts</span><span class="p">[</span><span class="nx">height</span><span class="p">]</span>
	<span class="c1">// 首先取 test 从node中查询, 如果查到了 那么目前查到路由 : /test
</span><span class="c1"></span>	<span class="c1">// 那么继续递归insert, 取v1 去查询,
</span><span class="c1"></span>	<span class="c1">// 如果查到了说明路由存在, 如果没有查到 那么新建这个node,添加到当前node的children, 目前查到路由: /test/v1,
</span><span class="c1"></span>	<span class="c1">// 同样最后可以 在node中生成一条 test(node) -&gt; v2(node) -&gt; add(node) 一条trie链表
</span><span class="c1"></span>	<span class="nx">child</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nf">matchChild</span><span class="p">(</span><span class="nx">part</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">child</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">child</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">node</span><span class="p">{</span>
			<span class="nx">part</span><span class="p">:</span><span class="nx">part</span><span class="p">,</span>
			<span class="nx">isWild</span><span class="p">:</span><span class="nx">part</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;:&#39;</span> <span class="o">||</span> <span class="nx">part</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;*&#39;</span><span class="p">,</span>
		<span class="p">}</span>
		<span class="nx">n</span><span class="p">.</span><span class="nx">children</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">children</span><span class="p">,</span> <span class="nx">child</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">child</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="nx">pattern</span><span class="p">,</span> <span class="nx">parts</span><span class="p">,</span> <span class="nx">height</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 从node中查询节点是否存在, 如果存在就返回
</span><span class="c1">//  例如 /test/v1/add
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span><span class="p">)</span> <span class="nf">search</span><span class="p">(</span><span class="nx">parts</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">height</span> <span class="kt">int</span> <span class="p">)</span> <span class="o">*</span><span class="nx">node</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">parts</span><span class="p">)</span> <span class="o">==</span> <span class="nx">height</span> <span class="o">||</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">part</span><span class="p">,</span><span class="s">&#34;*&#34;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">pattern</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">n</span>
	<span class="p">}</span>
	<span class="nx">part</span> <span class="o">:=</span> <span class="nx">parts</span><span class="p">[</span><span class="nx">height</span><span class="p">]</span>
	<span class="c1">// 这里查询同样是 先查询 test, 如果找到trie树的第一个节点 children = [ test(node) ]
</span><span class="c1"></span>	<span class="c1">// 然后在出现v1, 根据trie结构, v1只能是在test(node) 这个节点的
</span><span class="c1"></span>	<span class="c1">// 这里需要for循环 为什么不直接取 children[0] 呢?
</span><span class="c1"></span>	<span class="c1">// 1. 有可能是因为v1 可能匹配到 /test/v1 也可能匹配到 /test/:version, 所以返回的是2个
</span><span class="c1"></span>	<span class="c1">// 2. 如果让每次matchChildren查询返回一定是唯一呢? 那如果先有路由1:&#34;/hello/geektutu&#34;, 在注册了路由2:&#34;/hello/*name&#34;, 当请求&#34;/hello/geektutu/a/b&#34;的时候就会无法匹配路由2
</span><span class="c1"></span>	<span class="nx">children</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nf">matchChildren</span><span class="p">(</span><span class="nx">part</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">child</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">children</span> <span class="p">{</span>
		<span class="c1">//log.Println(&#34;child:&#34;,child.pattern)
</span><span class="c1"></span>		<span class="nx">result</span> <span class="o">:=</span> <span class="nx">child</span><span class="p">.</span><span class="nf">search</span><span class="p">(</span><span class="nx">parts</span><span class="p">,</span> <span class="nx">height</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">result</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">result</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Gin学习 简单记录form数据获取源码解读</title>
			<link>https://www.ngirl.xyz/golang/gin%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95form%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</link>
			<pubDate>Wed, 13 Jan 2021 14:24:43 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/gin%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95form%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</guid>
			<description>http.request form 数据测试 func main() { e := gin.Default() e.Any(&amp;#34;/test&amp;#34;,func(c *gin.Context) { // 获取所有参数 	_ = c.Request.ParseForm() // log.Println(c.Request.Header[&amp;#34;Content-Type&amp;#34;]) 	// get form 参数, c.Request.URL.Query, err = url.ParseQuery 	log.Println(c.Request.URL.Query()) //log.Println(url.ParseQuery(c.Request.URL.RawQuery)) 	// post form 参数 	log.Println(c.Request.PostForm) // form 参数 	log.Println(c.Request.Form) }) e.Run(&amp;#34;localhost:8123&amp;#34;) }  请求日志
 # curl -XPOST &amp;quot;http://localhost:8123/test&amp;quot; -d &amp;quot;abc=123&amp;amp;q=123&amp;amp;ccc=123123&amp;quot; 2021/01/13 14:31:30 map[] 2021/01/13 14:31:30 map[abc:[123] ccc:[123123] q:[123]] 2021/01/13 14:31:30 map[abc:[123] ccc:[123123] q:[123]] [GIN] 2021/01/13 - 14:31:30 | 200 | 339.</description>
			<content type="html"><![CDATA[<h3 id="httprequest-form-数据测试">http.request form 数据测试</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">Default</span><span class="p">()</span>
	<span class="nx">e</span><span class="p">.</span><span class="nf">Any</span><span class="p">(</span><span class="s">&#34;/test&#34;</span><span class="p">,</span><span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// 获取所有参数
</span><span class="c1"></span>		<span class="nx">_</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nf">ParseForm</span><span class="p">()</span>
		<span class="c1">// log.Println(c.Request.Header[&#34;Content-Type&#34;])
</span><span class="c1"></span>		<span class="c1">// get form 参数, c.Request.URL.Query, err  = url.ParseQuery
</span><span class="c1"></span>		<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nf">Query</span><span class="p">())</span>
		<span class="c1">//log.Println(url.ParseQuery(c.Request.URL.RawQuery))
</span><span class="c1"></span>		<span class="c1">// post form 参数
</span><span class="c1"></span>		<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">PostForm</span><span class="p">)</span>
		<span class="c1">// form 参数
</span><span class="c1"></span>		<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">Form</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="nx">e</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="s">&#34;localhost:8123&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><blockquote>
<p>请求日志</p>
</blockquote>
<pre><code># curl -XPOST &quot;http://localhost:8123/test&quot; -d &quot;abc=123&amp;q=123&amp;ccc=123123&quot;
2021/01/13 14:31:30 map[]
2021/01/13 14:31:30 map[abc:[123] ccc:[123123] q:[123]]
2021/01/13 14:31:30 map[abc:[123] ccc:[123123] q:[123]]
[GIN] 2021/01/13 - 14:31:30 | 200 |     339.106µs |       127.0.0.1 | POST     &quot;/test&quot;

# curl &quot;http://localhost:8123/test?aaa=111&amp;bbbb=2222&quot;
2021/01/13 14:31:38 map[aaa:[111] bbbb:[2222]]
2021/01/13 14:31:38 map[]
2021/01/13 14:31:38 map[aaa:[111] bbbb:[2222]]
[GIN] 2021/01/13 - 14:31:38 | 200 |      73.852µs |       127.0.0.1 | GET      &quot;/test?aaa=111&amp;bbbb=2222&quot;

# curl -XPOST &quot;http://localhost:8123/test?aaa=111&amp;bbbb=2222&quot; -d &quot;abc=123&amp;q=123&amp;ccc=123123&quot;
2021/01/13 14:31:48 map[aaa:[111] bbbb:[2222]]
2021/01/13 14:31:48 map[abc:[123] ccc:[123123] q:[123]]
2021/01/13 14:31:48 map[aaa:[111] abc:[123] bbbb:[2222] ccc:[123123] q:[123]]
[GIN] 2021/01/13 - 14:31:48 | 200 |     119.833µs |       127.0.0.1 | POST     &quot;/test?aaa=111&amp;bbbb=2222&quot;

</code></pre><h3 id="看下parseform-的源码">看下ParseForm 的源码</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="nf">ParseForm</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">PostForm</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 以下方法 会调用 parsePostForm
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Method</span> <span class="o">==</span> <span class="s">&#34;POST&#34;</span> <span class="o">||</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Method</span> <span class="o">==</span> <span class="s">&#34;PUT&#34;</span> <span class="o">||</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Method</span> <span class="o">==</span> <span class="s">&#34;PATCH&#34;</span> <span class="p">{</span>
			<span class="nx">r</span><span class="p">.</span><span class="nx">PostForm</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">parsePostForm</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">PostForm</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">r</span><span class="p">.</span><span class="nx">PostForm</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">url</span><span class="p">.</span><span class="nx">Values</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Form</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 这里  PostForm 会复制到 Form, 所以 Form &gt;= PostForm
</span><span class="c1"></span>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">PostForm</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">r</span><span class="p">.</span><span class="nx">Form</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">url</span><span class="p">.</span><span class="nx">Values</span><span class="p">)</span>
			<span class="nf">copyValues</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Form</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">PostForm</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// 这里 get的参数是在r.URL里面的, 所以通过 ParseQuery 获取get参数
</span><span class="c1"></span>		<span class="kd">var</span> <span class="nx">newValues</span> <span class="nx">url</span><span class="p">.</span><span class="nx">Values</span>
		<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">URL</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="kd">var</span> <span class="nx">e</span> <span class="kt">error</span>
			<span class="nx">newValues</span><span class="p">,</span> <span class="nx">e</span> <span class="p">=</span> <span class="nx">url</span><span class="p">.</span><span class="nf">ParseQuery</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">RawQuery</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">err</span> <span class="p">=</span> <span class="nx">e</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">newValues</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">newValues</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">url</span><span class="p">.</span><span class="nx">Values</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// 最后也会添加 get参数到form, 所以 Form &gt;= url.Query()
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Form</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">r</span><span class="p">.</span><span class="nx">Form</span> <span class="p">=</span> <span class="nx">newValues</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nf">copyValues</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Form</span><span class="p">,</span> <span class="nx">newValues</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></div><h3 id="这里看下-parsepostform">这里看下 parsePostForm</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">parsePostForm</span><span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">(</span><span class="nx">vs</span> <span class="nx">url</span><span class="p">.</span><span class="nx">Values</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Body</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;missing form body&#34;</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">ct</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;Content-Type&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">ct</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">ct</span> <span class="p">=</span> <span class="s">&#34;application/octet-stream&#34;</span>
	<span class="p">}</span>
	<span class="nx">ct</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">mime</span><span class="p">.</span><span class="nf">ParseMediaType</span><span class="p">(</span><span class="nx">ct</span><span class="p">)</span>
	<span class="k">switch</span> <span class="p">{</span>
	<span class="c1">// 这里我们默认的header 就是 application/x-www-form-urlencoded
</span><span class="c1"></span>	<span class="c1">// 可以 log.Println(c.Request.Header[&#34;Content-Type&#34;]) 打印查看
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">ct</span> <span class="o">==</span> <span class="s">&#34;application/x-www-form-urlencoded&#34;</span><span class="p">:</span>
		<span class="kd">var</span> <span class="nx">reader</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Body</span>
		<span class="c1">// 首先初始化 maxFormSize = 2^63 -1
</span><span class="c1"></span>		<span class="nx">maxFormSize</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">63</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Body</span><span class="p">.(</span><span class="o">*</span><span class="nx">maxBytesReader</span><span class="p">);</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
			<span class="c1">// 设置 io.LimitedReader 的  N
</span><span class="c1"></span>			<span class="nx">maxFormSize</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">10</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">)</span> <span class="c1">// 10 MB is a lot of text.
</span><span class="c1"></span>			<span class="c1">// 返回了一个 带限制的 io.LimitedReader, 当然实现了 Reader interfacer
</span><span class="c1"></span>			<span class="nx">reader</span> <span class="p">=</span> <span class="nx">io</span><span class="p">.</span><span class="nf">LimitReader</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Body</span><span class="p">,</span> <span class="nx">maxFormSize</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// 这里会调用 io.LimitedReader 的Read 方法, 通过接口实现
</span><span class="c1"></span>		<span class="c1">// 直接读取post 的body即可
</span><span class="c1"></span>		<span class="nx">b</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadAll</span><span class="p">(</span><span class="nx">reader</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">e</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">err</span> <span class="p">=</span> <span class="nx">e</span>
			<span class="p">}</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nb">int64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span> <span class="p">&gt;</span> <span class="nx">maxFormSize</span> <span class="p">{</span>
			<span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;http: POST too large&#34;</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="c1">// 最终也是调用 url.ParseQuery
</span><span class="c1"></span>		<span class="c1">// 这里 string(b) = abc=123&amp;q=123&amp;ccc=123123
</span><span class="c1"></span>		<span class="nx">vs</span><span class="p">,</span> <span class="nx">e</span> <span class="p">=</span> <span class="nx">url</span><span class="p">.</span><span class="nf">ParseQuery</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">err</span> <span class="p">=</span> <span class="nx">e</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="nx">ct</span> <span class="o">==</span> <span class="s">&#34;multipart/form-data&#34;</span><span class="p">:</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>

</code></pre></div><h3 id="简单看下-iolimitedreader-的read-方法">简单看下 io.LimitedReader 的Read 方法</h3>
<blockquote>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">LimitedReader</span><span class="p">)</span> <span class="nf">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nx">N</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">EOF</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">int64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">))</span> <span class="p">&gt;</span> <span class="nx">l</span><span class="p">.</span><span class="nx">N</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="p">=</span> <span class="nx">p</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nx">l</span><span class="p">.</span><span class="nx">N</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">R</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">N</span> <span class="o">-=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
	<span class="k">return</span>
<span class="p">}</span>

</code></pre></div><h3 id="parsequery-分析">parseQuery 分析</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="kd">func</span> <span class="nf">parseQuery</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Values</span><span class="p">,</span> <span class="nx">query</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 这里的循环结束条件是 query == &#34;&#34;
</span><span class="c1"></span>	<span class="c1">// 那什么时候会空呢?
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">query</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">key</span> <span class="o">:=</span> <span class="nx">query</span>
		<span class="c1">// 这里取到第一个 &amp;或者; 的索引, 然后将 query 分成两半
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">IndexAny</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="s">&#34;&amp;;&#34;</span><span class="p">);</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// 这里会每次 截取后一半 赋值给query, 所以query一直在消耗 第一个&amp;前的数据
</span><span class="c1"></span>			<span class="nx">key</span><span class="p">,</span> <span class="nx">query</span> <span class="p">=</span> <span class="nx">key</span><span class="p">[:</span><span class="nx">i</span><span class="p">],</span> <span class="nx">key</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
		<span class="c1">// 如果 已经没有 &amp; 或者 ; 字符了, 说明只有最后一个字段了, 那么就直接置空 query, 然后读取完key 就可以结束循环了
</span><span class="c1"></span>		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">query</span> <span class="p">=</span> <span class="s">&#34;&#34;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">key</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">value</span> <span class="o">:=</span> <span class="s">&#34;&#34;</span>
		<span class="c1">// 取出 第一个 &amp; 前面的 参数 按照=分割, 从而得到 变量名 和变量值
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Index</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="s">&#34;=&#34;</span><span class="p">);</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="p">=</span> <span class="nx">key</span><span class="p">[:</span><span class="nx">i</span><span class="p">],</span> <span class="nx">key</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
		<span class="p">}</span>
		<span class="nx">key</span><span class="p">,</span> <span class="nx">err1</span> <span class="o">:=</span> <span class="nf">QueryUnescape</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err1</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">err</span> <span class="p">=</span> <span class="nx">err1</span>
			<span class="p">}</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">value</span><span class="p">,</span> <span class="nx">err1</span> <span class="p">=</span> <span class="nf">QueryUnescape</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err1</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">err</span> <span class="p">=</span> <span class="nx">err1</span>
			<span class="p">}</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="c1">// 最后将 post参数写成map结构 写到m (url.Value) 中
</span><span class="c1"></span>		<span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">],</span> <span class="nx">value</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Gin学习 Validator</title>
			<link>https://www.ngirl.xyz/golang/gin%E5%AD%A6%E4%B9%A0-validator/</link>
			<pubDate>Tue, 12 Jan 2021 10:17:46 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/gin%E5%AD%A6%E4%B9%A0-validator/</guid>
			<description>&lt;p&gt;记录一下Gin学习验证器和翻译器模块&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>记录一下Gin学习验证器和翻译器模块</p>
<ul>
<li>github地址: <a href="https://github.com/zhangzw001/learnGin/tree/gin-shouldbind">https://github.com/zhangzw001/learnGin/tree/gin-shouldbind</a></li>
<li>官方文档: <a href="https://godoc.org/github.com/go-playground/validator">https://godoc.org/github.com/go-playground/validator</a></li>
<li>官方示例: <a href="https://github.com/go-playground/validator/tree/v10.4.1/_examples">https://github.com/go-playground/validator/tree/v10.4.1/_examples</a></li>
<li>原文: <a href="https://github.com/xinliangnote/Go">https://github.com/xinliangnote/Go</a></li>
</ul>
<h3 id="功能演示介绍">功能演示介绍</h3>
<blockquote>
<p>首先这个模块是很方便校验接口的输入结构体参数是否符合规则,不用繁琐的自己写参数校验, 翻译器又可以支持不同语言的错误提示,而且可以自定义返回错误格式覆盖默认的格式</p>
</blockquote>
<pre><code>1. 调用localhost:8000/sn/create 执行验证器中间件
2. 调用localhost:8000/v1/product/add 执行验证器,签名等中间件
</code></pre><h3 id="部分相关目录结构">部分相关目录结构</h3>
<pre><code>.
├── config
│   └── env.go
├── controller
│   ├── api
│   │   └── v1.go
│   └── sign
│       └── sign.go
├── docs
│   ├── docs.go
│   ├── swagger.json
│   └── swagger.yaml
├── dto
│   └── api.go
├── go.mod
├── go.sum
├── logs
│   ├── gin-logger.log -&gt; gin-logger.log.20210112-000000.log
│   └── gin-logger.log.20210112-000000.log
├── main.go
├── middleware
│   ├── logger.go
│   ├── response.go
│   ├── sign.go
│   └── validator.go
├── public
│   ├── public.go
│   └── validator.go
└── routers
    └── router.go

</code></pre><h3 id="1-首先定义路由规则">1. 首先定义路由规则</h3>
<h4 id="routersroutergo">routers/router.go</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">routers</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
	<span class="nx">ginSwagger</span> <span class="s">&#34;github.com/swaggo/gin-swagger&#34;</span>
	<span class="s">&#34;github.com/swaggo/gin-swagger/swaggerFiles&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/controller/api&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/controller/sign&#34;</span>
	<span class="c1">// 这里需要导入自己项目的目录,否则swagger页面会报错
</span><span class="c1"></span>	<span class="nx">_</span> <span class="s">&#34;github.com/zhangzw001/learnGin/docs&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/middleware&#34;</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">InitRouter</span><span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Engine</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// swagger 文档
</span><span class="c1"></span>	<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/swagger/*any&#34;</span><span class="p">,</span><span class="nx">ginSwagger</span><span class="p">.</span><span class="nf">WrapHandler</span><span class="p">(</span><span class="nx">swaggerFiles</span><span class="p">.</span><span class="nx">Handler</span><span class="p">))</span>
	<span class="c1">// sign路由
</span><span class="c1"></span>	<span class="nx">Sign</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nf">Group</span><span class="p">(</span><span class="s">&#34;/sn&#34;</span><span class="p">)</span>
	<span class="nx">Sign</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">middleware</span><span class="p">.</span><span class="nf">TranslationMiddleware</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="nx">controllersign</span><span class="p">.</span><span class="nf">RegisterSign</span><span class="p">(</span><span class="nx">Sign</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// api v1版本路由
</span><span class="c1"></span>	<span class="nx">GroupV1</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nf">Group</span><span class="p">(</span><span class="s">&#34;/v1&#34;</span><span class="p">)</span>
	<span class="nx">GroupV1</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">middleware</span><span class="p">.</span><span class="nf">SignMiddleware</span><span class="p">(),</span><span class="nx">middleware</span><span class="p">.</span><span class="nf">TranslationMiddleware</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="nx">controllerapi</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">GroupV1</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="2-看下sign-controller">2. 看下sign controller</h3>
<h4 id="21-controllersignsigngo">2.1 controller/sign/sign.go</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">controllersign</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/dto&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/middleware&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/public&#34;</span>
	<span class="s">&#34;strconv&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Controller</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="nf">RegisterSign</span><span class="p">(</span><span class="nx">router</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">RouterGroup</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">sign</span> <span class="o">:=</span> <span class="nx">Controller</span><span class="p">{}</span>
	<span class="nx">router</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/create&#34;</span><span class="p">,</span> <span class="nx">sign</span><span class="p">.</span><span class="nx">Create</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Add godoc
</span><span class="c1">// @Summary sign接口
</span><span class="c1">// @Description sign接口
</span><span class="c1">// @Tags sign 创建接口
</span><span class="c1">// @ID /sn/create
</span><span class="c1">// @Accept  json
</span><span class="c1">// @Produce  json
</span><span class="c1">// @Param name query string true &#34;名称&#34;
</span><span class="c1">// @Param price query string true &#34;价格&#34;
</span><span class="c1">// @Success 200 {object} middleware.Response{data=dto.ApiOutput} &#34;success&#34;
</span><span class="c1">// @Router /sn/create [get]
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">sign</span> <span class="nx">Controller</span><span class="p">)</span> <span class="nf">Create</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">ts</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">FormatInt</span><span class="p">(</span><span class="nx">public</span><span class="p">.</span><span class="nf">GetTimeUnix</span><span class="p">(),</span> <span class="mi">10</span><span class="p">)</span>

	<span class="nx">params</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">dto</span><span class="p">.</span><span class="nx">ApiUpdateInput</span><span class="p">{}</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">params</span><span class="p">.</span><span class="nf">BindValueParam</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">middleware</span><span class="p">.</span><span class="nf">ResponseError</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="mi">10001</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">paramsSign</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">Form</span>
	<span class="nx">paramsSign</span><span class="p">[</span><span class="s">&#34;ts&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="nx">ts</span><span class="p">}</span>

	<span class="nx">data</span> <span class="o">:=</span> <span class="nx">dto</span><span class="p">.</span><span class="nx">ApiOutput</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span>  <span class="nx">params</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span>
		<span class="nx">Price</span><span class="p">:</span> <span class="nx">params</span><span class="p">.</span><span class="nx">Price</span><span class="p">,</span>
		<span class="nx">Ts</span><span class="p">:</span>    <span class="nx">ts</span><span class="p">,</span>
		<span class="nx">Sn</span><span class="p">:</span>    <span class="nx">public</span><span class="p">.</span><span class="nf">CreateSign</span><span class="p">(</span><span class="nx">paramsSign</span><span class="p">),</span>
	<span class="p">}</span>
	<span class="nx">middleware</span><span class="p">.</span><span class="nf">ResponseSuccess</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h4 id="22-数据传输-dtoapigo">2.2 数据传输 dto.api.go</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="err">#</span><span class="o">/</span><span class="nx">sn</span><span class="o">/</span><span class="nx">create</span> <span class="nx">的输入仅允许两个参数</span>
<span class="kd">type</span> <span class="nx">ApiUpdateInput</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// 这里validate 代表通过validator.v10验证自定义规则 test_tag,默认规则 required 表示必传字段
</span><span class="c1"></span>	<span class="nx">Name</span> <span class="kt">string</span>		<span class="s">`json:&#34;name&#34; form:&#34;name&#34; comment:&#34;名称&#34; example:&#34;abcdef&#34; validate:&#34;required,test_tag&#34;`</span>
    <span class="c1">// 这里仅验证最小值0
</span><span class="c1"></span>	<span class="nx">Price</span> <span class="kt">int</span>	<span class="s">`json:&#34;price&#34; form:&#34;price&#34; comment:&#34;价格&#34; example:&#34;10&#34; validate:&#34;required,min=0&#34;`</span>
<span class="p">}</span>

<span class="c1">// 绑定结构体
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">param</span> <span class="o">*</span><span class="nx">ApiUpdateInput</span><span class="p">)</span> <span class="nf">BindValueParam</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span>  <span class="p">{</span>
	<span class="k">return</span> <span class="nx">public</span><span class="p">.</span><span class="nf">DefaultGetValidParams</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="nx">param</span><span class="p">)</span>
<span class="p">}</span>

<span class="err">#</span> <span class="nx">另外output结构体</span><span class="p">,</span><span class="nx">这里不需要验证器</span>
<span class="kd">type</span> <span class="nx">ApiOutput</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span> <span class="kt">string</span>
	<span class="nx">Price</span> <span class="kt">int</span>
	<span class="nx">Ts</span> <span class="kt">string</span>
	<span class="nx">Sn</span> <span class="kt">string</span>
<span class="p">}</span>


<span class="kd">type</span> <span class="nx">ApiAddInput</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span> <span class="kt">string</span> <span class="s">`json:&#34;name&#34; form:&#34;name&#34; comment:&#34;名称&#34; example:&#34;abc&#34; validate:&#34;required,test_tag,max=24,min=6&#34;`</span>
	<span class="nx">Price</span> <span class="kt">int</span> <span class="s">`json:&#34;price&#34; form:&#34;price&#34; comment:&#34;价格&#34; example:&#34;abc&#34;  validate:&#34;required,min=0&#34;`</span>
	<span class="nx">Ts</span> <span class="kt">string</span> <span class="s">`json:&#34;ts&#34; form:&#34;ts&#34; comment:&#34;有效期&#34; example:&#34;&#34; validate:&#34;required,min=1&#34;`</span>
	<span class="nx">Sn</span> <span class="kt">string</span> <span class="s">`json:&#34;sn&#34; form:&#34;sn&#34; comment:&#34;签名&#34; example:&#34;&#34; validate:&#34;required,min=32,max=32&#34;`</span>
<span class="p">}</span>

<span class="c1">// 绑定结构体
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">param</span> <span class="o">*</span><span class="nx">ApiAddInput</span><span class="p">)</span> <span class="nf">BindValueParam</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span>  <span class="p">{</span>
	<span class="k">return</span> <span class="nx">public</span><span class="p">.</span><span class="nf">DefaultGetValidParams</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="nx">param</span><span class="p">)</span>
<span class="p">}</span>


</code></pre></div><h4 id="23-publicvalidatorgo-调用shouldbind-验证器-和翻译器">2.3 public/validator.go 调用shouldbind ,验证器 和翻译器</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">public</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
	<span class="nx">ut</span> <span class="s">&#34;github.com/go-playground/universal-translator&#34;</span>
	<span class="s">&#34;github.com/go-playground/validator/v10&#34;</span>
	<span class="s">&#34;github.com/pkg/errors&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/config&#34;</span>
	<span class="s">&#34;strings&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">DefaultGetValidParams</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">params</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">ShouldBind</span><span class="p">(</span><span class="nx">params</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="c1">// 获取验证器
</span><span class="c1"></span>	<span class="nx">valid</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">GetValidator</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="c1">// 获取翻译器
</span><span class="c1"></span>	<span class="nx">trans</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">GetTranslate</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="nx">err</span> <span class="p">=</span> <span class="nx">valid</span><span class="p">.</span><span class="nf">Struct</span><span class="p">(</span><span class="nx">params</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">errs</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="nx">validator</span><span class="p">.</span><span class="nx">ValidationErrors</span><span class="p">)</span>
		<span class="nx">sliceErrs</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{}</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span><span class="k">range</span> <span class="nx">errs</span> <span class="p">{</span>
			<span class="nx">sliceErrs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">sliceErrs</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nf">Translate</span><span class="p">(</span><span class="nx">trans</span><span class="p">))</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">sliceErrs</span><span class="p">,</span> <span class="s">&#34;,&#34;</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// 获取验证器
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GetValidator</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">validator</span><span class="p">.</span><span class="nx">Validate</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">ValidatorKey</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;未设置验证器&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">validate</span> <span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">val</span><span class="p">.(</span><span class="o">*</span><span class="nx">validator</span><span class="p">.</span><span class="nx">Validate</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;获取验证器失败&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">validate</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// 获取翻译器
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GetTranslate</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">ut</span><span class="p">.</span><span class="nx">Translator</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">trans</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">TranslatorKey</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;未设置翻译器&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">translator</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">trans</span><span class="p">.(</span><span class="nx">ut</span><span class="p">.</span><span class="nx">Translator</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;获取翻译器失败&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">translator</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

</code></pre></div><h3 id="3-中间件-middlewarevalidatorgo">3. 中间件 middleware/validator.go</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">middleware</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
	<span class="s">&#34;github.com/go-playground/locales/en&#34;</span>
	<span class="s">&#34;github.com/go-playground/locales/zh&#34;</span>
	<span class="nx">ut</span> <span class="s">&#34;github.com/go-playground/universal-translator&#34;</span>
	<span class="s">&#34;github.com/go-playground/validator/v10&#34;</span>
	<span class="nx">en_translations</span> <span class="s">&#34;github.com/go-playground/validator/v10/translations/en&#34;</span>
	<span class="nx">zh_translations</span> <span class="s">&#34;github.com/go-playground/validator/v10/translations/zh&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/config&#34;</span>
	<span class="s">&#34;reflect&#34;</span>
	<span class="s">&#34;regexp&#34;</span>
<span class="p">)</span>


<span class="c1">// 设置验证器+翻译器
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">TranslationMiddleware</span><span class="p">()</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">HandlerFunc</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// 创建验证器实例
</span><span class="c1"></span>		<span class="nx">val</span> <span class="o">:=</span> <span class="nx">validator</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

		<span class="c1">// 设置支持的语言
</span><span class="c1"></span>		<span class="nx">en</span> <span class="o">:=</span> <span class="nx">en</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
		<span class="nx">zh</span> <span class="o">:=</span> <span class="nx">zh</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
		<span class="c1">// 创建翻译器, 支持zh,en两种
</span><span class="c1"></span>		<span class="nx">uni</span> <span class="o">:=</span> <span class="nx">ut</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">zh</span><span class="p">,</span> <span class="nx">zh</span><span class="p">,</span><span class="nx">en</span><span class="p">)</span>
		<span class="c1">// 根据参数取翻译器实例
</span><span class="c1"></span>		<span class="nx">locale</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">DefaultQuery</span><span class="p">(</span><span class="s">&#34;locale&#34;</span><span class="p">,</span><span class="s">&#34;zh&#34;</span><span class="p">)</span>
		<span class="c1">// 获取默认的f.fallback
</span><span class="c1"></span>		<span class="nx">trans</span> <span class="p">,</span><span class="nx">_</span> <span class="o">:=</span> <span class="nx">uni</span><span class="p">.</span><span class="nf">GetTranslator</span><span class="p">(</span><span class="nx">locale</span><span class="p">)</span>

		<span class="c1">// 翻译器注册到验证器
</span><span class="c1"></span>		<span class="k">switch</span> <span class="nx">locale</span> <span class="p">{</span>
		<span class="k">case</span> <span class="s">&#34;en&#34;</span><span class="p">:</span>
			<span class="nx">_</span> <span class="p">=</span> <span class="nx">en_translations</span><span class="p">.</span><span class="nf">RegisterDefaultTranslations</span><span class="p">(</span><span class="nx">val</span><span class="p">,</span><span class="nx">trans</span><span class="p">)</span>
			<span class="nx">val</span><span class="p">.</span><span class="nf">RegisterTagNameFunc</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">fld</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">StructField</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">fld</span><span class="p">.</span><span class="nx">Tag</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;en_comment&#34;</span><span class="p">)</span>
			<span class="p">})</span>
			<span class="k">break</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="nx">_</span> <span class="p">=</span> <span class="nx">zh_translations</span><span class="p">.</span><span class="nf">RegisterDefaultTranslations</span><span class="p">(</span><span class="nx">val</span><span class="p">,</span><span class="nx">trans</span><span class="p">)</span>
			<span class="nx">val</span><span class="p">.</span><span class="nf">RegisterTagNameFunc</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">fld</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">StructField</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">fld</span><span class="p">.</span><span class="nx">Tag</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;comment&#34;</span><span class="p">)</span>
			<span class="p">})</span>

			<span class="c1">// 自定义的验证器
</span><span class="c1"></span>			<span class="nx">val</span><span class="p">.</span><span class="nf">RegisterValidation</span><span class="p">(</span><span class="s">&#34;test_tag&#34;</span><span class="p">,</span><span class="kd">func</span><span class="p">(</span><span class="nx">fl</span> <span class="nx">validator</span><span class="p">.</span><span class="nx">FieldLevel</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
				<span class="nx">matched</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MatchString</span><span class="p">(</span><span class="s">`^[_0-9a-zA-Z]{6,24}$`</span><span class="p">,</span><span class="nx">fl</span><span class="p">.</span><span class="nf">Field</span><span class="p">().</span><span class="nf">String</span><span class="p">())</span>
				<span class="k">return</span> <span class="nx">matched</span>
			<span class="p">})</span>

			<span class="c1">// 自定义的翻译器
</span><span class="c1"></span>			<span class="nx">val</span><span class="p">.</span><span class="nf">RegisterTranslation</span><span class="p">(</span><span class="s">&#34;test_tag&#34;</span><span class="p">,</span><span class="nx">trans</span><span class="p">,</span><span class="kd">func</span><span class="p">(</span><span class="nx">ut</span> <span class="nx">ut</span><span class="p">.</span><span class="nx">Translator</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">ut</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;test_tag&#34;</span><span class="p">,</span><span class="s">&#34;{0} 填写不正确,仅允许数字字母下划线,长度大于6小于24&#34;</span><span class="p">,</span><span class="kc">true</span>  <span class="p">)</span>
			<span class="p">},</span><span class="kd">func</span><span class="p">(</span><span class="nx">ut</span> <span class="nx">ut</span><span class="p">.</span><span class="nx">Translator</span><span class="p">,</span> <span class="nx">fe</span> <span class="nx">validator</span><span class="p">.</span><span class="nx">FieldError</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
				<span class="nx">t</span> <span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">ut</span><span class="p">.</span><span class="nf">T</span><span class="p">(</span><span class="s">&#34;test_tag&#34;</span><span class="p">,</span><span class="nx">fe</span><span class="p">.</span><span class="nf">Field</span><span class="p">())</span>
				<span class="k">return</span> <span class="nx">t</span>
			<span class="p">})</span>
			<span class="k">break</span>
		<span class="p">}</span>

		<span class="c1">// 设置翻译器和验证器
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">TranslatorKey</span><span class="p">,</span><span class="nx">trans</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">ValidatorKey</span><span class="p">,</span><span class="nx">val</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h3 id="4-中间件-middlewaresigngo">4. 中间件 middleware/sign.go</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">middleware</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
	<span class="s">&#34;github.com/pkg/errors&#34;</span>
	<span class="nx">config2</span> <span class="s">&#34;github.com/zhangzw001/learnGin/config&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/public&#34;</span>
	<span class="s">&#34;net/url&#34;</span>
	<span class="s">&#34;strconv&#34;</span>
<span class="p">)</span>



<span class="kd">func</span> <span class="nf">SignMiddleware</span><span class="p">()</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">HandlerFunc</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">method</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">Method</span>
		<span class="kd">var</span> <span class="nx">ts</span> <span class="kt">int64</span>
		<span class="kd">var</span> <span class="nx">sn</span> <span class="kt">string</span>
		<span class="kd">var</span> <span class="nx">req</span> <span class="nx">url</span><span class="p">.</span><span class="nx">Values</span>

		<span class="k">if</span> <span class="nx">method</span> <span class="o">==</span> <span class="s">&#34;GET&#34;</span> <span class="p">{</span>
			<span class="nx">req</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nf">Query</span><span class="p">()</span>
			<span class="nx">sn</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;sn&#34;</span><span class="p">)</span>
			<span class="nx">ts</span><span class="p">,</span> <span class="nx">_</span>  <span class="p">=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">ParseInt</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;ts&#34;</span><span class="p">),</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>

		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">method</span> <span class="o">==</span> <span class="s">&#34;POST&#34;</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nf">ParseForm</span><span class="p">()</span>
			<span class="nx">req</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">PostForm</span>
			<span class="nx">sn</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">PostForm</span><span class="p">(</span><span class="s">&#34;sn&#34;</span><span class="p">)</span>
			<span class="nx">ts</span><span class="p">,</span> <span class="nx">_</span>  <span class="p">=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">ParseInt</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">PostForm</span><span class="p">(</span><span class="s">&#34;ts&#34;</span><span class="p">),</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nf">ResponseError</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="mi">10000</span><span class="p">,</span><span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;Illegal requests&#34;</span><span class="p">))</span>
			<span class="k">return</span>
		<span class="p">}</span>

		<span class="nx">exp</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">ParseInt</span><span class="p">(</span><span class="nx">config2</span><span class="p">.</span><span class="nx">ApiExpiry</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>

		<span class="c1">// 验证过期时间
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">ts</span> <span class="p">&gt;</span> <span class="nx">public</span><span class="p">.</span><span class="nf">GetTimeUnix</span><span class="p">()</span> <span class="o">||</span> <span class="nx">public</span><span class="p">.</span><span class="nf">GetTimeUnix</span><span class="p">()</span> <span class="o">-</span> <span class="nx">ts</span> <span class="o">&gt;=</span> <span class="nx">exp</span> <span class="p">{</span>
			<span class="nf">ResponseError</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="mi">10001</span><span class="p">,</span><span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;Ts Error&#34;</span><span class="p">))</span>
			<span class="k">return</span>
		<span class="p">}</span>

		<span class="c1">// 验证签名
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">sn</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="o">||</span> <span class="nx">sn</span> <span class="o">!=</span> <span class="nx">public</span><span class="p">.</span><span class="nf">CreateSign</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span> <span class="p">{</span>
			<span class="nf">ResponseError</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="mi">10002</span><span class="p">,</span><span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;Sn Error&#34;</span><span class="p">))</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="c1">//
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h3 id="5-统一的返回参-middlewareresponsego">5. 统一的返回参 middleware/response.go</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">middleware</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;encoding/json&#34;</span>
	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">ResponseCode</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">SuccessCode</span> <span class="nx">ResponseCode</span> <span class="p">=</span> <span class="mi">200</span> <span class="o">+</span> <span class="kc">iota</span>
	<span class="nx">StatusCreated</span>
	<span class="nx">StatusAccepted</span>
	<span class="nx">InternalServerError</span> <span class="nx">ResponseCode</span> <span class="p">=</span> <span class="mi">500</span>
	<span class="nx">CustomizeCode</span>           <span class="p">=</span> <span class="mi">1000</span>
	<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Response</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Code</span> <span class="nx">ResponseCode</span> <span class="s">`json:&#34;code&#34;`</span>
	<span class="nx">Msg</span>  <span class="kt">string</span>       <span class="s">`json:&#34;msg&#34;`</span>
	<span class="nx">Data</span> <span class="kd">interface</span><span class="p">{}</span>  <span class="s">`json:&#34;data&#34;`</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">ResponseSuccess</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nx">resp</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Response</span><span class="p">{</span>
		<span class="nx">Code</span><span class="p">:</span> <span class="nx">SuccessCode</span><span class="p">,</span>
		<span class="nx">Msg</span><span class="p">:</span>  <span class="s">&#34;ok&#34;</span><span class="p">,</span>
		<span class="nx">Data</span><span class="p">:</span> <span class="nx">data</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="nx">resp</span><span class="p">)</span>
	<span class="nx">response</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="nx">resp</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;response&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">response</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">ResponseError</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">code</span> <span class="nx">ResponseCode</span><span class="p">,</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">resp</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Response</span><span class="p">{</span>
		<span class="nx">Code</span><span class="p">:</span> <span class="nx">code</span><span class="p">,</span>
		<span class="nx">Msg</span><span class="p">:</span>  <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">(),</span>
		<span class="nx">Data</span><span class="p">:</span> <span class="s">&#34;&#34;</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="nx">resp</span><span class="p">)</span>
	<span class="nx">response</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="nx">resp</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;response&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">response</span><span class="p">))</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">AbortWithError</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><h3 id="6-配置文件-configenvgo">6. 配置文件 config/env.go</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">config</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">PORT</span>      <span class="p">=</span> <span class="s">&#34;:8000&#34;</span>
	<span class="nx">AppName</span>   <span class="p">=</span> <span class="s">&#34;test&#34;</span>
	<span class="nx">AppSecret</span> <span class="p">=</span> <span class="s">&#34;test.123&#34;</span>
	<span class="nx">ApiExpiry</span> <span class="p">=</span> <span class="s">&#34;1200&#34;</span>

	<span class="nx">LogFilePath</span> <span class="p">=</span> <span class="s">&#34;logs&#34;</span>
	<span class="nx">LogFileName</span> <span class="p">=</span> <span class="s">&#34;gin-logger.log&#34;</span>

	<span class="nx">ValidatorKey</span>  <span class="p">=</span> <span class="s">&#34;ValidatorKey&#34;</span>
	<span class="nx">TranslatorKey</span> <span class="p">=</span> <span class="s">&#34;TranslatorKey&#34;</span>
<span class="p">)</span>
</code></pre></div><h3 id="maingo">main.go</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/config&#34;</span>
	<span class="s">&#34;github.com/zhangzw001/learnGin/routers&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

	<span class="nx">gin</span><span class="p">.</span><span class="nf">SetMode</span><span class="p">(</span><span class="nx">gin</span><span class="p">.</span><span class="nx">DebugMode</span><span class="p">)</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">Default</span><span class="p">()</span>
	<span class="nx">routers</span><span class="p">.</span><span class="nf">InitRouter</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
	<span class="nx">e</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">PORT</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Google资深工程师深度讲解Go语言 Elastic简单使用</title>
			<link>https://www.ngirl.xyz/golang/google%E8%B5%84%E6%B7%B1%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%B7%B1%E5%BA%A6%E8%AE%B2%E8%A7%A3go%E8%AF%AD%E8%A8%80-elastic%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</link>
			<pubDate>Wed, 06 Jan 2021 14:27:27 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/google%E8%B5%84%E6%B7%B1%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%B7%B1%E5%BA%A6%E8%AE%B2%E8%A7%A3go%E8%AF%AD%E8%A8%80-elastic%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</guid>
			<description></description>
			<content type="html"><![CDATA[<h3 id="elastic-检查查询">elastic 检查查询</h3>
<pre><code># 查询 女, 已购房 年龄小于22岁
http://172.16.76.220:9200/crawler/youyuan/_search?q=女  AND 已购房  AND Payload.Age:(&lt;22)
</code></pre>]]></content>
		</item>
		
		<item>
			<title>Google资深工程师深度讲解Go语言 单任务爬虫</title>
			<link>https://www.ngirl.xyz/golang/google%E8%B5%84%E6%B7%B1%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%B7%B1%E5%BA%A6%E8%AE%B2%E8%A7%A3go%E8%AF%AD%E8%A8%80-%E5%8D%95%E4%BB%BB%E5%8A%A1%E7%88%AC%E8%99%AB/</link>
			<pubDate>Mon, 21 Dec 2020 18:03:36 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/google%E8%B5%84%E6%B7%B1%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%B7%B1%E5%BA%A6%E8%AE%B2%E8%A7%A3go%E8%AF%AD%E8%A8%80-%E5%8D%95%E4%BB%BB%E5%8A%A1%E7%88%AC%E8%99%AB/</guid>
			<description>&lt;p&gt;由于教程的代码在zhenai.com更新之后无法访问,所以记录下代码改动&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>由于教程的代码在zhenai.com更新之后无法访问,所以记录下代码改动</p>
<h3 id="问题说明">问题说明</h3>
<p>这里在首页和城市列表页访问是没有问题的, curl请求也是正常, 但是当请求到用户信息的时候, 是需要UA 和cookie的
没有UA 会提示403, 没有cookie会提示 202</p>
<h3 id="fetchergo-代码">fetcher.go 代码</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">fetcher</span>

<span class="kn">import</span> <span class="p">(</span>
 <span class="s">&#34;bufio&#34;</span>
 <span class="s">&#34;fmt&#34;</span>
 <span class="s">&#34;golang.org/x/net/html/charset&#34;</span>
 <span class="s">&#34;golang.org/x/text/encoding&#34;</span>
 <span class="s">&#34;golang.org/x/text/encoding/unicode&#34;</span>
 <span class="s">&#34;golang.org/x/text/transform&#34;</span>
 <span class="s">&#34;io/ioutil&#34;</span>
 <span class="s">&#34;log&#34;</span>
 <span class="s">&#34;net/http&#34;</span>
 <span class="s">&#34;strings&#34;</span>
<span class="p">)</span>


<span class="kd">func</span> <span class="nf">Fetch</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
 <span class="nx">client</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">http</span><span class="p">.</span><span class="nx">Client</span><span class="p">{}</span>
 <span class="nx">newUrl</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Replace</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span> <span class="s">&#34;http://&#34;</span><span class="p">,</span><span class="s">&#34;https://&#34;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
 <span class="nx">request</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">NewRequest</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">MethodGet</span><span class="p">,</span> <span class="nx">newUrl</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
 <span class="p">}</span>
 <span class="c1">//添加header
</span><span class="c1"></span> <span class="nx">request</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Referer&#34;</span><span class="p">,</span><span class="s">&#34;http://www.zhenai.com/&#34;</span><span class="p">)</span>
 <span class="nx">request</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;User-Agent&#34;</span><span class="p">,</span><span class="s">&#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&#34;</span><span class="p">)</span>
 <span class="c1">//这里cookie只有1分钟有效期
</span><span class="c1"></span> <span class="nx">request</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;cookie&#34;</span><span class="p">,</span><span class="s">&#34;FSSBBIl1UgzbN7NO=53ZIxjnyRAeDyH5t9pg7cBA7QAYBxvaF7jmWYAZu2.CGt7mB9u9LeMhKl8ljte21zs7CWozraQ0E5VOTTi2KxSa; FSSBBIl1UgzbN7NP=5U5rnkYdGQG7qqqmCfWUuTapalzEu3wBuwQIl47nXp0HkSYoWXO9YSlekNkkwawdb3zC2rSWIE1_qIWRw3n3..NPhTqKwJXHroqsoGBqaeo_dgsIn64FK2YWZU6Y6L_l6d6tC7YBN8SMAPRcMqpmfS_9Jw.J8tXrIUZ6bUSeDufFFL1lNf8p4Om5i4P2teK4H1gnsMEldbBc9MLc1xhrJ7yLwLZhXr_mi2AhSHpshGFF7BkPzO_5ye_HaYME37Ukhc9MqOaqdytUs.ZebVaXEo7; Hm_lvt_2c8ad67df9e787ad29dbd54ee608f5d2=1608543698; Hm_lpvt_2c8ad67df9e787ad29dbd54ee608f5d2=1608544780; sid=d399176c-21e3-4e91-b550-fa8656de10e1; _exid=Fj3xNob61luAF5gXz5MAJq5CxrtoI86y%2Bqoc4YZ%2F64joUS0XSSIaALTyeW81WLbDLc0Pzw0kcM1r%2FGU1gm%2F2lA%3D%3D; ec=DH5wblNm-1608543720671-6a5cbb1e341df-781494537; _efmdata=HZvSyojNYRIMPbor%2FAzLk%2B5xwF4NLHTxU22OynbdfqEpXG7eNyAO1kHkZ%2FWDHgT7hGdqxoGwjueLMevvIv%2FF3upAu3SmFFc2zAJsHFMNjAc%3D&#34;</span><span class="p">)</span>

 <span class="nx">resp</span> <span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="nx">request</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
 <span class="p">}</span>
 <span class="k">defer</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
 <span class="k">if</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">StatusCode</span> <span class="o">!=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;wrong status code: %d&#34;</span><span class="p">,</span><span class="nx">resp</span><span class="p">.</span><span class="nx">StatusCode</span><span class="p">)</span>
 <span class="p">}</span>

 <span class="nx">bodyReader</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
 <span class="nx">e</span> <span class="o">:=</span> <span class="nf">determineEncoding</span><span class="p">(</span><span class="nx">bodyReader</span><span class="p">)</span>
 <span class="nx">uft8Reader</span> <span class="o">:=</span> <span class="nx">transform</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">bodyReader</span><span class="p">,</span><span class="nx">e</span><span class="p">.</span><span class="nf">NewDecoder</span><span class="p">())</span>
 <span class="k">return</span>  <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadAll</span><span class="p">(</span><span class="nx">uft8Reader</span><span class="p">)</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="nf">determineEncoding</span><span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">bufio</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">Encoding</span> <span class="p">{</span>
 <span class="nx">bytes</span> <span class="p">,</span><span class="nx">err</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Peek</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Fetcher error : %v&#34;</span><span class="p">,</span><span class="nx">err</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">unicode</span><span class="p">.</span><span class="nx">UTF8</span>
 <span class="p">}</span>

 <span class="nx">e</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">charset</span><span class="p">.</span><span class="nf">DetermineEncoding</span><span class="p">(</span><span class="nx">bytes</span><span class="p">,</span><span class="s">&#34;&#34;</span><span class="p">)</span>
 <span class="k">return</span> <span class="nx">e</span>
<span class="p">}</span>

</code></pre></div><h3 id="profile_testgo-测试一下">profile_test.go 测试一下</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">parser</span>

<span class="kn">import</span> <span class="p">(</span>
 <span class="s">&#34;learngo_crawler/fetcher&#34;</span>
 <span class="s">&#34;testing&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">TestParseProfile</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
 <span class="nx">contents</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fetcher</span><span class="p">.</span><span class="nf">Fetch</span><span class="p">(</span><span class="s">&#34;https://album.zhenai.com/u/1715998969&#34;</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
 <span class="p">}</span>
 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s\n&#34;</span><span class="p">,</span><span class="nx">contents</span><span class="p">)</span>
 <span class="nf">ParseProfile</span><span class="p">(</span><span class="nx">contents</span><span class="p">)</span>
<span class="p">}</span>


</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Google资深工程师深度讲解Go语言-广度优先算法学习-迷宫</title>
			<link>https://www.ngirl.xyz/golang/google%E8%B5%84%E6%B7%B1%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%B7%B1%E5%BA%A6%E8%AE%B2%E8%A7%A3go%E8%AF%AD%E8%A8%80-%E5%B9%BF%E5%BA%A6%E6%B7%B1%E5%BA%A6%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E8%BF%B7%E5%AE%AB/</link>
			<pubDate>Fri, 18 Dec 2020 18:00:44 +0800</pubDate>
			
			<guid>https://www.ngirl.xyz/golang/google%E8%B5%84%E6%B7%B1%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%B7%B1%E5%BA%A6%E8%AE%B2%E8%A7%A3go%E8%AF%AD%E8%A8%80-%E5%B9%BF%E5%BA%A6%E6%B7%B1%E5%BA%A6%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E8%BF%B7%E5%AE%AB/</guid>
			<description>这里学习了Google吱声工程师深度讲解go语言-迷宫广度优先算法以记录
算法说明 图源: 图解迷宫算法（广度优先遍历)
首先看一张迷宫图, 左右黄色0 表示起始点, 0 表示可以行走, 1表示墙体 迷宫的广度优先算法的意思是, 可以通过0 发现四个方向的1, 然后在通过四个1 发现所有的2, 所有的2探索完 , 在探索3&amp;hellip; 以此类推&amp;hellip; 这里每个点都有三种状态:  未发现 已发现未探索 已探索  最终我们能探索到这样的结果图: 下面是详细代码 代码结构 ── maze ├── maze.go └── maze.in maze.in文件 6 5 0 1 0 0 0 0 0 0 1 0 0 1 0 1 0 1 1 1 0 0 0 1 0 0 1 0 1 0 0 0 maze.go package main import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;os&amp;#34; ) /* maze.</description>
			<content type="html"><![CDATA[<p>这里学习了Google吱声工程师深度讲解go语言-迷宫广度优先算法以记录</p>
<!-- more -->
<h3 id="算法说明">算法说明</h3>
<p>图源: <a href="https://www.pianshen.com/article/8849857777/">图解迷宫算法（广度优先遍历)</a></p>
<h4 id="首先看一张迷宫图-左右黄色0-表示起始点-0-表示可以行走-1表示墙体">首先看一张迷宫图, 左右黄色0 表示起始点, 0 表示可以行走, 1表示墙体</h4>
<p><img src="//zhangzw001.github.io/images/golang/maze-01.png" alt=""></p>
<p>迷宫的广度优先算法的意思是, 可以通过0 发现四个方向的1, 然后在通过四个1 发现所有的2, 所有的2探索完 , 在探索3&hellip;
<img src="//zhangzw001.github.io/images/golang/maze-02.png" alt=""></p>
<p>以此类推&hellip;
<img src="//zhangzw001.github.io/images/golang/maze-03.png" alt=""></p>
<h4 id="这里每个点都有三种状态">这里每个点都有三种状态:</h4>
<ul>
<li>未发现</li>
<li>已发现未探索</li>
<li>已探索</li>
</ul>
<p>最终我们能探索到这样的结果图:
<img src="//zhangzw001.github.io/images/golang/maze-04.png" alt=""></p>
<h3 id="下面是详细代码">下面是详细代码</h3>
<h4 id="代码结构">代码结构</h4>
<pre><code>── maze
   ├── maze.go
   └── maze.in
</code></pre><h4 id="mazein文件">maze.in文件</h4>
<pre><code>6 5
0 1 0 0 0
0 0 0 1 0
0 1 0 1 0
1 1 1 0 0
0 1 0 0 1
0 1 0 0 0
</code></pre><h4 id="mazego">maze.go</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
 <span class="s">&#34;fmt&#34;</span>
 <span class="s">&#34;log&#34;</span>
 <span class="s">&#34;os&#34;</span>
<span class="p">)</span>

<span class="cm">/*
</span><span class="cm">maze.in
</span><span class="cm">6 5
</span><span class="cm">0 1 0 0 0
</span><span class="cm">0 0 0 1 0
</span><span class="cm">0 1 0 1 0
</span><span class="cm">1 1 1 0 0
</span><span class="cm">0 1 0 0 1
</span><span class="cm">0 1 0 0 0
</span><span class="cm">
</span><span class="cm">- 未探索
</span><span class="cm">- 已发现未探索
</span><span class="cm">- 已探索
</span><span class="cm">
</span><span class="cm">- 广度优先算法 -&gt; 把所有的1全部探索完,再探索2
</span><span class="cm">*/</span>

<span class="kd">func</span> <span class="nf">readMaze</span><span class="p">(</span><span class="nx">filename</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
 <span class="nx">file</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
 <span class="p">}</span>
 <span class="k">defer</span> <span class="nx">file</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

 <span class="kd">var</span> <span class="nx">row</span><span class="p">,</span> <span class="nx">col</span> <span class="kt">int</span>
 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fscanf</span><span class="p">(</span><span class="nx">file</span><span class="p">,</span> <span class="s">&#34;%d %d&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">row</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">col</span><span class="p">)</span>
 <span class="nx">maze</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">row</span><span class="p">)</span>
 <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">maze</span> <span class="p">{</span>
  <span class="nx">maze</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">col</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">maze</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fscanf</span><span class="p">(</span><span class="nx">file</span><span class="p">,</span> <span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">maze</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">])</span>
  <span class="p">}</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="nx">maze</span>

<span class="p">}</span>

<span class="kd">type</span> <span class="nx">point</span> <span class="kd">struct</span> <span class="p">{</span>
 <span class="nx">i</span> <span class="kt">int</span>
 <span class="nx">j</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">dirs</span> <span class="p">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="nx">point</span><span class="p">{</span>
 <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="c1">//上
</span><span class="c1"></span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">},</span> <span class="c1">//左
</span><span class="c1"></span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>  <span class="c1">//下
</span><span class="c1"></span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>  <span class="c1">//右
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">//用值类型, 返回新的point
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">point</span><span class="p">)</span> <span class="nf">add</span><span class="p">(</span><span class="nx">po</span> <span class="nx">point</span><span class="p">)</span> <span class="nx">point</span> <span class="p">{</span>
 <span class="k">return</span> <span class="nx">point</span><span class="p">{</span><span class="nx">p</span><span class="p">.</span><span class="nx">i</span> <span class="o">+</span> <span class="nx">po</span><span class="p">.</span><span class="nx">i</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">j</span> <span class="o">+</span> <span class="nx">po</span><span class="p">.</span><span class="nx">j</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">point</span><span class="p">)</span> <span class="nf">notOver</span><span class="p">(</span><span class="nx">grid</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
 <span class="c1">//是否越界
</span><span class="c1"></span> <span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">p</span><span class="p">.</span><span class="nx">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">grid</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">false</span>
 <span class="p">}</span>
 <span class="c1">//if p.j &lt; 0 || p.j &gt;= len(grid[p.i]) {
</span><span class="c1"></span> <span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">j</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">p</span><span class="p">.</span><span class="nx">j</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">false</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">point</span><span class="p">)</span> <span class="nf">at</span><span class="p">(</span><span class="nx">grid</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>

 <span class="k">if</span> <span class="p">!</span><span class="nx">p</span><span class="p">.</span><span class="nf">notOver</span><span class="p">(</span><span class="nx">grid</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">false</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="nx">grid</span><span class="p">[</span><span class="nx">p</span><span class="p">.</span><span class="nx">i</span><span class="p">][</span><span class="nx">p</span><span class="p">.</span><span class="nx">j</span><span class="p">],</span> <span class="kc">true</span>

<span class="p">}</span>
<span class="kd">func</span> <span class="nf">walk</span><span class="p">(</span><span class="nx">maze</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">end</span> <span class="nx">point</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
 <span class="nx">steps</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">maze</span><span class="p">))</span>
 <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">steps</span> <span class="p">{</span>
  <span class="nx">steps</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">maze</span><span class="p">[</span><span class="nx">i</span><span class="p">]))</span>
 <span class="p">}</span>
 <span class="c1">//队列
</span><span class="c1"></span> <span class="nx">Q</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">point</span><span class="p">{</span><span class="nx">start</span><span class="p">}</span>

 <span class="c1">//开始探索
</span><span class="c1"></span> <span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">Q</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
  <span class="c1">// 探索头
</span><span class="c1"></span>  <span class="nx">cur</span> <span class="o">:=</span> <span class="nx">Q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="nx">Q</span> <span class="p">=</span> <span class="nx">Q</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

  <span class="c1">// 终端
</span><span class="c1"></span>  <span class="k">if</span> <span class="nx">cur</span> <span class="o">==</span> <span class="nx">end</span> <span class="p">{</span>
   <span class="k">break</span>
  <span class="p">}</span>

  <span class="c1">// 探索
</span><span class="c1"></span>  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">dir</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dirs</span> <span class="p">{</span>
   <span class="c1">//得到下一个点的坐标
</span><span class="c1"></span>   <span class="nx">next</span> <span class="o">:=</span> <span class="nx">cur</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">dir</span><span class="p">)</span>

   <span class="c1">// maze at next is 0
</span><span class="c1"></span>   <span class="c1">// and steps at next is 0
</span><span class="c1"></span>   <span class="c1">// and next != start
</span><span class="c1"></span>   <span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">next</span><span class="p">.</span><span class="nf">at</span><span class="p">(</span><span class="nx">maze</span><span class="p">)</span>
   <span class="c1">// 撞墙
</span><span class="c1"></span>   <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="o">||</span> <span class="nx">val</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
    <span class="k">continue</span>
   <span class="p">}</span>

   <span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">next</span><span class="p">.</span><span class="nf">at</span><span class="p">(</span><span class="nx">steps</span><span class="p">)</span>
   <span class="c1">// 不等于0 说明走过的
</span><span class="c1"></span>   <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="o">||</span> <span class="nx">val</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="k">continue</span>
   <span class="p">}</span>

   <span class="c1">// 原点
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">next</span> <span class="o">==</span> <span class="nx">start</span> <span class="p">{</span>
    <span class="k">continue</span>
   <span class="p">}</span>

   <span class="c1">//当前步骤数
</span><span class="c1"></span>   <span class="nx">curSteps</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">cur</span><span class="p">.</span><span class="nf">at</span><span class="p">(</span><span class="nx">steps</span><span class="p">)</span>
   <span class="nx">steps</span><span class="p">[</span><span class="nx">next</span><span class="p">.</span><span class="nx">i</span><span class="p">][</span><span class="nx">next</span><span class="p">.</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">curSteps</span> <span class="o">+</span> <span class="mi">1</span>

   <span class="nx">Q</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">Q</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span>
  <span class="p">}</span>
 <span class="p">}</span>

 <span class="k">return</span> <span class="nx">steps</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">walkLine</span><span class="p">(</span><span class="nx">steps</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">end</span> <span class="nx">point</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
 <span class="nx">newTable</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">steps</span><span class="p">))</span>
 <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">newTable</span> <span class="p">{</span>
  <span class="nx">newTable</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">steps</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
 <span class="p">}</span>

 <span class="nx">newTable</span><span class="p">[</span><span class="nx">end</span><span class="p">.</span><span class="nx">i</span><span class="p">][</span><span class="nx">end</span><span class="p">.</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">steps</span><span class="p">[</span><span class="nx">end</span><span class="p">.</span><span class="nx">i</span><span class="p">][</span><span class="nx">end</span><span class="p">.</span><span class="nx">j</span><span class="p">]</span>

 <span class="c1">//这里不需要队列, 因为只会找到一个值
</span><span class="c1"></span> <span class="nx">Q</span> <span class="o">:=</span> <span class="nx">end</span>
 <span class="c1">// 如果不是开头, 就继续找
</span><span class="c1"></span> <span class="k">for</span> <span class="nx">Q</span> <span class="o">!=</span> <span class="nx">start</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">dir</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dirs</span> <span class="p">{</span>
   <span class="c1">//得到下一个点的坐标
</span><span class="c1"></span>   <span class="nx">next</span> <span class="o">:=</span> <span class="nx">Q</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">dir</span><span class="p">)</span>
   <span class="c1">//是否越界
</span><span class="c1"></span>   <span class="k">if</span> <span class="p">!</span><span class="nx">next</span><span class="p">.</span><span class="nf">notOver</span><span class="p">(</span><span class="nx">steps</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">continue</span>
   <span class="p">}</span>
   <span class="c1">// 如果这个[坐标的值]=[当前坐标值]-1, 那就找到了,把这个坐标记录一下, 待会用这个坐标继续探索
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">steps</span><span class="p">[</span><span class="nx">next</span><span class="p">.</span><span class="nx">i</span><span class="p">][</span><span class="nx">next</span><span class="p">.</span><span class="nx">j</span><span class="p">]</span> <span class="o">==</span> <span class="nx">steps</span><span class="p">[</span><span class="nx">Q</span><span class="p">.</span><span class="nx">i</span><span class="p">][</span><span class="nx">Q</span><span class="p">.</span><span class="nx">j</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
    <span class="nx">newTable</span><span class="p">[</span><span class="nx">next</span><span class="p">.</span><span class="nx">i</span><span class="p">][</span><span class="nx">next</span><span class="p">.</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">steps</span><span class="p">[</span><span class="nx">next</span><span class="p">.</span><span class="nx">i</span><span class="p">][</span><span class="nx">next</span><span class="p">.</span><span class="nx">j</span><span class="p">]</span>
    <span class="nx">Q</span> <span class="p">=</span> <span class="nx">next</span>
   <span class="p">}</span>
  <span class="p">}</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="nx">newTable</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;&gt;&gt;&gt;&gt;&gt;&gt; 迷宫图如下:&#34;</span><span class="p">)</span>

 <span class="nx">maze</span> <span class="o">:=</span> <span class="nf">readMaze</span><span class="p">(</span><span class="s">&#34;maze/maze.in&#34;</span><span class="p">)</span>
 <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">row</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">maze</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">val</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">row</span> <span class="p">{</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%3d &#34;</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">()</span>
 <span class="p">}</span>

 <span class="nx">steps</span> <span class="o">:=</span> <span class="nf">walk</span><span class="p">(</span><span class="nx">maze</span><span class="p">,</span> <span class="nx">point</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="nx">point</span><span class="p">{</span><span class="nb">len</span><span class="p">(</span><span class="nx">maze</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">maze</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">})</span>
 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;&gt;&gt;&gt;&gt;&gt;&gt; 探索图如下:&#34;</span><span class="p">)</span>

 <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">row</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">steps</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">val</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">row</span> <span class="p">{</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%3d &#34;</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">()</span>
 <span class="p">}</span>
 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;&gt;&gt;&gt;&gt;&gt;&gt; 行走路线图如下:&#34;</span><span class="p">)</span>
 <span class="nx">newSteps</span> <span class="o">:=</span> <span class="nf">walkLine</span><span class="p">(</span><span class="nx">steps</span><span class="p">,</span> <span class="nx">point</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="nx">point</span><span class="p">{</span><span class="nb">len</span><span class="p">(</span><span class="nx">maze</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">maze</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">})</span>
 <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">row</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">newSteps</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">val</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">row</span> <span class="p">{</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%3d &#34;</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">()</span>
 <span class="p">}</span>
<span class="p">}</span>


</code></pre></div><h4 id="执行结果如下">执行结果如下:</h4>
<pre><code>&gt;&gt;&gt;&gt;&gt;&gt; 迷宫图如下:
  0   1   0   0   0
  0   0   0   1   0
  0   1   0   1   0
  1   1   1   0   0
  0   1   0   0   1
  0   1   0   0   0
&gt;&gt;&gt;&gt;&gt;&gt; 探索图如下:
  0   0   4   5   6
  1   2   3   0   7
  2   0   4   0   8
  0   0   0  10   9
  0   0  12  11   0
  0   0  13  12  13
&gt;&gt;&gt;&gt;&gt;&gt; 行走路线图如下:
  0   0   4   5   6
  1   2   3   0   7
  0   0   0   0   8
  0   0   0  10   9
  0   0   0  11   0
  0   0   0  12  13

</code></pre>]]></content>
		</item>
		
	</channel>
</rss>
