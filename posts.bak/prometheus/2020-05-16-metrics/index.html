<!DOCTYPE html>
<html lang="zh-hans">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#494f5c">
	<meta name="msapplication-TileColor" content="#494f5c">
<meta itemprop="name" content="Prometheus 四大度量指标的了解和应用">
<meta itemprop="description" content="在上一个章节中我们完成了 Prometheus 的基本概念了解和安装，由于考虑到看我博客的估计是开发向的小伙伴居多，因此没有再更深入。而今天本章节将介绍我们开发用的最多的度量指标，并结合实战对 Metrics 进行使用和细节分析。
什么是度量指标  来自维基百科
 度量是指对于一个物体或是事件的某个性质给予一个数字，使其可以和其他物体或是事件的相同性质比较。度量可以是对一物理量（如长度、尺寸或容量等）的估计或测定，也可以是其他较抽象的特质。
简单来讲，也就是数据的量化，形成对应的数据指标。
Prometheus 的指标格式 在 Prometheus 中，我们的指标表示格式如下：
&lt;metric name&gt;{&lt;label name&gt;=&lt;label value&gt;, ...} 主体为指标名称和标签组成：
api_http_requests_total{method=&quot;POST&quot;, handler=&quot;/eddycjy&quot;} 对外提供 metrics 服务 首先创建一个示例项目：
func main() { engine := gin.New() engine.GET(&#34;/hello&#34;, func(c *gin.Context) { c.String(http.StatusOK, &#34;煎鱼&#34;) }) engine.Run(&#34;:10001&#34;) } 接下我们需要安装 Prometheus Client SDK，在 Go 语言中对应 prometheus/client_golang 库：
$ go get github.com/prometheus/client_golang 然后调用 promhttp.Handler 方法创建对应的 metrics：
func main() { ... engine.GET(&#34;/metrics&#34;, gin.WrapH(promhttp.Handler())) engine.Run(&#34;:10001&#34;) } 重新启动程序，并访问 http://127.0.0.1:10001/metrics：
# HELP go_gc_duration_seconds A summary of the pause duration of garbage collection cycles.">
<meta itemprop="datePublished" content="2020-05-16T15:08:51+08:00" />
<meta itemprop="dateModified" content="2020-05-16T15:08:51+08:00" />
<meta itemprop="wordCount" content="633">



<meta itemprop="keywords" content="prometheus," />
<meta property="og:title" content="Prometheus 四大度量指标的了解和应用" />
<meta property="og:description" content="在上一个章节中我们完成了 Prometheus 的基本概念了解和安装，由于考虑到看我博客的估计是开发向的小伙伴居多，因此没有再更深入。而今天本章节将介绍我们开发用的最多的度量指标，并结合实战对 Metrics 进行使用和细节分析。
什么是度量指标  来自维基百科
 度量是指对于一个物体或是事件的某个性质给予一个数字，使其可以和其他物体或是事件的相同性质比较。度量可以是对一物理量（如长度、尺寸或容量等）的估计或测定，也可以是其他较抽象的特质。
简单来讲，也就是数据的量化，形成对应的数据指标。
Prometheus 的指标格式 在 Prometheus 中，我们的指标表示格式如下：
&lt;metric name&gt;{&lt;label name&gt;=&lt;label value&gt;, ...} 主体为指标名称和标签组成：
api_http_requests_total{method=&quot;POST&quot;, handler=&quot;/eddycjy&quot;} 对外提供 metrics 服务 首先创建一个示例项目：
func main() { engine := gin.New() engine.GET(&#34;/hello&#34;, func(c *gin.Context) { c.String(http.StatusOK, &#34;煎鱼&#34;) }) engine.Run(&#34;:10001&#34;) } 接下我们需要安装 Prometheus Client SDK，在 Go 语言中对应 prometheus/client_golang 库：
$ go get github.com/prometheus/client_golang 然后调用 promhttp.Handler 方法创建对应的 metrics：
func main() { ... engine.GET(&#34;/metrics&#34;, gin.WrapH(promhttp.Handler())) engine.Run(&#34;:10001&#34;) } 重新启动程序，并访问 http://127.0.0.1:10001/metrics：
# HELP go_gc_duration_seconds A summary of the pause duration of garbage collection cycles." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.k1s.club/posts.bak/prometheus/2020-05-16-metrics/" />
<meta property="article:published_time" content="2020-05-16T15:08:51+08:00" />
<meta property="article:modified_time" content="2020-05-16T15:08:51+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Prometheus 四大度量指标的了解和应用"/>
<meta name="twitter:description" content="在上一个章节中我们完成了 Prometheus 的基本概念了解和安装，由于考虑到看我博客的估计是开发向的小伙伴居多，因此没有再更深入。而今天本章节将介绍我们开发用的最多的度量指标，并结合实战对 Metrics 进行使用和细节分析。
什么是度量指标  来自维基百科
 度量是指对于一个物体或是事件的某个性质给予一个数字，使其可以和其他物体或是事件的相同性质比较。度量可以是对一物理量（如长度、尺寸或容量等）的估计或测定，也可以是其他较抽象的特质。
简单来讲，也就是数据的量化，形成对应的数据指标。
Prometheus 的指标格式 在 Prometheus 中，我们的指标表示格式如下：
&lt;metric name&gt;{&lt;label name&gt;=&lt;label value&gt;, ...} 主体为指标名称和标签组成：
api_http_requests_total{method=&quot;POST&quot;, handler=&quot;/eddycjy&quot;} 对外提供 metrics 服务 首先创建一个示例项目：
func main() { engine := gin.New() engine.GET(&#34;/hello&#34;, func(c *gin.Context) { c.String(http.StatusOK, &#34;煎鱼&#34;) }) engine.Run(&#34;:10001&#34;) } 接下我们需要安装 Prometheus Client SDK，在 Go 语言中对应 prometheus/client_golang 库：
$ go get github.com/prometheus/client_golang 然后调用 promhttp.Handler 方法创建对应的 metrics：
func main() { ... engine.GET(&#34;/metrics&#34;, gin.WrapH(promhttp.Handler())) engine.Run(&#34;:10001&#34;) } 重新启动程序，并访问 http://127.0.0.1:10001/metrics：
# HELP go_gc_duration_seconds A summary of the pause duration of garbage collection cycles."/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>Prometheus 四大度量指标的了解和应用</title>
	<link rel="stylesheet" href="https://blog.k1s.club/css/style.min.d3141168199607bf3a517216ce3c263814eecdbc8fca72a9a88700799a838219.css">
	
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp faster">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://blog.k1s.club">zhangzw</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					<a href="https://blog.k1s.club/posts/">文章</a>
					<a href="https://blog.k1s.club/k8s-categories/">Kubernetes系列</a>
				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<button id="toc-btn" class="hdr-btn desktop-only-ib" title="Table of Contents"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-list"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3" y2="6"></line><line x1="3" y1="12" x2="3" y2="12"></line><line x1="3" y1="18" x2="3" y2="18"></line></svg></button><span class="hdr-social hide-in-mobile"><a href="https://github.com/zhangzw001" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a></span><button id="menu-btn" class="hdr-btn" title="Menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://blog.k1s.club/posts/">文章</a></li>
			<li><a href="https://blog.k1s.club/tags/">标签</a></li>
			<li><a href="https://blog.k1s.club/about/">关于</a></li>
		</ul>
	</div>


	<main class="site-main section-inner thin animated fadeIn faster">
		<h1>Prometheus 四大度量指标的了解和应用</h1>
		<div class="content">
			<p>在上一个章节中我们完成了 Prometheus 的基本概念了解和安装，由于考虑到看我博客的估计是开发向的小伙伴居多，因此没有再更深入。而今天本章节将介绍我们开发用的最多的度量指标，并结合实战对 Metrics 进行使用和细节分析。</p>
<h2 id="什么是度量指标">什么是度量指标<a href="#什么是度量指标" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<blockquote>
<p>来自维基百科</p>
</blockquote>
<p>度量是指对于一个物体或是事件的某个性质给予一个数字，使其可以和其他物体或是事件的相同性质比较。度量可以是对一物理量（如长度、尺寸或容量等）的估计或测定，也可以是其他较抽象的特质。</p>
<p>简单来讲，也就是数据的量化，形成对应的数据指标。</p>
<h2 id="prometheus-的指标格式">Prometheus 的指标格式<a href="#prometheus-的指标格式" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>在 Prometheus 中，我们的指标表示格式如下：</p>
<pre><code>&lt;metric name&gt;{&lt;label name&gt;=&lt;label value&gt;, ...}
</code></pre><p>主体为指标名称和标签组成：</p>
<pre><code>api_http_requests_total{method=&quot;POST&quot;, handler=&quot;/eddycjy&quot;}
</code></pre><h2 id="对外提供-metrics-服务">对外提供 metrics 服务<a href="#对外提供-metrics-服务" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>首先创建一个示例项目：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">engine</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
    <span class="nx">engine</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/hello&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">c</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;煎鱼&#34;</span><span class="p">)</span>
    <span class="p">})</span>
    <span class="nx">engine</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="s">&#34;:10001&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>接下我们需要安装 Prometheus Client SDK，在 Go 语言中对应 <a href="https://github.com/prometheus/client_golang">prometheus/client_golang</a> 库：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ go get github.com/prometheus/client_golang
</code></pre></div><p>然后调用 <code>promhttp.Handler</code> 方法创建对应的 metrics：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="nx">engine</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/metrics&#34;</span><span class="p">,</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">WrapH</span><span class="p">(</span><span class="nx">promhttp</span><span class="p">.</span><span class="nf">Handler</span><span class="p">()))</span>
    <span class="nx">engine</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="s">&#34;:10001&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>重新启动程序，并访问 <code>http://127.0.0.1:10001/metrics</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># HELP go_gc_duration_seconds A summary of the pause duration of garbage collection cycles.</span>
<span class="c1"># TYPE go_gc_duration_seconds summary</span>
go_gc_duration_seconds<span class="o">{</span><span class="nv">quantile</span><span class="o">=</span><span class="s2">&#34;0&#34;</span><span class="o">}</span> <span class="m">0</span>
go_gc_duration_seconds<span class="o">{</span><span class="nv">quantile</span><span class="o">=</span><span class="s2">&#34;0.25&#34;</span><span class="o">}</span> <span class="m">0</span>
go_gc_duration_seconds<span class="o">{</span><span class="nv">quantile</span><span class="o">=</span><span class="s2">&#34;0.5&#34;</span><span class="o">}</span> <span class="m">0</span>
go_gc_duration_seconds<span class="o">{</span><span class="nv">quantile</span><span class="o">=</span><span class="s2">&#34;0.75&#34;</span><span class="o">}</span> <span class="m">0</span>
go_gc_duration_seconds<span class="o">{</span><span class="nv">quantile</span><span class="o">=</span><span class="s2">&#34;1&#34;</span><span class="o">}</span> <span class="m">0</span>
go_gc_duration_seconds_sum <span class="m">0</span>
go_gc_duration_seconds_count <span class="m">0</span>
<span class="c1"># HELP go_goroutines Number of goroutines that currently exist.</span>
<span class="c1"># TYPE go_goroutines gauge</span>
go_goroutines <span class="m">8</span>
<span class="c1"># HELP go_info Information about the Go environment.</span>
<span class="c1"># TYPE go_info gauge</span>
go_info<span class="o">{</span><span class="nv">version</span><span class="o">=</span><span class="s2">&#34;go1.14.2&#34;</span><span class="o">}</span> <span class="m">1</span>
<span class="c1"># HELP go_memstats_alloc_bytes Number of bytes allocated and still in use.</span>
<span class="c1"># TYPE go_memstats_alloc_bytes gauge</span>
go_memstats_alloc_bytes 2.563056e+06
...
</code></pre></div><p>我们可以聚焦其中一个指标：</p>
<pre><code># HELP go_goroutines Number of goroutines that currently exist.
# TYPE go_goroutines gauge
go_goroutines 8
</code></pre><p>你会发现其具有固定的表示格式，分别是指标的含义、指标的类型、指标的具体字段和数值。而在 <code>promhttp.Handler</code> 方法所暴露出来的 metrics 数值，虽然看似很多，但你认真看一下，可以主体为两块：</p>
<ol>
<li>
<p>go_memstats 开头的指标都是 <a href="https://golang.org/pkg/runtime/#MemStats">runtime.MemStats</a> 的格式化数值。</p>
</li>
<li>
<p>promhttp_metric 开头的指标是 HTTP 服务的状态码统计。</p>
</li>
</ol>
<h2 id="prometheus-四大度量指标的了解和应用">Prometheus 四大度量指标的了解和应用<a href="#prometheus-四大度量指标的了解和应用" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<h3 id="counter计数器">Counter（计数器）<a href="#counter计数器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>Counter 类型代表一个累积的指标数据，其单调递增，只增不减。在应用场景中，像是请求次数、错误数量等等，就非常适合用 Counter 来做指标类型，另外 Counter 类型，只有在被采集端重新启动时才会归零。</p>
<p>Counter 类型一共包含两个常规方法，如下：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Inc</td>
<td>将计数器递增 1。</td>
</tr>
<tr>
<td>Add(float64)</td>
<td>将给定值添加到计数器，如果设置的值 &lt; 0，则发生错误。</td>
</tr>
</tbody>
</table>
<h4 id="实战演练">实战演练<a href="#实战演练" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>Counter 类型是单纯的累积类计数，最基础的就是在访问请求的时候进行分类统计，在上文的示例项目中继续添加代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">AccessCounter</span> <span class="p">=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewCounterVec</span><span class="p">(</span>
    <span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterOpts</span><span class="p">{</span>
        <span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;api_requests_total&#34;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;method&#34;</span><span class="p">,</span> <span class="s">&#34;path&#34;</span><span class="p">},</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">prometheus</span><span class="p">.</span><span class="nf">MustRegister</span><span class="p">(</span><span class="nx">AccessCounter</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="nx">engine</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/counter&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">purl</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">url</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">RequestURI</span><span class="p">)</span>
        <span class="nx">AccessCounter</span><span class="p">.</span><span class="nf">With</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span>
            <span class="s">&#34;method&#34;</span><span class="p">:</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">Method</span><span class="p">,</span>
            <span class="s">&#34;path&#34;</span><span class="p">:</span>   <span class="nx">purl</span><span class="p">.</span><span class="nx">Path</span><span class="p">,</span>
        <span class="p">}).</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">})</span>
    <span class="nx">engine</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/metrics&#34;</span><span class="p">,</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">WrapH</span><span class="p">(</span><span class="nx">promhttp</span><span class="p">.</span><span class="nf">Handler</span><span class="p">()))</span>
    <span class="nx">engine</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="s">&#34;:10001&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>这时候我们访问 <code>http://127.0.0.1:10001/counter</code>，就可以发现 metrics +1：</p>
<pre><code># HELP api_requests_total 
# TYPE api_requests_total counter
api_requests_total{method=&quot;GET&quot;,path=&quot;/counter&quot;} 1
</code></pre><p>如果希望对全部请求进行记录和统计，我们可以利用拦截器来实现，但是在添加 Labels 时需要注意一点，就是你所定义的指标 Labels 和实际写入时的 Labels 要对应，否则会造成 panic：</p>
<pre><code>2020/05/17 11:01:06 http: panic serving 127.0.0.1:53393: inconsistent label cardinality: expected 3 label values but got 2 in prometheus.Labels{&quot;method&quot;:&quot;GET&quot;, &quot;path&quot;:&quot;/hello&quot;}
goroutine 51 [running]:
net/http.(*conn).serve.func1(0xc0000ee000)
        /usr/local/Cellar/go/1.14.2_1/libexec/src/net/http/server.go:1772 +0x139
panic(0x16272a0, 0xc00009c130)
        /usr/local/Cellar/go/1.14.2_1/libexec/src/runtime/panic.go:975 +0x3e3
github.com/prometheus/client_golang/prometheus.(*CounterVec).With(0xc0001347e0, 0xc00009a4e0, 0x16ea903, 0x4)
        /Users/eddycjy/go/pkg/mod/github.com/prometheus/client_golang@v1.6.0/prometheus/counter.go:259 +0xc2

</code></pre><h3 id="gauge仪表盘">Gauge（仪表盘）<a href="#gauge仪表盘" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>Gauge 类型代表一个可以任意变化的指标数据，其可增可减。在应用场景中，像是 Go 应用程序运行时的 Goroutine 的数量就可以用该类型来表示，因为其是浮动的数值，并非固定的，侧重于反馈当前的情况。</p>
<p>Gauge 类型一共包含六个常规方法，如下：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Set(float64)</td>
<td>将仪表设置为任意值。</td>
</tr>
<tr>
<td>Inc()</td>
<td>将仪表增加 1。</td>
</tr>
<tr>
<td>Dec()</td>
<td>将仪表减少 1。</td>
</tr>
<tr>
<td>Add(float64)</td>
<td>将给定值添加到仪表，该值如果为负数，那么将导致仪表值减少。</td>
</tr>
<tr>
<td>Sub(float64)</td>
<td>从仪表中减去给定值，该值如果为负数，那么将导致仪表值增加。</td>
</tr>
<tr>
<td>SetToCurrentTime()</td>
<td>将仪表设置为当前Unix时间（以秒为单位）。</td>
</tr>
</tbody>
</table>
<h4 id="实战演练-1">实战演练<a href="#实战演练-1" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>Gauge 类型是每次都重新设置的统计类型，在系统中统计 CPU、Memory 等等时很常见，而在业务场景中，业务队列的数量也可以用 Gauge 来统计，实时观察队列数量，及时发现堆积情况：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">QueueGauge</span> <span class="p">=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewGaugeVec</span><span class="p">(</span>
    <span class="nx">prometheus</span><span class="p">.</span><span class="nx">GaugeOpts</span><span class="p">{</span>
        <span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;queue_num_total&#34;</span><span class="p">,</span>
    <span class="p">},</span>
	<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;name&#34;</span><span class="p">},</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">prometheus</span><span class="p">.</span><span class="nf">MustRegister</span><span class="p">(</span><span class="nx">AccessCounter</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="nx">engine</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/queue&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">num</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;num&#34;</span><span class="p">)</span>
        <span class="nx">fnum</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">ParseFloat</span><span class="p">(</span><span class="nx">num</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
        <span class="nx">QueueGauge</span><span class="p">.</span><span class="nf">With</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;name&#34;</span><span class="p">:</span> <span class="s">&#34;queue_eddycjy&#34;</span><span class="p">}).</span><span class="nf">Set</span><span class="p">(</span><span class="nx">fnum</span><span class="p">)</span>
    <span class="p">})</span>
    <span class="nx">engine</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/metrics&#34;</span><span class="p">,</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">WrapH</span><span class="p">(</span><span class="nx">promhttp</span><span class="p">.</span><span class="nf">Handler</span><span class="p">()))</span>
    <span class="nx">engine</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="s">&#34;:10001&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>访问 <code>http://127.0.0.1:10001/queue?num=5</code> 后，再查看 metrics 结果：</p>
<pre><code># HELP queue_num_total 
# TYPE queue_num_total gauge
queue_num_total{name=&quot;queue_eddycjy&quot;} 5
</code></pre><p>另外 Gauge 类型也支持各种增减方法，大家根据实际情况调用即可。</p>
<h3 id="histogram累积直方图">Histogram（累积直方图）<a href="#histogram累积直方图" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>Histogram 类型将会在一段时间范围内对数据进行采样（通常是请求持续时间或响应大小等等），并将其计入可配置的存储桶（bucket）中，后续可通过指定区间筛选样本，也可以统计样本总数。</p>
<p>简单来讲，也就是在配置 Histogram 类型时，我们会设置分组区间，例如要分析请求的响应时间，我们可以分为 0-100ms，100-500ms，500-1000ms 等等区间段，那么在 metrics 的上报接口中，将会分为多个维度显示统计情况。</p>
<p>Histogram 类型一共包含一个常规方法，如下：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Observe(float64)</td>
<td>将一个观察值添加到直方图。</td>
</tr>
</tbody>
</table>
<h4 id="实战演练-2">实战演练<a href="#实战演练-2" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>Histogram 类型在应用场景中非常的常用，因为其代表的就是分组区间的统计，而在分布式场景盛行的现在，链路追踪系统是必不可少的，那么针对不同的链路的分析统计就非常的有必要，例如像是对 RPC、SQL、HTTP、Redis 的 P90、P95、P99 进行计算统计，并且更进一步的做告警，就能够及时的发现应用链路缓慢，进而发现和减少第三方系统的影响。</p>
<p>我们模仿记录 HTTP 调用响应时间的应用场景：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">HttpDurationsHistogram</span> <span class="p">=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewHistogramVec</span><span class="p">(</span>
    <span class="nx">prometheus</span><span class="p">.</span><span class="nx">HistogramOpts</span><span class="p">{</span>
        <span class="nx">Name</span><span class="p">:</span>    <span class="s">&#34;http_durations_histogram_seconds&#34;</span><span class="p">,</span>
        <span class="nx">Buckets</span><span class="p">:</span> <span class="p">[]</span><span class="kt">float64</span><span class="p">{</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">},</span>
    <span class="p">},</span>
    <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;path&#34;</span><span class="p">},</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">prometheus</span><span class="p">.</span><span class="nf">MustRegister</span><span class="p">(</span><span class="nx">HttpDurationsHistogram</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="o">...</span>
    <span class="nx">engine</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/histogram&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">purl</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">url</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">RequestURI</span><span class="p">)</span>
        <span class="nx">HttpDurationsHistogram</span><span class="p">.</span><span class="nf">With</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;path&#34;</span><span class="p">:</span> <span class="nx">purl</span><span class="p">.</span><span class="nx">Path</span><span class="p">}).</span><span class="nf">Observe</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="mi">30</span><span class="p">)))</span>
    <span class="p">})</span>
    <span class="nx">engine</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/metrics&#34;</span><span class="p">,</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">WrapH</span><span class="p">(</span><span class="nx">promhttp</span><span class="p">.</span><span class="nf">Handler</span><span class="p">()))</span>
    <span class="nx">engine</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="s">&#34;:10001&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>多次调用 <code>http://127.0.0.1:10001/histogram</code>，查看 metrics：</p>
<pre><code># HELP http_durations_histogram_seconds 
# TYPE http_durations_histogram_seconds histogram
http_durations_histogram_seconds_bucket{path=&quot;/histogram&quot;,le=&quot;0.2&quot;} 1
http_durations_histogram_seconds_bucket{path=&quot;/histogram&quot;,le=&quot;0.5&quot;} 1
http_durations_histogram_seconds_bucket{path=&quot;/histogram&quot;,le=&quot;1&quot;} 3
http_durations_histogram_seconds_bucket{path=&quot;/histogram&quot;,le=&quot;2&quot;} 3
http_durations_histogram_seconds_bucket{path=&quot;/histogram&quot;,le=&quot;5&quot;} 3
http_durations_histogram_seconds_bucket{path=&quot;/histogram&quot;,le=&quot;10&quot;} 3
http_durations_histogram_seconds_bucket{path=&quot;/histogram&quot;,le=&quot;30&quot;} 13
http_durations_histogram_seconds_bucket{path=&quot;/histogram&quot;,le=&quot;+Inf&quot;} 13
http_durations_histogram_seconds_sum{path=&quot;/histogram&quot;} 191
http_durations_histogram_seconds_count{path=&quot;/histogram&quot;} 13
</code></pre><p>我们结合 histogram metrics 的结果来看，可以发现其分为了三个部分：</p>
<ol>
<li>
<p>http_durations_histogram_seconds_bucket：在 Buckets 中你可以发现一共包含 8 个值，分别代表：0-0.2s、0.2-0.5s、0.5-1s、1-2s、2-5s、5-10s、10-30s 以及大于 30s（+Inf），这是我们在 <code>HistogramOpts.Buckets</code> 中所定义的区间值。</p>
</li>
<li>
<p>http_durations_histogram_seconds_sum：调用的总耗时。</p>
</li>
<li>
<p>http_durations_histogram_seconds_count：调用总次数。</p>
</li>
</ol>
<p>Histogram 是一个比较精巧类型，首先 Buckets 的分布区间要根据你的实际应用情况，合理的设置，否则就会出现不均，自然而然 PXX（P95、P99 等）计算也就会有问题，同时在 Grafana 上的绘图也会出现偏差，因此需要在理论上多多理解，然后再进行具体的设置，否则后期改来改去会比较麻烦</p>
<p>同时我们也可以利用 http_durations_histogram_seconds_sum 和 http_durations_histogram_seconds_count 相除得出平均耗时，一举多得。</p>
<h3 id="summary摘要">Summary（摘要）<a href="#summary摘要" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>Summary 类型将会在一段时间范围内对数据进行采样，但是与 Histogram 类型不同的是 Summary 类型将会存储分位数（在客户端进行计算），而不像 Histogram 类型，根据所设置的区间情况统计存储。</p>
<p>Summary 类型在采样计算后，一共提供三种摘要指标，如下：</p>
<ul>
<li>样本值的分位数分布情况。</li>
<li>所有样本值的大小总和。</li>
<li>样本总数。</li>
</ul>
<p>Summary 类型一共包含一个常规方法，如下：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Observe(float64)</td>
<td>将一个观察值添加到摘要。</td>
</tr>
</tbody>
</table>
<h4 id="实战演练-3">实战演练<a href="#实战演练-3" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>Summary 类型主要是</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">HttpDurations</span> <span class="p">=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewSummaryVec</span><span class="p">(</span>
    <span class="nx">prometheus</span><span class="p">.</span><span class="nx">SummaryOpts</span><span class="p">{</span>
        <span class="nx">Name</span><span class="p">:</span>       <span class="s">&#34;http_durations_seconds&#34;</span><span class="p">,</span>
        <span class="nx">Objectives</span><span class="p">:</span> <span class="kd">map</span><span class="p">[</span><span class="kt">float64</span><span class="p">]</span><span class="kt">float64</span><span class="p">{</span><span class="mf">0.5</span><span class="p">:</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">:</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">:</span> <span class="mf">0.001</span><span class="p">},</span>
    <span class="p">},</span>
    <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;path&#34;</span><span class="p">},</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">prometheus</span><span class="p">.</span><span class="nf">MustRegister</span><span class="p">(</span><span class="nx">HttpDurations</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="nx">engine</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/summary&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">purl</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">url</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">RequestURI</span><span class="p">)</span>
        <span class="nx">HttpDurations</span><span class="p">.</span><span class="nf">With</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;path&#34;</span><span class="p">:</span> <span class="nx">purl</span><span class="p">.</span><span class="nx">Path</span><span class="p">}).</span><span class="nf">Observe</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="mi">30</span><span class="p">)))</span>
    <span class="p">})</span>
    <span class="nx">engine</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/metrics&#34;</span><span class="p">,</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">WrapH</span><span class="p">(</span><span class="nx">promhttp</span><span class="p">.</span><span class="nf">Handler</span><span class="p">()))</span>
    <span class="nx">engine</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="s">&#34;:10001&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>多次调用 <code>http://127.0.0.1:10001/summary</code>，查看 metrics：</p>
<pre><code># HELP http_durations_seconds 
# TYPE http_durations_seconds summary
http_durations_seconds{path=&quot;/summary&quot;,quantile=&quot;0.5&quot;} 17
http_durations_seconds{path=&quot;/summary&quot;,quantile=&quot;0.9&quot;} 29
http_durations_seconds{path=&quot;/summary&quot;,quantile=&quot;0.99&quot;} 29
http_durations_seconds_sum{path=&quot;/summary&quot;} 85
http_durations_seconds_count{path=&quot;/summary&quot;} 5
</code></pre><p>结合 summary metrics 来看，同样分为了三个部分：</p>
<ol>
<li>
<p>http_durations_seconds：分别是中位数（0.5），9 分位数（0.9）以及 99 分位数（0.99），对应 <code>SummaryOpts.Objectives</code> 中我们所定义的中位数，而各自的意义代表着中位数（0.5）的耗时为 17s，9 分位数为 29s，99 分位数为 29s。</p>
</li>
<li>
<p>http_durations_seconds_sum：调用总耗时。</p>
</li>
<li>
<p>http_durations_seconds_count：调用总次数。</p>
</li>
</ol>
<h2 id="小结">小结<a href="#小结" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>在本章节中我们介绍并实操了 Prometheus 的四种度量指标类型 Counter、Gauge、Histogram、Summary，这四种度量类型都极具代表性：Counter 是单调递增的计数器，Gauge 是可任意调整数值的仪表盘，Histogram 是分组区间统计，Summary 是中位数统计。</p>
<p>其中 Histogram 和 Summary 具有一定的 “相似” 度，因为在 Histogram 指标中我们可以通过 <code>histogram_quantile</code> 函数计算出分位值，而 Summary 也可以计算分位值，两者区别就在于 Histogram 是在服务端计算的，而 Summary 是在客户端就进行了计算，其一个计算好了再推上去，一个直接推上去，数据维度不一样，可以做的事情也不一样，有利有弊，具体可以根据指标的实际情况做衡量。</p>
<p>另外针对度量指标的命名，这是一个非常多人问的问题，因为命名是一个难题，在这里大家可以参照官方的<a href="https://prometheus.io/docs/practices/naming/">文档</a>建议去针对指标命名就可以了。</p>

		</div>
		<div id="comments" class="thin">
						<script src="https://utteranc.es/client.js"
							repo="zhangzw001/blog-hugo"
							issue-term="pathname"
							theme="github-light"
							crossorigin="anonymous"
							async>
			</script>

		</div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2019 - 2020 <a href="https://blog.k1s.club">zhangzw</a> &#183; <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://blog.k1s.club/post/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>


	<script src="https://blog.k1s.club/js/main.min.784417f5847151f848c339cf0acb13a06cbb648b1483435a28ed4556c4ead69b.js"></script>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-166045776-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


</body>

</html>
